---
page_id: 2b425ccb-d328-41ff-afb2-016019f46839
title: Python SDK
description: "Complete guide for Python SDK including Flask and FastAPI integration, OAuth configuration, environment variables, and session management for Python 3.9+ applications."
sidebar:
  order: 15
head:
  - tag: meta
    attrs:
      property: "og:image"
      content: "https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/7696a047-06ef-4955-5720-d630fd88ab00/socialsharingimage"
topics:
  - developer-tools
  - sdks
  - python
  - backend
sdk:
  - python
languages:
  - python
  - bash
  - html
audience: developers
complexity: intermediate
keywords:
  - Python SDK
  - Flask
  - FastAPI
  - OAuth
  - environment variables
  - callback URLs
  - session management
updated: 2024-01-15
featured: false
deprecated: false
ai_summary: Complete guide for Python SDK including Flask and FastAPI integration, OAuth configuration, environment variables, and session management for Python 3.9+ applications.
---

The Kinde Python SDK allows developers to quickly and securely integrate a new or an existing Python application into the Kinde platform. The SDK provides separate implementations for synchronous and asynchronous applications, ensuring consistent APIs across different paradigms.

## Before you begin

- Kinde Python SDK supports Python 3.9+
- If you haven't already got a Kinde account, [register for free here](https://app.kinde.com/register) (no credit card required). Registering gives you a Kinde domain, which you need to get started, e.g. `yourapp.kinde.com`.

If you are using a previous version of Python, you may need to refer to the [previous v1 SDK](/developer-tools/sdks/backend/python-sdk-v1/).

If you're migrating from an older version of the SDK, see our [migration guide](https://github.com/kinde-oss/kinde-python-sdk/blob/main/MIGRATION.md) for detailed instructions.

For new projects, you can find our [Starter Kit on GitHub](https://github.com/kinde-starter-kits/python-starter-kit).

## Install

Install [PIP](https://pip.pypa.io/en/stable/installation/) and then execute the following command:

```bash
pip install kinde-python-sdk
```

### Environment variables

The Kinde Python SDK uses environment variables for configuration. Here are all the supported variables:

#### Required variables
- `KINDE_CLIENT_ID` - Your application's client ID from Kinde
- `KINDE_CLIENT_SECRET` - Your application's client secret from Kinde
- `KINDE_REDIRECT_URI` - The callback URL where Kinde will redirect after authentication
- `KINDE_HOST` - Your Kinde domain (e.g., `https://yourdomain.kinde.com`)
- `KINDE_ISSUER_URL` - Your Kinde issuer URL (typically same as KINDE_HOST)
- `GRANT_TYPE` - The OAuth grant type to use (e.g., `AUTHORIZATION_CODE_WITH_PKCE`)

#### Optional variables
- `KINDE_AUDIENCE` - The intended recipient of the access token (for API access)
- `KINDE_CALLBACK_URL` - Alternative name for KINDE_REDIRECT_URI
- `LOGOUT_REDIRECT_URL` - Where users are redirected after logout
- `SITE_HOST` - Your application's host (default: `127.0.0.1`)
- `SITE_PORT` - Your application's port (default: `5000`)
- `SITE_URL` - Your application's base URL
- `CODE_VERIFIER` - Required for PKCE flow (auto-generated if not provided)

**Session management variables** (core SDK features):
- `SECRET_KEY` - Used for session management and token security
- `SESSION_TYPE` - Session storage type (e.g., `filesystem`)
- `SESSION_PERMANENT` - Whether sessions are permanent (default: `False`)

**Application configuration**:
- `TEMPLATES_AUTO_RELOAD` - Whether to auto-reload templates (default: `True`)

**Management API variables** (only needed if using Management API features):
- `MGMT_API_CLIENT_ID` - Management API client ID
- `MGMT_API_CLIENT_SECRET` - Management API client secret

Example `.env` file:
```bash
KINDE_CLIENT_ID=your_client_id
KINDE_CLIENT_SECRET=your_client_secret
KINDE_REDIRECT_URI=http://localhost:5000/api/auth/kinde_callback
KINDE_HOST=https://yourdomain.kinde.com
KINDE_ISSUER_URL=https://yourdomain.kinde.com
GRANT_TYPE=AUTHORIZATION_CODE_WITH_PKCE
SITE_HOST=localhost
SITE_PORT=5000
SITE_URL=http://localhost:5000
LOGOUT_REDIRECT_URL=http://localhost:8000
SECRET_KEY=your_secret_key
SESSION_TYPE=filesystem
SESSION_PERMANENT=False
TEMPLATES_AUTO_RELOAD=True
```

### Set callback URLs

1. In Kinde, go to **Settings > Applications > [Your app] > View details**.
2. Add your callback URLs in the relevant fields. For example:
   - Allowed callback URLs (also known as redirect URIs) - for example, `http://localhost:8000/callback`
   - Allowed logout redirect URLs - for example, `http://localhost:8000`
3. Select **Save**.

### Add environments

Kinde comes with a production environment, but you can set up other environments if you want to. Note that each environment needs to be set up independently, so you need to use the Environment subdomain in the code block above for those new environments.

## Configure your app

The Kinde Python SDK provides three different OAuth client types to support various application patterns:

### 1. Synchronous Client (OAuth)

For traditional synchronous applications like Flask:

```python
from kinde_sdk.auth.oauth import OAuth

# For Flask applications
from flask import Flask
app = Flask(__name__)
oauth = OAuth(
    framework="flask",
    app=app  # optional: pass your Flask app instance
)
```

### 2. Asynchronous Client (AsyncOAuth)

For asynchronous applications like FastAPI:

```python
from kinde_sdk.auth.async_oauth import AsyncOAuth

# For FastAPI applications
from fastapi import FastAPI
app = FastAPI()
oauth = AsyncOAuth(
    framework="fastapi",
    app=app  # optional: pass your FastAPI app instance
)
```

### 3. Smart Client (SmartOAuth)

Context-aware client that automatically adapts to sync/async contexts:

```python
from kinde_sdk.auth.smart_oauth import SmartOAuth

# Works in both sync and async contexts
oauth = SmartOAuth(
    framework="fastapi",  # or "flask"
    app=app
)
```

### 4. Factory Function

For explicit control over client type:

```python
from kinde_sdk.auth.smart_oauth import create_oauth_client

# Explicit sync client
oauth = create_oauth_client(async_mode=False, framework="flask", app=app)

# Explicit async client  
oauth = create_oauth_client(async_mode=True, framework="fastapi", app=app)

# Smart client (auto-detects context)
oauth = create_oauth_client(framework="fastapi", app=app)
```

### 5. Standalone Usage (No Framework)

For serverless functions or standalone applications:

```python
from kinde_sdk.auth.async_oauth import AsyncOAuth
from kinde_sdk import KindeSessionManagement

# Standalone usage without a web framework
oauth = AsyncOAuth(
    framework=None,  # Uses null framework
    client_id="your_client_id",
    client_secret="your_client_secret",
    redirect_uri="your_redirect_uri",
    host="https://yourdomain.kinde.com"
)

# Initialize session management for standalone usage
session_mgmt = KindeSessionManagement()
```

### Choosing the Right Client

- **OAuth (Sync)**: Use for Flask applications or traditional synchronous Python code
- **AsyncOAuth**: Use for FastAPI applications or fully async codebases
- **SmartOAuth**: Use when you need to support both sync and async contexts
- **Standalone**: Use for serverless functions (AWS Lambda, Google Cloud Functions, etc.)

## Sign in and sign up

The Kinde client provides methods for easy sign in and sign up. You can add buttons in your HTML as follows:

```html
<div class="navigation">
  <a href="{{ url_for('login') }}" type="button">Sign in</a>
  <a href="{{ url_for('register') }}" type="button">Sign up</a>
</div>
```

### Automatic Route Registration

The framework wrapper can automatically register all necessary routes. For Flask (sync):

```python
from kinde_sdk.auth.oauth import OAuth
from flask import Flask

app = Flask(__name__)
oauth = OAuth(
    framework="flask",
    app=app
)
```

For FastAPI (async):

```python
from kinde_sdk.auth.async_oauth import AsyncOAuth
from fastapi import FastAPI

app = FastAPI()
oauth = AsyncOAuth(
    framework="fastapi",
    app=app
)
```

For SmartOAuth (works with both):

```python
from kinde_sdk.auth.smart_oauth import SmartOAuth
from fastapi import FastAPI

app = FastAPI()
oauth = SmartOAuth(
    framework="fastapi",
    app=app
)
```

## Manual route implementation

If you prefer to implement the routes manually, here's how you can do it:

### Flask (Synchronous)

```python
import asyncio
from flask import Flask, request, session, redirect
from kinde_sdk.auth.oauth import OAuth

app = Flask(__name__)
oauth = OAuth(
    framework="flask",
    app=app
)

@app.route('/login')
def login():
    """Redirect to Kinde login page."""
    import asyncio
    login_url = asyncio.run(oauth.login())
    return redirect(login_url)

@app.route('/register')
def register():
    """Redirect to Kinde registration page."""
    import asyncio
    register_url = asyncio.run(oauth.register())
    return redirect(register_url)

@app.route('/callback')
def callback():
    """Handle the OAuth callback from Kinde."""
    try:
        code = request.args.get('code')
        state = request.args.get('state')
        
        if not code:
            return "Authentication failed: No code provided", 400
        
        # Generate a unique user ID for the session
        import uuid
        user_id = session.get('user_id') or str(uuid.uuid4())
        
        # Use OAuth's handle_redirect method to process the callback
        import asyncio
        result = asyncio.run(oauth.handle_redirect(code, user_id, state))
        
        # Store user ID in session
        session['user_id'] = user_id
        
        return redirect('/')
    except Exception as e:
        return f"Authentication failed: {str(e)}", 400

@app.route('/logout')
def logout():
    """Logout the user and redirect to Kinde logout page."""
    user_id = session.get('user_id')
    session.clear()
    import asyncio
    logout_url = asyncio.run(oauth.logout(user_id))
    return redirect(logout_url)

@app.route('/user')
def get_user():
    """Get the current user's information."""
    try:
        if not oauth.is_authenticated():
            import asyncio
            login_url = asyncio.run(oauth.login())
            return redirect(login_url)
        
        return oauth.get_user_info()
    except Exception as e:
        return f"Failed to get user info: {str(e)}", 400
```

### FastAPI (Asynchronous)

```python
from fastapi import FastAPI, Request
from fastapi.responses import RedirectResponse, HTMLResponse
from kinde_sdk.auth.async_oauth import AsyncOAuth

app = FastAPI()
oauth = AsyncOAuth(
    framework="fastapi",
    app=app
)

@app.get("/login")
async def login(request: Request):
    url = await oauth.login()
    return RedirectResponse(url=url)

@app.get("/register")
async def register(request: Request):
    url = await oauth.register()
    return RedirectResponse(url=url)

@app.get("/callback")
async def callback(request: Request, code: str, state: str = None):
    try:
        result = await oauth.handle_redirect(code, state)
        return RedirectResponse(url="/")
    except Exception as e:
        return HTMLResponse(f"Authentication failed: {str(e)}")

@app.get("/logout")
async def logout(request: Request):
    logout_url = await oauth.logout()
    return RedirectResponse(url=logout_url)

@app.get("/user")
async def get_user(request: Request):
    if not oauth.is_authenticated():
        return RedirectResponse(url=await oauth.login())
    return await oauth.get_user_info_async()
```

### SmartOAuth (Context-Aware)

```python
from fastapi import FastAPI, Request
from fastapi.responses import RedirectResponse
from kinde_sdk.auth.smart_oauth import SmartOAuth

app = FastAPI()
oauth = SmartOAuth(
    framework="fastapi",
    app=app
)

@app.get("/login")
async def login(request: Request):
    # SmartOAuth automatically uses async methods in FastAPI context
    url = await oauth.login()
    return RedirectResponse(url=url)

@app.get("/user")
async def get_user(request: Request):
    if not oauth.is_authenticated():
        return RedirectResponse(url=await oauth.login())
    
    # Use async method for better performance
    return await oauth.get_user_info_async()
```

### Standalone Usage (No Framework)

```python
import uuid
from kinde_sdk.auth.async_oauth import AsyncOAuth
from kinde_sdk import KindeSessionManagement

# Initialize OAuth without framework
oauth = AsyncOAuth(
    framework=None,  # Uses null framework
    client_id="your_client_id",
    client_secret="your_client_secret",
    redirect_uri="your_redirect_uri",
    host="https://yourdomain.kinde.com"
)

# Initialize session management
session_mgmt = KindeSessionManagement()

async def handle_login():
    """Handle login flow in standalone application."""
    session_id = str(uuid.uuid4())
    
    # Set the current user session
    session_mgmt.set_user_id(session_id)
    
    # Generate login URL
    login_url = await oauth.login()
    return login_url, session_id

async def handle_callback(code: str, session_id: str, state: str = None):
    """Handle OAuth callback in standalone application."""
    # Set the current user session
    session_mgmt.set_user_id(session_id)
    
    # Handle the redirect
    result = await oauth.handle_redirect(code, session_id, state)
    return result

async def get_user_info(session_id: str):
    """Get user information in standalone application."""
    # Set the current user session
    session_mgmt.set_user_id(session_id)
    
    if oauth.is_authenticated():
        return await oauth.get_user_info_async()
    return None
```

The manual implementation gives you more control over the authentication flow and allows you to add custom logic like session management, error handling, and logging. Choose the appropriate client type based on your application's needs:

- **OAuth**: For traditional synchronous Flask applications
- **AsyncOAuth**: For asynchronous FastAPI applications  
- **SmartOAuth**: For applications that need to work in both sync and async contexts
- **Standalone**: For serverless functions or applications without web frameworks

## User permissions

The Kinde Python SDK provides a simple way to check user permissions in your application. The permissions module is async and works with all OAuth client types:

```python
from kinde_sdk.auth import permissions
```

Here's how to use permissions in your application:

### Flask (Synchronous)

```python
import asyncio
from flask import Flask, request
from kinde_sdk.auth.oauth import OAuth
from kinde_sdk.auth import permissions

app = Flask(__name__)
oauth = OAuth(framework="flask", app=app)

@app.route('/create-todo', methods=['POST'])
def create_todo():
    # Run async permission check in sync context
    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)
    try:
        permission = loop.run_until_complete(permissions.get_permission("create:todos"))
        if not permission["isGranted"]:
            return "Permission denied", 403
        # Create todo logic here...
        return "Todo created successfully"
    finally:
        loop.close()
```

### FastAPI (Asynchronous)

```python
from fastapi import FastAPI, HTTPException
from kinde_sdk.auth.async_oauth import AsyncOAuth
from kinde_sdk.auth import permissions

app = FastAPI()
oauth = AsyncOAuth(framework="fastapi", app=app)

@app.post("/todos")
async def create_todo(todo_data: dict):
    permission = await permissions.get_permission("create:todos")
    if not permission["isGranted"]:
        raise HTTPException(status_code=403, detail="Permission denied")
    # Create todo logic here...
    return {"message": "Todo created successfully"}
```

### SmartOAuth (Context-Aware)

```python
from fastapi import FastAPI, HTTPException
from kinde_sdk.auth.smart_oauth import SmartOAuth
from kinde_sdk.auth import permissions

app = FastAPI()
oauth = SmartOAuth(framework="fastapi", app=app)

@app.post("/todos")
async def create_todo(todo_data: dict):
    # Works seamlessly in async context
    permission = await permissions.get_permission("create:todos")
    if not permission["isGranted"]:
        raise HTTPException(status_code=403, detail="Permission denied")
    # Create todo logic here...
    return {"message": "Todo created successfully"}
```

### Common permission patterns

Here are some common permission patterns you might use:

```python
# Resource-based permissions
"create:todos
"read:todos
"update:todos
"delete:todos

# Feature-based permissions
"can:export_data
"can:manage_users
"can:view_analytics

# Organization-based permissions
"org:manage_members
"org:view_billing
"org:update_settings
```

For more information about setting up permissions in Kinde, see [User permissions](/manage-users/roles-and-permissions/user-permissions/).

## Feature flags

The Kinde Python SDK provides a simple way to access feature flags from your application. The feature flags module is async and works with all OAuth client types:

```python
from kinde_sdk.auth import feature_flags
```

Here's how to use feature flags in your application:

### Flask (Synchronous)

```python
import asyncio
from flask import Flask, render_template_string
from kinde_sdk.auth.oauth import OAuth
from kinde_sdk.auth import feature_flags

app = Flask(__name__)
oauth = OAuth(framework="flask", app=app)

@app.route('/')
def home():
    if oauth.is_authenticated():
        # Run async feature flag check in sync context
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        try:
            theme = loop.run_until_complete(feature_flags.get_flag("theme", default_value="light"))
            dark_mode = loop.run_until_complete(feature_flags.get_flag("is_dark_mode", default_value=False))
            
            return render_template_string("""
                <html>
                    <body style="background: {{ 'dark' if dark_mode.value else 'light' }}">
                        <h1>Welcome!</h1>
                        <p>Theme: {{ theme.value }}</p>
                    </body>
                </html>
            """, theme=theme, dark_mode=dark_mode)
        finally:
            loop.close()
    return "Please login"
```

### FastAPI (Asynchronous)

```python
from fastapi import FastAPI, HTTPException
from kinde_sdk.auth.async_oauth import AsyncOAuth
from kinde_sdk.auth import feature_flags

app = FastAPI()
oauth = AsyncOAuth(framework="fastapi", app=app)

@app.post("/competitions")
async def create_competition(competition_data: dict):
    limit_flag = await feature_flags.get_flag("competitions_limit", default_value=3)
    current_count = await get_user_competition_count()  # Your implementation
    
    if current_count >= limit_flag.value:
        raise HTTPException(
            status_code=403,
            detail=f"Competition limit reached (max: {limit_flag.value})"
        )
    # Create competition logic here...
    return {"message": "Competition created successfully"}

@app.get("/theme")
async def get_user_theme():
    theme = await feature_flags.get_flag("theme", default_value="light")
    dark_mode = await feature_flags.get_flag("is_dark_mode", default_value=False)
    return {
        "theme": theme.value,
        "is_dark_mode": dark_mode.value
    }
```

### SmartOAuth (Context-Aware)

```python
from fastapi import FastAPI
from kinde_sdk.auth.smart_oauth import SmartOAuth
from kinde_sdk.auth import feature_flags

app = FastAPI()
oauth = SmartOAuth(framework="fastapi", app=app)

@app.get("/")
async def home():
    if oauth.is_authenticated():
        # Works seamlessly in async context
        theme = await feature_flags.get_flag("theme", default_value="light")
        return {"theme": theme.value}
    return {"message": "Please login"}
```

### Feature flag types

The SDK supports the following feature flag types:

```python
# String flags
{
    "t": "s",
    "v": "pink"
}

# Boolean flags
{
    "t": "b",
    "v": true
}

# Integer flags
{
    "t": "i",
    "v": 5
}
```

### Common use cases

```python
# Feature Toggles
can_use_feature = await feature_flags.get_flag("enable_new_feature", default_value=False)

# User Preferences
theme = await feature_flags.get_flag("theme", default_value="light")
dark_mode = await feature_flags.get_flag("is_dark_mode", default_value=False)

# Usage Limits
max_uploads = await feature_flags.get_flag("max_uploads", default_value=10)

# A/B Testing
test_group = await feature_flags.get_flag("ab_test_group", default_value="control")
```

## Claims

The Kinde Python SDK provides a simple way to access user claims from your application. The claims module is async and works with all OAuth client types:

```python
from kinde_sdk.auth import claims
```

Here's how to use claims in your application:

### Flask (Synchronous)

```python
import asyncio
from flask import Flask, request
from kinde_sdk.auth.oauth import OAuth
from kinde_sdk.auth import claims

app = Flask(__name__)
oauth = OAuth(framework="flask", app=app)

@app.route('/profile')
def get_user_profile():
    if oauth.is_authenticated():
        # Run async claims check in sync context
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        try:
            given_name = loop.run_until_complete(claims.get_claim("given_name", token_type="id_token"))
            family_name = loop.run_until_complete(claims.get_claim("family_name", token_type="id_token"))
            email = loop.run_until_complete(claims.get_claim("email", token_type="id_token"))
            
            if given_name["value"] and family_name["value"]:
                return {
                    "name": f"{given_name['value']} {family_name['value']}",
                    "email": email["value"]
                }
        finally:
            loop.close()
    return {"error": "Not authenticated"}
```

### FastAPI (Asynchronous)

```python
from fastapi import FastAPI, HTTPException
from kinde_sdk.auth.async_oauth import AsyncOAuth
from kinde_sdk.auth import claims

app = FastAPI()
oauth = AsyncOAuth(framework="fastapi", app=app)

@app.get("/profile")
async def get_user_profile():
    if oauth.is_authenticated():
        given_name = await claims.get_claim("given_name", token_type="id_token")
        family_name = await claims.get_claim("family_name", token_type="id_token")
        email = await claims.get_claim("email", token_type="id_token")
        
        if given_name["value"] and family_name["value"]:
            return {
                "name": f"{given_name['value']} {family_name['value']}",
                "email": email["value"]
            }
    return {"error": "Not authenticated"}

@app.get("/api/protected")
async def protected_endpoint():
    aud_claim = await claims.get_claim("aud")
    if not aud_claim["value"] or "api.yourapp.com" not in aud_claim["value"]:
        raise HTTPException(status_code=401, detail="Invalid token audience")
    return {"message": "Access granted"}
```

### SmartOAuth (Context-Aware)

```python
from fastapi import FastAPI, HTTPException
from kinde_sdk.auth.smart_oauth import SmartOAuth
from kinde_sdk.auth import claims

app = FastAPI()
oauth = SmartOAuth(framework="fastapi", app=app)

@app.get("/profile")
async def get_user_profile():
    if oauth.is_authenticated():
        # Works seamlessly in async context
        given_name = await claims.get_claim("given_name", token_type="id_token")
        return {"name": given_name["value"]}
    return {"error": "Not authenticated"}
```

### Common claims

Here are some common claims you might want to access:

```python
# User Information (ID Token)
"given_name
"family_name
"email
"picture

# Token Information (Access Token)
"aud"           # Audience
"iss"           # Issuer
"exp"           # Expiration time
"iat"           # Issued at time

# Organization Information
"org_code
"org_name
"org_id
```



## Organizations

### Create an organization

To create a new organization within your application, you will need to run a similar function to below:

```python
return app.redirect(oauth.create_org())
```

### Sign up and sign in to organizations

Kinde has a unique code for every organization. You'll have to pass this code through when you register a new user or sign in to a particular organization. Example function below:

```python
oauth.get_claim("org_code")

@app.route("/login")
def login():
    return app.redirect(oauth.get_login_url())


@app.route("/register")
def register():
    return app.redirect(oauth.get_register_url())
```

Following authentication, Kinde provides a json web token (jwt) to your application. Along with the standard information we also include the `org_code` and the permissions for that organization (this is important as a user can belong to multiple organizations and have different permissions for each).

Example of a returned token:

```python
{
   "aud": [],
   "exp": 1658475930,
   "iat": 1658472329,
   "iss": "https://your_subdomain.kinde.com",
   "jti": "123457890",
   "org_code": "org_1234",
   "permissions": ["read:todos", "create:todos"],
   "scp": [
		   "openid",
		   "profile",
		   "email",
		   "offline
   ],
   "sub": "kp:123457890"
}
```

The `id_token` will also contain an array of organizations that a user belongs to - this is useful if you wanted to build out an organization switcher for example.

```python
{
		...
		"org_codes": ["org_1234", "org_4567"],
		...
};
```

There are two helper functions you can use to extract information:

```python
oauth.get_organization()

oauth.get_user_organizations()
```

For more information about how organizations work in Kinde, see [Kinde organizations for developers](/build/organizations/orgs-for-developers/).

### Token and session management

The Kinde Python SDK automatically handles token and session management for your application. Once a user has successfully authenticated, the SDK manages:

- **Token acquisition and storage**: Automatically obtains and securely stores access tokens, ID tokens, and refresh tokens
- **Token refresh**: Automatically refreshes tokens when they expire
- **Session management**: Handles user sessions across requests
- **Framework integration**: Works seamlessly with Flask and FastAPI session systems

The SDK uses the session configuration from your environment variables (`SECRET_KEY`, `SESSION_TYPE`, `SESSION_PERMANENT`) to manage sessions appropriately for your chosen framework.

#### Token types

The SDK supports two types of tokens:

1. **Access Token** (`token_type="access_token"`):
   - Contains authorization information
   - Used for API access
   - Contains permissions and organization context
   - Default token type

2. **ID Token** (`token_type="id_token"`):
   - Contains user identity information
   - Used for user profile data
   - Contains name, email, and other user details
   - Must be explicitly requested using `token_type="id_token"`

#### Session handling

The SDK automatically integrates with your framework's session system:

- **Flask**: Uses Flask's built-in session management
- **FastAPI**: Integrates with FastAPI's session handling

You don't need to manually manage tokens or sessions - the SDK handles this automatically for you.

## Management API

The Kinde Python SDK provides a Management API client for interacting with Kinde's management endpoints. This allows you to programmatically manage users, organizations, and other resources.

### Getting started

To use the Management API, you can initialize the client directly or through your OAuth client:

### Direct initialization

```python
from kinde_sdk.management import ManagementClient

# Initialize management client directly
management = ManagementClient(
    domain="https://yourdomain.kinde.com",
    client_id="your_management_client_id",
    client_secret="your_management_client_secret"
)
```

### Through OAuth client

```python
from kinde_sdk.auth.oauth import OAuth

oauth = OAuth(
    framework="flask",
    app=app
)

# Get the management client (if configured)
management = oauth.get_management()
```

The Management API provides methods for common operations on resources. Here are some examples:

### Synchronous usage

```python
# List users
users = management.get_users()

# Get a specific user
user = management.get_user(user_id="user_123")

# Create a new user
new_user = management.create_user(
    email="user@example.com",
    given_name="John",
    family_name="Doe"
)

# Update a user
updated_user = management.update_user(
    user_id="user_123",
    given_name="Johnny"
)

# Delete a user
management.delete_user(user_id="user_123")
```

### Asynchronous usage (wrapping in async functions)

```python
from kinde_sdk.management import ManagementClient
import asyncio

# Initialize client
management = ManagementClient(
    domain="your-domain.kinde.com",
    client_id="your-management-client-id",
    client_secret="your-management-client-secret"
)

# Wrap in async function for use in async contexts
async def get_users_async():
    """Get users asynchronously."""
    # Run sync method in thread pool
    loop = asyncio.get_event_loop()
    return await loop.run_in_executor(None, management.get_users, 10)

# Use in FastAPI
@app.get("/users")
async def users():
    users_data = await get_users_async()
    return {"users": users_data}
```

### Organization management

```python
# List organizations
orgs = management.get_organizations()

# Get a specific organization
org = management.get_organization(org_id="org_123")

# Create a new organization
new_org = management.create_organization(
    name="My Organization"
)

# Update an organization
updated_org = management.update_organization(
    org_id="org_123",
    name="Updated Name"
)

# Delete an organization
management.delete_organization(org_id="org_123")
```

### Error handling

The Management API methods will raise exceptions for API errors. It's recommended to handle these appropriately:

```python
try:
    user = management.get_user(user_id="user_123")
except Exception as e:
    # Handle API-specific errors
    print(f"Error: {e}")
```

### Token management

The Management API client has its own token management system for API authentication, which is separate from the core SDK's user session token management. The Management API client automatically handles:

- **accessing Kinde Management API endpoints**: Obtains tokens for accessing Kinde's management endpoints
- **Token refresh**: Automatically refreshes management API tokens when they expire
- **Token storage**: Securely stores management API tokens
- **Thread safety**: Ensures thread-safe token handling for concurrent requests

You don't need to manually manage Management API tokens - the client handles this for you. This is different from the core SDK's user session token management, which handles user authentication tokens automatically.

### Best practices

1. Use the appropriate sync/async pattern based on your application type
2. Handle API errors appropriately
3. Cache results when appropriate to reduce API calls
4. Use appropriate error handling for production environments
5. Keep your client credentials secure
6. Use the Management API client directly for better performance in standalone scenarios

For more information about the Management API endpoints and capabilities, see the [Kinde Management API documentation](https://docs.kinde.com/kinde-apis/management/).

## Error Handling

The SDK raises several exception types that you should handle appropriately:

- `KindeConfigurationException` - Configuration errors (missing client ID, etc.)
- `KindeLoginException` - Login/authentication errors
- `KindeTokenException` - Token-related errors (token exchange failures, etc.)
- `KindeRetrieveException` - Data retrieval errors

### Error Handling in Flask (Sync)

```python
from flask import Flask, jsonify, redirect
from kinde_sdk import OAuth
from kinde_sdk.core.exceptions import (
    KindeConfigurationException,
    KindeLoginException,
    KindeTokenException
)
import asyncio

app = Flask(__name__)
oauth = OAuth(framework="flask", app=app)

@app.route("/login")
def login():
    """Handle login with error handling."""
    try:
        login_url = asyncio.run(oauth.login())
        return redirect(login_url)
    except KindeConfigurationException as e:
        return jsonify({"error": f"Configuration error: {str(e)}"}), 500
    except Exception as e:
        return jsonify({"error": f"Unexpected error: {str(e)}"}), 500

@app.route("/callback")
def callback():
    """Handle callback with error handling."""
    code = request.args.get("code")
    state = request.args.get("state")
    
    try:
        result = asyncio.run(oauth.handle_redirect(code=code, state=state))
        return redirect("/")
    except KindeTokenException as e:
        return jsonify({"error": f"Token error: {str(e)}"}), 400
    except KindeLoginException as e:
        return jsonify({"error": f"Login error: {str(e)}"}), 400
    except Exception as e:
        return jsonify({"error": f"Unexpected error: {str(e)}"}), 500
```

### Error Handling in FastAPI (Async)

```python
from fastapi import FastAPI, HTTPException
from fastapi.responses import RedirectResponse
from kinde_sdk import AsyncOAuth
from kinde_sdk.core.exceptions import (
    KindeConfigurationException,
    KindeLoginException,
    KindeTokenException
)

app = FastAPI()
oauth = AsyncOAuth(framework="fastapi", app=app)

@app.get("/login")
async def login():
    """Handle login with error handling."""
    try:
        login_url = await oauth.login()
        return RedirectResponse(url=login_url)
    except KindeConfigurationException as e:
        raise HTTPException(status_code=500, detail=f"Configuration error: {str(e)}")
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Unexpected error: {str(e)}")

@app.get("/callback")
async def callback(code: str, state: str = None):
    """Handle callback with error handling."""
    try:
        result = await oauth.handle_redirect(code=code, state=state)
        return RedirectResponse(url="/")
    except KindeTokenException as e:
        raise HTTPException(status_code=400, detail=f"Token error: {str(e)}")
    except KindeLoginException as e:
        raise HTTPException(status_code=400, detail=f"Login error: {str(e)}")
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Unexpected error: {str(e)}")
```

## Best Practices

### 1. Choose the Right Client

- **Flask applications**: Use `OAuth` (sync client)
- **FastAPI applications**: Use `AsyncOAuth` or `SmartOAuth`
- **Serverless/Lambda**: Use `AsyncOAuth` with `KindeSessionManagement`
- **Mixed contexts**: Use `SmartOAuth`

### 2. Consistent Async Patterns

- Always use `await` for async methods
- Use `asyncio.run()` in sync contexts when calling async methods
- Prefer async methods in async contexts for better performance

### 3. Error Handling

- Always wrap OAuth operations in try/except blocks
- Handle specific exception types appropriately
- Provide meaningful error messages to users
- Log errors for debugging

### 4. Session Management

- Use framework session management when available (Flask, FastAPI)
- Use `KindeSessionManagement` for serverless/standalone usage
- Always clear sessions on logout

### 5. Token Management

- Let the SDK handle token refresh automatically
- Don't manually manipulate tokens unless necessary
- Store tokens securely using the SDK's storage mechanisms

### 6. Performance Optimization

- Use async clients in async contexts for better performance
- Cache permission/claim/flag results when appropriate
- Avoid unnecessary token refreshes

### 7. Security Best Practices

- Always validate state parameters in OAuth callbacks
- Use HTTPS in production
- Store secrets securely (environment variables, secret managers)
- Implement proper session timeout handling

### 8. Testing

- Test both sync and async paths
- Mock external API calls in tests
- Test error handling scenarios
- Test session management edge cases

## Important Notes

### Async/Sync Consistency

The SDK now provides consistent async and sync APIs to address previous inconsistencies:
- **Auth modules** (permissions, claims, feature_flags) are async and work with all client types
- **OAuth methods** are now properly separated into sync and async versions
- **SmartOAuth** provides a unified interface that adapts to the execution context

### Backward Compatibility

All existing code continues to work without changes:
- The original `OAuth` class remains unchanged
- Existing sync methods remain sync
- Existing async methods remain async
- No breaking changes to the public API

### Migration Recommendations

- **New Flask projects**: Use `OAuth` for simplicity
- **New FastAPI projects**: Use `AsyncOAuth` for best performance
- **Mixed projects**: Use `SmartOAuth` for flexibility
- **Serverless/Lambda**: Use `AsyncOAuth` with `framework=None`
- **Existing projects**: No changes required, but consider migrating for better consistency

