---
page_id: c1b1ea81-35f9-467e-8079-042d6a786e55
title: Testing authentication flows
description: "Guide to testing sign-up, sign-in, and sign-out flows using browser automation tools like Playwright, Cypress, and AWS CloudWatch Synthetic Canaries."
sidebar:
  order: 3
relatedArticles:
  - cc2bd7c3-b365-417f-a6d0-a2685acd6a7e
  - f38ed786-7234-44d1-a564-f7269ce536c5
topics:
  - developer-tools
  - testing
  - ui-testing
  - e2e-testing
  - authentication
sdk: []
languages:
  - JavaScript
  - TypeScript
  - Python
audience: developers
complexity: intermediate
keywords:
  - UI testing
  - authentication flows
  - sign-up testing
  - sign-in testing
  - Playwright
  - Cypress
  - AWS CloudWatch
  - browser automation
updated: 2025-01-27
featured: false
deprecated: false
ai_summary: Guide to testing authentication flows (sign-up, sign-in, sign-out) using browser automation tools including Playwright, Cypress, and AWS CloudWatch Synthetic Canaries.
---

<Aside type="info">

**Last updated: January 27, 2025**

We're continuously improving Kinde and expanding testing capabilities. This documentation is regularly updated to reflect the latest supported use cases and best practices.

</Aside>

For full UI testing including the authentication flow, you can use browser automation tools like Puppeteer, Playwright, or Cypress. This guide covers how to test sign-up, sign-in, and sign-out flows with Kinde authentication.

## Recommended setup

1. **Use username/password authentication**: Configure your test environment with email + password as the sign-in method. This avoids dependencies on external services (social providers, email verification).

2. **Create a verified test user**: Set up a test user with a verified email address to skip verification flows.

3. **Use a test application**: Create a dedicated application in Kinde for testing purposes.

## Tool comparison

Different browser automation tools offer various trade-offs. Here's a comparison:

| Method | Pros | Cons |
| --- | --- | --- |
| **AWS Synthetic Canaries** | Native AWS integration, scheduled runs, built-in metrics | Higher cost per execution |
| **Self-hosted Playwright/Puppeteer** | Lower cost, full control | Requires infrastructure management |
| **Cypress Cloud** | Great DX, parallel execution | Subscription cost |
| **Playwright (self-hosted)** | Modern API, cross-browser support, free | Requires CI/CD setup |

## Example: AWS CloudWatch Synthetic Canaries

Here's a pattern using AWS CloudWatch Synthetic Canaries with Puppeteer:

```jsx
// Synthetic canary script
const synthetics = require('Synthetics');
const { launch } = require('puppeteer-core');

const flowStep = async (stepName, action) => {
  await synthetics.executeStep(stepName, action);
};

exports.handler = async () => {
  const page = await synthetics.getPage();

  await flowStep('Open app', async () => {
    await page.goto('https://your-app.com');
  });

  await flowStep('Click sign in', async () => {
    await page.click('[data-testid="sign-in-button"]');
  });

  await flowStep('Enter email', async () => {
    await page.type('input[name="email"]', 'test@example.com');
    await page.click('button[type="submit"]');
  });

  await flowStep('Enter password', async () => {
    await page.type('input[name="password"]', process.env.TEST_PASSWORD);
    await page.click('button[type="submit"]');
  });

  await flowStep('Verify signed in', async () => {
    await page.waitForSelector('[data-testid="user-profile"]');
  });

  await flowStep('Sign out', async () => {
    await page.click('[data-testid="sign-out-button"]');
  });
};
```

## Testing sign-up flows

When testing sign-up flows, ensure:

1. **Test user doesn't exist**: Use unique email addresses for each test run (e.g., `test-${timestamp}@example.com`)
2. **Handle email verification**: If email verification is required, use an email testing service (see Passwordless flows below)
3. **Verify redirect**: Check that users are redirected to the correct page after sign-up
4. **Test error cases**: Test with invalid emails, weak passwords, etc.

**Example with Playwright:**

```tsx
test('user can sign up', async ({ page }) => {
  const timestamp = Date.now();
  const testEmail = `test-${timestamp}@example.com`;

  await page.goto('https://your-app.com');
  await page.click('[data-testid="sign-up-button"]');

  // Wait for Kinde sign-up page
  await page.waitForURL(/.*kinde\.com.*/);

  // Fill sign-up form
  await page.fill('input[name="p_email"]', testEmail);
  await page.fill('input[name="p_password"]', 'SecurePassword123!');
  await page.click('button[type="submit"]');

  // Wait for redirect back to app
  await page.waitForURL('https://your-app.com/**');
  await expect(page.locator('[data-testid="user-profile"]')).toBeVisible();
});
```

## Testing sign-in flows

For sign-in flows:

1. **Use existing test user**: Create a verified test user beforehand
2. **Test both success and failure**: Test valid credentials and invalid credentials
3. **Verify session**: Ensure the user is properly authenticated after sign-in
4. **Test redirects**: Verify redirects to intended pages

**Example with Playwright:**

```tsx
test('user can sign in with email and password', async ({ page }) => {
  await page.goto('https://your-app.com');
  await page.click('[data-testid="sign-in-button"]');

  // Wait for Kinde login page
  await page.waitForURL(/.*kinde\.com.*/);

  // Enter credentials
  await page.fill('input[name="p_email"]', process.env.TEST_USER_EMAIL!);
  await page.click('button[type="submit"]');

  await page.fill('input[name="p_password"]', process.env.TEST_USER_PASSWORD!);
  await page.click('button[type="submit"]');

  // Wait for redirect back to app
  await page.waitForURL('https://your-app.com/**');
  await expect(page.locator('[data-testid="user-profile"]')).toBeVisible();
});

test('invalid credentials show error message', async ({ page }) => {
  await page.goto('https://your-app.com');
  await page.click('[data-testid="sign-in-button"]');

  await page.fill('input[name="p_email"]', 'invalid@example.com');
  await page.click('button[type="submit"]');

  await page.fill('input[name="p_password"]', 'wrong-password');
  await page.click('button[type="submit"]');

  // Should show error
  await expect(page.locator('[data-testid="error-message"]')).toBeVisible();
});
```

## Testing sign-out flows

Test that sign-out:

1. **Clears session**: User is no longer authenticated
2. **Redirects correctly**: User is redirected to the intended page
3. **Protects routes**: Protected routes are no longer accessible

**Example with Playwright:**

```tsx
test('user can sign out', async ({ page }) => {
  // First authenticate
  await page.goto('https://your-app.com');
  await page.click('[data-testid="sign-in-button"]');
  await page.fill('input[name="p_email"]', process.env.TEST_USER_EMAIL!);
  await page.click('button[type="submit"]');
  await page.fill('input[name="p_password"]', process.env.TEST_USER_PASSWORD!);
  await page.click('button[type="submit"]');
  await page.waitForURL('https://your-app.com/**');

  // Now sign out
  await page.click('[data-testid="sign-out-button"]');

  // Should show signed-out state
  await expect(page.locator('[data-testid="sign-in-button"]')).toBeVisible();
  
  // Protected route should redirect
  await page.goto('https://your-app.com/dashboard');
  await expect(page).toHaveURL(/.*sign-in.*/);
});
```

## Handling passwordless flows (Email OTP)

Testing passwordless authentication with email OTP requires capturing the verification code. Some approaches:

### Using a test email service

**Mailosaur** or **Mailtrap** provide API access to test inboxes:

```tsx
import MailosaurClient from 'mailosaur';

const mailosaur = new MailosaurClient(process.env.MAILOSAUR_API_KEY!);
const serverId = process.env.MAILOSAUR_SERVER_ID!;
const testEmail = `test.${serverId}@mailosaur.net`;

// Request OTP
await page.fill('input[name="p_email"]', testEmail);
await page.click('button[type="submit"]');

// Wait for OTP email
const email = await mailosaur.messages.get(serverId, {
  sentTo: testEmail,
});

// Extract 6-digit OTP code from email
const otpMatch = email.text?.body?.match(/\b(\d{6})\b/);
const otpCode = otpMatch?.[1];

// Enter OTP
await page.fill('input[name="p_otp"]', otpCode);
await page.click('button[type="submit"]');
```

### Email-to-storage pipeline

Route test emails to S3 or a database, then query from your tests:

```tsx
// utils/email-otp.ts
import { S3Client, GetObjectCommand } from '@aws-sdk/client-s3';

const s3 = new S3Client({ region: 'us-east-1' });

export async function waitForOTPEmail(
  email: string,
  timeoutMs = 30000
): Promise<string> {
  const startTime = Date.now();

  while (Date.now() - startTime < timeoutMs) {
    try {
      const command = new GetObjectCommand({
        Bucket: 'your-test-emails-bucket',
        Key: `${email}/latest.txt`,
      });

      const response = await s3.send(command);
      const body = await response.Body?.transformToString();

      const otpMatch = body?.match(/\b(\d{6})\b/);
      if (otpMatch) {
        return otpMatch[1];
      }
    } catch (e) {
      // Email not arrived yet
    }

    await new Promise((r) => setTimeout(r, 1000));
  }

  throw new Error('Timeout waiting for OTP email');
}
```

### Dedicated test domain

Configure a subdomain's email to be programmatically accessible.

## What's not supported

The following limitations apply to UI authentication flow testing:

- **Social provider flows**: Automated testing of Google, GitHub, or other social sign-in flows is not directly supported due to third-party provider restrictions
- **Enterprise SSO flows**: Testing SAML/SSO enterprise connections requires coordination with identity providers
- **MFA flows**: Testing multi-factor authentication may require manual intervention
- **Real email delivery**: Testing with real email addresses requires manual code entry (use test email services instead)

## Best practices

1. **Use data-testid attributes**: Add test IDs to your UI elements for reliable selectors
2. **Handle redirects gracefully**: Add appropriate waits for Kinde redirects (they can take time)
3. **Isolate test users**: Use separate test users for each test run when possible
4. **Clean up test data**: Delete test users or test data after test runs when possible
5. **Handle flakiness**: Add retry logic for network-related failures
6. **Use environment variables**: Store test credentials securely, never commit to source control

## Related guides

- [Testing Authenticated Features with Playwright](/developer-tools/testing/testing-authenticated-features-playwright/) - Learn how to test features after authentication
- [Backend API Testing with Refresh Tokens](/developer-tools/testing/backend-api-testing/) - Learn how to test APIs without browser automation

