---
page_id: c1b1ea81-35f9-467e-8079-042d6a786e55
title: Testing authentication flows
description: "Guide to testing sign-up, sign-in, and sign-out flows using browser automation tools like Playwright, Cypress, and AWS CloudWatch Synthetic Canaries."
sidebar:
  order: 4
relatedArticles:
  - cc2bd7c3-b365-417f-a6d0-a2685acd6a7e
  - 5a67a5c0-3211-4d66-a090-4df8fde1cdad
  - f38ed786-7234-44d1-a564-f7269ce536c5
  - a1b2c3d4-e5f6-7890-abcd-ef1234567890
topics:
  - developer-tools
  - testing
  - ui-testing
  - e2e-testing
  - authentication
sdk: []
languages:
  - JavaScript
  - TypeScript
  - Python
audience: developers
complexity: intermediate
keywords:
  - UI testing
  - authentication flows
  - sign-up testing
  - sign-in testing
  - Playwright
  - Cypress
  - AWS CloudWatch
  - browser automation
updated: 2025-12-18
featured: false
deprecated: false
ai_summary: Guide to testing authentication flows (sign-up, sign-in, sign-out) using browser automation tools including Playwright, Cypress, and AWS CloudWatch Synthetic Canaries.
---

Authentication is critical, and when it breaks, users can't access your product. This guide shows you how to test Kinde authentication flows using browser automation tools like Playwright, Cypress, and AWS CloudWatch Synthetic Canaries. You'll learn how to automate sign-up, sign-in, and sign-out flows, test error scenarios, and verify session management.

### What you need

- A test user with email and password created in the [test user and environment setup](/developer-tools/testing/setup-test-user-environment/) guide.

## Tool comparison

Different browser automation tools offer various trade-offs. Here's a comparison:

| Method | Pros | Cons |
| --- | --- | --- |
| **AWS Synthetic Canaries** | Native AWS integration, scheduled runs, built-in metrics | Higher cost per execution |
| **Playwright (self-hosted)** | Modern API, cross-browser support, free | Requires CI/CD setup |
| **Cypress Cloud** | Great DX, parallel execution | Subscription cost |
| **Self-hosted Puppeteer** | Lower cost, full control | Requires infrastructure management |

## Testing sign-up flows

Kinde requires OTP email verification when signing up for a new user. See the [Testing Passwordless Flows](/developer-tools/testing/testing-passwordless-flows/) guide for details on how to handle OTP verification in your test methods.

When testing sign-up flows, ensure:

1. **Test user doesn't exist**: Use unique email addresses for each test run (e.g., `test-${timestamp}@example.com`)
2. **Handle email verification**: Use an email testing service to test user sign up
3. **Verify redirect**: Check that users are redirected to the correct page after sign-up
4. **Test error cases**: Test with invalid emails, weak passwords, etc.

### General pattern

The typical sign-up flow involves:

1. Navigate to your application
2. Click the sign-up button (redirects to Kinde)
3. Fill in email and password on the Kinde sign-up page
4. Submit the form
5. Handle OTP email verification (extract code from email and enter it)
6. Wait for redirect back to your application
7. Verify the user is authenticated

**Key selectors to use:**
- Email input: `input[name="p_email"]`
- Password input: `input[name="p_password"]`
- OTP input: `input[name="p_otp"]`
- Submit button: `button[type="submit"]`

## Testing sign-in flows

For sign-in flows:

1. **Use existing test user**: Create a verified test user beforehand
2. **Test both success and failure**: Test valid credentials and invalid credentials
3. **Verify session**: Ensure the user is properly authenticated after sign-in
4. **Test redirects**: Verify redirects to intended pages

### General pattern

The typical sign-in flow involves:

1. Navigate to your application
2. Click the sign-in button (redirects to Kinde)
3. Enter email and submit
4. Enter password and submit
5. Wait for redirect back to your application
6. Verify the user is authenticated

**Error handling:**
- Test with invalid credentials
- Verify error messages are displayed
- Ensure users remain on the login page after errors

## Testing sign-out flows

Test that sign-out:

1. **Clears session**: User is no longer authenticated
2. **Redirects correctly**: User is redirected to the intended page
3. **Protects routes**: Protected routes are no longer accessible

### General pattern

The typical sign-out flow involves:

1. Authenticate the user first
2. Click the sign-out button
3. Verify the user is signed out (sign-in button visible)
4. Attempt to access protected routes
5. Verify redirect to sign-in page

## Example: AWS CloudWatch Synthetic Canaries

Here's a pattern using AWS CloudWatch Synthetic Canaries with Puppeteer:

```jsx
// Synthetic canary script
const synthetics = require('Synthetics');
const { launch } = require('puppeteer-core');

const flowStep = async (stepName, action) => {
  await synthetics.executeStep(stepName, action);
};

exports.handler = async () => {
  const page = await synthetics.getPage();

  // Sign-up flow
  await flowStep('Open app for sign-up', async () => {
    await page.goto('https://your-app.com');
  });

  await flowStep('Click sign up', async () => {
    await page.click('[data-testid="sign-up-button"]');
  });

  await flowStep('Fill sign-up form', async () => {
    const timestamp = Date.now();
    const testEmail = `test-${timestamp}@mailosaur.net`;
    
    await page.type('input[name="p_email"]', testEmail);
    await page.type('input[name="p_password"]', process.env.TEST_PASSWORD);
    await page.click('button[type="submit"]');
  });

  await flowStep('Handle OTP verification', async () => {
    // Wait for OTP email and extract code
    // Note: Integrate with Mailosaur or email service to retrieve OTP
    // See Testing Passwordless Flows guide for email service integration
    // const otpCode = await getOTPFromEmail(testEmail);
    // await page.type('input[name="p_otp"]', otpCode);
    // await page.click('button[type="submit"]');
  });

  await flowStep('Verify signed up', async () => {
    await page.waitForSelector('[data-testid="user-profile"]');
  });

  // Sign-in flow (sign out first to reset state)
  await flowStep('Sign out before sign-in test', async () => {
    await page.click('[data-testid="sign-out-button"]');
  });

  await flowStep('Click sign in', async () => {
    await page.click('[data-testid="sign-in-button"]');
  });

  await flowStep('Enter email', async () => {
    await page.type('input[name="p_email"]', process.env.TEST_USER_EMAIL);
    await page.click('button[type="submit"]');
  });

  await flowStep('Enter password', async () => {
    await page.type('input[name="p_password"]', process.env.TEST_PASSWORD);
    await page.click('button[type="submit"]');
  });

  await flowStep('Verify signed in', async () => {
    await page.waitForSelector('[data-testid="user-profile"]');
  });

  // Sign-out flow
  await flowStep('Sign out', async () => {
    await page.click('[data-testid="sign-out-button"]');
  });

  await flowStep('Verify signed out', async () => {
    await page.waitForSelector('[data-testid="sign-in-button"]');
  });
};
```

## Example: Cypress

Here's a pattern using Cypress for testing authentication flows:

```tsx
describe('Authentication Flows', () => {
  it('user can sign up with email and password', () => {
    // Generate unique email for this test run
    const timestamp = Date.now();
    const testEmail = `test-${timestamp}@mailosaur.net`;
    
    cy.visit('https://your-app.com');
    cy.get('[data-testid="sign-up-button"]').click();
    
    // Wait for Kinde sign-up page
    cy.url().should('include', 'kinde.com');
    
    // Fill sign-up form
    cy.get('input[name="p_email"]').type(testEmail);
    cy.get('input[name="p_password"]').type(Cypress.env('TEST_PASSWORD'));
    cy.get('button[type="submit"]').click();
    
    // Wait for OTP email and extract code
    // Note: Integrate with Mailosaur or email service to retrieve OTP
    // See Testing Passwordless Flows guide for email service integration
    // cy.task('getOTPFromEmail', testEmail).then((otpCode) => {
    //   cy.get('input[name="p_otp"]').type(otpCode);
    //   cy.get('button[type="submit"]').click();
    // });
    
    // Wait for redirect back to app
    cy.url().should('include', 'your-app.com');
    cy.get('[data-testid="user-profile"]').should('be.visible');
  });

  it('user can sign in with email and password', () => {
    cy.visit('https://your-app.com');
    cy.get('[data-testid="sign-in-button"]').click();

    // Wait for Kinde login page
    cy.url().should('include', 'kinde.com');

    // Enter credentials
    cy.get('input[name="p_email"]').type(Cypress.env('TEST_USER_EMAIL'));
    cy.get('button[type="submit"]').click();

    cy.get('input[name="p_password"]').type(Cypress.env('TEST_USER_PASSWORD'));
    cy.get('button[type="submit"]').click();

    // Wait for redirect back to app
    cy.url().should('include', 'your-app.com');
    cy.get('[data-testid="user-profile"]').should('be.visible');
  });

  it('user can sign out', () => {
    // First authenticate (or use cy.session for state reuse)
    cy.visit('https://your-app.com');
    cy.get('[data-testid="sign-in-button"]').click();
    cy.get('input[name="p_email"]').type(Cypress.env('TEST_USER_EMAIL'));
    cy.get('button[type="submit"]').click();
    cy.get('input[name="p_password"]').type(Cypress.env('TEST_USER_PASSWORD'));
    cy.get('button[type="submit"]').click();
    cy.url().should('include', 'your-app.com');

    // Now sign out
    cy.get('[data-testid="sign-out-button"]').click();

    // Should show signed-out state
    cy.get('[data-testid="sign-in-button"]').should('be.visible');
  });
});
```

## Example: Playwright

Here's a pattern using Playwright for testing authentication flows:

```tsx
import { test, expect } from '@playwright/test';

test.describe('Authentication Flows', () => {
  test('user can sign up with email and password', async ({ page }) => {
    // Generate unique email for this test run
    const timestamp = Date.now();
    const testEmail = `test-${timestamp}@mailosaur.net`;
    
    await page.goto('https://your-app.com');
    await page.click('[data-testid="sign-up-button"]');
    
    // Wait for Kinde sign-up page
    await expect(page).toHaveURL(/kinde\.com/);
    
    // Fill sign-up form
    await page.fill('input[name="p_email"]', testEmail);
    await page.fill('input[name="p_password"]', process.env.TEST_PASSWORD!);
    await page.click('button[type="submit"]');
    
    // Wait for OTP email and extract code
    // Note: Integrate with Mailosaur or email service to retrieve OTP
    // See Testing Passwordless Flows guide for email service integration
    // const otpCode = await getOTPFromEmail(testEmail);
    // await page.fill('input[name="p_otp"]', otpCode);
    // await page.click('button[type="submit"]');
    
    // Wait for redirect back to app
    await expect(page).toHaveURL(/your-app\.com/);
    await expect(page.locator('[data-testid="user-profile"]')).toBeVisible();
  });

  test('user can sign in with email and password', async ({ page }) => {
    await page.goto('https://your-app.com');
    await page.click('[data-testid="sign-in-button"]');
    
    // Wait for Kinde login page
    await expect(page).toHaveURL(/kinde\.com/);
    
    // Enter credentials
    await page.fill('input[name="p_email"]', process.env.TEST_USER_EMAIL!);
    await page.click('button[type="submit"]');
    
    await page.fill('input[name="p_password"]', process.env.TEST_USER_PASSWORD!);
    await page.click('button[type="submit"]');
    
    // Wait for redirect back to app
    await expect(page).toHaveURL(/your-app\.com/);
    await expect(page.locator('[data-testid="user-profile"]')).toBeVisible();
  });

  test('user can sign out', async ({ page }) => {
    // First authenticate
    await page.goto('https://your-app.com');
    await page.click('[data-testid="sign-in-button"]');
    await page.fill('input[name="p_email"]', process.env.TEST_USER_EMAIL!);
    await page.click('button[type="submit"]');
    await page.fill('input[name="p_password"]', process.env.TEST_USER_PASSWORD!);
    await page.click('button[type="submit"]');
    await expect(page).toHaveURL(/your-app\.com/);
    
    // Now sign out
    await page.click('[data-testid="sign-out-button"]');
    
    // Should show signed-out state
    await expect(page.locator('[data-testid="sign-in-button"]')).toBeVisible();
  });
});
```

## What's not supported

The following limitations apply to UI authentication flow testing:

- **Social provider flows**: Automated testing of Google, GitHub, or other social sign-in flows is not directly supported due to third-party provider restrictions
- **Enterprise SSO flows**: Testing SAML/SSO enterprise connections requires coordination with identity providers
- **MFA flows**: Testing multi-factor authentication may require manual intervention
- **Real email delivery**: Testing with real email addresses requires manual code entry (use test email services instead)

## Best practices

1. **Use data-testid attributes**: Add test IDs to your UI elements for reliable selectors
2. **Handle redirects gracefully**: Add appropriate waits for Kinde redirects (they can take time)
3. **Isolate test users**: Use separate test users for each test run when possible
4. **Clean up test data**: Delete test users or test data after test runs when possible
5. **Handle flakiness**: Add retry logic for network-related failures
6. **Use environment variables**: Store test credentials securely, never commit to source control

## Passwordless authentication flows

If your application uses passwordless authentication with email OTP, see the dedicated guide on **[Testing Passwordless Flows](/developer-tools/testing/testing-passwordless-flows/)**.
