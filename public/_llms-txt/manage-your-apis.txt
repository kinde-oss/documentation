---
page_id: 0a1b2c3d-4e5f-6a7b-8c9d-0e1f2a3b4c5d
title: Kinde Documentation - Manage your apis
description: "Complete documentation for Kinde's manage your apis section containing titles, descriptions, keywords, topics, and full content from all documentation files in this section for LLM training"
sidebar:
  order: 1
topics:
  - llm
  - documentation
  - training
  - manage-your-apis
sdk: []
languages:
  - markdown
  - text
audience: developers
complexity: beginner
keywords:
  - llm training
  - documentation
  - manage-your-apis
  - section
  - frontmatter
  - metadata
  - kinde
updated: 2025-09-18
featured: false
deprecated: false
ai_summary: "Complete documentation for Kinde's manage your apis section containing titles, descriptions, keywords, topics, and full content from all documentation files in this section for LLM training"
---

# Kinde Documentation - Manage your apis

This is the complete documentation for Kinde's manage your apis section containing titles, descriptions, keywords, topics, and full content from all documentation files in this section.

# Manage your apis - About api keys - API best practice for AI apps

> Tips for using API keys to securely integrate AI applications, including performance, and monitoring recommendations.

ai applications, api keys, ai integration, ai security
api-keys, key-types

Here's a selection of recommendations for using API keys to build AI apps. ## Security tips for AI apps - **Always verify API keys**: Never trust unverified API keys - **Validate trusted context**: Ensure AI operations are within user or organization boundaries - **Sanitize inputs**: Clean AI inputs to prevent injection attacks - **Validate outputs**: Check AI responses for harmful content - **Rate limiting**: Implement stricter limits for AI endpoints ## Performance tips for AI apps - **Cache AI responses**: Cache common AI responses to reduce latency - **Async processing**: Use async/await for AI operations - **Timeout handling**: Set reasonable timeouts for AI requests - **Resource monitoring**: Track AI resource usage per user or organization ## Monitoring tips for AI apps - **Usage tracking**: Monitor AI usage patterns per user or organization - **Performance metrics**: Track response times and success rates - **Error logging**: Log all AI-related errors with context - **Cost tracking**: Monitor AI costs per organization ## Integration tips for AI apps - **Clear boundaries**: Define clear limits for AI access - **Documentation**: Document AI capabilities and limitations - **Testing**: Test AI integration thoroughly - **Fallbacks**: Provide fallback options when AI is unavailable

# Manage your apis - About api keys - API key best practices

> Recommended security, performance, and monitoring practices for implementing API keys with Kinde.

api key best practices, security, performance, monitoring
api-keys, best-practices

Here's some tips to ensure you use API keys with security and performance in mind. ## Security - **Validate scopes**: always check that a key has the required scopes for the requested action. - **Cache verification results**: cache positive verification results briefly to reduce load and latency. - **Log verification attempts**: record verification attempts and outcomes for auditing. - **Rotate API keys**: rotate keys on a regular cadence and after suspected exposure. See (/manage-your-apis/add-manage-api-keys/rotate-api-keys/) - **Revoke keys**: promptly revoke keys that are no longer needed. See (/manage-your-apis/add-manage-api-keys/revoke-api-keys/) ## Performance - **Implement caching**: cache verification results for 5â€“10 minutes where appropriate. - **Use async verification**: avoid blocking request handlers while waiting on verification. ## Monitoring - **Track usage**: Monitor which keys are used most and when, in general and by specific customers. - **Set up alerts**: Alert on spikes in failed verification attempts and unusual patterns. - **Monitor performance**: Track verification latency and error rates over time.

# Manage your apis - About api keys - Using API keys for AI products

> Learn how to use API keys to securely integrate AI applications for both B2C (user-level) and B2B (organization-level) products while maintaining proper data isolation

ai applications, api keys, user level, organization level, ai integration, data isolation, ai security
api-keys, key-types

API keys are ideal for people building AI products. They allow developers to securely connect apps to third-party services (like OpenAI) and to manage access to AI models or data. For example, a SaaS app might use API keys to let users generate AI-powered content, analyze data, or automate workflows. API keys also provide secure authentication, usage tracking, and control over access, making it easier to safely expose AI capabilities to end-users without exposing underlying system credentials. This guide shows you how to implement secure AI integrations for both B2C (user-level) and B2B (organization-level) products while maintaining proper data isolation. ## Why use API keys for AI (B2C and B2B)? ### B2C (user-level) benefits - **Clear user context**: Every AI action is attributed to a specific user (`user_id`). - **Trusted verification**: The `user_id` in verification responses is verified and cannot be tampered with. - **Audit trail**: Attribute model actions, prompts, and results to a user. ### B2B (organization-level) benefits - **Clear organization context**: AI applications are associated with specific organizations (`org_code`). - **Trusted verification**: The `org_code` in verification responses is verified and cannot be tampered with. - **Audit trail**: Track which organization each AI operation affects. ### Use case examples (both) - **Customer AI assistants**: Respond using a user's or organization's data. - **AI-powered analytics**: Analyze personal or organization datasets. - **Automated workflows**: Perform tasks within user or organization boundaries. - **Intelligent integrations**: Connect to customer systems with the right context. ## Choose the right API key type - Use user-level API keys for B2C features, personal assistants, or per-user automations. - Use organization-level API keys for multi-tenant B2B features, shared datasets, or team automations. Learn more: user-level keys (/manage-your-apis/key-types/api-keys-for-users/), organization-level keys (/manage-your-apis/key-types/api-keys-for-organizations/) ## Setting up AI applications with API keys ### Step 1a: Create organization-level API keys (B2B) ```bash # Create an API key for each customer's AI integration curl -X POST https://your-domain.kinde.com/api/v1/api_keys \ -H "Authorization: Bearer YOUR_M2M_TOKEN" \ -H "Content-Type: application/json" \ -d '{ "name": "AI Assistant for Customer ABC", "api_id": "api_customer_data", "scope_ids": ["read:users", "read:analytics", "read:support"], "org_code": "org_customer_abc" }' ``` ### Step 1b: Create user-level API keys (B2C) ```bash # Create an API key for a user's personal AI assistant curl -X POST https://your-domain.kinde.com/api/v1/api_keys \ -H "Authorization: Bearer YOUR_M2M_TOKEN" \ -H "Content-Type: application/json" \ -d '{ "name": "Personal AI Assistant for Jane Doe", "api_id": "api_user_data", "scope_ids": ["read:profile", "read:history"], "user_id": "kp_1234567890" }' ``` ### Step 2: Configure your API scopes - Define scopes for your AI endpoints in your API settings. For example: - `read:ai_chats` - `write:ai_chat` - `read:ai_analytics` - `write:ai_analytics` - `read:ai_workflows` - Assign the appropriate `scope_ids` when creating keys (see step 1a/1b above). - Enforce scopes at runtime when handling requests: ```javascript // After verifying the API key const requiredScopes = ["read:ai_chats"]; // adjust per endpoint for (const scope of requiredScopes) { if (!verification.scopes.includes(scope)) { return res.status(403).json({error: `Insufficient scope: ${scope}`}); } } ``` Learn more: Scopes for API keys (/manage-your-apis/api-key-setup/scopes-for-api-keys/), Secure your API using scopes (/manage-your-apis/your-apis/custom-api-scopes/) ### Step 3: Implement AI logic with trusted context ```javascript class AIApplication { constructor(apiKey) { this.apiKey = apiKey; this.organization = null; // For org-level keys this.userId = null; // For user-level keys } async authenticate() { const verification = await this.verifyApiKey(); this.organization = verification.org_code || null; this.userId = verification.user_id || null; return verification; } async verifyApiKey() { const response = await fetch("https://your-domain.kinde.com/api/v1/api_keys/verify", { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ api_key: this.apiKey }) }); if (!response.ok) { throw new Error("API key verification failed"); } return response.json(); } async processAIRequest(prompt, context = {}) { // Ensure we have some trusted context if (!this.organization && !this.userId) { throw new Error("AI application not authenticated"); } // Add context (user or organization) to the prompt const enhancedPrompt = ` ContextOwner: ${this.organization ? `org:${this.organization}` : `user:${this.userId}`} Context: ${JSON.stringify(context)} User Request: ${prompt} `; // Process with AI provider const aiResponse = await this.callAIProvider(enhancedPrompt); return { response: aiResponse, organization: this.organization, user_id: this.userId, context }; } } ``` ## Common AI integration patterns ### AI support or help assistant (handles both) ```javascript app.post("/ai/support", async (req, res) => { try { const apiKey = extractApiKey(req); const verification = await verifyApiKey(apiKey); if (!verification.is_valid) { return res.status(401).json({error: "Invalid API key"}); } // Restrict data to either the user or organization context const contextOwner = verification.org_code ? {org: verification.org_code} : {user: verification.user_id}; if (!contextOwner.org && !contextOwner.user) { return res .status(403) .json({error: "Trusted context required (user-level or org-level API key)"}); } // Fetch only allowed data for that context const supportHistory = contextOwner.org ? await getOrgSupportHistory(contextOwner.org) : await getUserSupportHistory(contextOwner.user); const profile = contextOwner.org ? await getOrgProfile(contextOwner.org) : await getUserProfile(contextOwner.user); // Process AI request with context const aiResponse = await processSupportRequest( req.body.message, supportHistory, profile, contextOwner ); res.json({ response: aiResponse, organization: verification.org_code || null, user_id: verification.user_id || null, data_sources: ["support_history", "profile"] }); } catch (error) { console.error("AI support error:", error); res.status(500).json({error: "Internal server error"}); } }); ``` ### AI-powered analytics dashboard ```javascript app.get("/ai/analytics", async (req, res) => { try { const apiKey = extractApiKey(req); const verification = await verifyApiKey(apiKey); if (!verification.is_valid) { return res.status(401).json({error: "Invalid API key"}); } // If it's org-level, analyze org data; otherwise analyze per-user analytics const analyticsData = verification.org_code ? await getOrgAnalyticsData(verification.org_code) : await getUserAnalyticsData(verification.user_id); // Generate AI insights const insights = await generateAnalyticsInsights( analyticsData, verification.org_code || verification.user_id ); res.json({ insights, organization: verification.org_code || null, user_id: verification.user_id || null, data_summary: { total_records: analyticsData.length, date_range: analyticsData.dateRange } }); } catch (error) { console.error("AI analytics error:", error); res.status(500).json({error: "Internal server error"}); } }); ``` ### AI workflow automation ```javascript app.post("/ai/workflow", async (req, res) => { try { const apiKey = extractApiKey(req); const verification = await verifyApiKey(apiKey); if (!verification.is_valid) { return res.status(401).json({error: "Invalid API key"}); } // Execute within the allowed boundary (user or organization) const workflowData = verification.org_code ? await getOrgWorkflowData(verification.org_code) : await getUserWorkflowData(verification.user_id); const permissions = verification.org_code ? await getOrgPermissions(verification.org_code) : await getUserPermissions(verification.user_id); // Execute AI workflow const result = await executeAIWorkflow( req.body.workflow, workflowData, permissions, verification.org_code || verification.user_id ); res.json({ result, organization: verification.org_code || null, user_id: verification.user_id || null, workflow_id: result.id, execution_time: new Date().toISOString() }); } catch (error) { console.error("AI workflow error:", error); res.status(500).json({error: "Internal server error"}); } }); ``` ## AI-specific security considerations ### Rate limiting for AI applications ```javascript const rateLimit = require("express-rate-limit"); // Stricter rate limiting for AI endpoints const aiRateLimiter = rateLimit({ windowMs: 15 * 60 * 1000, // 15 minutes max: 50, // Limit each API key to 50 AI requests per window message: { error: "AI rate limit exceeded", code: "AI_RATE_LIMITED" }, keyGenerator: (req) => { // Use API key as rate limit key return req.apiKey?.key_id || req.ip; } }); app.use("/ai/*", aiRateLimiter); ``` ### AI prompt security ```javascript function sanitizeAIInput(input) { // Remove potentially harmful content const sanitized = input .replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, "") .replace(/javascript:/gi, "") .replace(/on\w+\s*=/gi, ""); // Limit input length if (sanitized.length > 10000) { throw new Error("Input too long"); } return sanitized; } app.post("/ai/process", async (req, res) => { try { const sanitizedInput = sanitizeAIInput(req.body.input); // Process with AI... const result = await processWithAI(sanitizedInput); res.json({result}); } catch (error) { res.status(400).json({error: error.message}); } }); ``` ### AI response validation ```javascript function validateAIResponse(response) { // Check for potentially harmful content const harmfulPatterns = [ /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, /javascript:/gi, /on\w+\s*=/gi ]; for (const pattern of harmfulPatterns) { if (pattern.test(response)) { throw new Error("AI response contains potentially harmful content"); } } // Check response length if (response.length > 50000) { throw new Error("AI response too long"); } return response; } ``` ## Monitoring AI applications ### Track AI usage patterns ```javascript function logAIUsage(apiKey, organization, endpoint, inputLength, responseLength) { logger.info("AI usage", { api_key: apiKey, organization, endpoint, input_length: inputLength, response_length: responseLength, timestamp: new Date().toISOString() }); } // Usage in endpoints app.post("/ai/chat", async (req, res) => { const startTime = Date.now(); try { // ... AI processing logic ... // Log usage logAIUsage( req.apiKey.key_id, req.apiKey.org_code || req.apiKey.user_id, "/ai/chat", req.body.message.length, response.length ); res.json({response}); } catch (error) { // Log errors too logger.error("AI chat error", { error: error.message, context: req.apiKey?.org_code || req.apiKey?.user_id }); res.status(500).json({error: "Internal server error"}); } }); ``` ### AI performance monitoring ```javascript function monitorAIPerformance(organization, endpoint, duration, success) { // Track response times if (duration > 5000) { // 5 seconds logger.warn("Slow AI response", { organization, endpoint, duration, threshold: 5000 }); } // Track success rates if (!success) { logger.error("AI request failed", { organization, endpoint, duration }); } } ```

# Manage your apis - About api keys - API keys overview

> Learn how to manage API keys for your own APIs using Kinde's API key management system

api key management, api keys, key verification, registered apis, Verify keys, key lifecycle
api-keys, about-api-keys

Kinde provides a comprehensive API key management system that allows you to issue and manage API keys for your own APIs. This system supports both organization-level and user-level key management, making it suitable for B2B, B2C, and B2B2C business models. <Aside type="upgrade"> This feature is available on [Kinde paid plans](https://kinde.com/pricing/) </Aside> ## What are API keys? API keys are long-lived credentials that allow end users to authenticate with your APIs. They provide a simple way for users to access your services without going through OAuth flows and enables them to make requests outside of the browser, such as with CLIs, cURL, etc. ### Key characteristics - **Scoped**: each key is limited to a specific API - **Permissions**: each key can be granted specific scopes/permissions - **Secure**: keys are stored as secure hashes and never exposed after creation - **Manageable**: keys can be created, rotated, and revoked as needed - **Long-lived**: API keys don't expire unless you set an expiration date (coming soon) ## Key management models ### Organization-level keys - Managed by organization administrators - Suitable for B2B scenarios where customers need access to your APIs - Keys are associated with specific organizations - Admins can manage keys on behalf of their users ### User-level keys - Managed by individual users - Suitable for B2C scenarios where end users need API access - Users create and manage their own keys - Keys are associated with specific user accounts ## How API keys work ### 1. Register an API Before you can issue API keys, you must register your APIs in Kinde: - Provide a name and description - Define available scopes - Get a unique `api_id` for each API Read more about [API registration](/developer-tools/your-apis/register-manage-apis/). ### 2. Create keys When creating an API key: - Associate it with a registered API - Assign specific scopes for access control - Generate a secure secret (shown only once) - Create a stable `key_id` for management ### 3. Use keys End users include the API key in their requests to your API: - Usually sent in an `Authorization` header - Your API extracts the key and verifies it with Kinde - Kinde returns validation results including scopes and metadata Read more about [verifying API keys](/manage-your-apis/add-manage-api-keys/verify-api-keys-in-your-api/). ### 4. Manage keys Keys can be managed throughout their lifecycle: - **Rotate**: generate new secrets while keeping the same key ID - **Revoke**: mark keys as inactive - **Update**: modify associated APIs or scopes (requires new key) ## What you can use API keys for ### AI and automation - Enable AI agents to access your APIs - Support automated workflows and integrations - Provide secure access for machine learning applications ### Third-party integrations - Allow customers to integrate with your platform - Provide different access levels based on customer tier - Track usage and enforce rate limits ### Internal automation - Enable automated scripts and tools - Provide secure access for CI/CD pipelines - Support internal development and testing ### Partner access - Grant partners access to specific APIs - Control what data and features partners can access - Maintain audit trails for compliance ### Developer tools - Provide API access for developer tools and SDKs - Enable self-service API exploration - Support API testing and development ## API key security features ### Secure storage - API key secrets are never stored in plain text - All secrets are hashed using secure algorithms - No way to retrieve the original secret after creation ### Access control - Keys are tied to a single API - Keys can be granted specific scopes/permissions - Organization-level isolation prevents cross-tenant access

# Manage your apis - About api keys - API keys quick start

> Get started with API key management in Kinde - create, manage, and verify API keys for your own APIs

api key quick start, get started with api keys, api key management, key verification, registered apis
api-keys, about-api-keys

This guide will walk you through setting up API key management for your APIs using Kinde. You'll learn how to register your APIs, create API keys, and implement key verification in your application. ## Prerequisites Before you following this guide, ensure you have: - A Kinde account with admin access - An API that you want to protect with API keys ## Step 1: Register your API Before you can issue API keys, you need to register your API in Kinde: 1. Go to **Settings** > **APIs**. 2. Select **Add API**. 3. Enter an API name and Audience. The audience (aud) is a unique identifier for this API. Often a short code or the URL of the API is used. 4. Select **Save**. You'll see an `API ID` for your new API. This ID is used when creating API keys. ## Step 2: Create an API key for a user or organization You can enable your customers to create API keys via the self-service portal or via API, but for this guide we'll assume you are creating them on their behalf inside the Kinde admin area. 1. Open a user or organization record in Kinde. 2. Select **API keys** from the menu. 3. Click **Add API key**. 5. Configure the key: - **Name**: Give it a descriptive name (e.g., "Production Integration") - **API**: Select the API this key can access - **Scopes**: Choose specific scopes for the API 6. Select **Save** Securely issue this API key to your customer. ## Step 3: Test calling your API and verify the API key 1. Call your API endpoint with the API key as the `Authorization` header. 2. Extract the API key from the `Authorization` header. 3. Call the Kinde Management API to verify the API key (you will need an [M2M token](/developer-tools/kinde-api/connect-to-kinde-api/) for this). ```javascript // Extract API key from request const apiKey = req.headers.authorization?.replace("Bearer ", ""); // Verify with Kinde (requires M2M access token) // Obtain an M2M token as per /developer-tools/kinde-api/connect-to-kinde-api/ const verificationResult = await verifyApiKey(apiKey, m2mAccessToken); if (verificationResult.is_valid) { // Key is valid, check scopes if (verificationResult.scopes.includes("read:users")) { // Proceed with request res.json({data: "Your data here"}); } else { res.status(403).json({error: "Insufficient scope"}); } } else { res.status(401).json({error: "Invalid API key"}); } async function verifyApiKey(apiKey, m2mAccessToken) { const response = await fetch("https://your-domain.kinde.com/api/v1/api_keys/verify", { method: "POST", headers: { "Content-Type": "application/json", "Authorization": `Bearer ${m2mAccessToken}` }, body: JSON.stringify({ api_key: apiKey }) }); return response.json(); } ``` The response will look like this: ```json { "code": "API_KEY_VERIFIED", "message": "API key verified", "is_valid": true, "key_id": "api_key_0195ac80a14e8d71f42b98e75d3c61ad", "status": "active", "scopes": ["read:users", "write:users"], "org_code": "org_1234567890", "user_id": "kp_1234567890", "last_verified_on": "2024-11-18T13:32:03+11", "verification_count": 42 } ``` That's it! You have verified the API key and can proceed with the request.

# Manage your apis - About api keys - Organization-level API keys

> Learn how to create and use organization-level API keys for secure, isolated access to organization-specific resources

organization level api keys, org level, multi tenant, organization isolation, api key security
api-keys, key-types

Organization-level API keys provide enhanced security by ensuring that all API calls are associated with a specific organization context. This is particularly useful for multi-tenant applications where you need to maintain clear boundaries between different organizations. ## What are organization-level API keys? Organization-level API keys are API keys that are tied to a specific organization within your Kinde account. When these keys are used to authenticate, the resulting verification includes the organization context, ensuring that all API operations can be properly scoped to that organization. ## Benefits of organization-level API keys ### Security - **Clear ownership**: All API calls are clearly associated with an organization - **Reduced risk**: Prevents accidental cross-organization data access - **Audit trail**: Clear tracking of which organization each API call affects ### Compliance - **Data isolation**: Helps ensure compliance with data residency requirements - **Access control**: Maintains clear boundaries for sensitive data - **Regulatory compliance**: Helps meet industry-specific compliance requirements ### Multi-tenancy - **Tenant isolation**: Perfect for SaaS applications serving multiple customers - **Resource management**: Clear separation of resources between organizations - **Billing isolation**: Separate tracking and billing per organization ### Let organizations self-serve You can expose API key creation to organizations in the Kinde self-serve portal. See [Self-serve API keys](/manage-your-apis/add-manage-api-keys/self-serve-api-keys/) for more information. ## Organization context in verification When you use an organization-level API key, the verification response automatically includes the `org_code` field: ```json { "code": "API_KEY_VERIFIED", "message": "API key verified", "is_valid": true, "key_id": "api_key_123", "status": "active", "scopes": ["read:users", "write:users"], "org_code": "org_abc123", "user_id": null, "last_verified_on": "2024-11-18T13:32:03+11", "verification_count": 42 } ``` This `org_code` field is trusted and cannot be tampered with, ensuring that your application can rely on it for authorization decisions. ## Use cases for organization-level API keys ### SaaS applications - **Customer integrations**: Each customer gets their own API key. - **Data isolation**: Customer data is automatically separated. - **Customization**: Customer-specific configurations and features. ### Internal tools - **Department access**: Different departments get different API keys. - **Project isolation**: Separate keys for different projects. - **Resource management**: Control access to organization resources. ### Partner integrations - **Third-party access**: Grant partners access to specific APIs. - **Limited scope**: Control what partners can access. - **Audit trails**: Track all partner API usage. ### AI and automation - **AI assistants**: AI tools that help with organization-specific data. - **Automated workflows**: Scripts that operate within organization boundaries. - **Integration tools**: Tools that connect with organization systems. ## Best practices for organization-level API keys ### Key management - **Naming conventions**: Use clear names that indicate the organization. - **Scope limits**: Only grant the minimum required scopes. - **Regular rotation**: Rotate keys periodically for security. - **Monitoring**: Track usage patterns for each organization. ### Security considerations - **Organization validation**: Always verify the `org_code` in verification responses. - **Scope enforcement**: Enforce scope restrictions in your API. - **Audit logging**: Log all API operations with organization context. - **Access reviews**: Regularly review organization access patterns. ### Integration patterns - **Multi-tenant APIs**: Design your APIs to handle organization context. - **Data isolation**: Ensure data is properly isolated between organizations. - **Error handling**: Provide clear error messages for organization-related issues. - **Documentation**: Document organization-specific API behavior.

# Manage your apis - About api keys - User-level API keys

> Learn how to create and use user-level API keys that carry a trusted user context for B2C apps and per-user integrations.

user-level api keys, b2c, user isolation, api key security
api-keys, key-types

User-level API keys are tied to an individual user account. When verified, these keys return a trusted user context so you can authorize requests on a per-user basis. This is ideal for B2C apps, personal automations, and integrations where actions should be attributed to a specific user. ## What are user-level API keys? User-level API keys authenticate requests on behalf of a single user. The verification response includes that user's identifier so you can enforce user-specific authorization rules in your API. ## Benefits of user-level API keys ### Security - **Clear ownership**: Every call is attributed to a specific user. - **Fine-grained access**: Enforce per-user permissions and quotas. - **Auditability**: Attribute changes and access to a concrete user identity. ### Simplicity - **Straightforward logic**: No need to infer user context from other signals. - **Consistent across services**: Portable for personal integrations and scripts. ### Let users self-serve You can expose API key creation to users in the Kinde self-serve portal. See: [Self-serve API keys](/manage-your-apis/add-manage-api-keys/self-serve-api-keys/). ## User context in verification When you verify a user-level API key, the response includes a non-null `user_id`: ```json { "code": "API_KEY_VERIFIED", "message": "API key verified", "is_valid": true, "key_id": "api_key_123", "status": "active", "scopes": ["read:profile"], "org_code": null, "user_id": "kp_1234567890", "last_verified_on": "2024-11-18T13:32:03+11", "verification_count": 42 } ``` Rely on the `user_id` for authorization and auditing within your API. If you need organization context, consider using [organization-level API keys](/manage-your-apis/about-api-keys/organization-api-keys/) instead. ## Use cases for user-level API keys ### B2C applications - **Personal data access**: Users access and manage their own data. - **Per-user rate limits**: Enforce limits per user account. ### Personal automations and scripts - **Background jobs**: Users run scripts that act as them. - **Third-party tooling**: Allow integrations to operate within a single user's scope. ### AI assistance - **User-specific retrieval**: Attribute AI actions and retrieval to a user. ## Best practices for user-level API keys ### Key management - **Naming**: Include the user's name or ID in key names for clarity. - **Minimum scopes**: Grant only the scopes needed. - **Rotation**: Encourage periodic key rotation. - **Monitoring**: Track usage and anomalies per user. ### Security considerations - **User validation**: Always validate `user_id` from verification before processing. - **Scope enforcement**: Enforce scopes server-side. - **Audit logging**: Log operations with the `user_id` for traceability.

# Manage your apis - Add manage api keys - Create an API key

> Learn how to create API keys for your registered APIs, including organization-level and user-level keys

create api key, api key setup, organization level, user level, registered apis, key scopes
api-keys, api-key-setup

This guide shows you how to create API keys in Kinde for your registered APIs. API keys can be created at the organization level (managed by admins) or user level (managed by individual users), depending on your business model. ## Prerequisites Before creating API keys: 1. **Register your APIs** in Kinde (see [API registration guide](/developer-tools/your-apis/)). 2. **Define scopes** for your APIs (optional). 3. Set up an **M2M application** for accessing the [Kinde management API](/developer-tools/kinde-api/connect-to-kinde-api/) (if you intend to use our API). ## Create API keys You can enable your customers to [create API keys via the self-service portal](/manage-your-apis/add-manage-api-keys/self-serve-api-keys/). You can also create API keys on their behalf via the Kinde admin area or via API. See below. ### Via the Kinde admin area #### Create organization-level keys 1. Go to **Organizations** 2. Select an organization. 3. Select **API keys** from the left sidebar. 4. Click **Add API key**. 5. Configure the key: - **Name**: Give it a descriptive name (e.g., "Production Integration") - **API**: Select the API this key can access - **Scopes**: Choose specific scopes for the API 6. Select **Save** #### Create user-level keys 1. Go to **Users** 2. Select a user. 3. Select **API keys** from the left sidebar. 4. Click **Add API key**. 5. Configure the key: - **Name**: Give it a descriptive name (e.g., "Production Integration") - **API**: Select the API this key can access - **Scopes**: Choose specific scopes for the API 6. Select **Save** ### Via API Use your [M2M application](/developer-tools/kinde-api/connect-to-kinde-api/) to create API keys programmatically: ```bash # Create an organization-level key curl -X POST https://your-domain.kinde.com/api/v1/api_keys \ -H "Authorization: Bearer YOUR_M2M_TOKEN" \ -H "Content-Type: application/json" \ -d '{ "name": "Production Integration", "api_id": "<your-api-id>", "scope_ids": ["read:users", "write:users"], "org_code": "<your-org-code>" }' # Create a user-level key curl -X POST https://your-domain.kinde.com/api/v1/api_keys \ -H "Authorization: Bearer YOUR_M2M_TOKEN" \ -H "Content-Type: application/json" \ -d '{ "name": "User API Access", "api_id": "<your-api-id>", "scope_ids": ["read:users"], "user_id": "<your-user-id>" }' ``` ## API key response When you create a key via API, Kinde returns a `key` value. Store it securely immediately â€” you won't be able to see it again. You can use the `id` later to manage the key (for example, rotate, revoke, or fetch metadata). You cannot retrieve the secret again. ```json { "message": "API key created", "code": "API_KEY_CREATED", "api_key": { "id": "api_key_0195ac80a14e8d71f42b98e7xxxxxxx", "key": "k_live_12345678abcdefghijkl" // example placeholder; not a real key" } } ```

# Manage your apis - Add manage api keys - Revoke API keys

> Immediately disable an API key and block further use across your APIs.

revoke api key, disable api key, incident response
api-keys, api-key-setup

Revoking an API key immediately prevents it from authenticating with your APIs. Use this when a key is no longer needed, has the wrong scopes, or is suspected to be exposed. ## How to revoke an API key You can revoke an API key in the dashboard or [via the API](https://docs.kinde.com/kinde-apis/management/#tag/api-keys/delete/api/v1/api_keys/). Your customers can also revoke keys themselves in the self-serve portal if you have enabled self-serve API keys. See [Self-serve API keys](/manage-your-apis/add-manage-api-keys/self-serve-api-keys/) for more information. ### Revoke a key on behalf of a user or organization in Kinde - For a user-level key: Go to **Users > [User] > API keys**. Find the key and open the three dots menu > **Revoke**. - For an organization-level key: Go to **Organizations > [Organization] > API keys**. Find the key and open the three dots menu > **Revoke**. ![Submenu on API key](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/bd8fdfaa-5146-4f11-2c30-a3263ee3e500/public) ## What changes after an API key is revoked? Verification responses will indicate the key is not usable. Ensure your API enforces this: ```javascript // After verifying the API key with Kinde if (!verification.is_valid || verification.status !== "active") { return res.status(401).json({error: "Invalid or inactive API key"}); } ``` ## Recommendations - If the key was in use, create a replacement key and distribute it securely. - Audit logs for usage of the revoked `key_id`. - Consider rotating other keys if there was a broader incident.

# Manage your apis - Add manage api keys - Rotate API keys

> Safely rotate API keys using built-in rotation (same key_id, new secret) or a dual-key rollout with zero downtime.

api key rotation, key rollover, deprecation window
api-keys, api-key-setup

Rotating API keys helps reduce risk from accidental exposure and aligns with security best practices. This guide shows two rotation methods for both userâ€‘level and organizationâ€‘level API keys. ## When to rotate API keys - On a regular schedule (e.g., every 60â€“90 days) - After suspected exposure or repository history changes - When scope requirements change ## Choosing an approach to API key rotation - **Builtâ€‘in rotation**: When you control client updates and can push new secrets quickly; keeps `key_id` stable - **Dualâ€‘key rotation**: When you need a migration window; supports staggered updates across many clients/services ## Approach 1: Builtâ€‘in rotation (same key_id, new secret) Use the Rotate key action to keep the `key_id` the same and replace only the secret. This is the simplest option when you can quickly update clients with the new secret. Steps: 1. Open the key you want to rotate: - User key: **Users > [User] > API Keys > [Key]** - Organization key: **Organizations > [Organization] > API Keys > [Key]** 2. Select **Rotate key** and confirm. 3. Securely distribute the new secret to your clients/services. 4. Ensure your clients reload configuration or secrets promptly. Verification behavior: - `key_id` remains the same - `status` remains `active` - Only the secret changes; old secret will fail verification Choose this when you control secret distribution and can update clients nearâ€‘immediately. ## Approach 2: Dualâ€‘key rotation (new key_id) Create a second key, migrate traffic, then revoke the old one. This minimizes risk when you cannot coordinate an immediate secret update. Steps: 1. Create a new key with the same API and scopes. - User: **Users > [User] > API Keys > Add API key**. - Organization: **Organizations > [Organization] > API Keys > Add API key**. - Or use the Management API to create a new key. 2. Update your client(s) to use the new key. - Ship configuration changes or secrets to the environments that call your API. 3. Keep both keys valid during a grace period. - Allow traffic with either key while clients roll over. - Monitor verification results to ensure migration progress. 4. Revoke the old key. - Once traffic has fully moved to the new key, revoke the old one. ## Verifying during rotation Use Kinde to verify incoming keys. During a dualâ€‘key grace window, both old and new keys verify as valid. You can optionally check `key_id` to track when clients have switched. ```javascript // Example Express handler (after verifying with Kinde) if (!verification.is_valid || verification.status !== "active") { return res.status(401).json({error: "Invalid or inactive API key"}); } // Optional: observe rollout by key_id (for telemetry/alerts only) logger.info("api_key_used", {key_id: verification.key_id}); // Enforce required scopes as usual const requiredScopes = ["read:ai_chats"]; // adjust per endpoint for (const scope of requiredScopes) { if (!verification.scopes.includes(scope)) { return res.status(403).json({error: `Insufficient scope: ${scope}`}); } } ``` ## Rotate via selfâ€‘serve portal (optional) If youâ€™ve enabled the self-serve portal, customers can rotate their keys themselves using the built-in **Rotate key** option. You can also deep link to the API Keys page. See [Self-serve API keys](/manage-your-apis/add-manage-api-keys/self-serve-api-keys/). ## Best practices for API key rotation - Keep rotations small and frequent rather than rare and large - Automate notifications to teams when a rotation window begins or ends - Use monitoring to detect lingering use of old `key_id`

# Manage your apis - Add manage api keys - Scopes for API keys

> Learn about the different scopes available for API keys and how to configure them for proper access control

api key scopes, access control, permissions, scope configuration, api key permissions
api-keys, api-key-setup

Scopes define what permissions an API key has when making requests to your API. You can create and define [custom scopes](/developer-tools/your-apis/custom-api-scopes/) when you register your API in Kinde, then assign them for each API key you create. This topic is about strategies and considerations when assigning scopes to API keys. ## Example custom scopes The scopes you set will be related to what your app is and does. These are just some examples for AI apps. - `read:ai_chats` - `write:ai_chat` - `read:ai_analytics` - `write:ai_analytics` - `read:ai_workflows` ## Scope configuration ### When creating an API key 1. Select the minimum required scopes for your use case. 2. Consider the principle of least privilege. 3. Review scope descriptions carefully. ### Updating existing API keys API keys are immutable, so you can't update the scopes of an existing API key. You can only create a new API key with the desired scopes. ## Recommendations for API scopes best practice ### Security - **Principle of least privilege**: Only grant the minimum required scopes. - **Regular review**: Periodically review and audit scope assignments. - **Scope isolation**: Use different API keys for different purposes. ### Structure - **Naming conventions**: Use clear, descriptive scope names. - **Documentation**: Document what each scope provides access to. - **Versioning**: Consider scope versioning for breaking changes. ## Scope validation When your application receives a token, validate that it has the required scopes: ```javascript function hasRequiredScope(scopes, requiredScope) { return Array.isArray(scopes) && scopes.includes(requiredScope); } // Example usage (after verifying the API key) if (!hasRequiredScope(verification.scopes, "write:users")) { return res.status(403).json({ error: "Insufficient scope" }); } ```

# Manage your apis - Add manage api keys - Self-serve API keys

> Turn on API key management in the self-serve portal for users and organizations, and deep link straight to the API keys page using SDK helpers.

self-serve portal, api keys, PortalLink, deep link
api-keys, self-serve-portal

You can allow your customers to create and manage their own API keys directly in the self-serve portal for users and organizations. ## Switch on self-serve API keys in Kinde 1. Go to **Settings** > **Environment** > **Self-serve portal**. 2. Enable the API Keys option for the audience you want: - Users (B2C) - Organizations (B2B) 3. Select **Save**. An **API keys** navigation item will appear in the portal for your customers. ### Self-serve portal details - [Self-serve portal for orgs](/build/self-service-portal/self-serve-portal-for-orgs/) - [Self-serve portal for users](/build/self-service-portal/self-serve-portal-for-users/) ## Deep link to API keys from your app Most SDKs provide a `PortalLink` helper that generates a one-time portal URL and redirects the user. Use the `subNav` parameter to open the API Keys section directly. ### React ```jsx import {PortalLink} from "@kinde-oss/kinde-auth-react"; // Opens the organization level API Keys section in the self-serve portal <PortalLink subNav="organization_api_keys">Manage API keys</PortalLink>; ``` ### Next.js ```jsx import {PortalLink} from "@kinde-oss/kinde-auth-nextjs/components"; // Opens the API Keys section in the self-serve portal <PortalLink subNav="user_api_keys">Manage API keys</PortalLink>; ``` ### Without an SDK (server-side) If you generate portal links using an API on your server, include a `sub_nav` field to deep link to API Keys. ```json { "user_id": "kp_abc123", // or organization_code for org-level links "return_url": "https://yourapp.com/account", "sub_nav": "api_keys" } ``` ### Tips for setting up - Use `subNav` (camelCase) in SDK helpers and `sub_nav` (snake_case) in API payloads. - For organization-level experiences, pass organization context according to your integration pattern. ## Customer portal experience After enabling the API key function for customers, an **API Keys** item shows in the portal navigation where customers can create, view, rotate and revoke keys. ## Access control for self-serve organization level API keys There are system level permissions which Kinde provides which you can assign to your custom roles. - `read:org:authentication` - The user is able to view API keys created by the organization - `write:org:authentication` - The user is able to create, rotate and revoke API keys for the organization. When assigning permissions to roles, our recommendation is to only give the minimum permissions required for someone to do their job. It is always better to be more granular in this area.

# Manage your apis - Add manage api keys - Verify API keys in your API

> Learn how to implement API key verification in your API endpoints to authenticate requests from end users

api key verification, key validation, authentication, api security, key verification endpoint
api-keys, api-key-setup, FASTapi, API-middleware

When end users make requests to your API using their API keys, you need to verify those keys with Kinde before processing the request. This guide shows you how to implement API key verification in your API endpoints. ## How API key verification works The verification flow follows these steps: 1. **End user** sends a request to your API with their API key 2. **Your API** extracts the key and calls Kinde's verification endpoint (this call requires an [M2M token](/developer-tools/kinde-api/connect-to-kinde-api/)) 3. **Kinde** validates the key and returns verification results 4. **Your API** processes the request based on verification results ## Basic implementation ### Extract API key from request First, extract the API key from the incoming request: ```javascript // Express.js example function extractApiKey(req) { const authHeader = req.headers.authorization; if (!authHeader) { throw new Error('No authorization header'); } if (!authHeader.startsWith('Bearer ')) { throw new Error('Invalid authorization format'); } return authHeader.substring(7); // Remove 'Bearer ' prefix } // FastAPI example def extract_api_key(authorization: str = Header(None)): if not authorization: raise HTTPException(status_code=401, detail="No authorization header") if not authorization.startswith("Bearer "): raise HTTPException(status_code=401, detail="Invalid authorization format") return authorization[7:] # Remove 'Bearer ' prefix ``` ### Verify API key with Kinde Call Kinde's verification endpoint to validate the key: ```javascript // Node.js/Express example async function verifyApiKey(apiKey) { try { const response = await fetch('https://your-domain.kinde.com/api/v1/api_keys/verify', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ api_key: apiKey }) }); if (!response.ok) { throw new Error(`Verification failed: ${response.status}`); } return await response.json(); } catch (error) { console.error('API key verification error:', error); throw new Error('Failed to verify API key'); } } // Python/FastAPI example async def verify_api_key(api_key: str): async with httpx.AsyncClient() as client: response = await client.post( "https://your-domain.kinde.com/api/v1/api_keys/verify", headers={ "Content-Type": "application/json" }, json={ "api_key": api_key } ) if not response.is_success: raise HTTPException(status_code=400, detail="Verification failed") return response.json() ``` ### Implement in your API endpoint Use this verification in your API endpoints: ```javascript // Express.js endpoint app.get('/api/data', async (req, res) => { try { // Extract API key const apiKey = extractApiKey(req); // Verify with Kinde const verification = await verifyApiKey(apiKey); if (!verification.is_valid) { return res.status(401).json({ error: 'Invalid API key' }); } // Check if key is active if (verification.status !== 'active') { return res.status(401).json({ error: 'API key is not active' }); } // Check required scopes if (!verification.scopes.includes('read:users')) { return res.status(403).json({ error: 'Insufficient scope' }); } // Process request const data = await getData(); res.json({ data, key_id: verification.key_id }); } catch (error) { console.error('API key verification error:', error); res.status(500).json({ error: 'Internal server error' }); } }); # FastAPI endpoint @app.get("/api/data") async def get_data(authorization: str = Header(None)): try: # Extract API key api_key = extract_api_key(authorization) # Verify with Kinde verification = await verify_api_key(api_key) if not verification["is_valid"]: raise HTTPException(status_code=401, detail="Invalid API key") # Check if key is active if verification["status"] != "active": raise HTTPException(status_code=401, detail="API key is not active") # Check required scopes if "read:users" not in verification["scopes"]: raise HTTPException(status_code=403, detail="Insufficient scope") # Process request data = await get_data() return {"data": data, "key_id": verification["key_id"]} except HTTPException: raise except Exception as error: logger.error(f"API key verification error: {error}") raise HTTPException(status_code=500, detail="Internal server error") ``` <Aside> If you see a `Scope missing` error when calling Kinde, ensure the M2M client you use to call the verification endpoint has the `read:api_keys` scope. Grant this scope to your M2M application in Kinde, then retry. </Aside> ## Verification response Kinde's verification endpoint returns: ```json { "code": "API_KEY_VERIFIED", "message": "API key verified", "is_valid": true, "key_id": "api_key_0195ac80a14e8d71f42b98e75d3c61ad", "status": "active", "scopes": ["read:users", "write:users"], "org_code": "org_1234567890", "user_id": "kp_1234567890", "last_verified_on": "2024-11-18T13:32:03+11", "verification_count": 42 } ``` ### Response fields - **`code`**: Response code indicating the result - **`message`**: Human-readable message - **`is_valid`**: Boolean indicating if the key is valid - **`scopes`**: Array of scopes the key has access to - **`status`**: Key status (`active`, `inactive`, `revoked`) - **`key_id`**: Unique identifier for the key - **`org_code`**: Organization code if it's an organization-level key - **`user_id`**: User ID if it's a user-level key - **`last_verified_on`**: When the key was last verified - **`verification_count`**: Number of times the key has been verified ## Advanced implementation ### Middleware for Express.js Create reusable middleware for API key verification: ```javascript function requireApiKey(requiredScopes = []) { return async (req, res, next) => { try { const apiKey = extractApiKey(req); const verification = await verifyApiKey(apiKey); if (!verification.is_valid) { return res.status(401).json({error: "Invalid API key"}); } if (verification.status !== "active") { return res.status(401).json({error: "API key is not active"}); } // Check required scopes for (const scope of requiredScopes) { if (!verification.scopes.includes(scope)) { return res.status(403).json({ error: `Insufficient scope. Required: ${scope}` }); } } // Attach verification data to request req.apiKey = verification; next(); } catch (error) { console.error("API key middleware error:", error); res.status(500).json({error: "Internal server error"}); } }; } // Use middleware app.get("/api/data", requireApiKey(["read:users"]), (req, res) => { // req.apiKey contains verification data const data = getData(); res.json({data, key_id: req.apiKey.key_id}); }); app.post("/api/data", requireApiKey(["read:users", "write:users"]), (req, res) => { // Requires both read and write scopes const result = createData(req.body); res.json({result, key_id: req.apiKey.key_id}); }); ``` ### Dependency injection for FastAPI Create a dependency for API key verification: ```python async def verify_api_key_dependency( authorization: str = Header(None), required_scopes: List[str] = [] ) -> dict: try: api_key = extract_api_key(authorization) verification = await verify_api_key(api_key) if not verification["is_valid"]: raise HTTPException(status_code=401, detail="Invalid API key") if verification["status"] != "active": raise HTTPException(status_code=401, detail="API key is not active") # Check required scopes for scope in required_scopes: if scope not in verification["scopes"]: raise HTTPException( status_code=403, detail=f"Insufficient scope. Required: {scope}" ) return verification except HTTPException: raise except Exception as error: logger.error(f"API key verification error: {error}") raise HTTPException(status_code=500, detail="Internal server error") # Use dependency @app.get("/api/data") async def get_data(api_key: dict = Depends(verify_api_key_dependency)): data = await get_data() return {"data": data, "key_id": api_key["key_id"]} @app.post("/api/data") async def create_data( data: dict, api_key: dict = Depends(lambda: verify_api_key_dependency(required_scopes=["read:users", "write:users"])) ): result = await create_data(data) return {"result": result, "key_id": api_key["key_id"]} ``` ## Performance optimization ### Implement caching Cache verification results to avoid repeated calls to Kinde: ```javascript class ApiKeyCache { constructor() { this.cache = new Map(); this.ttl = 5 * 60 * 1000; // 5 minutes } get(key) { const cached = this.cache.get(key); if (cached && Date.now() - cached.timestamp < this.ttl) { return cached.data; } return null; } set(key, data) { this.cache.set(key, { data, timestamp: Date.now() }); } clear() { this.cache.clear(); } } const apiKeyCache = new ApiKeyCache(); async function verifyApiKeyWithCache(apiKey) { // Check cache first const cached = apiKeyCache.get(apiKey); if (cached) { return cached; } // Verify with Kinde const verification = await verifyApiKey(apiKey); // Cache valid results if (verification.is_valid && verification.status === "active") { apiKeyCache.set(apiKey, verification); } return verification; } ``` ### Batch verification If you need to verify multiple keys, consider implementing batch verification: ```javascript async function verifyMultipleApiKeys(apiKeys) { // Note: This would require a batch endpoint from Kinde // For now, verify keys in parallel const verificationPromises = apiKeys.map((key) => verifyApiKey(key)); return Promise.all(verificationPromises); } ``` ## Error handling ### Common error responses ```javascript // Invalid API key { "error": "Invalid API key", "code": "INVALID_KEY" } // Insufficient scope { "error": "Insufficient scope. Required: write:users", "code": "INSUFFICIENT_SCOPE", "required_scopes": ["write:users"], "available_scopes": ["read:users"] } // Revoked key { "error": "API key is not active", "code": "KEY_REVOKED" } ``` <Aside> If you receive a `Scope missing` error, it might be because the `read:api_keys` scope is missing. </Aside> ### Rate limiting Implement rate limiting for verification attempts: ```javascript const rateLimit = require("express-rate-limit"); const verificationLimiter = rateLimit({ windowMs: 15 * 60 * 1000, // 15 minutes max: 100, // Limit each IP to 100 verification attempts per window message: { error: "Too many verification attempts", code: "RATE_LIMITED" } }); app.use("/api/v1/api_keys/verify", verificationLimiter); ``` ## Recommendations ### Secure API key verification - **HTTPS only**: Always use HTTPS for verification requests - **Input validation**: Validate the API key format before sending to Kinde - **Error handling**: Don't expose sensitive information in error messages ### Verify and validate - Always validate the verification response from Kinde - Check all required fields before processing requests - Implement proper error handling for verification failures ### Monitor verification activity - Log verification attempts (without sensitive data) - Monitor for unusual verification patterns - Set up alerts for verification failures ## Test the API key validation process ### Test with valid keys ```bash # Test with a valid API key curl -X GET https://your-api.com/data \ -H "Authorization: Bearer YOUR_TEST_API_KEY" ``` ### Test error cases ```bash # Test with invalid key curl -X GET https://your-api.com/data \ -H "Authorization: Bearer invalid_key" # Test with missing header curl -X GET https://your-api.com/data # Test with revoked key curl -X GET https://your-api.com/data \ -H "Authorization: Bearer REVOKED_API_KEY" ``` ## Verification for AI applications ### Validate API keys for AI assistant integration ```javascript // AI assistant using API key for customer support app.post("/ai/chat", async (req, res) => { try { const apiKey = extractApiKey(req); const verification = await verifyApiKey(apiKey); if (!verification.is_valid) { return res.status(401).json({error: "Invalid API key"}); } // Check if key has access to support data if (!verification.scopes.includes("read:tickets")) { return res.status(403).json({error: "Insufficient scope for support data"}); } // AI can now access customer support data within the organization scope const customerData = await getCustomerSupportData(verification.org_code); // Process AI request with customer context const aiResponse = await processAIRequest(req.body.message, customerData); res.json({ response: aiResponse, context: `Organization: ${verification.org_code}`, key_id: verification.key_id }); } catch (error) { console.error("AI chat error:", error); res.status(500).json({error: "Internal server error"}); } }); ``` ### Validate API keys for automated workflow with AI ```javascript // AI-powered workflow automation app.post("/workflow/automate", async (req, res) => { try { const apiKey = extractApiKey(req); const verification = await verifyApiKey(apiKey); if (!verification.is_valid) { return res.status(401).json({error: "Invalid API key"}); } // AI workflow needs both read and write access const requiredScopes = ["read:users", "write:workflows"]; for (const scope of requiredScopes) { if (!verification.scopes.includes(scope)) { return res.status(403).json({ error: `Insufficient scope. Required: ${scope}` }); } } // AI can now automate workflows within the organization const workflowResult = await executeAIWorkflow( req.body.workflow, verification.org_code, verification.user_id ); res.json({ result: workflowResult, automated_by: verification.key_id, organization: verification.org_code }); } catch (error) { console.error("Workflow automation error:", error); res.status(500).json({error: "Internal server error"}); } }); ```

# Manage your apis - Troubleshoot api keys - Troubleshoot API key errors

> Common API key errors and their solutions, including authentication issues, scope problems, and organization access errors

api key errors, troubleshooting, authentication errors, scope errors, organization access, api key issues
api-keys, troubleshooting-api-keys

Although we hope nothing goes awry with API keys, it can happen. This guide will help you identify, diagnose, and resolve problems that could arise when using API keys. ## Perform regular maintenance to prevent errors with API keys It's always better to prevent errors than have to deal with them in a moment of crisis. Here's some tips for long-term API key management. - **Rotate API keys**: Periodically rotate keys for security. See [Rotate API keys](/manage-your-apis/add-manage-api-keys/rotate-api-keys/) - **Revoke unused keys**: Clean up keys that are no longer needed. See [Revoke API keys](/manage-your-apis/add-manage-api-keys/revoke-api-keys/) - **Review scopes**: Regularly audit and update API key permissions. See [Scopes for API keys](/manage-your-apis/add-manage-api-keys/scopes-for-api-keys/) - **Monitor usage**: Track API key usage patterns and anomalies. See [Verify API keys](/manage-your-apis/add-manage-api-keys/verify-api-keys-in-your-api/) ## Common error types Here's a summary of some of the most common errors and the type of errors that can occur. ### Authentication errors - Invalid API key - Expired tokens - Malformed requests - Missing authentication headers ### Authorization errors - Insufficient scopes - Organization access denied - Rate limit exceeded - Geographic restrictions ### Configuration errors - Missing properties - Invalid scopes - Organization mismatch - Workflow failures See below for full explanations and de-bugging assistance. ## Authentication errors ### "Invalid API key" error **Symptoms:** - HTTP 401 Unauthorized response - Error message: "Invalid API key" or "Authentication failed" **Common causes:** 1. **API key copied incorrectly**: Missing or extra characters 2. **API key revoked**: Key was deleted or deactivated 3. **Wrong environment**: Using production key in test environment 4. **Malformed request**: Incorrect header format **Solutions:** ```bash # Verify API key format # Should look like: k_live_1234567890abcdef... # Check header format curl -X GET https://your-domain.kinde.com/api/users \ -H "Authorization: Bearer YOUR_API_KEY" # Note: "Bearer " prefix # Verify key is active # Go to Settings > API Keys and check if key is enabled ``` **Debugging steps:** 1. Copy the API key again from the dashboard. 2. Check if the key is still active in your dashboard. 3. Ensure you're using the correct domain. ### "Token expired" error **Symptoms:** - HTTP 401 Unauthorized response - Error message: "Token expired" or "Invalid token" **Common causes:** 1. **Access token expired**: Tokens typically expire after 1 hour 2. **Clock skew**: Server time differs from client time 3. **Cached expired token**: Application using old token **Solutions:** ```javascript // Implement token refresh logic async function getValidToken(apiKey) { try { const response = await fetch("https://your-domain.kinde.com/oauth2/token", { method: "POST", headers: { "Content-Type": "application/x-www-form-urlencoded", Authorization: `Bearer ${apiKey}` }, body: "grant_type=client_credentials&scope=openid profile" }); const data = await response.json(); return data.access_token; } catch (error) { throw new Error("Failed to obtain access token"); } } // Use in your application let accessToken = await getValidToken(apiKey); let tokenExpiry = Date.now() + 3600000; // 1 hour // Check if token needs refresh if (Date.now() >= tokenExpiry) { accessToken = await getValidToken(apiKey); tokenExpiry = Date.now() + 3600000; } ``` **Debugging steps:** 1. Check your system clock for accuracy. 2. Implement proper token caching with expiration. 3. Add logging to track token refresh cycles. 4. Verify token expiration time in response. ### "Malformed request" error **Symptoms:** - HTTP 400 Bad Request response - Error message: "Malformed request" or "Invalid request format" **Common causes:** 1. **Missing Authorization header**: No Bearer token provided 2. **Incorrect header format**: Wrong header name or value 3. **Invalid request body**: Malformed JSON or form data **Solutions:** ```javascript // Ensure proper header format const headers = { Authorization: `Bearer ${apiKey}`, "Content-Type": "application/json" }; // For token exchange const formData = new URLSearchParams(); formData.append("grant_type", "client_credentials"); formData.append("scope", "openid profile"); const response = await fetch("https://your-domain.kinde.com/oauth2/token", { method: "POST", headers: { "Content-Type": "application/x-www-form-urlencoded", Authorization: `Bearer ${apiKey}` }, body: formData }); ``` ## Authorization errors ### "Insufficient scope" error **Symptoms:** - HTTP 403 Forbidden response - Error message: "Insufficient scope" or "Access denied" **Common causes:** 1. **Missing required scopes**: API key doesn't have necessary permissions 2. **Scope mismatch**: Requested scope not granted to key 3. **Organization restrictions**: Key scoped to different organization **Solutions:** ```bash # Check current scopes # Go to the relevant user or organization > API Keys > [Your Key] > View # Verify required scopes are assigned ``` **Debugging steps:** 1. Review the API key's assigned scopes. 2. Check what scopes your endpoint requires. 3. Verify organization scoping if applicable. 4. Update API key scopes if needed. ### "Organization access denied" error **Symptoms:** - HTTP 403 Forbidden response - Error message: "Organization access denied" or "Invalid organization" **Common causes:** 1. **Wrong organization scope**: API key scoped to different organization 2. **Organization not found**: Organization doesn't exist or is inactive 3. **Cross-organization access**: Attempting to access different organization's data **Solutions:** ```javascript // Verify organization in token function validateOrganizationAccess(token, requiredOrgCode) { if (!token.org_code) { throw new Error("Organization-scoped token required"); } if (token.org_code !== requiredOrgCode) { throw new Error("Access denied: organization mismatch"); } return true; } // Use in your API endpoint app.get("/api/users/:userId", async (req, res) => { try { const token = extractTokenFromRequest(req); const user = await getUserById(req.params.userId); // Validate organization access validateOrganizationAccess(token, user.organization_code); res.json(user); } catch (error) { res.status(403).json({error: error.message}); } }); ``` **Debugging steps:** 1. Check if your API key is organization-scoped. 2. Verify the organization code in the token. 3. Ensure you're not trying to access cross-organization data. 4. Check the organization status in the dashboard. ### "Rate limit exceeded" error **Symptoms:** - HTTP 429 Too Many Requests response - Error message: "Rate limit exceeded" or "Too many requests" **Common causes:** 1. **High request volume**: Exceeding API key rate limits 2. **Burst requests**: Too many requests in short time 3. **Shared rate limits**: Multiple applications using same key **Solutions:** ```javascript // Implement rate limiting in your application class RateLimiter { constructor(limit, window) { this.limit = limit; this.window = window; this.requests = new Map(); } async checkLimit(key) { const now = Date.now(); const windowStart = now - this.window; // Clean old entries if (this.requests.has(key)) { this.requests.set( key, this.requests.get(key).filter((timestamp) => timestamp > windowStart) ); } const currentRequests = this.requests.get(key) || []; if (currentRequests.length >= this.limit) { return false; // Rate limited } currentRequests.push(now); this.requests.set(key, currentRequests); return true; } } // Usage const rateLimiter = new RateLimiter(100, 60000); // 100 requests per minute if (!(await rateLimiter.checkLimit(apiKey))) { throw new Error("Rate limit exceeded. Please try again later."); } ``` **Debugging steps:** 1. Check your API key's rate limit settings. 2. Monitor request frequency in your application. 3. Implement proper request throttling. 4. Consider using separate API keys for different services. ## Configuration errors ### "Invalid scopes" error **Symptoms:** - API key creation fails - Error message: "Invalid scope" or "Scope not found" **Common causes:** 1. **Scope doesn't exist**: Requested scope not defined 2. **Scope name typo**: Incorrect scope name 3. **Scope not available**: Scope not enabled for your plan **Solutions:** ```bash # Check available scopes # Go to Settings > APIs > Scopes # Verify scope names and availability # Common standard scopes: # Common standard scopes: # - openid # - profile # - email # - offline_access **Debugging steps:** 1. Review available scopes in dashboard. 2. Check scope spelling and format. 3. Verify scope availability for your plan. 4. Create custom scopes if needed.

