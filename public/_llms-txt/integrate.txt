---
page_id: 6c7d8e9f-0a1b-2c3d-4e5f-6a7b8c9d0e1f
title: Kinde Documentation - Integrate
description: "Complete documentation for Kinde's integrate section containing titles, descriptions, keywords, topics, and full content from all documentation files in this section for LLM training"
sidebar:
  order: 1
topics:
  - llm
  - documentation
  - training
  - integrate
sdk: []
languages:
  - markdown
  - text
audience: developers
complexity: beginner
keywords:
  - llm training
  - documentation
  - integrate
  - section
  - frontmatter
  - metadata
  - kinde
updated: 2025-09-18
featured: false
deprecated: false
ai_summary: "Complete documentation for Kinde's integrate section containing titles, descriptions, keywords, topics, and full content from all documentation files in this section for LLM training"
---

# Kinde Documentation - Integrate

This is the complete documentation for Kinde's integrate section containing titles, descriptions, keywords, topics, and full content from all documentation files in this section.

# Integrate - Connected apps - Add connected apps

> Comprehensive guide to adding and configuring connected apps in Kinde including OAuth setup, scope management, and access token retrieval for third-party integrations

connected apps, third party integration, oauth, access tokens, scopes, client id, client secret, callback urls, management api
integrate, connected-apps

Connected apps let your users access third party tools and services through Kinde. When you add a connection, you’ll need to define which features (or scopes) that you want to be made available. To get the connection up and running, you’ll need to do some steps in Kinde and some in the app you are connecting. ## **Before you add a connected app** - Set up a [machine to machine application](/developer-tools/kinde-api/connect-to-kinde-api/) - Ensure you have at least one [end-user created](/manage-users/add-and-edit/add-and-edit-users/) ## **Step 1: Add the connected app in Kinde** 1. In Kinde, go to **Settings > Connected apps**. 2. Select **Connect an app**. A dialog opens. 3. Select the connected app you want from the available apps. 4. Select **Save**. The app will appear in the list of your connected apps. 5. Select **Configure** on the tile and copy the **Provider to Kinde** callback URL. 6. Next: Set up the app. See instructions for setting up apps below. ## **Step 2: Set up the app you want to connect** - [Google Drive](/integrate/connected-apps/google-drive-connected-app/) - [GitHub](/integrate/connected-apps/github-connected-app/) - [GitLab](/integrate/connected-apps/gitlab-connected-app/) - [Patreon](/integrate/connected-apps/patreon-connected-app/) - [Discord](/integrate/connected-apps/discord-connected-app/) - [Microsoft 365](/integrate/connected-apps/microsoft-365-connected-app/) ## **Step 3: Configure the connected app in Kinde** To complete this procedure, you need to have set up the app. See relevant instructions below. 1. In Kinde, go to **Settings > Connected apps**. 2. On the app tile, select **Configure**. 3. On the Details tab: 1. Enter a name. 2. Enter the **Client ID** and **Client secret** from the app, e.g. Google Drive. 3. Enter a reference key that will be used in your app’s code. 4. Enter the callback URL for your app. 5. Select **Save**. 4. In the **Permissions** tab, select the permissions (scopes) that you want to access via the connection. 5. Select **Save**. The next time a user signs in, they will be prompted to allow the above permissions. ## **Step 4: Get an access token via the Kinde Management API** This final step needs to be performed in your own app, using that app’s language. The steps below simulate the process in Postman. 1. Get the user ID of one of your users by calling the following API in Postman: `https://yourdomain.kinde.com/api/v1/users`. In the below example, the `id` of the only user in the business is `kp:xxxxx...` <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/4226353f-43a6-4fbd-381c-5f6817e32800/public" alt="" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" /> Note: The user’s endpoint is a Kinde management API endpoint, therefore you will need a token to call this API. 2. Using Postman, call the auth url endpoint to get a URL that will allow you to connect, e.g. to Google. The URL is: `https://<KINDE_URL>/api/v1/connected_apps/auth_url?key_code_ref=<KEY>&user_id=<USER_ID>` 3. Replace: - `<KINDE_URL>` with your Kinde business url, e.g. `mybiz.kinde.com` - `<KEY>` with the unique key you gave your connected app - `<USER_ID>` with the user id you got in step 1 Note: The `auth_url` endpoint is a Kinde management API endpoint, therefore you will need a token to call this API. You will get back a URL and session_id in the response if the call was successful: <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/040b6860-0774-4128-fbb9-95dd24774300/public" alt="Getting session_id in Postman" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" /> 4. Copy the URL from the call to `url` and paste it in a browser’s address bar. This should redirect you to get authenticated. 5. Authorize the requested scopes for the application. You will be redirected to the URL defined in the `Kinde to application` . 6. Use Postman to call the `connected_apps/token` API to get an access token that has been granted the scopes you have defined previously. The URL is: `https://<KINDE_URL>/api/v1/connected_apps/token?session_id=<SESSION_ID>` 7. Replace: - `<KINDE_URL>` with your Kinde business url, e.g. `mybiz.kinde.com` - `<SESSION_ID>` with the session_id that was returned when calling the `auth_url` endpoint Note: The `connected_apps/token` endpoint is a Kinde management API endpoint, therefore you will need a token. You will get an access token back from the call. This token can be used to call the connected services. 8. You’re ready to use the connection. Below is an example API call to Google Drive. ### **Example connected app access - Google Drive** 1. In your code or using Postman, call the Google Drive API to list files. The URL is `https://www.googleapis.com/drive/v3/files` . 2. You will need to use the access token you obtained earlier, and pass it as a bearer token in the Authorization header. Here’s what the call and return looks like. <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/c76b98f4-828e-4147-4ff1-32fa489e1400/public" alt="Calling Google Drive API in Postman" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" /> ## **Disconnect a connected app** You can disconnect a connected app from Kinde, however this does not revoke permissions. To revoke permissions you need to call the `/connected apps/revoke` endpoint. 1. Go to **Settings > Connected Apps**. 2. Select the three dots menu on the tile for the connected app, then select **Disconnect**. A confirmation window pops up. 3. Select **Disconnect**.

# Integrate - Connected apps - Discord connected app

> Guide to setting up Discord as a connected app in Kinde including OAuth2 configuration, client credentials, and redirect URI setup

discord, oauth2, client id, client secret, redirect uri, callback url, discord developer
integrate, connected-apps

Before you can add Discord as a connected app in Kinde, you need to [set up a machine to machine application](/developer-tools/kinde-api/connect-to-kinde-api/) to connect to Kinde’s API. This is Step 2 of the [Kinde Connected apps setup](/integrate/connected-apps/add-connected-apps/#step-2-set-up-the-app-you-want-to-connect) topic. You first need to have [added the connected app](/integrate/connected-apps/add-connected-apps/#step-1-add-the-connected-app-in-kinde) in Kinde. ## What you need The Provider to Kinde callback URL from the Kinde connected app. ## Set up the Discord app 1. Sign in to your [Discord developer account](https://discord.com/developers/applications). 2. In the **Applications** section, select **New application**. 3. Give your application a name and agree to Discord’s terms, then select **Create**. 4. Copy the **Client ID** and **Client secret**. These correspond to the Client ID and Client secret in your Kinde M2M application. ![screen shot of discord add application screen](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/9b43cdbe-70fd-4c61-beee-155efadfde00/public) 5. In the menu, select **OAuth2**. ![screen shot of redirects field in discord app](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/b7fa03fd-f67c-433a-f603-8607f1df4a00/public) 6. If the Redirect URI field is not blank, select **Add Another**. 7. Paste the **Provider to Kinde callback URL** that you copied when you set up the connection in Kinde. 8. Next: Finish setting up the connection in the Kinde application. See [Configure the connected app in Kinde](/integrate/connected-apps/add-connected-apps/#step-3-configure-the-connected-app-in-kinde).

# Integrate - Connected apps - GitHub connected app

> Step-by-step guide to setting up GitHub as a connected app in Kinde including OAuth app creation, permissions configuration, and callback URL setup

github, github app, oauth, permissions, scopes, client id, client secret, webhooks, developer settings
integrate, connected-apps

Before you can add GitHub as a connected app in Kinde, you need [set up a machine to machine application](/developer-tools/kinde-api/connect-to-kinde-api/) for connecting to the Kinde API. This is Step 2 of the [Kinde Connected apps setup](/integrate/connected-apps/add-connected-apps/#step-2-set-up-the-app-you-want-to-connect) topic. 1. Sign in to your GitHub account and open the **Developer settings:** 1. If this is a personal account, select your avatar and select **Settings**. 2. If this is an organization account, select your avatar, select **Your Organizations**, then select **Settings**. 2. Select **Developer Settings** in the left menu. The **GitHub apps** page opens. 3. Select **New GitHub App**. 4. Enter a name for the app and add a **Homepage URL**. 5. Add the callback URL copied from Kinde's GitHub connected app. It should be something like `https://<yourdomain>.com/connected_apps/callback`. 6. In the **Webhook** section, make webhooks inactive if they are not being used. 7. In the **Permissions** section, for each permission group (Repository, Organization, Account), open the group and select the access level for each permission - **No access**, **Read-only,** or **Read and write**. For a permission (scope) to be available in Kinde, it needs to be made accessible here. Note that not every permission visible here will also be available in Kinde. Some scopes have been excluded for security and data protection reasons. <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/eb5b9196-bbdc-47ba-947d-68923092ed00/public" alt="" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" /> 8. Based on the permissions you have selected, choose which events you want to subscribe to in the **Subscribe to events** section. 9. When you have finished, select **Create GitHub app**. Details for the app are created. <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/20cfa2af-06c5-4e21-3e10-003e40d8cb00/public" alt="" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" /> 10. Copy the **Client ID** and **Generate a new client secret** to copy into your Kinde GitHub connected app. 11. Note that you can **Revoke all user tokens** in the same area you set up your app (see the screen shot at step 9 above). It is better to revoke tokens in your app set up, rather than through Kinde. 12. Finish setting up the connection in Kinde by following [Step 3: Configure the connected app in Kinde](/integrate/connected-apps/add-connected-apps/#step-3-configure-the-connected-app-in-kinde).

# Integrate - Connected apps - GitLab connected app

> Guide to setting up GitLab as a connected app in Kinde including OAuth provider configuration, scope selection, and application credentials setup

gitlab, oauth provider, scopes, application id, secret, redirect uri, callback url
integrate, connected-apps

Before you can add GitHub as a connected app in Kinde, you need to [set up a machine to machine application](/developer-tools/kinde-api/connect-to-kinde-api/) to connect to Kinde’s API. This is Step 2 of the [Kinde Connected apps setup](/integrate/connected-apps/add-connected-apps/#step-2-set-up-the-app-you-want-to-connect) topic. 1. Sign in to your GitLab account and follow steps 1 to 3 of [these instructions](https://docs.gitlab.com/ee/integration/oauth_provider.html) for adding a group-owned or user-owned application. 2. Name the application. 3. Select the scopes you want to be available in your application. For example, `api`, `read_api`, `read_user`, etc. For a scope to be available in Kinde, it needs to be selected here. Note that not every scope visible here will also be available in Kinde. Some scopes have been excluded for security and data protection reasons. <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/dcf1eb8b-e83e-4e23-323f-4aac3289a400/public" alt="" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" /> 4. Paste the Kinde callback URL in the **Redirect URI** field. 5. Select **Save**. 6. Copy the **Application ID** and **Secret**, and paste them where you can access them later. <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/f3ceadff-02b5-467d-4ade-e22480e87400/public" alt="" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" /> 7. Next: Finish setting up the connection in Kinde. See [Configure the connected app in Kinde](/integrate/connected-apps/add-connected-apps/#step-3-configure-the-connected-app-in-kinde).

# Integrate - Connected apps - Google Drive connected app

> Comprehensive guide to setting up Google Drive as a connected app in Kinde including Google Cloud Console configuration, OAuth setup, and API enablement

google drive, google cloud console, oauth client id, consent screen, scopes, client id, client secret, redirect uris, google drive api
integrate, connected-apps

Before you can add Google Drive as a connected app in Kinde, you need to set up the API connection by following all these steps. This is Step 2 of the [Kinde Connected apps setup](/integrate/connected-apps/add-connected-apps/#step-2-set-up-the-app-you-want-to-connect) topic. ### **Create a project** 1. Sign in to Google and go to the Google Cloud Console [https://console.cloud.google.com/apis](https://console.cloud.google.com/apis). 2. In the **Enabled APIs and services** section, select **Create project.** 3. Give the project a name and location (optional). 4. Select **Save**. You’ll be redirected to the project dashboard. ### **Configure consent and add scopes** You need to configure consent to update scopes before creating the OAuth client ID. 1. Select **Configure Consent Screen**. 2. Select the **User type**: Internal or External. This will usually be **Internal** for Google Workspaces. 3. Select **Create**. You’ll be prompted to follow the app registration process. <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/a8c7c8ea-ca67-4c54-ad5c-bf31d8e36d00/public" alt="Configuring consent in Google Cloud" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" /> 4. Enter the app information, including: 1. **App name** 2. **User support email** 3. **App domain** information, including privacy links and terms. If prompted, add **Authorized domains**. 4. **Developer contact** information 5. Select **Save and continue**. 6. Select **Add or remove scopes**. A panel slides out on the right. <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/abef19e0-fd75-4a5f-7bb0-9fa6c7f21f00/public" alt="Updating scopes in Google Cloud" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" /> 7. Browse the list and select scopes you want to include by selecting the checkbox. You can also filter the list or add scopes manually. See the [full list of available scopes](https://developers.google.com/identity/protocols/oauth2/scopes). For a scope to be accessed by Kinde, it needs to be selected in this list. 8. When you have finished selecting scopes, select **Update**. 9. Select **Save and continue**. 10. If you want, you can add test users, but you don’t have to. ### **Create OAuth Client ID** 1. Select **Credentials** in the left hand menu. 2. Select **+ create credentials > OAuth client ID.** 3. Select the application type and enter a name. 4. If you want, add **Authorized JavaScript origins** 5. Add **Authorized redirect URIs**. Enter your Kinde callback URL. E.g. `https://yourdomain.kinde.com/connected_apps/callback` 6. Select **Create**. A modal appears with your Client ID and Client Secret. <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/39a36b61-b554-4156-a8b0-4b49e3e26e00/public" alt="Creating OAuth client in Google Cloud" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" /> 7. Copy these details immediately somewhere you can access them later for entering in Kinde. You can also download them as a JSON file. ### **Enable the API in the project** 1. On the API and Services page (where you have setup your Google client), in the **Enable APIs and Services** section, select **Enable APIs and Services.** <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/f1b88701-9cbc-419d-1ea6-9e84e8d22a00/public" alt="Enabling the API in Google Cloud" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" /> 2. Search for Drive, then select the search result for **Google Drive API.** 3. Click **Enable**. This can take a few seconds to enable. 4. Finish setting up the connection in Kinde by following Step 3: [Configure the connected app in Kinde](/integrate/connected-apps/add-connected-apps/#step-3-configure-the-connected-app-in-kinde).

# Integrate - Connected apps - Microsoft 365 connected app

> Guide to setting up Microsoft 365 as a connected app in Kinde including Azure app registration, calendar permissions, and client secret generation

microsoft 365, microsoft azure, entra id, app registration, calendar scopes, client id, client secret, redirect uri, microsoft graph
integrate, connected-apps

You can now set up a connection between Kinde and Microsoft 365. You might do this, for example, to request Microsoft 365-related permissions from users during auth. The procedure below covers the case for adding calendar permissions. ## Before you begin - Set up a [machine to machine application](/developer-tools/kinde-api/connect-to-kinde-api/) - Ensure you have at least one [end-user created](/manage-users/add-and-edit/add-and-edit-users/) - Complete [Step 1: Add a connected app to Kinde](/integrate/connected-apps/add-connected-apps/#step-1-add-the-connected-app-in-kinde) You also need a [Microsoft Azure account](https://portal.azure.com/#home) for creating MS Entra ID apps. ## Register a Microsoft app This is Step 2 of [Add a connected app to Kinde](/integrate/connected-apps/add-connected-apps/#step-1-add-the-connected-app-in-kinde). 1. Sign in to your [Microsoft Azure account](https://portal.azure.com/). 2. Navigate to **Entra ID**. You can do this from links on the main screen or in the left side menu. 3. Select **Add+ > App registration** or go to **Manage > App registrations > New registration**. 4. Enter a name for the app. 5. Select a **Supported account types option**. For testing purposes, we selected **Accounts in any organizational directory and personal Microsoft accounts**. 6. In the **Redirect URI (optional)** section, select **Web** in the **Select a platform** dropdown. 7. Enter the **Provider to Kinde callback URL** from the Kinde connected app. For example, `https://app.<yourdomain>/connected_apps/callback`. 8. Select **Register**. Details of your new app appear. 9. Copy the **Application (client) ID** and paste it in a text file or somewhere you can easily access it again. You’ll use this as the **Client ID** for the connected app in Kinde. ## Add calendar scopes and generate a secret <Aside type="warning"> While it may be possible to add other scopes, we have currently only tested the inclusion of calendar scopes. </Aside> 1. Add scopes to the Microsoft app. 1. Go to **API permissions**. 2. Select **+ Add a permission**. 3. In the pop-out, select **Microsoft Graph** and then **Application permissions**. 4. Search for ‘calendar’, then select only `Calendars.Read` and `Calendars.ReadWrite`. ![Entra app Permissions for calendar](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/1fa72783-a7e0-45d1-08ee-ba6df5106300/public) 5. Select **Add permissions**. These permissions can now be selected as scopes in the Kinde connected app. 2. Generate a secret. 1. Select **Certificates and secrets** from the left menu, select + **New client secret.** 2. Enter a name and give it an expiry date (or accept the default), then select **Add**. Details of the secret are generated. 3. Copy the value in the **Value** column and paste it in a text file or somewhere you can easily access it again. Make sure you copy from the **Value** column, not the **Secret ID** column. ![Entra app secret value not secret ID](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/56dd1ace-8646-44c9-9add-982528e4a800/public) ## Finish configuring the connection in Kinde You’ll need the **Application (Client) ID** and **Secret** that you copied above. You’ll also need your Kinde app callback URL. See [Step 3: Configure the connected app in Kinde](/integrate/connected-apps/add-connected-apps/#step-3-configure-the-connected-app-in-kinde).

# Integrate - Connected apps - Patreon connected app

> Guide to setting up Patreon as a connected app in Kinde including creator platform registration, OAuth client creation, and API version configuration

patreon, creator platform, oauth, client id, client secret, redirect uri, api version, scopes
integrate, connected-apps

You can connect Patreon to your Kinde account so you can manage Patreon members and campaigns. Before you can add Patreon as a connected app in Kinde, you need to [set up a machine to machine application](/developer-tools/kinde-api/connect-to-kinde-api/) to connect to Kinde’s API. This is Step 2 of the [Kinde Connected apps setup](/integrate/connected-apps/add-connected-apps/#step-2-set-up-the-app-you-want-to-connect) topic. 1. Sign up as a creator at [patreon.com](http://patreon.com/). 2. Go to the [Patreon Platform (developer area)](https://www.patreon.com/portal/registration/register-clients) and sign in if you are not already. 3. Select **Create new client**. <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/a35a8351-ed96-41ea-2adb-4e2339adb400/public" alt="" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" /> 4. In the window that appears, complete all the required and other fields. 1. In the **Redirect URI** field, enter the callback URL from your app in Kinde. 2. In the **Client API Version** field select **2**. This selection defines the included scopes, which are detailed in the [Patreon docs](https://docs.patreon.com/#scopes). 5. When you’re finished, select **Create New Client**. Your new client is shown in the dashboard of the Patreon Portal. 6. Select the down arrow on the client tile. The app details and other client information is shown. Copy the **Client ID and Client Secret**. 7. Next: Finish setting up the connection in Kinde. See [Configure the connected app in Kinde](/integrate/connected-apps/add-connected-apps/#step-3-configure-the-connected-app-in-kinde).

# Integrate - Third party tools - Kinde as identity provider with Cloudflare Zero Trust

> Guide to configuring Kinde as an identity provider with Cloudflare Zero Trust using OpenID Connect for secure authentication across systems

cloudflare zero trust, openid connect, identity provider, oauth, jwks, token endpoint, authorization endpoint, callback urls
integrate, third-party-tools

If you use Cloudflare to manage authentication across your systems, you can use Kinde as an third-party identity provider. This topic explains how to set up Cloudflare Zero Trust to use Kinde as an auth identity provider through OpenID Connect. You need to already have a backend [web application set up](/build/applications/add-and-manage-applications/) in Kinde to follow this procedure. ## Get your Cloudflare team domain 1. [Sign into Cloudflare](https://dash.cloudflare.com/) and navigate to **Zero Trust**. 2. Go to **Settings > Custom Pages**. <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/9b73e4d9-5478-44f7-a917-8324c529d100/public" alt="" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" /> 3. Copy your **Team domain**. ## Set up your Kinde app 1. In Kinde, go to **Settings > Applications**. 2. Select **View details** on the relevant backend/web application. 3. Copy the **Client ID** and **Client secret** and add them somewhere you can access later. 4. Scroll to the **Callback URLs** section and enter the Zero Trust Team domain in the **Allowed callback URLs** field. (Copied in the procedure above) In this example, we would paste: `mirosaurus.cloudflareaccess.com/cdn-cgi/access/callback` 5. Select **Save**. ## Get your OpenID config info 1. In your browser, go to the OpenID configuration URL of your Kinde business. This will be `https://<your_kinde_subdomain>.kinde.com/.well-known/openid-configuration` Our example shows details for `mirosaurus.kinde.com/.well-known/openid-configuration` <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/8e82dc48-a516-42c7-2a41-0bfea682a600/public" alt="" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" /> 2. Copy the following information somewhere you can access it later. - jwks_uri - e.g. `https://mirosaurus.kinde.com/.well-known/jwks` - token_endpoint - e.g. `https://mirosaurus.kinde.com/oauth2/token` - authorization_endpoint - e.g. `https://mirosaurus.kinde.com/oauth2/auth` ## Add Kinde as a provider in Cloudflare Zero Trust 1. Back in the Cloudflare Zero Trust dashboard, go to **Settings > Authentication**. <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/eb59f014-9fbb-4ef2-6291-ec1d946a7f00/public" alt="" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" /> 2. In the **Login methods** section, select **Add new**. The **Add a login method** screen opens. 3. Select **OpenID Connect** as the identity provider. <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/eb21ed9c-150a-47cd-510d-0a0e5dc15500/public" alt="" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" /> 4. Follow the page guide and enter the following details: - Name - Whatever you want - App ID - this is the Client ID you copied from your Kinde app - Client Secret - this is the Client secret you copied from your Kinde app - Auth URL - the `authorization_endpoint` copied in the previous procedure - Token URL - the `token_endpoint` copied in the previous procedure - Certificate URL - the `jwks_uri` copied in the previous procedure <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/e5cffb1e-e316-473d-d51a-3dac205b1a00/public" alt="" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" /> 5. Select **Save**. ## Enable Cloudflare to use Kinde as an auth provider 1. In the **Zero Trust** dashboard, go to **Access > Applications**. 2. In the **Authentication** tab, select the newly created **Open ID Connect** method. <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/7e72598a-d4a6-48ae-7948-c8face8d0200/public" alt="" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" /> 3. Select **Save application**. When an authentication event is triggered, Cloudflare will offload to Kinde to complete the authentication.

# Integrate - Third party tools - Use Kinde auth in an Electron app

> Step-by-step guide to integrating Kinde authentication with an Electron app, incorporating configuration via SDK, along with login, logout, and user profile access.

electron, OAuth, express, desktop app, authentication, callback urls, client id, client secret
integrate, third-party-tools

## What you need - Latest version of Node.js installed on your computer - A [Kinde](https://kinde.com/) account (Sign up for free) ## Step 1: Create a Kinde application 1. On the Kinde home page, select **Add application.** 1. Enter a name for your application. 2. Select **Front-end and mobile** as the type. 3. Select **Save**, the Quickstart page opens. 2. In the **Quick Start** section, select **Other native**, and then select **Save** to continue. 3. Go to **Details** and make a copy of the **Domain** and **Client ID**. 4. Scroll down, enter the following in the **Allowed callback URLs,** and select **Save** ``` http://127.0.0.1:53180/callback ``` ## Step 2: Initialize an Electron app 1. Open a terminal and run the following commands to create a new folder for your Electron app, and then navigate into it. ```bash mkdir electron-kinde-auth cd electron-kinde-auth ``` 2. Create a new `package.json` file: ```bash touch package.json ``` 3. Open the newly created `package.json` file with your code editor and add the following: ```json { "name": "electron-kinde-auth", "description": "A simple Electron app to authenticate with Kinde using OAuth", "productName": "Electron Kinde Auth", "version": "1.0.0", "main": "main.js", "scripts": { "start": "electron .", "dev": "electron ." }, "dependencies": { "dotenv": "^17.2.2", "express": "^4.19.2", "keytar": "^7.9.0", "node-fetch": "^3.3.2" }, "devDependencies": { "electron": "^31.3.0" } } ``` 4. Run the following command to install the required packages: ```bash npm install ``` 5. Create a `.env` file for environment variables: ```bash touch .env ``` 6. Open it in your editor and paste the Kinde credentials copied from the **Details** page. ```bash KINDE_ISSUER_URL=https://<KINDE_DOMAIN>.kinde.com KINDE_CLIENT_ID=<CLIENT_ID> KINDE_SCOPES=openid profile email offline ``` 7. Create a new `helpers.js` file: ```bash touch helpers.js ``` 8. Add the following code to the `helpers.js` file: ```jsx const crypto = require("crypto") function base64urlencode(buf) { return buf .toString("base64") .replace(/\+/g, "-") .replace(/\//g, "_") .replace(/=+$/, "") } function generateVerifier() { return base64urlencode(crypto.randomBytes(32)) } function challengeFromVerifier(v) { return base64urlencode(crypto.createHash("sha256").update(v).digest()) } function randomState(len = 12) { return crypto .randomBytes(Math.ceil((len * 3) / 4)) .toString("base64url") .slice(0, len) } // Minimal JWT decode (no signature verification) function decodeIdToken(idToken) { try { const [, payload] = idToken.split(".") const pad = (s) => s + "=".repeat((4 - (s.length % 4)) % 4) const json = Buffer.from( pad(payload).replace(/-/g, "+").replace(/_/g, "/"), "base64" ).toString("utf8") return JSON.parse(json) } catch { return null } } function createTokenStore(storage, { serviceName, accountName, logger }) { const safeParse = (s) => { try { return JSON.parse(s) } catch { return null } } return { async load() { const s = await storage.getPassword(serviceName, accountName) const t = s ? safeParse(s) : null if (!t || typeof t.access_token !== "string") return null return t }, async save(tokens) { await storage.setPassword( serviceName, accountName, JSON.stringify({ ...tokens }) ) }, async clear() { try { await storage.deletePassword(serviceName, accountName) } catch (e) { logger?.warn?.(e) } }, async exists() { return (await this.load()) !== null }, } } module.exports = { generateVerifier, challengeFromVerifier, randomState, decodeIdToken, createTokenStore, } ``` ### Code explanation for `helpers.js` **PKCE helpers** - `base64urlencode(buf)` converts raw bytes to URL-safe Base64 (no `+`, `/`, or `=`), which OAuth endpoints expect. - `generateVerifier()` returns a high-entropy, URL-safe PKCE **code_verifier** (32 random bytes → Base64URL). - `challengeFromVerifier(v)` derives the **code_challenge** by SHA-256 hashing the verifier and Base64URL-encoding the digest (`S256` method). Together these implement the PKCE half of the authorization flow. **Random state** - `randomState(len = 12)` generates a short, URL-safe random string for the OAuth `state` parameter (CSRF protection). It uses cryptographic randomness and trims the Base64URL output to your requested length. **ID token decoding** - `decodeIdToken(idToken)` decodes the JWT payload so you can read claims (e.g., `name`, `picture`) without verifying the signature. *Note:* This is for **display/convenience only**—don’t make trust decisions on the decoded payload without verifying the signature remotely (which you typically don’t do in a desktop main process). **Token storage (factory + DI)** - `createTokenStore(storage, { serviceName, accountName, logger })` returns a tiny persistence API: - `load()` → parses the secret and ensures there’s an `access_token`, else `null`. - `save(tokens)` → stores the token blob as JSON. - `clear()` → deletes the secret (logs a warning on failure if a `logger` is provided). - `exists()` → convenience check built on `load()`. - It’s dependency-injected: pass a `storage` that looks like **keytar** (`getPassword`, `setPassword`, `deletePassword`). This makes it trivial to test by swapping in an in-memory mock. **Error handling & resilience** - Safe JSON parsing prevents crashes on corrupt secrets and simply returns `null`. - The store doesn’t encrypt itself; it relies on the OS credential vault (e.g., Keychain, Credential Manager) provided by your `storage` implementation. 9. Create a new `main.js` file: ```bash touch main.js ``` 10. Add the following code to the `main.js` file: ```jsx require("dotenv").config() const { app, BrowserWindow, ipcMain, shell } = require("electron") const path = require("path") const os = require("os") const express = require("express") const keytar = require("keytar") const { generateVerifier, challengeFromVerifier, randomState, decodeIdToken, createTokenStore, } = require("./helpers") // ---------- Config ---------- const CALLBACK_HOST = "127.0.0.1" const CALLBACK_PORT = 53180 const REDIRECT_URI = `http://${CALLBACK_HOST}:${CALLBACK_PORT}/callback` const ISSUER = process.env.KINDE_ISSUER_URL const CLIENT_ID = process.env.KINDE_CLIENT_ID const AUDIENCE = process.env.KINDE_AUDIENCE || "" const SCOPES = ( process.env.KINDE_SCOPES || "openid profile email offline" ).trim() if (!ISSUER || !CLIENT_ID) { console.error("Please configure KINDE_ISSUER_URL and KINDE_CLIENT_ID in .env") } const tokenStore = createTokenStore(keytar, { serviceName: "electron-kinde-pkce-sample", accountName: os.userInfo().username, // or 'default' }) // Ensure we have a fetch impl (Electron/Node 18+ has global fetch) const fetchFn = global.fetch || ((...args) => import("node-fetch").then(({ default: f }) => f(...args))) // ---------- Small helpers ---------- function stampIssued(tokens) { const t = { ...tokens } t.issued_at = Date.now() if (typeof t.expires_in === "number") t.expires_at = t.issued_at + t.expires_in * 1000 return t } async function postForm(url, data) { const body = new URLSearchParams(data) const res = await fetchFn(url, { method: "POST", headers: { "Content-Type": "application/x-www-form-urlencoded" }, body, }) const text = await res.text() if (!res.ok) throw new Error(`${res.status} ${text}`) return JSON.parse(text) } // ---------- OAuth helpers ---------- async function exchangeCodeForTokens({ code, codeVerifier, redirectUri }) { const tokenUrl = new URL("/oauth2/token", ISSUER).toString() const json = await postForm(tokenUrl, { grant_type: "authorization_code", code, client_id: CLIENT_ID, redirect_uri: redirectUri, code_verifier: codeVerifier, }) return stampIssued(json) } async function refreshTokens(refreshToken) { const tokenUrl = new URL("/oauth2/token", ISSUER).toString() const json = await postForm(tokenUrl, { grant_type: "refresh_token", refresh_token: refreshToken, client_id: CLIENT_ID, }) // Some providers omit refresh_token on refresh → keep the old one if (!json.refresh_token) json.refresh_token = refreshToken return stampIssued(json) } async function getValidAccessToken() { const tokens = await tokenStore.load() if (!tokens) return null const expiresAt = tokens.expires_at ?? (tokens.issued_at || 0) + (tokens.expires_in || 0) * 1000 const aboutToExpire = !expiresAt || Date.now() + 60_000 >= expiresAt // refresh when <60s left if (!aboutToExpire) return tokens.access_token if (!tokens.refresh_token) return null const refreshed = await refreshTokens(tokens.refresh_token) await tokenStore.save(refreshed) return refreshed.access_token } // ---------- Callback server (single fixed port) ---------- function listenForCallback(expectedState) { const appx = express() let server // Promise we resolve/reject from inside the route let resolveLogin, rejectLogin const waitForCode = new Promise((resolve, reject) => { resolveLogin = resolve rejectLogin = reject }) appx.get("/callback", (req, res) => { const { code, state, error, error_description } = req.query // Validate state if (state !== expectedState) { res .status(400) .send("<h1>Invalid state</h1><p>Please try signing in again.</p>") try { server?.close() } catch {} return rejectLogin(new Error("Invalid OAuth state")) } if (error) { res .status(400) .send(`<h1>Login error</h1><p>${error}: ${error_description || ""}</p>`) try { server?.close() } catch {} return rejectLogin(new Error(`${error}: ${error_description || ""}`)) } res.send( "<h1>Login successful</h1><p>You can close this window and return to the app.</p>" ) try { server?.close() } catch {} return resolveLogin({ code: String(code), redirectUri: REDIRECT_URI }) }) server = appx.listen(CALLBACK_PORT, CALLBACK_HOST) server.on("error", (err) => { const msg = err && err.code === "EADDRINUSE" ? `Callback port ${CALLBACK_PORT} is already in use. Close the other process or change the port.` : String(err) try { server?.close() } catch {} rejectLogin(new Error(msg)) }) return { waitForCode } } // ---------- Login flow ---------- async function startLogin() { const codeVerifier = generateVerifier() const codeChallenge = challengeFromVerifier(codeVerifier) const state = randomState() // Start fixed-port server (closes itself on success/error) const { waitForCode } = listenForCallback(state) const auth = new URL("/oauth2/auth", ISSUER) auth.searchParams.set("client_id", CLIENT_ID) auth.searchParams.set("response_type", "code") auth.searchParams.set("redirect_uri", REDIRECT_URI) auth.searchParams.set("scope", SCOPES) auth.searchParams.set("code_challenge_method", "S256") auth.searchParams.set("code_challenge", codeChallenge) auth.searchParams.set("state", state) if (AUDIENCE) auth.searchParams.set("audience", AUDIENCE) await shell.openExternal(auth.toString()) // Exchange the code for tokens const { code } = await waitForCode const tokens = await exchangeCodeForTokens({ code, codeVerifier, redirectUri: REDIRECT_URI, }) await tokenStore.save(tokens) const claims = decodeIdToken(tokens.id_token) return { tokens, claims } } async function doLogout() { await tokenStore.clear() try { const url = new URL("/logout", ISSUER) url.searchParams.set("client_id", CLIENT_ID) await shell.openExternal(url.toString()) } catch {} } // ---------- Electron window ---------- let win function createWindow() { win = new BrowserWindow({ width: 1000, height: 700, webPreferences: { preload: path.join(__dirname, "preload.js"), // CommonJS preload contextIsolation: true, nodeIntegration: false, sandbox: true, }, }) win.loadFile(path.join(__dirname, "renderer", "index.html")) } app.whenReady().then(() => { createWindow() app.on("activate", () => { if (BrowserWindow.getAllWindows().length === 0) createWindow() }) }) app.on("window-all-closed", () => { if (process.platform !== "darwin") app.quit() }) // ---------- IPC ---------- ipcMain.handle("auth:login", async () => { try { const { claims } = await startLogin() return { ok: true, claims } } catch (e) { return { ok: false, error: String(e) } } }) ipcMain.handle("auth:getAccessToken", async () => { try { const token = await getValidAccessToken() return { ok: true, access_token: token } } catch (e) { return { ok: false, error: String(e) } } }) ipcMain.handle("auth:logout", async () => { try { await doLogout() return { ok: true } } catch (e) { return { ok: false, error: String(e) } } }) ipcMain.handle("auth:getSession", async () => { try { const tokens = await tokenStore.load() if (!tokens) return { ok: true, signedIn: false } // Optional: ensures token freshness (ignore failure for UI) try { await getValidAccessToken() } catch {} const claims = decodeIdToken(tokens.id_token) return { ok: true, signedIn: true, claims } } catch (e) { return { ok: false, error: String(e) } } }) ``` ### Code explanation for `main.js` **Bootstrapping & configuration** - Loads env vars with `dotenv` and pulls Kinde settings (`ISSUER`, `CLIENT_ID`, optional `AUDIENCE`, `SCOPES`). - Defines a **fixed loopback redirect** (`http://127.0.0.1:53180/callback`) so you can whitelist a single URL in Kinde. - Sets up a secure token store backed by **keytar** (`createTokenStore`), namespaced per OS user. Safe networking & utilities - Ensures a `fetch` implementation: uses Node/Electron’s global `fetch` when available, otherwise lazy-loads `node-fetch`. - Provides two tiny helpers: - `postForm(url, data)`: POSTs `application/x-www-form-urlencoded`, throws on non-2xx, returns JSON. - `stampIssued(tokens)`: annotates tokens with `issued_at` and `expires_at` for easier expiry checks. **OAuth (Authorization Code + PKCE)** - **PKCE bits** come from `helpers`: generates a `code_verifier`, derives `code_challenge`, and creates a random `state`. - **Exchange/refresh**: - `exchangeCodeForTokens(...)` hits `/oauth2/token` with `authorization_code` grant and returns stamped tokens. - `refreshTokens(refreshToken)` refreshes access tokens; if the server omits a new `refresh_token`, it keeps the old one. - `getValidAccessToken()` loads tokens, checks expiry with a 60s buffer, and refreshes if needed; returns a valid access token or `null`. **Local callback server (loopback)** - `listenForCallback(expectedState)` spins up a one-route **Express** server on `127.0.0.1:53180`. - When `/callback` is hit: - Validates the `state` to prevent CSRF. - On error: returns a friendly HTML message and rejects. - On success: replies “Login successful” and resolves with the `code`. - The server is **closed** on success or error; startup errors (e.g., `EADDRINUSE`) are handled gracefully. **Login & logout flows** - `startLogin()`: - Builds the Kinde `/oauth2/auth` URL with PKCE and `state`. - Opens the system browser (`shell.openExternal`) to authenticate (more secure than embedding). - Waits for the loopback callback, exchanges the code for tokens, **persists** them via `tokenStore`, decodes the ID token for UI claims, and returns `{ tokens, claims }`. - `doLogout()`: - Clears local credentials and opens Kinde’s `/logout` URL (best-effort). **Electron window & security** - Creates the main `BrowserWindow` and loads `renderer/index.html`. - Uses a **preload** script with: - `contextIsolation: true` - `nodeIntegration: false` - `sandbox: true` (These keep the renderer locked down and expose only the APIs you allow via preload.) **IPC surface (renderer ↔ main)** Exposes four IPC handlers the renderer can call: - `auth:login` → runs the full PKCE flow and returns ID token **claims**. - `auth:getAccessToken` → returns a fresh access token (refreshing if needed). - `auth:logout` → clears local tokens and calls the provider’s logout. - `auth:getSession` → checks keytar for existing tokens, tries to freshen silently, and returns `{ signedIn, claims }`. 11. Create a new `preload.js` file: ```bash touch preload.js ``` 12. Add the following code to the file and save changes: ```jsx const { contextBridge, ipcRenderer } = require("electron") contextBridge.exposeInMainWorld("kindeAuth", { login: () => ipcRenderer.invoke("auth:login"), getAccessToken: () => ipcRenderer.invoke("auth:getAccessToken"), logout: () => ipcRenderer.invoke("auth:logout"), getSession: () => ipcRenderer.invoke("auth:getSession"), }) ``` 13. Run the following to set up your project structure: ```bash mkdir renderer touch renderer/index.html renderer/style.css renderer/renderer.js ``` 14. Add the following code to `index.html` file to create the UI: ```html <!DOCTYPE html> <html lang="en"> <head> <meta charset="utf-8" /> <title>Kinde Auth App</title> <meta name="viewport" content="width=device-width, initial-scale=1" /> <!-- CSP allows local file + external HTTPS connects for token/API calls --> <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline'; img-src 'self' https: data:; connect-src 'self' https: http:;" /> <link rel="stylesheet" href="./style.css" /> <style> .hidden { display: none !important; } </style> </head> <body> <!-- Header / Nav --> <header> <nav class="nav container"> <h1 class="text-display-3">KindeAuth</h1> <!-- Signed-out nav --> <div id="nav-guest"> <button class="btn btn-ghost sign-in-btn" id="signInBtn"> Sign in </button> <button class="btn btn-dark" id="signUpBtn">Sign up</button> </div> <!-- Signed-in nav --> <div id="nav-authed" class="profile-blob hidden"> <img id="avatar" class="avatar" src="" alt="User avatar" /> <div> <p class="text-heading-2" id="fullName">—</p> <a class="text-subtle" href="#" id="signOutLink">Sign out</a> </div> </div> </nav> </header> <!-- Main --> <main> <div class="container"> <!-- Guest hero --> <section id="guest-hero" class="card hero"> <p class="text-display-2 hero-title"> Let&rsquo;s start authenticating </p> <p class="text-display-2 hero-title">with KindeAuth</p> <p class="text-body-1 hero-tagline">Configure your app</p> <a class="btn btn-light btn-big" href="https://docs.kinde.com" target="_blank" rel="noreferrer" > Go to docs </a> </section> <!-- Authed hero --> <section id="authed-hero" class="card start-hero hidden"> <p class="text-body-2 start-hero-intro">Woohoo!</p> <p class="text-display-2">Your authentication is all sorted.</p> <p class="text-display-2">Build the important stuff.</p> </section> <!-- Next steps --> <section id="next-steps" class="next-steps-section hidden"> <h2 class="text-heading-1">Next steps for you</h2> <ul class="next-steps-list"> <li class="text-body-3"> Call your API using a fresh access token </li> <li class="text-body-3"> Use ID token claims to personalize the UI </li> <li class="text-body-3">Wire billing/entitlements as needed</li> </ul> </section> </div> </main> <!-- Footer --> <footer class="footer"> <div class="container"> <strong class="text-heading-2">KindeAuth</strong> <p class="footer-tagline text-body-3"> Visit our <a class="link" href="https://kinde.com/docs">help center</a> </p> <small class="text-subtle" >&copy; 2025 KindeAuth, Inc. All rights reserved</small > </div> </footer> <script src="./renderer.js"></script> </body> </html> ``` 15. Add the following code to `style.css` file to style the UI. ```css :root { --g-color-black: #000; --g-color-white: #fff; --g-color-grey-50: #f6f6f6; --g-color-grey-600: #636363; --g-color-grey-700: #4d4d4d; --g-color-grey-900: #0f0f0f; --g-box-shadow: 0px 6px 12px rgba(18, 20, 23, 0.06), 0px 15px 24px rgba(18, 20, 23, 0.07), 0px -4px 12px rgba(18, 20, 23, 0.05); --g-font-family: Helvetica, sans-serif; --g-font-size-x-small: 0.75rem; /* 12px */ --g-font-size-small: 0.875rem; /* 14px */ --g-font-size-base: 1rem; /* 16px */ --g-font-size-large: 1.25rem; /* 20x */ --g-font-size-x-large: 1.5rem; /* 24px */ --g-font-size-2x-large: 2rem; /* 32px */ --g-font-size-3x-large: 2.5rem; /* 40px */ --g-font-size-4x-large: 4rem; /* 64px */ --g-font-weight-base: 400; --g-font-weight-semi-bold: 500; --g-font-weight-bold: 600; --g-font-weight-black: 700; --g-border-radius-small: 0.5rem; --g-border-radius-base: 1rem; --g-border-radius-large: 1.5rem; --g-spacing-small: 0.5rem; /* 8px */ --g-spacing-base: 1rem; /* 16px */ --g-spacing-large: 1.5rem; /* 24px */ --g-spacing-x-large: 2rem; /* 32px */ --g-spacing-2x-large: 2.5rem; /* 40px */ --g-spacing-3x-large: 3rem; /* 48px */ --g-spacing-6x-large: 6rem; /* 96px */ } * { padding: 0; margin: 0; box-sizing: border-box; } html, body { font-family: var(--g-font-family); } a { color: inherit; text-decoration: none; } .text-subtle { color: var(--g-color-grey-600); font-size: var(--g-font-size-x-small); font-weight: var(--g-font-weight-base); } .text-body-1 { font-size: var(--g-font-size-2x-large); font-weight: var(--g-font-weight-base); } .text-body-2 { font-size: var(--g-font-size-x-large); font-weight: var(--g-font-weight-base); } .text-body-3 { color: var(--g-color-grey-900); font-size: var(--g-font-size-small); font-weight: var(--g-font-weight-base); } .text-display-1 { font-size: var(--g-font-size-4x-large); font-weight: var(--g-font-weight-black); line-height: 1.2; } .text-display-2 { font-size: var(--g-font-size-3x-large); font-weight: var(--g-font-weight-black); line-height: 1.4; } .text-display-3 { font-size: var(--g-font-size-x-large); font-weight: var(--g-font-weight-black); } .text-heading-1 { font-size: var(--g-font-size-large); font-weight: var(--g-font-weight-semi-bold); } .text-heading-2 { font-size: var(--g-font-size-base); font-weight: var(--g-font-weight-semi-bold); } .container { padding: 0 var(--g-spacing-6x-large); margin: auto; } .nav { align-items: center; display: flex; justify-content: space-between; padding-bottom: var(--g-spacing-x-large); padding-top: var(--g-spacing-x-large); width: 100%; } .sign-in-btn { margin-right: var(--g-spacing-small); } .btn { border-radius: var(--g-border-radius-small); display: inline-block; font-weight: var(--g-font-weight-bold); padding: var(--g-spacing-base); cursor: pointer; border: none; } .btn-ghost { color: var(--g-color-grey-700); } .btn-dark { background-color: var(--g-color-black); color: var(--g-color-white); } .btn-light { background: var(--g-color-white); color: var(--g-color-black); font-weight: 600; } .btn-big { font-size: var(--g-font-size-large); padding: var(--g-font-size-large) var(--g-font-size-x-large); } .hero { align-items: center; display: flex; flex-direction: column; height: 30rem; justify-content: center; text-align: center; } .hero-title { margin-bottom: var(--g-spacing-x-large); } .hero-tagline { margin-bottom: var(--g-spacing-x-large); } .card { background: var(--g-color-black); border-radius: var(--g-border-radius-large); box-shadow: var(--g-box-shadow); color: var(--g-color-white); } .link { text-decoration: underline; text-underline-offset: 0.2rem; } .link:hover, .link:focus { background: #f1f2f4; } .footer { padding-bottom: var(--g-spacing-x-large); padding-top: var(--g-spacing-x-large); } .footer-tagline { margin-bottom: var(--g-font-size-x-small); margin-top: var(--g-font-size-x-small); } .start-hero { padding: var(--g-spacing-2x-large); text-align: center; } .start-hero-intro { margin-bottom: var(--g-spacing-base); } .avatar { align-items: center; background-color: var(--g-color-grey-50); border-radius: var(--g-border-radius-large); display: flex; height: var(--g-spacing-3x-large); justify-content: center; text-align: center; width: var(--g-spacing-3x-large); } .profile-blob { align-items: center; display: grid; gap: var(--g-spacing-base); grid-template-columns: auto 1fr; } .next-steps-section { margin-top: var(--g-spacing-2x-large); } ``` 16. Add the following code to `renderer.js` file to make everything work. ```jsx const els = { navGuest: document.getElementById("nav-guest"), navAuthed: document.getElementById("nav-authed"), guestHero: document.getElementById("guest-hero"), authedHero: document.getElementById("authed-hero"), nextSteps: document.getElementById("next-steps"), claimsPre: document.getElementById("claims"), tokenPre: document.getElementById("token"), signInBtn: document.getElementById("signInBtn"), signUpBtn: document.getElementById("signUpBtn"), signOutLink: document.getElementById("signOutLink"), avatar: document.getElementById("avatar"), fullName: document.getElementById("fullName"), getTokenBtn: document.getElementById("getTokenBtn"), } function safeSetText(el, text) { if (el) el.textContent = text } function safeSetSrc(el, src, alt = "") { if (!el) return if (src) { el.src = src el.alt = alt || "" } else { el.removeAttribute("src") } } function setAuthedUI(on, claims) { // guard everything with optional chaining to avoid null errors if (on) { els.navGuest?.classList.add("hidden") els.navAuthed?.classList.remove("hidden") els.guestHero?.classList.add("hidden") els.authedHero?.classList.remove("hidden") els.nextSteps?.classList.remove("hidden") const name = [claims?.given_name, claims?.family_name].filter(Boolean).join(" ") || claims?.name || "Signed in" safeSetText(els.fullName, name) safeSetSrc(els.avatar, claims?.picture, name) } else { els.navGuest?.classList.remove("hidden") els.navAuthed?.classList.add("hidden") els.guestHero?.classList.remove("hidden") els.authedHero?.classList.add("hidden") els.nextSteps?.classList.add("hidden") safeSetText(els.claimsPre, "{}") safeSetText(els.tokenPre, '(click "Get access token")') } } // --- Startup: restore session if present --- async function bootstrap() { try { const res = await window.kindeAuth.getSession() if (res?.ok && res.signedIn) { if (els.claimsPre) els.claimsPre.textContent = JSON.stringify(res.claims || {}, null, 2) setAuthedUI(true, res.claims) } else { setAuthedUI(false) } } catch { setAuthedUI(false) } } // Wire buttons (unchanged, but safe to keep) els.signInBtn?.addEventListener("click", async () => { safeSetText(els.claimsPre, "...") const res = await window.kindeAuth.login() if (!res.ok) { safeSetText(els.claimsPre, "Login failed: " + res.error) setAuthedUI(false) } else { if (els.claimsPre) els.claimsPre.textContent = JSON.stringify(res.claims, null, 2) setAuthedUI(true, res.claims) } }) els.signUpBtn?.addEventListener("click", async () => { els.signInBtn?.click() }) els.getTokenBtn?.addEventListener("click", async () => { safeSetText(els.tokenPre, "...") const res = await window.kindeAuth.getAccessToken() safeSetText( els.tokenPre, res.ok ? res.access_token || "(no token)" : "Error: " + res.error ) }) els.signOutLink?.addEventListener("click", async (e) => { e.preventDefault() await window.kindeAuth.logout() setAuthedUI(false) }) // Ensure DOM is ready, then bootstrap if (document.readyState === "loading") { document.addEventListener("DOMContentLoaded", bootstrap) } else { bootstrap() } ``` ## Step 3: Run and test the Electron app 1. To start your Electron application and Express server, run the following command in your terminal: ```bash npm start ``` The Kinde app sign up screen opens. ![Electron app with kinde auth](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/ca9076c5-3193-48f9-78bb-80ca2bc43b00/public) 2. Sign in or sign up for a new account and test the auth flow. You should be able to see your admin area, for example: ![Signed in to electron app](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/4da712af-5ac0-4798-7260-3f5d9deb5f00/public) ## Next steps - [Call your API](/developer-tools/your-apis/register-manage-apis/) using a fresh access token - [Set up your brand experience](/design/brand/global-brand-defaults/) - [Get started with billing](/billing/about-billing/about-billing/) ## Finished! You’ve successfully built a full-stack Electron app with an Express.js backend, including user authentication and an admin area. This setup serves as a solid foundation for further development, allowing you to expand features, improve the user interface, or enhance security. You can now continue adding functionality or explore packaging the app for distribution.

# Integrate - Third party tools - Kinde and Bravo Studio

> Step-by-step guide to integrating Kinde authentication with Bravo Studio for mobile app development including OAuth 2.0 setup and Figma integration

bravo studio, figma, oauth 2.0, mobile app, authentication, callback urls, client id, client secret, bravo vision
integrate, third-party-tools

Adding authentication to your Bravo Studio app is easier than you think! With **Kinde**, you can let users securely sign up, log in, and access their profile data. This guide will walk you through connecting **Kinde** with **Bravo Studio** so you can build apps that authenticate users seamlessly. ## What you need - A [Figma account](http://figma.com/) (Sign up for free) - A [Kinde account](https://kinde.com/) (Sign up for free) - A [Bravo Studio account](https://www.bravostudio.app/) paid plan (minimum Solo plan) ## Step 1: Set up your Kinde application 1. Sign in to Kinde and select **Add application**. 2. In the dialog that opens, enter a name for the application (we’ve used ‘Bravo Studio app’). 3. Choose **Back-end web** as the application type, and select **Save**. 4. On the **Quickstart** page, select **Other back end**, and select **Save**. ![SDK choices](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/a5d21fe1-266e-4dc7-e311-54e787757400/public) 5. Go to **Authentication** and switch on each authentication method you want to be available. (e.g. Google, passwordless, etc.) For these to work, you need to [set up the selected auth methods](https://docs.kinde.com/authenticate/about-auth/authentication-methods/) in Kinde. 6. Select **Save**. 7. Go to **Details** and note your **Client ID** and **Client secret**. You’ll need these later. ![App keys in kinde](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/d7cd88fb-2724-415a-d31f-c9f100ab4600/public) ## Step 2: Connect Bravo Studio with Kinde 1. Sign in to your [Figma account](http://figma.com/) on the web or desktop. 2. Open the [Bravo Sample: Kinde Auth Starter Kit](https://www.figma.com/community/file/1470830408542459372). 3. Select **Open in Figma**. This will create a copy in your account. 4. Select **Share** in the top-right corner, then select **Copy link** to copy the public Figma file URL. ![figma share dialog](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/fd4a0c30-8d72-496c-ef2b-ca1aa2be4600/public) 5. Sign in to your [Bravo Studio dashboard](https://projects.bravostudio.app/apps), and select **Create a new app**. 6. Paste the Figma file URL and select **Connect Bravoized Figma file.** ![Convert figma to bravo](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/0abac93d-0f34-48f8-85a5-cc4a545b7100/public) 7. In the **App** tab, open the **Home page** screen. - Select the **Your Name** text element. - Select the **database icon** to configure dynamic data. - Choose **Static** and enter `${user.name}`. - Bravo supports built-in variables like `${user.id}`, `${user.name}`, and `${user.email}`. [View all built-in variables](https://docs.bravostudio.app/connect-api/request-url-variables/built-in-variables) ![Shows bravo view of figma](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/36ffe4dc-3e3c-4b2c-ed40-946f4319b900/public) ![Shows Bravo view of figma continued](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/8de14b7f-ac7b-474c-e6d5-0aae8422cd00/public) 8. Go to the **Integrations** tab and enable **OAuth 2.0 code flow**. ![Bravo login](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/36a186ab-047f-40a9-89eb-b3becfcbc100/public) 9. Select **Show** to view your Bravo **callback URLs.** 10. Copy the URLs. ![bravo callback urls.png](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/d0228081-a535-47cd-a9e3-a04fd0d41000/public) 11. In your **Kinde app > Details** page, paste the **callback URLs** (without trailing `/`) into **Allowed callback URLs** and select **Save**. ![kinde allowed callback urls.png](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/8760257c-92ed-4f71-91c6-4c26f9b90000/public) 12. Build your **Authorize URI:** - Find your **OAuth 2.0 URL** in **Kinde > Quick Start** (e.g., `https://<YOUR_BUSINESS>.kinde.com/oauth2/auth`). - Find your **Bravo project URI** in the **callback URLs** section. - Set **state** to any random 8+ characters. - Combine them into the following format. ``` https://<YOUR_BUSINESS>.kinde.com/oauth2/auth?response_type=code&client_id=<YOUR_KINDE_CLIENT_ID>&redirect_uri=https://<YOUR_BRAVO_APP_ID>.callbacks.bravostudio.app&scope=openid+profile+email+offline&state=abcxyz123 ``` 13. Go back to **Bravo > Integrations** and fill in the following. - Client ID: `<YOUR_KINDE_CLIENT_ID>` - Client Secret: `<YOUR_KINDE_CLIENT_SECRET>` - Authorize URI: The URL you just built - Token URI: `https://<YOUR_BUSINESS>.kinde.com/oauth2/token` - UserInfo URI: `https://<YOUR_BUSINESS>.kinde.com/oauth2/v2/user_profile` - Scope: `openid profile email offline` ![bravo oauth.png](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/3998a039-7bb0-4dda-424e-f92350323b00/public) 14. Select **Save**. You can find all Kinde endpoints in your business’s OpenID configuration page. (e.g., `https://<YOUR_BUSINESS>.kinde.com/.well-known/openid-configuration`). ## Step 3: Test your Bravo application 1. Download [the Bravo Vision app](https://www.bravostudio.app/download-bravo-vision) on your smartphone. 2. Open **Bravo Vision** and log in with your Bravo account. Your projects will appear. 3. Select **Bravo Sample: Kinde Auth Starter Kit** to open the app preview. ![sign in entry screen](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/4491108e-d668-45fb-fada-b02760681e00/public) 4. Select **Sign in** to register or log in with your Kinde account. Follow the authentication steps. ![sign in screen](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/e7beda48-18dd-4fa0-18fb-3516804f8d00/public) 5. Once authenticated, you’ll be redirected to the app’s homepage. You should see your profile name displayed. ![enter username](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/8fe71e60-19a5-4a8d-4560-33ac6d0af900/public) That’s it! You’ve successfully connected Kinde authentication with Bravo Studio and tested it on your mobile app. <Aside title="Troubleshooting"> If a deployment error occurs, trying changing the Bravo callback URLs in Kinde to be lowercase. See step 11 of **Connect Bravo Studio with Kinde** above. E.g. change `https://a01JMF34GB3VYX7Z5GVQXSGYFP0.callbacks.bravostudio.app` to `https://a01jmf34gb3vyx7z5gvqxsgyfp0.callbacks.bravostudio.app`. It's odd but it has fixed an issue previously. </Aside> ## You did it! Your app can now securely sign in users and display their profile data. This is a huge step towards building production-ready apps with authentication powered by Kinde. What’s next? - Explore [Bravo’s API features](https://docs.bravostudio.app/connect-api) to connect your app to live data. - Dive deeper into Kinde’s [documentation](https://docs.kinde.com/) to unlock more authentication capabilities. - Start customizing your app’s design and logic in Bravo to make it your own. Happy building!

# Integrate - Third party tools - Kinde and edge worker services

> Guide to integrating Kinde with edge worker services including Cloudflare Workers, Vercel, Next.js Edge Runtime, and Deno Deploy with JWT handling

edge workers, cloudflare workers, vercel, nextjs, nuxt, deno deploy, jwt, wrangler
integrate, third-party-tools

Kinde works with edge worker services and providers. We have tested the following: - [Nuxt on Vercel](https://vercel.com/docs/frameworks/nuxt#edge-functions) - [Next.js Edge Runtime](https://nextjs.org/docs/pages/api-reference/edge) - [Deno Deploy](https://deno.com/deploy) - [Cloudflare Workers](https://workers.cloudflare.com/) You will need to follow the edge worker service instructions linked above, to get things running. Here’s an example of how we set up Cloudflare Workers. ## Example Cloudflare Workers integration <Aside> With server-side SDKs, you'll need to handle JWT implementation (generate & validate JWT tokens) without relying on external libraries, so it is suitable to deploy within the Cloudflare environment. [Here’s some docs to help](https://github.com/tsndr/cloudflare-worker-jwt). </Aside> 1. Set up a Cloudflare account. 2. Install Wrangler. This is Cloudflare’s CLI. ```bash brew install wrangler ``` 3. Run the Wrangler login to authenticate into your Cloudflare account: ```bash wrangler login ``` 4. Create a repository to install dependencies using the below command. During this process, answer any questions best suited to your app: ```bash wrangler init ``` 5. Combine the folder created for Cloudflare + kinde sdk/starter kit. 1. Sort out any conflicts in the code (including your package.json / package-lock.json files), such as conflicting scripts, commands, dependencies, etc. 2. Merge into the one file. 6. Install Kinde dependencies if required. Here’s an example for React: ```bash npm install @kinde-oss/kinde-auth-react ``` 7. Deploy your project. We suggest you deploy to your local environment for testing. ```bash npm run pages\:deploy ``` You’ll get a link to see the changes.

# Integrate - Third party tools - Kinde and Resend for custom SMTP

> Guide to configuring Kinde with Resend for custom SMTP email delivery including API key setup, domain verification, and SMTP configuration

resend, smtp, email, api key, domain verification, email deliverability, troubleshooting
integrate, third-party-tools

You can configure Kinde to send emails using your existing Resend account. This means your users will receive communications from your business’s email address, and not Kinde’s. Other benefits include better control of email deliverability, analytics and tracking, scalability, email compliance, etc. Please review the documentation at [Customize email sender](/get-started/connect/customize-email-sender/) for details about how custom SMTP works with Kinde and third party providers. ## Generate an API key from Resend You'll need an API key from Resend to use as the password for authenticating with their SMTP server. You can use an existing API key from Resend if you have one already. Or you can create a new API key from the Resend dashboard by going to the API keys section and clicking `Create API Key`. See Resend's [API Keys](https://resend.com/docs/dashboard/api-keys/introduction) documentation for more details. ## Whitelist domain Resend also requires you to verify the domain being used for the emails. See Resend's [Managing Domains](https://resend.com/docs/dashboard/domains/introduction) documentation for verifying your domain. ## Add email sender SMTP details If you are setting this up and your production environment is already live, we recommend testing this in a staging or test environment first. 1. In Kinde, go to **Settings > Email**. 2. Enter a **Sender name**. This is usually your business name, but might be a specific person. 3. Enable the **Use custom sender** switch. The SMTP details section opens. <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/d4c4b57d-9f1a-4b1c-638c-0a770c4fe400/public" alt="" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" /> 4. Enter the **Sender email**. This is the address your users will receive emails from and should be one of the verified domains from your Resend account. 5. Enter the SMTP details of your email provider: - Server name - `smtp.resend.com` - Port - `465` - User - `resend` - Password - Use the API key generated from your Resend account 6. Select **Send test email**. This sends a test email to the email address you are logged into Kinde with. 7. If the test is successful, select **Save**. 8. If the test is not successful, check the SMTP details (step 5) and try sending a test email again. If this does not work, see the troubleshooting section below. ## Troubleshooting If sending a test email fails: - Verify network connectivity to smtp.resend.com. - Confirm the port, user, and API key are correct. - Review error messages on the Resend dashboard. For more details, see Resend's troubleshooting guide: https://resend.com/docs/dashboard/api-keys/troubleshooting

# Integrate - Third party tools - Create a to-do app with Kinde and Supabase

> A walkthough example on how to create a to-do list app using Kinde and Supabase, as previously set up.

supabase, postgresql, row level security, rls, nextjs, jwt, authentication, database, todo app
integrate, third-party-tools

User authentication and secure data access are critical components of modern web applications. Kinde simplifies the process by handling user authentication, managing session tokens, and offering robust user management features. When combined with Supabase's powerful database management and PostgreSQL’s Row-Level Security (RLS) policies, you can create a secure, scalable application that ensures user-specific data access. In this guide, we will walk through building a personalized and secure to-do application. We’ll use Next.js as the application framework. ### What you need - A Kinde & Supabase project built [using this guide](/integrate/third-party-tools/kinde-supabase/) ## Step 1: Create to-do table in Supabase 1. Sign in to your Supabase dashboard and go to **SQL Editor.** 2. Select the **plus “+” icon**, and then **Create a new snippet**. ![Create Snippet in Supabase](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/ee3d1db7-9029-4ea1-9d76-f573af311b00/public) 3. Paste the following SQL code into the command window and select **Run**: ```sql -- Create the table CREATE TABLE todos ( id BIGINT PRIMARY KEY GENERATED ALWAYS AS IDENTITY, task TEXT NOT NULL, user_id TEXT NOT NULL, completed_state BOOLEAN DEFAULT FALSE ); -- Insert some sample data into the table INSERT INTO todos (task, user_id, completed_state) VALUES ('Finish writing blog post', 'kp_123', FALSE), ('Buy groceries', 'kp_456', TRUE), ('Work out at the gym', 'kp_789', FALSE), ('Read 10 pages of a book', 'kp_101', TRUE); -- Enable row-level security ALTER TABLE todos ENABLE ROW LEVEL SECURITY; ``` This command creates a `todos` table with the following columns: - **`task`**: with a type of **text**. - **`user_id`**: with a type of **text**. - **`completed_state`**: with a type of **boolean**. We use boolean because the completed state of each item is either true or false. It also inserts four sample todo items. We will need this for later. 4. Create another new snippet and run the following SQL statement to enable the row-level policy. ```sql create policy "users can read only their todos" on public.todos for select to public using (get_user_id() = user_id); ``` Your database policy is now set up to ensure that only the authenticated user's to-do items are displayed. In the next step, you'll update your table rows to include user IDs. ## **Step 2: Build a simple to-do app** 1. Open the `/components/hero.tsx` file with your favorite code editor. 2. Add the following code to `hero.tsx` which is a basic to-do list table: ```tsx import { createClient } from "@/lib/supabase/server" export async function Hero() { const supabase = await createClient() const { data: todos } = await supabase.from("todos").select() return ( <div className="flex flex-col gap-16 items-center"> <table style={{ width: "100%", borderCollapse: "collapse" }}> <thead> <tr> <th style={{ border: "1px solid #ddd", padding: "8px", textAlign: "left", backgroundColor: "#f2f2f2", }} > ID </th> <th style={{ border: "1px solid #ddd", padding: "8px", textAlign: "left", backgroundColor: "#f2f2f2", }} > Task </th> <th style={{ border: "1px solid #ddd", padding: "8px", textAlign: "left", backgroundColor: "#f2f2f2", }} > Is Complete </th> </tr> </thead> <tbody> {todos?.map((row) => ( <tr key={row.id}> <td style={{ border: "1px solid #ddd", padding: "8px" }}> {row.id} </td> <td style={{ border: "1px solid #ddd", padding: "8px" }}> {row.task} </td> <td style={{ border: "1px solid #ddd", padding: "8px" }}> {String(row.completed_state)} </td> </tr> ))} </tbody> </table> </div> ) } ``` 3. Run the project with the following terminal command: ```bash npm run dev ``` 4. Go to [http://localhost:3000](http://localhost:3000/), sign in/sign up, and preview the page. You won’t see any to-do items because we haven’t set any user ID yet. ![Empty to do list](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/a7a2213e-a5db-43cd-7d12-b33bb2cc6100/public) ## **Step 3: Link Kinde ID to to-do items** 1. Sign in to your Kinde dashboard and select **Users** to view the user list. 2. Locate the user registered with your Supabase to-do app (e.g: Tamal Chowdhury) and select their name to view their profile. [List of Kinde users](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/9a063bd4-4aaf-4f7d-d4d2-2e9425a06f00/public) 3. Copy the unique **Kinde profile ID** displayed on their profile page. [Kinde profile ID](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/8ca5c4de-0a28-4f1a-8baa-e960d79c3e00/public) 4. Go to **Table Editor** in your Supabase project, and open the **todos** table. 5. Locate the rows corresponding to your to-do items and update the `user_id` column with the Kinde ID you copied. Save your changes. ![to-do items](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/bf7a1ea7-0cb8-4512-3935-55b5d03f1e00/public) 6. In the Kinde project, log in with the same user you signed up with. Verify that the to-do items linked to this user are now visible on the **to-do page** of your app. ![to-do list finished](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/fc135833-78c1-4277-e3d1-6f92cfcad600/public) This step links the Kinde user ID to specific to-do items, enabling the app to filter and display tasks based on the authenticated users. ## Excellent work! You’ve successfully built a secure and personalized to-do app using Kinde for authentication and Supabase for database management. With this foundation, your app is now equipped to manage user authentication and personalized data securely. You can extend this project further by adding features like task creation, deletion, updates, or even real-time collaboration.

# Integrate - Third party tools - Kinde and Supabase

> Comprehensive guide to integrating Kinde authentication with Supabase database including PostgreSQL RLS policies, Next.js setup, and secure user-specific data access

supabase, postgresql, row level security, rls, nextjs, jwt, authentication, database, todo app
integrate, third-party-tools

User authentication and secure data access are critical components of modern web applications. Kinde simplifies the process by handling user authentication, managing session tokens, and offering robust user management features. When combined with Supabase's powerful database management and PostgreSQL’s Row-Level Security (RLS) policies, you can create a secure, scalable application that ensures user-specific data access. In this guide, we will walk through integrating Kinde and Supabase. We’ll use Next.js as the application framework. You can then go on to build a to-do app following [this doc](/integrate/third-party-tools/kinde-supabase-todo-app/). ## What you need - A [Supabase](https://supabase.com/) account (sign up for free) - A [Kinde](https://kinde.com/) account (sign up for free) ## Step 1: Set up your Kinde application 1. [Sign in to Kinde](https://kinde.com/) and on the front page, select **Add application**. 2. Enter a name for the application and select **Back-end web** as the application type. 3. Select **Save**. The **Quick start** page opens. 4. Select **Next.js** from the list of back-end SDKs, then select **Save**. 5. On the **Quick Start** page, select either **Starter Kit** or **Existing codebase** and follow the setup steps. For either path: 1. Select **Set** for each default callback URL to configure your application's callback settings. ![Callback URLs in Kinde](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/e3452f72-18ad-4647-3f6f-20a7a7c43300/bloglarge) 2. Copy the environment variables. We will use these later. ![Env variables from Kinde](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/e748137c-2db9-4f84-54fa-349d28245d00/public) 6. Select **Authentication** in the menu. 7. Enable the authentication types you want your users to sign in with (e.g. Email and Google), and select **Save**. ![Select auth options screen](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/6b0c12ba-6aec-4317-47c5-93b78a8afd00/public) ## Step 2: Set up a Supabase project 1. Sign in to your [Supabase dashboard](https://supabase.com/). 2. Select or add a new organization to add the project to. 3. Select **New Project.** 1. Enter a project name. 2. Set a secure password for your database. 3. Select a database region that best suits your application. 4. Select **Create new project**. ![Create new project in supabase](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/2c69ee62-35cc-4ebe-4a5b-a50ee30cf900/public) 4. In the **Project settings**, go to **API Keys** and select **Create new API keys**. ![Supabase API keys page](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/2df82b9c-6bea-4254-3167-548a199c3e00/public) 5. Copy the **Publishable key**, we will need it in the upcoming steps. 6. Go to **JWT Keys > JWT Signing Keys**. 7. Select **Migrate JWT secret**. ![Supabase migrate JWT secret](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/be3c2870-b253-4067-78d7-a080c884b700/public) ![Start using new JWT keys dialog](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/a6e04626-98c0-4bf7-c4a7-2ab21b2cea00/public) You will see a pair of JWT keys in the page. The CURRENT KEY (Legacy HS256) and the STANDBY KEY (ECC P-256). We will mint our own JWT key with a shared secret. ![Supabase JWT Keys](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/b25a37ad-74cf-413f-f04c-095b43905e00/public) 8. Select the **three dots** next to the `STANDBY KEY` and select **Move to previously used**. This will enable you to create a new standby key. 9. Select **Create Standby Key**. ![Supabase new JWT standby keys](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/0b4ceff8-3b6b-4412-220a-0f5937bbfb00/public) 10. From the dropdown of algorithm selection, choose **HS256 (Shared Secret)**. 1. Select the **Import an existing secret** option. 2. Paste in the Kinde client secret from your application. To find it, go to **Kinde > Applications > Your application > Details >** **Client Secret.** 3. Select **Create standby key**. Your new key is listed as a `STANDBY KEY` ![Supabase new standby key window](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/08f09e3c-1711-4a3e-45dd-b8a856ebdd00/public) ![Supabase rotate keys window](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/38b9ece2-8f68-4e5c-21c6-18fa1d07d100/public) 11. Select **Rotate keys**. 12. Check both confirmation boxes and select **Rotate signing key**. You will have your shared secret key set as your `CURRENT KEY`. ![Rotate JWT signing key dialog](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/9e5e96ed-108f-448d-62d3-6fdd17ad9a00/public) ![standby keys](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/6c012dee-38c4-43d3-087d-321af5ba8000/public) 13. Navigate to **SQL Editor** and select **New SQL Snippet**. ![New SQL Snippet](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/24671391-0aa5-466a-8860-887468ac6200/public) 14. Paste the following SQL code into the command window and select **Run**: ```sql create or replace function get_user_id() returns text language sql stable as $$ select nullif(current_setting('request.jwt.claims', true)::json->>'sub', '')::text; $$; ``` This function extracts the `sub` field from the JSON Web Token (JWT) sent by Kinde auth. The `sub` field contains the Kinde user ID, which allows Supabase to authenticate the correct Kinde user. ## Step 3: Setup a Next.js project with Supabase and Kinde 1. Run the following command in your terminal window to start a new project with Next.js and Supabase. Follow the on-screen instructions. ```bash npx create-next-app -e with-supabase ``` 2. Set a name for your project (e.g: `kinde-with-supabase`) 3. Go into the project directory: ```bash cd kinde-with-supabase ``` 4. Install the Kinde dependency with this command: ```bash npm install @kinde-oss/kinde-auth-nextjs jsonwebtoken npm install --save-dev @types/jsonwebtoken ``` 5. Create the Kinde auth endpoint in this path **app/api/auth/[kindeAuth]**: ```bash mkdir -p "app/api/auth/[kindeAuth]" touch "app/api/auth/[kindeAuth]/route.js" ``` 6. Open the newly created `route.js` file, enter the following code, and save the file: ```bash import { handleAuth } from "@kinde-oss/kinde-auth-nextjs/server" export const GET = handleAuth() ``` 7. Create an environment variables file `.env.local` by typing: ```bash touch .env.local ``` 8. Add the following to your `.env.local` file: - The Kinde environment vars details you copied earlier. You can get these again from your Kinde application Quick start page. - The Supabase Project URL from **Supabase > Project Settings > Data API > Project URL.** - The Publishable key from **Supabase > Project Settings > API Keys > API Keys** tab **→ Publishable key** ``` KINDE_CLIENT_ID=<kinde_client_id> KINDE_CLIENT_SECRET=<kinde_client_secret> KINDE_ISSUER_URL=https://<your_kinde_business>.kinde.com KINDE_SITE_URL=http://localhost:3000 KINDE_POST_LOGOUT_REDIRECT_URL=http://localhost:3000 KINDE_POST_LOGIN_REDIRECT_URL=http://localhost:3000 NEXT_PUBLIC_SUPABASE_URL=https://<supabase_project_id>.supabase.co NEXT_PUBLIC_SUPABASE_PUBLISHABLE_OR_ANON_KEY=<supabase_publishable_key> ``` 9. To ensure the user is redirected to the homepage after they sign in, update the `KINDE_POST_LOGIN_REDIRECT_URL` in your `.env.local` file to: ``` KINDE_POST_LOGIN_REDIRECT_URL=http://localhost:3000 ``` 10. Open the `components/auth-button.tsx` file and replace the entire content with the following. This code will replace Supabase Auth functions with Kinde Auth. ```tsx import { RegisterLink, LoginLink, LogoutLink, } from "@kinde-oss/kinde-auth-nextjs/components" import { getKindeServerSession } from "@kinde-oss/kinde-auth-nextjs/server" import { Button } from "./ui/button" export async function AuthButton() { const { getUser } = getKindeServerSession() const user = await getUser() return user ? ( <div className="flex items-center gap-4"> Hey, {user.email}!<LogoutLink className="text-subtle">Log out</LogoutLink> </div> ) : ( <div className="flex gap-2"> <Button asChild size="sm" variant={"outline"}> <LoginLink className="btn btn-ghost sign-in-btn">Sign in</LoginLink> </Button> <Button asChild size="sm" variant={"default"}> <RegisterLink className="btn btn-dark">Sign up</RegisterLink> </Button> </div> ) } ``` 11. Replace `lib/supabase/server.ts` with the following code: ```tsx import { getKindeServerSession } from "@kinde-oss/kinde-auth-nextjs/server" import { createServerClient } from "@supabase/ssr" import { cookies } from "next/headers" import jwt from "jsonwebtoken" export const createClient = async () => { const cookieStore = await cookies() const { getIdToken } = getKindeServerSession() const idToken = await getIdToken() let token: string if (idToken) { token = jwt.sign(idToken, process.env.KINDE_CLIENT_SECRET!) } else { token = process.env.NEXT_PUBLIC_SUPABASE_PUBLISHABLE_OR_ANON_KEY! } return createServerClient( process.env.NEXT_PUBLIC_SUPABASE_URL!, process.env.NEXT_PUBLIC_SUPABASE_PUBLISHABLE_OR_ANON_KEY!, { global: { headers: { Authorization: `Bearer ${token}`, }, }, cookies: { getAll() { return cookieStore.getAll() }, setAll(cookiesToSet) { try { cookiesToSet.forEach(({ name, value, options }) => { cookieStore.set(name, value, options) }) } catch (error) { // The `set` method was called from a Server Component. // This can be ignored if you have middleware refreshing // user sessions. } }, }, } ) } ``` 12. Replace `lib/supabase/middleware.ts` with the following code: ```tsx import { NextResponse, type NextRequest } from "next/server" import { hasEnvVars } from "../utils" export async function updateSession(request: NextRequest) { const supabaseResponse = NextResponse.next({ request, }) // If the env vars are not set, skip middleware check. You can remove this once you setup the project. if (!hasEnvVars) { return supabaseResponse } // Do not run code between createServerClient and // supabase.auth.getUser(). A simple mistake could make it very hard to debug // issues with users being randomly logged out. // IMPORTANT: DO NOT REMOVE auth.getUser() // IMPORTANT: You *must* return the supabaseResponse object as it is. // If you're creating a new response object with NextResponse.next() make sure to: // 1. Pass the request in it, like so: // const myNewResponse = NextResponse.next({ request }) // 2. Copy over the cookies, like so: // myNewResponse.cookies.setAll(supabaseResponse.cookies.getAll()) // 3. Change the myNewResponse object to fit your needs, but avoid changing // the cookies! // 4. Finally: // return myNewResponse // If this is not done, you may be causing the browser and server to go out // of sync and terminate the user's session prematurely! return supabaseResponse } ``` 13. Start the development environment by typing the following in your terminal: ```bash npm run dev ``` 14. Go to [http://localhost:3000](http://localhost:3000/) and sign up/sign in to your Kinde application to test the integration. ![Your local app showing supabase readiness](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/115c087b-d820-444e-7809-a059c37fa400/public) ## Well done! You've successfully integrated Kinde for authentication with Supabase for database management, creating a secure foundation for user-specific data access. With this integration in place, your application is now equipped to handle user authentication and manage personalized data securely. You can extend this foundation by adding various features and functionalities specific to your application's requirements, all while maintaining the security and scalability provided by this Kinde-Supabase integration. Take this one step further by creating a [to-do list application following the next guide](/integrate/third-party-tools/kinde-supabase-todo-app/).

# Integrate - Third party tools - Connect Kinde and WordPress

> Guide to integrating Kinde with WordPress using the OpenID Connect Generic Client plugin including plugin installation and OAuth configuration

wordpress, openid connect, plugin, oauth, client id, client secret, callback urls, endpoints
integrate, third-party-tools

This topic describes how to set up Kinde with WordPress using the `OpenID Connect - Generic Client` plugin. <Aside> This topic includes only basic steps. Depending on your exact setup, additional configuration might be required. </Aside> ## Step 1: Install the Plugin 1. In the WordPress admin area, go to **Plugins** and select **Add New**. 2. Search for `OpenID Connect - Generic Client` and select **Install Now**. 3. Once installed, select **Activate**. ## Step 2: Set up Kinde 1. Sign in to your Kinde dashboard. 2. Go to **Settings > Applications > [Your App Name] > View Details**. 3. In the **Allowed callback URLs** field, enter: `https://[your_wordpress_domain]/wp-admin/admin-ajax.php?action=openid-connect-authorize` 4. In the **Allowed logout redirect URLs** field, enter: `https://[your_wordpress_domain]/` 5. Select **Save**. ## Step 3: Configure the Plugin 1. In WordPress, go to the **Settings** page for the plugin. 2. Set the **Scope** to **openid**. 3. Enter the following details: - **Client ID**: Client ID from your Kinde application - **Client Secret:** Client secret from your Kinde application - **Login Endpoint URL:** `https://[your_kinde_domain].kinde.com/oauth2/auth` - **Userinfo Endpoint URL:** `https://[your_kinde_domain].kinde.com/oauth2/v2/user_profile` - **Token Validation Endpoint URL:** `https://[your_kinde_domain].kinde.com/oauth2/token` - **End Session Endpoint URL:** `https://[your_kinde_domain].kinde.com/logout` - **Identity Key:** sub - **Nickname Key:** sub ## Step 4: Test the configuration Finally, you should test your configuration to ensure that everything is set up correctly. 1. Sign in to your WordPress site. This should redirect to Kinde pages. 2. If everything is set up correctly, you should be able to sign in successfully.

# Integrate - Third party tools - Marketing campaign tracking with Kinde

> Guide to marketing campaign tracking with Kinde including Google Analytics integration and state parameter usage for UTM code correlation

marketing campaigns, google analytics, tracking, state parameter, utm codes, analytics, sign up tracking
integrate, third-party-tools

Kinde gives you several options for extracting your data, while we work toward providing a more comprehensive analytics feature. ## Google analytics Kinde lets you integrate with [Google Analytics](/manage-users/view-activity/track-user-sign-in-with-google-analytics/), so you can track sign up patterns, rates, frequency, etc. To start using it, enter your Google UA or G-tag in **Settings > Environment > Details > Tracking**. ## The state parameter If GA does not give you the specific information you need, you might be able to use the `state` parameter as a solution. The `state` parameter is used to store a unique code for each sign up flow, adding security to the authentication experience. But It can also be harnessed to correlate unique marketing IDs (such as UTM codes) along with it. Here’s how it works: 1. Your campaign ad carries a unique ID for the campaign. 2. A user clicks through the campaign to sign up to your app or product. 3. A unique event code is generated and the unique ID from the ad is picked up and passed through the Kinde auth process in the `state` parameter. 4. A token is issued for the user by Kinde, then Kinde redirects your user back, passing the same `state` parameter. The value of the `state` can then be used to correlate back any ad-specific information or call the advertiser’s API. Any information you need after the authentication flow, can be correlated with the passed through `state` parameter value. See the [definition of State in Using Kinde without an SDK](/developer-tools/about/using-kinde-without-an-sdk/#state).

# Integrate - Third party tools - Kinde and Shopify Multipass

> Guide to integrating Kinde with Shopify Multipass for seamless user authentication and customer data passing between applications

shopify, multipass, shopify plus, jwt decoder, customer data, redirect, api endpoint
integrate, third-party-tools

[Shopify Multipass](https://shopify.dev/docs/api/multipass) lets you seamlessly log your users from your application to Shopify, passing over related metadata about your user via a token. ## What you need - A Kinde account, this will work on all Kinde plans. - [Shopify Plus plan](https://www.shopify.com/au/pricing/) and [Multipass enabled.](https://shopify.dev/docs/api/multipass/) ## Configure Multipass in your project The following example uses [Next.js](https://nextjs.org/), however this can also be configured in other languages and frameworks. ### Add new environment variables Add Shopify and Multipass settings to your .env file. ```shell title=".env SHOPIFY_MULTIPASS_SECRET = "[Your Mulitpass secret]"; SHOPIFY_STORE_URL = "[yourshopify].myshopify.com"; ``` ### Set up API endpoint Create an endpoint file, e.g. `/api/multipass` that contains the following. Make sure to replace the generic information with your specific domain and secret information. ```tsx import {NextResponse} from "next/server"; import {jwtDecoder, type JWTDecoded} from "@kinde/jwt-decoder"; import {cookies} from "next/headers"; import {Multipass} from "multipass-js"; export async function GET() { const decodedToken = jwtDecoder<JWTDecoded & {email: string}>(cookies().get("id_token")?.value); if (decodedToken) { const multipass = new Multipass(process.env.SHOPIFY_MULTIPASS_SECRET as string); const customerData = { // Required email: decodedToken?.email, created_at: decodedToken?.iat // add additional fields here }; const url = multipass .withCustomerData(customerData) .withDomain(process.env.SHOPIFY_STORE_URL as string) .url(); return NextResponse.redirect(url, 302); } else { const params = new URLSearchParams(); params.append("post_login_redirect_url", `${process.env.KINDE_SITE_URL}/api/multipass`); return NextResponse.redirect( `${process.env.KINDE_SITE_URL}/api/auth/login?${params.toString()}`, 302 ); } } ``` Shopify Multipass is now configured with Kinde. When you redirect the user to the endpoint `/api/multipass`, this will generate the Multipass token and redirect the user logged in to your Shopify site.

# Integrate - Third party tools - Integrate fraud detection with TrustPath

> Comprehensive guide to integrating TrustPath fraud detection with Kinde workflows including risk assessment, threat detection rules, and API integration for secure authentication

trustpath, fraud detection, workflows, risk assessment, threat detection, api integration, security, m2m application
integrate, third-party-tools

This guide shows you how to build a Fraud Detection Workflow that runs after user authentication in **Kinde**, and uses **TrustPath** to detect and block potentially fraudulent sign-ins and sign-ups. The core idea: **whenever a user signs in or registers**, Kinde sends data to TrustPath. Based on the risk score it returns, Kinde allows or denies access. TrustPath works with Kinde workflows to trigger certain actions at key points in the authentication journey, using your own code. ## What you need Here’s what you need to get started. - **Kinde account** - [Create one](https://app.kinde.com/register) for free if you haven’t already. You’ll also need to set up an application in Kinde. - **Kinde M2M application** - Create a [dedicated M2M app](https://docs.kinde.com/developer-tools/kinde-api/connect-to-kinde-api/) for accessing the Kinde Management API - **TrustPath account** - [Sign up](https://console.trustpath.io/login) here if you don’t have one. A free account does not require any payment information. - **TrustPath API access** - Grab an API key from the [TrustPath console](https://console.trustpath.io). - **Git repo for storing your code** - clone [this repository](https://github.com/trust-path/kinde-trustpath-integration-example). It contains integration code that is already prepared for use with this guide. ## Step 1: Set up the workflow and connect your repo For a workflow to function in Kinde, the workflow files need to be structured and set up in a specific way. Refer to the docs to get this part right. 1. [Create a new workflow](/workflows/getting-started/workflow-files/) or [clone a template workflow](https://github.com/trust-path/kinde-trustpath-integration-example). 2. [Connect your GitHub repo](/workflows/getting-started/connect-repo-for-workflows/) to execute the workflow. ## Step 2: Define the workflow entry point The workflow starts with a simple async function triggered after user authentication: ```js export default async function FraudDetectionWorkflow(event: onPostAuthenticationEvent) { } ``` The event parameter gives us initial context—such as the user ID, IP address, and whether this is a new user. But we need to enrich this data before we can send it to TrustPath. We’ll do this in the next step. ## Step 3: Fetch full user data from Kinde To make an informed decision, TrustPath. needs more than a user ID—it also needs the user's email, first name, and last name. To get this data from Kinde, do the following. 1. [Set up an M2M application](/developer-tools/kinde-api/connect-to-kinde-api/) to access the Kinde Management API and switch on the `read:users` scope. 2. Copy the Client ID and Client secret from the above application. 3. Create two new [environment variables](/workflows/configuration/environment-variables-and-secrets/) in Kinde. Go to **Settings > Data management > Env variables**. 4. Add the following variables: | Key | Value | Sensitive | | --- | --- | --- | | KINDE_WF_M2M_CLIENT_ID | Copy from M2M application | No | | KINDE_WF_M2M_CLIENT_SECRET | Copy from M2M application | Yes | Once these are set up, you can retrieve the additional data you need, using the `createKindeAPI` helper from [@kinde/infrastructure](https://github.com/kinde-oss/infrastructure), which allows us to call the Kinde Management API: ```js const kindeAPI = await createKindeAPI(event); const user = await getUserData(kindeAPI, event.context.user.id); async function getUserData(kindeAPI: any, userId: string) { const { data: user } = await kindeAPI.get({ endpoint: `user?id=${userId}` }); return user; } ``` ## Step 4: Set up your TrustPath API key **TrustPath** requires an API key to authenticate your requests, in this case a request that originates from the Kinde workflow. To get your API Key: 1. Log in to the [TrustPath Console](https://console.trustpath.io). 2. On the left-hand menu, go to **[Your Name] > API Keys**. 3. Copy either one of the API keys provided there. (Recommended) Store the API key securely as an [environment variable](/workflows/configuration/environment-variables-and-secrets/) in **Kinde**, just like the other variables mentioned above. ```js const trustPathAPIKey = getEnvironmentVariable("TRUSTPATH_API_KEY")?.value; ``` This ensures you’re not hardcoding sensitive credentials, and it keeps your app secure and maintainable. ## Step 5: Determine the event type TrustPath evaluates risk differently based on the event type. For example, account creation versus account sign in. ```js const isNewUser = event.context.auth.isNewUserRecordCreated; const eventType = isNewUser ? "account_register" : "account_login"; ``` We check whether the user is new and set the event type accordingly: - `account_register`: Used for new sign-ups - typically includes more rigorous fraud checks. - `account_login`: Used for existing users - can focus on things like account takeover detection. By classifying the event properly, you can take advantage of TrustPath's specialized rule sets. ## Step 6: Define TrustPath threat detection rules TrustPath threat detection rules are individual risk assessment criteria designed to identify fraudulent activities. Each rule analyzes specific signals to detect suspicious behavior and assigns a risk score to the event. Each risk detected then contributes to the total risk score, which ranges from 0 to 100. - A score of 0 means no risk (approve) - A score of 100 means very risky (decline) You need to set up separate rules for `account_register` and `account_login` events. Select **Threat Rules** from the menu and choose the card labeled **Account Register** to configure it. TrustPath offers the flexibility to add your own rules, but it also provides default rules tailored to each event type. ![Threat rules in TrustPath dashboard](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/eada27f8-80b4-4c2b-0f3f-a379fda7b800/public) ![TrustPath Rules library](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/2b574b60-336c-4a2b-7585-e1f575537800/public) Here’s an example of how to add a rule for the account register event. 1. Select **Add Rule From Library** in the top right corner. 2. From the list, select the following rules by clicking on each rule: - Email addresses are disposable. - IP Address is a Tor exit node. - Email server IP addresses have abuse reports. This will enable any new account registration on Kinde to perform IP and email threat signal checks. Next, configure rules for the account log in event. For this, we want to prevent users from entering the system with disposable email addresses, as well as detect rapid IP changes, which can be a sign of unusual behavior. Here’s where you configure rules for the `account_login` event. ![Event type rules in TrustPath](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/5902e60b-45b8-470d-8ec1-4fd46e6ec100/public) You can see we have some rules switched on, and each rule has a score. The example above detects rapid IP changes and blocks users by assigning a high risk score, which signals potential issues. ### Advanced rule configuration The above rule can be strengthened by adding browser fingerprinting to IP change detection. For instance, the rule might be: “*if the same user email sees more than three different IP addresses within five minutes **and** also has a new browser fingerprint”*, it’s a stronger signal of suspicious activity. When set up, this detects a user logging in from multiple locations or while traveling—where the IP may change, but the browser fingerprint typically remains consistent if they’re using the same device. TrustPath supports many advanced configurations like this. You can contact their team to help you set up any complex rules you want. ## Step 7: Build the request body Now that we have the user info and event type, we can build the payload to send to TrustPath when the workflow is triggered. ```js const requestBody = { ip: event.request.ip.split(",")[0].trim(), // Handles cases where multiple IPs are forwarded email: user.preferred_email, user: { user_id: event.context.user.id, first_name: user.first_name, last_name: user.last_name, }, event_type: eventType, }; ``` This information passed in the request body allows TrustPath to cross-reference behavioral history, analyze IP risk, and more. ## Step 8: Call the TrustPath Risk API Once the connection is set up between APIs, data is ready to be sent to TrustPath via a standard HTTP POST request. Here’s an example: ```js const response = await kinde.fetch( "https://api.trustpath.io/v1/risk/evaluate", { method: "POST", responseFormat: "json", headers: { Authorization: `Bearer ${trustPathAPIKey}`, "Content-Type": "application/json", }, body: JSON.stringify(requestBody), } ); ``` This request is made using `kinde.fetch`, which handles outbound API calls securely within the workflow context. ## Step 9: Evaluate the response and take action When the API call to TrustPath comes back, the response will include a state field showing one of three values: - **approve** - let the user through - **review** - optionally flags cases for manual review - **decline** - block access Here's how to enforce a block for declined requests: ```js const state = response.json.data.score.state; if (state === "decline") { denyAccess( "You are not allowed to access this resource. Request declined by TrustPath.io ); } ``` You can adapt this to handle review flags differently, or to just mark it for review. ## Step 10: Test your fraud detection setup Now that everything is set up, we can test the entire flow. Starting with the `account_register event`, select a disposable email address (choosing any from your favorite search engine should be sufficient) and try to create a new account on Kinde. Once everything is set up and deployed: 1. Log in or register using your test account 2. Check TrustPath's Event History to see the result 3. By default, new accounts will return **approve** until you define threat rules in TrustPath. You can also test the `account_login` event by simulating logins from different IP addresses—using a VPN is a simple way to do this. ## Support If you need extra support, here’s where to get it. - **TrustPath support:** For questions related to fraud detection rules, API integration, or threat analysis, visit **TrustPath**, [contact the TrustPath team](https://trustpath.io/contact), or view the TrustPath [API docs](https://docs.trustpath.io/). - **Kinde support:** For help with authentication workflows, triggers, or general setup, refer to the [Kinde docs](https://docs.kinde.com/) or reach out to [our support team](https://kinde.com/support/). TrustPath is a German-based company. Their team wrote this guide to help Kinde users.

# Integrate - Webhooks - About webhooks

> Comprehensive guide to Kinde webhooks including event monitoring, security best practices, JWT handling, and retry policies for real-time notifications

webhooks, event monitoring, jwt, idempotency, replay attacks, security, retry policy, endpoints
integrate, webhooks

<Aside type="warning"> If you are experiencing issues with webhooks, it could be because the webhooks request content-type header has changed from `application/json` to `application/jwt`. Read the full details [here](https://kinde.notion.site/Important-notice-for-webhooks-users-7fcf184faece41368603e513267dffc6). We apologize for any inconvenience. </Aside> Webhooks are a way of monitoring events in Kinde, so that you can be notified and take action when something you’re monitoring happens. <Aside type="upgrade"> Depending which Kinde plan you’re on, the number of webhooks you can create might be limited. [View plans](https://kinde.com/pricing/). </Aside> ## How webhooks work When you create a webhook, you register your own URL endpoints in Kinde and associate them with a Kinde event (e.g. when a user is created). When an endpoint is triggered, Kinde sends data about the event, so that you can initiate an action in your application or store the data. A simple example would be setting up a webhook for when a new user is created in Kinde. This event can be set up to trigger an update to your database, enabling your system to automatically send a welcome email. ## Webhooks flow 1. Webhook endpoints are registered in Kinde. 2. An event occurs in your account, e.g. `user.created`. 3. Your endpoint will be called with a JWT containing the data object about that event, and details about the webhook. 1. If a `200` response is received, the workflow is complete. 2. If it fails to receive a response, it will retry using a back-off policy (see **Webhooks responses and retry policy** below). 4. In your application you should verify the authenticity of the webhook request, and decode the JWT (see **Webhooks security** below). 5. Logic is triggered in your application using the event data. ## Webhooks identifiers There are a number of unique IDs you will come across with webhooks. - **Webhook ID**: prefixed with `webhook_`, this refers to the webhooks that you create in Kinde. Webhook IDs are exposed via the Kinde Management API webhook endpoints. You can get a list of webhooks via the endpoint `GET /api/v1/webhooks` - **Event ID**: prefixed with `event_`, this is the ID of an event that has occurred in your account, and is included as `event_id` in webhook request payloads. You can use this ID to retrieve an event from Kinde’s API using `GET /api/v1/events/{event_id}` - **Webhook Request ID**: found in the webhook headers as `webhook-id`, this is unique to a webhook and event, and will not change between attempts. You can use this as the idempotency key (see Webhooks security below). ## Webhooks decoder Kinde provides a [webhooks decoder](https://github.com/kinde-oss/webhook) to help you decode and validate webhook tokens, for an easier implementation. ## Webhooks security ### Idempotency key Each webhook has a webhook-id header that can be used to avoid reprocessing the same webhook request. This is referred to as the ‘idempotency key’ meaning that multiple requests will result in the same outcome. ### Prevent Replay Attacks A replay attack occurs when a payload is intercepted, potentially modified and re-transmitted. Kinde webhooks contain a ‘timestamp’ attribute in the payload, and the payload is a signed JSON Web Token (JWT). This allows you to verify that the request came from Kinde, and check the timestamp to prevent replay attacks. ### Verify an event You can request events by their event_id using the Kinde management api via `/api/v1/events/{event_id}`. The event_id is provided in all webhook requests. ## Webhooks best practices Ensure webhooks are secure and optimized. - Handle duplicate request attempts by checking that the webhook-id header has not already been received and processed, making your processing idempotent - Verify the JWT to ensure that the request came from Kinde using your public JWKS file - Only add the events to your endpoint that your implementation requires, listening for all events creates unnecessary load on your server - Endpoints must use HTTPS - Return a 200 from your endpoint to indicate it has received the request ## Webhooks responses and retry policy If we fail to receive a 200 response from your endpoint, Kinde operates a back-off retry policy, this roughly equates to the following attempts: - Immediately - After 5 seconds - After 30 seconds - After 2 minutes - After 10 minutes - After 1 hour - After 4 hours - Every 12 hours until 36 hours ## Webhooks terminology You’ll come across these terms when you start using webhooks. **Endpoint** - the URL called when an event occurs. **Event type** - something that happens in Kinde, e.g. a user is created. **Event** - an instance of an event type that happens in Kinde, e.g. Jane Doe just signed up. **Request** - the request object sent to your endpoint that contains a JSON Web Token (JWT) with the event data and details about the event. **Attempt** - an instance of a request making an http request, multiple request attempts may be made if we do not receive a 200 response.

# Integrate - Webhooks - Add and manage webhooks

> Guide to adding and managing webhooks in Kinde including security setup, trigger configuration, API management, and local testing with proxy tools

webhook management, webhook triggers, authentication webhooks, user management webhooks, billing webhooks, jwt validation, local testing, ngrok, localtunnel
integrate, webhooks

<Aside type="warning"> If you are experiencing issues with webhooks, it could be because the webhook request content-type header has changed from `application/json` to `application/jwt`. Read the full details [here](https://kinde.notion.site/Important-notice-for-webhooks-users-7fcf184faece41368603e513267dffc6). We apologize for any inconvenience. </Aside> Webhooks are outbound calls that are sent from Kinde when a specified events occurs. Calls are sent using HTTPS REST calls to a verified external URL you specify. Use Kinde’s webhooks to create triggers and push event data to your other systems and applications. <Aside type="upgrade"> Webhook limits apply if you are on the Kinde free plan. [See all plans](https://kinde.com/pricing/). </Aside> ## Webhook security Webhook request payloads are signed and sent as a JSON Web Token (JWT) from Kinde. You’re probably using a library to validate your JWTs and they will require the url for your public JSON Web Key (also known as a `jwks` file). The jwks file can be found at `https://<your_subdomain>.kinde.com/.well-known/jwks` ## Add a webhook 1. Go to **Settings > Environment > Webhooks**. 2. Select **Add webhook**. 3. Give the webhook a name and enter a description so it’s clear what it’s for. 4. Enter the external URL. 5. Select the event triggers. You can choose from a number of triggers and categories. See below for definitions. ## Edit a webhook 1. Go to **Settings > Environment > Webhooks**. 2. Select the webhook name to open the details window. 3. Update events and triggers. 4. Select **Save**. ## Delete a webhook 1. Go to **Settings > Environment > Webhooks**. 2. Select the three dots menu next to the webhook you want to delete. 3. Select **Delete webhook**. A confirmation message appears. 4. Confirm you want to delete the webhook. ## Manage webhooks via the Kinde API Everything you can do in Kinde’s UI with webhooks, you can also do through the Kinde API using these endpoints. - `POST api/v1/webhooks` - create a webhook - `PATCH api/v1/webhook/{webhook_id}` - update a webhook - `DELETE api/v1/webhook/{webhook_id}` - delete a webhook - `GET api/v1/webhooks` - list of available webhooks Events can also be retrieved using: - `GET /api/v1/events/{event_id}` - get an event by the event_id provided in a webhook - `GET /api/v1/event_types` - list the available event types ## Webhook triggers ### Authentication webhooks ```jsx organization.created; user.created; user.authentication_failed; user.authenticated; subscriber.created; access_request.created; ``` ### User management webhooks ```jsx role.created; role.updated; role.deleted; permission.created; permission.updated; permission.deleted; organization.updated; organization.deleted; user.updated; user.deleted; ``` ### Billing webhooks ```jsx customer.agreement_cancelled; customer.agreement_created; customer.invoice_overdue; customer.meter_usage_updated; customer.payment_failed; customer.payment_succeeded; customer.plan_created; customer.plan_assigned; customer.plan_changed; ``` <Aside> The `user.created` trigger does not create a call when you import users </Aside> ## Testing webhooks locally In order to use webhooks, you need a publicly available URL. To test locally you need to use a proxy to expose your local instance on the internet. Here are a couple of free tools to help you to do this. - [localtunnel](https://theboroer.github.io/localtunnel-www/) - fast and easy, we recommend using the `—subdomain` attribute to fix the issued subdomain. - [Ngrok](https://ngrok.com/) - for intermediate users, requires some dev experience to get set up. Each of these services exposes a local port though a public URL that can be set as your web socket.

# Integrate - Webhooks - Set up webhooks using Next.js

> Step-by-step guide to implementing Kinde webhooks in Next.js including JWT verification, API route setup, and local development testing

nextjs webhooks, jwt verification, jwks-rsa, jsonwebtoken, api routes, local development, ngrok, localtunnel
integrate, webhooks

While webhooks will work with any Next.js setup, this guide uses [Next.js 14 with app router](/developer-tools/sdks/backend/nextjs-sdk/) and the `app` directory. You may need to alter some code samples if you have a different setup, but the core instructions remain the same. ## Set up local development In order to use webhooks, you need a publicly available URL. To test locally you need to use a proxy to expose your local instance on the internet. Here are a couple of free tools to help you to do this. - [localtunnel](https://theboroer.github.io/localtunnel-www/) - fast and easy, we recommend using the `—subdomain` attribute to fix the issued subdomain. - [Ngrok](https://ngrok.com/) - for intermediate users, requires some dev experience to get set up. Each of these services expose a local port though a public URL that can be set as your web socket. Follow their instructions to run your local Next.js application and you will receive a URL that you need later in this guide. ## Create the Kinde webhook route Kinde sends webhooks as JWT’s to make them both easy and secure. In this example we will leverage 2 libraries to parse the JWT and verify the signature. 1. Create the file `app/api/kinde-webhook/route.ts`. The `route.ts` file is a specific file convention in Next.js that marks the route as an API route, rather than a page. ```jsx // app/api/kinde-webhook/route.ts import { NextResponse } from "next/server"; export async function POST(req: Request) { return NextResponse.json({ status: 200, statusText: "success" }); } ``` Whenever an event occurs in Kinde, a POST request is sent via this route to the specified endpoint, so that your project can react to the event. For example, refreshing a token or updating data in your database. Note that the endpoint needs to be publicly available, with no route protection. 2. Install the dependencies. <PackageManagers pkg="jwks-rsa jsonwebtoken" /> 3. Update your file as follows: ```jsx // app/api/kinde-webhook/route.ts import { NextResponse } from "next/server"; import jwksClient from "jwks-rsa"; import jwt from "jsonwebtoken"; // The Kinde issuer URL should already be in your `.env` file // from when you initially set up Kinde. This will fetch your // public JSON web keys file const client = jwksClient({ jwksUri: `${process.env.KINDE_ISSUER_URL}/.well-known/jwks.json`, }); export async function POST(req: Request) { try { // Get the token from the request const token = await req.text(); // Decode the token const { header } = jwt.decode(token, { complete: true }); const { kid } = header; // Verify the token const key = await client.getSigningKey(kid); const signingKey = key.getPublicKey(); const event = await jwt.verify(token, signingKey); // Handle various events switch (event?.type) { case "user.updated": // handle user updated event // e.g update database with event.data console.log(event.data); break; case "user.created": // handle user created event // e.g add user to database with event.data console.log(event.data); break; default: // other events that we don't handle break; } } catch (err) { if (err instanceof Error) { console.error(err.message); return NextResponse.json({ message: err.message }, { status: 400 }); } } return NextResponse.json({ status: 200, statusText: "success" }); } ``` As per the sample above, the JWKs file is fetched from Kinde, the token is decoded, and the signature is compared against your keys file. This is how you know you can trust the request has come from Kinde. <Aside title="Handling different event types"> In the example above, we used a switch statement. But you could also set up an endpoint per event type, group them into related endpoints, use a map, or any other method for splitting and managing the events. </Aside> 4. Start your server so it’s ready and listening out for the next step. With most Next.js applications, run `npm run dev` in the terminal. ## Set up the webhook in Kinde 1. In the Kinde, go to **Settings > Environment > Webhooks**. 2. Select **Add webhook**. 3. Give the webhook a name and description. 4. Enter the Next.js endpoint we set up earlier in your project. For example `<your_app_url>/api/kinde-webhook`. If you are using an external tool to test the endpoint locally, enter the endpoint URL specified in the tool. <Aside type="warning" title="Make sure URLs match"> Testing will fail if the endpoint URL in Kinde does not match the site URL where you are testing the webhook. </Aside> 5. Select **Add events.** 6. In the dialog that opens, select the events you want. For example, user events, organization events, etc. 7. Select **Save**. 8. In the webhook window, select **Save**. ## Test the webhook 1. Either create a new user or update an existing one in Kinde. 2. Switch back to where your server is running and you should see the data in your server console. 3. Done! Have a tasty beverage.

# Integrate - Webhooks - Connect Zapier to Kinde

> Guide to connecting Zapier with Kinde for automation and event-driven workflows using webhooks and event hooks

zapier, event hooks, automation, integration, webhooks
integrate, webhooks

When we first introduced a Zapier connection, it was to offer approximate webhooks functionality, until we had [actual webhooks](/integrate/webhooks/about-webhooks/). Now that we have webhooks, you can still integrate with Zapier, it just works a bit different. Here’s how: <YoutubeVideo videoId={"2C0GNM0t-sY"} />

