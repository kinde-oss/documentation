---
page_id: 8a9b0c1d-2e3f-4a5b-6c7d-8e9f0a1b2c3d
title: Kinde Documentation - Complete
description: "Complete documentation for Kinde containing titles, descriptions, keywords, topics, and full content from all documentation files for LLM training"
sidebar:
  order: 1
topics:
  - llm
  - documentation
  - training
  - complete
sdk: []
languages:
  - markdown
  - text
audience: developers
complexity: beginner
keywords:
  - llm training
  - documentation
  - complete
  - full content
  - frontmatter
  - metadata
  - kinde
updated: 2025-09-18
featured: false
deprecated: false
ai_summary: "Complete documentation for Kinde containing titles, descriptions, keywords, topics, and full content from all documentation files for LLM training"
---

# Kinde Documentation - Complete

This is the complete documentation for Kinde containing titles, descriptions, keywords, topics, and full content from all documentation files.

# Authenticate - About auth - About Kinde authentication

> Learn about Kinde's authentication methods including password, passwordless, social sign-in, and enterprise connections.

authentication, sign up, sign in, password, passwordless, social login, enterprise, SSO
authenticate

Kinde makes authentication easy by providing a range of methods to choose from. Allow your users to sign up or sign in: - [by invitation only](/authenticate/custom-configurations/disable-sign-up/) - using self-sign-up (default) - [with a password](/authenticate/authentication-methods/password-authentication/) - [passwordless](/authenticate/authentication-methods/passwordless-authentication/) (Applied by default in all new Kinde businesses) - with a [phone number](/authenticate/authentication-methods/phone-authentication/) - with a range of [social sign in options](/authenticate/social-sign-in/add-social-sign-in/), like Google, Apple, Slack, and more - via [enterprise connections](/authenticate/enterprise-connections/about-enterprise-connections/) such as Cloudflare or SAML Authentication can be set per environment, and can be changed for different applications, e.g. your production web app and mobile app can have different authentication requirements. You can start simple with email self-sign-up, and then add more options as needed, such as social sign in and multi-factor authentication. ## Multi-domain authentication Kinde supports: - authenticated sessions across domains and subdomains - users switching between domains and subdomains Kinde supports multi-domain authentication where the primary domain is the same, but there are different subdomains. For example, `website.yourdomain.com`, `app.yourdomain.com`, `docs.yourdomain.com`. This is similar to how Google manages authentication for `calendar.google.com`, `mail.google.com`, etc. Once a user is signed in to one domain or subdomain, they can switch to another and remain authenticated. To do this, you need to initiate the flow with `prompt=none` as part of the auth URL. This checks for a session on Kinde invisibly. If it exists the user experiences a seamless session between sites, and if a session doesn’t exist, they are prompted to reauthenticate. See also, [Manage authentication across applications](/authenticate/manage-authentication/user-auth-applications/). ## Rate limiting and identity management issues if third party keys not entered When setting up third party authentication, such as [social sign in](/authenticate/social-sign-in/add-social-sign-in/), ensure you have added the third party app, and included the Client ID and Client Secret (Keys) to the configuration screens in your live environment. If you don’t use your own app's keys: - Kinde will fall back to using our own credentials as a proxy, which will cause rate limiting - For Apple SSO specifically, if you don't use your own app from the start, users will be permanently associated with the wrong app and cannot be transferred later Using the Kinde app is okay for local development environments, but not for live production environments. <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/d7bdcd1a-1800-4e8f-780f-ea7d56c37400/public" alt="" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" /> ## Get started with authentication Before setting up authentication, think about what your audience preferences are and how you want to manage access in the short and longer term. Enabling social sign in GitHub, for example, might be expected if your audience are software developers. Here’s a common set of tasks for getting started. 1. [Set up user authentication](/authenticate/authentication-methods/set-up-user-authentication/) 2. [Add social sign in](/authenticate/social-sign-in/add-social-sign-in/) 3. [Enable multi-factor authentication](/authenticate/multi-factor-auth/enable-multi-factor-authentication/)

# Authenticate - About auth - Ways to authenticate

> Detailed guide to all authentication methods supported by Kinde including email, phone, social, and enterprise authentication.

email authentication, password, passwordless, phone auth, SMS, social login, enterprise SSO, OTP
authenticate

Kinde supports the following authentication methods. For instructions on how to switch on each method for your apps, see [Set up user authentication](/authenticate/authentication-methods/set-up-user-authentication/). ## Email authentication ### Password You can set up authentication so users can authenticate via email using a [password](/authenticate/authentication-methods/password-authentication/). The password needs to be at least 8 characters and popular passwords are blocked. If allowing this method, you should encourage users to use a password manager to increase security. Users will be prompted to verify their email address when they first sign up, using a one time code. <Aside type="warning"> If you switch your users from passwordless to password, Kinde will first check if a password exists for the user when they next sign in. If a password doesn't exist, we verify the email address and ask user to set the password. The next time they sign in, they will use the email + password. Note that they enter their password on a different screen to their email. </Aside> ### Passwordless <Aside> Email + passwordless is switched on for all new Kinde businesses by default </Aside> For [passwordless](/authenticate/authentication-methods/passwordless-authentication/) authentication, set up authentication so users can authenticate via email or username using a one time code. When you activate this option, users will be sent a one-time password (OTP) to confirm their identity when they sign in. This option is more secure than using passwords, which need to be stored and protected by the user. Users will be prompted to verify their email address when they first sign up, also using an OTP. Kinde does not currently support magic links as a passwordless authentication method, as they are less secure than an OTP. ## Phone authentication <Aside> You need to have a [Twilio](https://www.twilio.com/en-us) account set up before implementing phone authentication in your production environment. See [Set up phone authentication](/authenticate/authentication-methods/phone-authentication/) for more information. </Aside> You can allow users to authenticate using their phone number as their sign in identity. This is a passwordless method. Once set up, users enter their phone number on the sign in screen and then enter a one-time passcode (sent via SMS) on the next screen. ### Passwordless via SMS For users to receive a sign in code via SMS, you need to set up a connection to [Twilio](https://www.twilio.com/en-us), who offer a messaging service for authenticating via SMS. You will need a Twilio account to set up this auth option in Kinde. See [Set up phone authentication](/authenticate/authentication-methods/phone-authentication/). Once set up, users will receive a one time code via SMS that enables them to complete the sign up process to your application or site. If you’re switching to Kinde from another auth provider, you can [import phone numbers with other user details](/manage-users/add-and-edit/import-users-in-bulk/) (such as email, first name, last name, etc.) to support authentication. ### OTP message format The SMS message that users receive through Kinde auth complies with OTP best practice. Here’s an example: <aside> 123456 is your one-time code to sign in to xxxx@login.xxx.au #123456 </aside> The content and format of the OTP SMS message is not editable. You’ll notice that the last part of the message includes a duplication of the OTP - `@bound_domain.xxx.dk #OTP_CODE` in the last line of the message. This keeps the OTP secured to the specified domain and allows browsers to reliably extract the OTP. The reason the OTP is included at the start of the message as well, is so that it can be read easily from a short notification popup. ## Social authentication You can let users sign up and sign in using social profiles. This requires some admin setup work and developer skills. **Returning users matched by email** Unlike some other authentication providers, Kinde automatically matches some accounts on sign up by matching verified email addresses. This means that if a user signs up with Google the first time, and they come back and sign up again with Slack, and the same email is detected (and the emails are verified), then the accounts get linked. See the [individual social sign in](/authenticate/social-sign-in/add-social-sign-in/) instructions. ## Enterprise authentication Kinde supports the use of [Microsoft Entra ID](/authenticate/enterprise-connections/azure/) and [SAML](/authenticate/enterprise-connections/custom-saml/) as an enterprise-level single sign on (SSO) authentication methods. These methods are more suited to big corporate and government organizations.

# Authenticate - About auth - User identity and verification

> Understanding how user identity and verification works in Kinde, including identity types, trusted providers, and verification processes.

user identity, verification, trusted providers, email verification, social identity, enterprise identity, profile sync
authenticate

A key part of making authentication secure, is through verification of user identities. Verification usually happens at sign up, to ensure the person signing up exists and is the intended person gaining access to your app or project. This topic is a conceptual overview of how identity works in Kinde. There are two parts to a user’s identity in Kinde: - Kinde profile - first name, last name, and picture - Identity details - information a user can sign in with: Email, phone, social, enterprise. This is explained in more detail below. ## Identity When we use the term ‘identity’, we’re referring to a unique identifier that allows a user to sign in and be verified. An email, phone number, SSO provider, etc. When a user tries to access a system or service, they provide their identity along with additional credentials (e.g. password, one-time password OTP) to verify their identity and gain access. ## Types of identities ### Identity credentials This refers to an email, phone number, or username. Identity credentials are created for a user when they first sign up with an email address, phone number, or username. If it’s the first identity to be added, it will be marked as primary. You can [manually add these user identities](/manage-users/add-and-edit/add-manage-user-identities/). ### Social A social identity is created when a user signs up with a social account or when they sign in with a trusted provider, who supplies a verified email that matches an existing email identity in Kinde. If a user signs up with a trusted social provider that provides us a verified email, and an email identity does not exist for the user, Kinde creates an email identity with this email. They can use this email to sign in with (if an email authentication method is enabled for your application). ### Enterprise An enterprise identity is created when a user signs up via an enterprise connection, or when they sign in via a trusted provider who supplies a verified email that matches an existing email identity. Users with enterprise identities in Kinde can't also have other identity types in Kinde. E.g. a user can have an email identity and a social identity. But if a user has an enterprise identity, they cannot have other identities. In this case, identity information is sourced with the identity provider and is managed via the identity provider, not in Kinde. ## Trusting emails from providers ### Trusted emails A trusted email provider is one that guarantees the email they issue is verified and also does not allow the user to change their primary email address. Currently Google is the only provider we treat as trusted by default. But you can choose to trust emails from any provider when you configure them in Kinde (See below). You can also choose not to trust Google emails if you want. **Google example** 1. When a user signs up, the Kinde profile first name, last name and picture are populated from Google. 2. If Google is a trusted provider, we create a social identity and an email identity. 3. The user can sign in with either Google or their email (if this auth method is allowed). ### Untrusted emails This isn’t to say that other email providers are not trustworthy, this purely relates to email addresses and the guarantee that it will not change. **LinkedIn example** 1. When a user signs up, the Kinde profile first name, last name and picture are populated from LinkedIn. 2. If LinkedIn is an untrusted email provider, we only create a social identity. 3. At this stage the user can only sign in with their LinkedIn account. ### Trust an untrusted provider When you set up an enterprise connection or a social connection, you can select the option to trust them. For example, go to **Settings > Authentication > Social connections** and select **Configure** on a tile. You’ll see the **Trust this connection** switch. Switch on or off as you like. ## Email sign up flow example 1. When a user signs up with email, the Kinde profile first name, last name are populated by the user (if you ask for it as part of the sign up flow). Their picture will be populated from Gravatar if it exists. 2. Kinde creates a primary contact email using the address they signed up with. They can only sign in with this email address. 3. If the same user returns and signs in with a trusted connection, e.g. Google, Kinde recognises that a user exists and the email address is from a trusted provider, so we add a Google identity to their profile. 4. The Kinde profile first name, last name and picture are updated by Google (if profile syncing is also turned on). 5. The user can sign in using either email or Google. ## Keeping identities in sync ### Social provider syncing If a social provider gives us a new first name, last name or picture for a user, Kinde updates these fields in the user profile to match those supplied to us. This is on by default, but you can turn it off if you wish to keep a static profile. [About profile sync](/manage-users/about/). If you have syncing off at an environment level but turned on at a social connection level we will honor the request for the social connection to sync. ### Enterprise connection syncing If an enterprise provider gives us a new first name, last name, or picture for a user, Kinde updates these fields in the user profile to match those supplied to us. This is on by default, but you can turn it off if you wish to keep a static profile. [About profile sync](/manage-users/about/). If you have syncing off at an environment level but turned on at an enterprise connection level we will honor the request for the enterprise connection to sync. ## Identity verification Verification is an authentication security measure that checks the person seeking system access is who they say they are. In addition, an up to date identity provides a secure method to contact a user. Email identity details are required, for example, to reset a user’s password (requested or forced), and are needed to reliably send OTPs and trigger other auth mechanisms, like auth apps. ## Username identities must have an email At Kinde, we don’t treat username identities the same as phone and email identities. If you want users to sign in and authenticate with usernames, they still need to verify themselves (if only once) via email. ## Cases in usernames Kinde treats usernames as case-insensitive. In other words, we ignore case. We do this because it eliminates the possibility of auth issues and fraud when two usernames are identical in every aspect except the case of one of their letters. We are happy to support users choosing an aesthetically pleasing username combination, like `RosyRose` or `BuilderBob`. We just don't also support separate identities for `rosYrosE` and `BUilderbob`. ## When an identity changes For security reasons, you can’t edit a user’s verified identity. But we know it still needs to be possible. People change emails, change names, get new phone numbers, etc. You can update identities by adding a new identity and deleting the old one. See [Add and manage user identities](/manage-users/add-and-edit/add-manage-user-identities/), or [via the Kinde API](/kinde-apis/management/).

# Authenticate - About auth - Top questions about Kinde authentication

> A collection of the top questions and answers about how to set up and configure Kinde authentication for your user's needs.

login, sign in, popup, error, sessions, tokens, auth
authentication, enterprise auth, SSO, social sign-in, authentication issues, user access control, user access, user authentication

Here’s some short answers to the most common authentication questions. Click on any question to expand the answer. <Aside title="Ask the docs"> Type **@kindeAI** to access 24/7 global support in the **#ask-kinde-ai** channel in the Kinde [Slack](https://join.slack.com/t/thekindecommunity/shared_invite/zt-1vyq8qilj-jFH5V27jfFnHk~BuBSU0ZA) or [Discord](https://discord.gg/KdkCXRNTFn) communities. </Aside> ## Authentication methods & core functionality <details> <summary><strong>How do I choose the right Kinde authentication method for my SaaS product's user base?</strong></summary> Think about who you're building for and what they're used to. If you're targeting developers, they'll probably expect GitHub or GitLab sign-in options. Building something for everyday consumers? Google and Apple sign-in will feel familiar and remove friction. Got enterprise customers? They'll likely need SAML or Microsoft Entra ID to keep their IT teams happy. You don't need to figure it all out upfront. Start simple with email authentication and add more options as you grow. Your web app and mobile app can even have different auth requirements if that makes sense for your users. [Learn more about authentication methods](/authenticate/about-auth/about-authentication/) </details> <details> <summary><strong>What's the difference between Kinde's password and passwordless authentication, and which should I implement?</strong></summary> With passwords, your users create and remember their own passwords (we enforce 8+ characters and block common ones). With passwordless, we send them a one-time code via email or SMS instead. Passwordless is genuinely more secure - no passwords to store, steal, or forget, and codes expire after 2 hours. Just know you can't mix both methods for the same app - it's one or the other. If you're building something mobile-first or want to reduce support tickets about forgotten passwords, passwordless is your friend. [Password authentication guide](/authenticate/authentication-methods/password-authentication/) | [Passwordless authentication guide](/authenticate/authentication-methods/passwordless-authentication/) </details> <details> <summary><strong>How does Kinde's automatic account linking work?</strong></summary> Kinde automatically connect accounts when someone uses the same verified email across different sign-in methods. So if someone first signs up with Google, then later tries to create an account with Slack using the same email, we'll link them together automatically. No duplicate accounts, no confusion. They can sign in with either method to access the same account. Once your users verify their email with any method, all their sign-in options with that email will work seamlessly together. [Learn about identity and verification](/authenticate/about-auth/identity-and-verification/) </details> <details> <summary><strong>Can I set different Kinde authentication requirements for different parts of my application?</strong></summary> Absolutely! This is one of those features that sounds complicated but actually makes total sense. Set up your baseline authentication methods at the environment level, then customize per application or organization as needed. Maybe your main web app uses social sign-in to keep things simple, while your mobile app needs phone authentication, or you want business customers to use MFA while keeping consumer sign-up super easy. It's all about matching the auth experience to what makes sense for each user group. [Configure authentication options](/authenticate/authentication-methods/set-up-user-authentication/) </details> <details> <summary><strong>How do I handle Kinde authentication across multiple domains and subdomains?</strong></summary> We've got this covered with multi-domain authentication. Think about how Google lets you stay signed in whether you're on Gmail, Calendar, or Drive - same idea. Users can hop between `website.yourapp.com`, `app.yourapp.com`, `docs.yourapp.com` and stay authenticated. The trick is using `prompt=none` in your auth URL, which invisibly checks for an existing session. If they're already signed in elsewhere, it's seamless. If not, they'll get prompted to sign in again. [About Kinde authentication](/authenticate/about-auth/about-authentication/) </details> <details> <summary><strong>What happens when my users can't receive their Kinde auth verification codes?</strong></summary> Tell them to check their spam folder first. This fixes it most of the time because email providers can be overly protective. For SMS codes, make sure they've got decent cell reception. If they're taking too long (codes expire after 2 hours), they'll need to request a fresh one. And if you're using SMS auth, double-check that your Twilio setup is working properly - that's usually where things go sideways. [Passwordless authentication troubleshooting](/authenticate/authentication-methods/passwordless-authentication/) </details> ## Social sign-in <details> <summary><strong>How do I set up Kinde social authentication without compromising security for my production app?</strong></summary> Before you go live, you absolutely must swap out Kinde's default social credentials with your own. We let you use ours for testing, but keeping them in production is asking for trouble - security risks, performance issues, and you'll be stuck if you ever want to switch providers. Create your own apps with Google, GitHub, Apple, whatever you're using, grab your Client ID and Client Secret, and put them into Kinde's social connection settings. Don't forget to add your custom domain callbacks if you're using those. [Add and manage social connections](/authenticate/social-sign-in/add-social-sign-in/) </details> <details> <summary><strong>Some social providers don't provide email addresses. How does Kinde maintain these user identities?</strong></summary> Some social providers (looking at you, X/Twitter and Apple) don't always hand over email addresses, but we need them for security things like password resets. When this happens, we'll ask your users for an email address just once during their first sign-up. After that one-time thing, they can sign in with their social account without any hassle. It's a small bump in the road that keeps everyone secure. [X social sign-in](/authenticate/social-sign-in/twitter/) | [Apple social sign-in](/authenticate/social-sign-in/apple/) </details> <details> <summary><strong>How can I use Kinde to create a seamless social authentication experience for my users?</strong></summary> If you're going all-in on social auth (no email/password fallbacks), you can create a pretty slick experience. Users click your sign-in button and boom - straight to Google's or Apple's account picker. Set up custom authentication pages and use the `connectionId` parameter to skip our initial screens entirely. The only catch? We'll still handle verification and MFA screens because, well, security matters and we're good at it. [Custom authentication pages](/authenticate/custom-configurations/custom-authentication-pages/) </details> <details> <summary><strong>Should I mark social connections as "trusted providers" in Kinde?</strong></summary> Generally, no - leave this off for better security. "Trusted provider" means we'll take their word that emails are verified, but here's the thing: people change email addresses, and social providers don't always keep up. Only flip this switch if you're 100% certain the provider maintains verified, current email addresses. When in doubt, err on the side of caution. [Social connections configuration](/authenticate/social-sign-in/add-social-sign-in/) </details> ## Enterprise authentication & SAML <details> <summary><strong>How do I set up Kinde SAML authentication for enterprise customers?</strong></summary> SAML setup is where things get a bit technical, but stick with us. Kinde acts as the service provider while your enterprise customer brings their own identity provider (Google Workspace, Microsoft Entra ID, Cloudflare, whatever they're using). You'll create an enterprise connection in Kinde, make up a unique Entity ID (just a random string like "870sa9fbasfasdas23aghkhc12zasfnasd"), and get their IdP metadata URL. They'll need to add your ACS URL to their setup. Pro tip: generate certificate and private key pairs for extra security, and always test in a sandbox environment first. [Custom SAML setup](/authenticate/enterprise-connections/custom-saml/) </details> <details> <summary><strong>What do I use home realm domains for in Kinde enterprise connections?</strong></summary> Home realm domains are basically a shortcut that makes enterprise sign-in smoother. When you set `bigcorp.com` as a home realm domain, anyone with a "@bigcorp.com" email gets automatically routed to their company's sign-in flow - no extra clicks needed. Just remember that each domain can only be used once across all your connections, so no sharing. And the SSO button disappears by default when you use this (though you can bring it back if needed). [Microsoft Entra ID setup](/authenticate/enterprise-connections/azure/) </details> <details> <summary><strong>What's the best way to migrate enterprise users to Kinde?</strong></summary> Get your enterprise connections set up in Kinde first - SAML, Entra ID, whatever they're using. Then when you import their user data (via CSV or JSON), we'll automatically match everyone to the right connection based on their email addresses. This means their sign-in experience stays exactly the same - they won't even notice you've switched to Kinde behind the scenes. Import their roles and permissions too if you've got them. [Migrate to Kinde](/get-started/switch-to-kinde/switch-to-kinde-for-user-authentication/) </details> <details> <summary><strong>How do I handle enterprise users who are already signed into their identity provider with Kinde?</strong></summary> When enterprise users sign out of your app, they're only signing out of Kinde, not their company's identity provider (like Entra ID). This is totally normal for federated auth - it's how most enterprise setups work. If your customer really needs full sign-out from both systems, you'll need to build additional logout flows, but honestly, most companies prefer it this way. [Entra ID SAML connection](/authenticate/enterprise-connections/entra-id-saml/) </details> ## Multi-factor authentication <details> <summary><strong>How do I use Kinde to implement MFA for different types of customers?</strong></summary> MFA is one of those things where one size definitely doesn't fit all. You can set it up for everyone (environment level) or get granular with specific customer segments (organization level). Finance and government customers? They'll probably want mandatory MFA. Consumer-facing app? Maybe make it optional so you don't scare people away. Kinde supports email codes, SMS codes, and authenticator apps as second factors. Just don't use the same method twice - as in don't make email the primary and secondary auth method. That could be confusing. [Enable multi-factor authentication](/authenticate/multi-factor-auth/enable-multi-factor-authentication/) </details> <details> <summary><strong>Can I exempt certain users or connections from MFA requirements in Kinde?</strong></summary> Yep, you've got options here. You can exempt specific roles (maybe only admins need MFA) or exempt enterprise connections where MFA is already handled by their company's identity provider. Nobody wants double MFA - that's just annoying. Set these exemptions at the organization level, and if someone has a mix of exempt and non-exempt roles, MFA kicks in by default (better safe than sorry). [Set MFA per organization](/authenticate/multi-factor-auth/mfa-per-org/) </details> <details> <summary><strong>How do I help users who are having trouble with MFA?</strong></summary> Make the instructions super clear for each method you support. For authenticator apps, walk them through the QR code scanning and emphasize saving those backup codes (they will lose them otherwise). For SMS, double-check they're entering phone numbers correctly with country codes. For email codes, check spam folder. Always give users a way to contact you when they get locked out - it happens to the best of us. You can also [reset MFA for a user](/manage-users/access-control/reset-multi-factor-authentication-for-a-user/). [Multi-factor authentication guide](/authenticate/multi-factor-auth/enable-multi-factor-authentication/) </details> ## Username authentication <details> <summary><strong>Do people still use username authentication? Does Kinde allow this?</strong></summary> Absolutely Kinde supports this. Username auth is perfect when you want to give users more personality in their sign-in experience or when your app has that community vibe (think gaming platforms or developer tools). They'll still need to verify their email once for security (we're not animals), but after that they can sign in with their chosen username. Works with both password and passwordless methods, so you've got flexibility there. [Username authentication guide](/authenticate/authentication-methods/username-authentication/) </details> <details> <summary><strong>How does Kinde handle username uniqueness and case sensitivity?</strong></summary> We treat usernames as case-insensitive because life's too short for "BuilderBob" vs "builderbob" authentication headaches. Users can still make their aesthetic choices like "RosyRose" or "DevDan" for display, but behind the scenes we're not picky about capitalization. This prevents fraud attempts and those frustrating "username not found" moments when someone forgets their exact capitalization. [Username authentication details](/authenticate/authentication-methods/username-authentication/) </details> <details> <summary><strong>What happens if a user changes their password when using both email and username authentication in Kinde?</strong></summary> Both methods share the same password! If someone can sign in with both their email and username, changing the password for one affects both. It keeps things simple for users (one password to remember) and prevents the confusion of having different passwords for the same account. We think this makes way more sense than forcing people to juggle multiple credentials. [Username authentication configuration](/authenticate/authentication-methods/username-authentication/) </details> ## Device Authorization Flow <details> <summary><strong>When should I use Kinde's device authorization flow instead of regular authentication?</strong></summary> Device authorization flow is perfect for situations where typing is a nightmare - think smart TVs, gaming consoles, IoT devices, or anything without a proper keyboard. Instead of watching users struggle with TV remote controls to spell out "MyComplexPassword123!", the device shows them a simple code to enter on their phone or laptop where typing doesn't suck. It's basically Netflix's approach: the TV shows a code, you enter it on your phone, boom - you're authenticated. Much better user experience, and way more secure. [Device Authorization Flow](/authenticate/device-authorization-flow/overview/). </details> <details> <summary><strong>How does Kinde's device authorization flow work, and what should I tell my users?</strong></summary> Here's the flow: your device (let's say a smart TV app) requests a device code from Kinde, then shows users a simple code and a URL like "Go to `yourapp.com/device` and enter code: ABC123". Users grab their phone, visit that URL, sign in normally (with all their usual auth methods available), enter the code, and authorize the device. Meanwhile, your TV app is polling our servers asking "Are they done yet? Are they done yet?" until we give it the green light with tokens. The whole thing happens in parallel - no hanging around waiting. [Device Authorization Flow](/authenticate/device-authorization-flow/overview/) </details> <details> <summary><strong>What are the security benefits of Kinde's device authorization flow?</strong></summary> It keeps credentials off devices you don't control, which is huge for security. Users never enter their actual passwords on the TV, CLI, or IoT device - they authenticate on their trusted phone or laptop instead. Plus, they get access to all their usual security features like MFA, social sign-in, and password managers. The codes expire quickly, we rate-limit the polling to prevent abuse, and users always see a proper consent screen before authorizing access. It's basically taking the most secure part of OAuth (browser-based auth) and making it work for devices that can't do browsers. [About authentication methods](/authenticate/about-auth/authentication-methods/) </details> <details> <summary><strong>How do I handle Kinde device authorization flow errors and edge cases?</strong></summary> The main errors you'll see are `authorization_pending` (user hasn't finished yet - keep polling), `slow_down` (you're polling too aggressively - back off), and `expired_token` (codes expired - start over). Handle these gracefully in your app rather than crashing. Users might also get confused about which device they're supposed to use for what, so make your instructions crystal clear. And remember, some users will start the process but never finish it - that's normal, just clean up expired sessions. [OAuth token validation and errors](/build/tokens/token-validation-errors/) </details> <details> <summary><strong>What's the best UX for presenting Kinde device codes to users?</strong></summary> Keep it simple and obvious. Show the code clearly (big, readable font), include the full URL they need to visit, and consider showing both a QR code and the manual entry option. Don't overwhelm them with too much text - just "Go to `yourapp.com/device` on your phone and enter: ABC123" works perfectly. If you can, show some kind of progress indicator so they know the app is waiting for them to complete the process. And please, test this with actual humans - what seems obvious to developers often isn't to regular users. </details> ## Custom configurations & user experience <details> <summary><strong>What do I need to set up Kinde phone authentication for my users?</strong></summary> You'll need a paid Twilio business account - this isn't something we can handle for free because SMS costs money. Before you dive in, check if you need 10DLC registration (10 Digit Long Code) for your region - it's required in some places for business messaging. Read up on Twilio's A2P (Application to Person) messaging guidelines too. Once you've got that sorted, plug your Twilio details into Kinde, pick between using their messaging service (better for global apps) or a specific phone number, and set your default country. [Set up phone authentication](/authenticate/authentication-methods/phone-authentication/) </details> <details> <summary><strong>Can I customize the SMS message that Kinde users receive?</strong></summary> Nope, and here's why - we use a standard format that meets security best practices and works across different languages. The message looks like: "123456 is your one-time code to sign in to [xxxx@login.xxx.au](mailto:xxxx@login.xxx.au) #123456". That weird duplication at the end? It's for security. We know it might not match your brand perfectly, but it keeps everyone safe and compliant. [Phone authentication details](/authenticate/authentication-methods/phone-authentication/) </details> <details> <summary><strong>How can I create a more seamless Kinde sign-up experience for invited users?</strong></summary> Use the `login_hint` parameter to pre-fill email fields when you know who's trying to sign in - it's like having their name already on the guest list. You can also create a unified experience where users don't have to choose between "sign up" or "sign in" (because honestly, who remembers if they've been here before?). Skip asking for first and last names if you want to keep things really minimal. Every little bit of friction you remove makes a difference. [Pre-populate user identity](/authenticate/custom-configurations/prepopulate-identity-sign-in/) | [Manage authentication experience](/authenticate/custom-configurations/authentication-experience/) </details> <details> <summary><strong>What's the best way to handle profile pictures and user data with Kinde?</strong></summary> We automatically grab profile pictures from email providers like Google and use Gravatar as backup when pictures are missing. If you'd rather handle profile pics your own way or just hate blank avatars, you can switch off the Gravatar fallback. Fair warning: Apple is pretty stingy with user data - they don't pass through avatars or much profile info, so don't expect much there. [Authentication experience customization](/authenticate/custom-configurations/authentication-experience/) </details> <details> <summary><strong>How can I pass additional parameters to identity providers through Kinde?</strong></summary> Upstream parameters let you send extra data during authentication - either the same value every time (static) or something unique per user (dynamic). Common use case: passing `login_hint` to pre-fill sign-in forms or enabling those handy account switchers you see on Google. Each provider supports different parameters (check their docs), and you can even rename parameters using aliases if your IdP is picky about naming. [Pass parameters to identity providers](/authenticate/auth-guides/pass-params-idp/) </details> ## Developer questions <details> <summary><strong>Why does Kinde authentication state get lost when users refresh the page in single-page apps?</strong></summary> We store tokens in memory for security - it protects against both CSRF and XSS attacks, which is definitely worth the trade-off. But yeah, it means page refreshes wipe the tokens. The best fix? Use our Custom Domains feature, which lets us set secure httpOnly cookies on your domain. For local development, there's an escape hatch called `is_dangerously_use_local_storage`, but seriously, don't use that in production - the name isn't kidding about the danger part. [JavaScript SDK guide](m/developer-tools/sdks/frontend/javascript-sdk/) | [React SDK guide](/developer-tools/sdks/frontend/react-sdk/) </details> <details> <summary><strong>How do I implement Kinde authentication in a React application without losing user state?</strong></summary> Wrap your app in the KindeProvider - it's your new best friend for managing auth state. Use hooks like `useKindeAuth()` to check if someone's signed in, and always check the `isLoading` state before making decisions (nobody likes flickering UI). For production, definitely set up custom domains so you can use secure cookies. Handle your post-auth redirects properly, and your users will never know how complex this stuff really is under the hood. [React SDK implementation](/developer-tools/sdks/frontend/react-sdk/) </details> <details> <summary><strong>What's the best approach for handling Kinde authentication callbacks in different frameworks?</strong></summary> Each framework has its own quirks. Next.js App Router wants `app/api/auth/[kindeAuth]/route.js`, Pages Router prefers `pages/api/auth/[...kindeAuth].js`, and vanilla JavaScript means you're handling the OAuth dance yourself. Always make sure your callback URLs match what you've configured in Kinde (case-sensitive, protocol-specific). Use our SDK callback handlers instead of rolling your own - we've already dealt with all the edge cases. [Next.js App Router SDK](/developer-tools/sdks/backend/nextjs-sdk/) | [Using Kinde without SDK](/developer-tools/about/using-kinde-without-an-sdk/) </details> <details> <summary><strong>How can I protect API endpoints and validate Kinde tokens properly?</strong></summary> Use our backend SDKs or validate JWT tokens manually - either works, but the SDKs handle the fiddly bits for you. The `getToken()` method gives you bearer tokens for API calls. On your backend, always check the token's audience claim matches your API and verify it hasn't expired. And please, never put client secrets in frontend code - that's like leaving your house key under the doormat. [TypeScript SDK guide](/developer-tools/sdks/backend/typescript-sdk/) </details> ## Troubleshooting & common issues <details> <summary><strong>How do I use Kinde to help my users who forgot their passwords?</strong></summary> Users can hit "forgot password" on the sign-in screen and we'll send them a one-time code via email to reset it. As an admin, you can also trigger password resets through the Kinde dashboard or API (as long as they have a verified email). There's also the option to set a temporary password for them, but you'll need to send it through your own channels - we won't email passwords directly because that's not secure. [Password reset procedures](/authenticate/authentication-methods/password-authentication/) </details> <details> <summary><strong>How should I help users who aren't receiving Kinde SMS auth codes?</strong></summary> Start with the basics - did they enter their phone number correctly with the right country code? Do they have cell reception? Are they in a country where SMS might be restricted? Then check your end - is your Twilio account funded and configured properly? SMS delivery can be finicky, especially internationally, so having backup contact methods is always smart. [Phone authentication setup](/authenticate/authentication-methods/phone-authentication/) </details> <details> <summary><strong>How should I help users who aren't receiving Kinde auth codes via email?</strong></summary> Start with the basics - could the email have been caught in their spam or been caught by their organization's firewall and have been added to a supression list? Have them check this first. If you have [custom SMTP email delivery](/integrate/third-party-tools/kinde-resend-custom-smtp/) set up, you should be able to check logs from the delivery provider. If you rely on Kinde to deliver emails, check the same basic things with the recipient and ask them to try again. If you need to, contact the Kinde support team to check our logs to see if there was an email disruption. [Phone authentication setup](/authenticate/authentication-methods/phone-authentication/) </details> <details> <summary><strong>If I want to change which providers can be used for auth in Kinde, how do I support my customers?</strong></summary> If users were relying on a social or enterprise connection that got removed or changed, they're stuck until you fix it. Before deleting any connection, make sure nobody's using it for auth. If you need to switch providers, set up the new one first, then help users transition by linking their accounts or setting up alternative auth methods. Always have a backup plan. [Manage social connections](/authenticate/social-sign-in/add-social-sign-in/) </details> <details> <summary><strong>Why are my Kinde authentication redirects failing?</strong></summary> Nine times out of ten, it's a URL mismatch. Your callback URLs in Kinde need to match exactly what's in your app code and any social provider configs - we're talking case-sensitive, protocol-specific matching here. If you're using custom domains, double-check that your DNS records are set up correctly and SSL certificates are active. Also remember that custom domain tokens and Kinde subdomain tokens don't play nice together - pick one and stick with it. [Custom domain setup](/build/domains/pointing-your-domain/) </details> <details> <summary><strong>How do I debug Kinde OAuth 2.0 authentication errors?</strong></summary> The error names are pretty self-explanatory once you know what to look for. `invalid_client` usually means wrong client ID or secret, `invalid_grant` means your authorization code expired (they only last a short time), and `invalid_scope` means you're asking for something we don't support. Check your credentials first, make sure you're exchanging codes quickly, and verify your requested scopes are valid. Give users helpful error messages instead of raw OAuth codes - nobody wants to see "invalid_grant" when they're just trying to sign in. [OAuth 2.0 validation and errors](/build/tokens/token-validation-errors/) </details> <details> <summary><strong>What should I check in Kinde when users report authentication isn't working on mobile?</strong></summary> Mobile auth has its own special challenges. For React Native, make sure your deep linking is configured properly with the right URL schemes for both iOS and Android. Check that your redirect URLs use the correct custom scheme format like `myapp://your_kinde_domain.kinde.com/kinde_callback`. And here's a fun fact: Google doesn't support auth in webview, so make sure you're using proper browser-based flows. If your users are not receiving verification codes and you have Twilio set up, you can check the Twilio logs to help you troubleshoot. [React Native SDK](/developer-tools/sdks/native/react-native-sdk/) and [Set up phone auth with Twilio](/authenticate/authentication-methods/phone-authentication/) </details> <details> <summary><strong>How do I handle Kinde authentication state persistence across different environments?</strong></summary> For production, custom domains are your friend - they enable secure cookie storage that survives page refreshes. For local development, you can use the local storage escape hatch (just remember to remove it before going live). On your backend, implement proper session management using encrypted cookies or shared cache systems if you're running multiple servers. The right approach depends on your architecture, but security should always come first. [TypeScript SDK session management](/developer-tools/sdks/backend/typescript-sdk/) </details> ## Best practices & security <details> <summary><strong>What security considerations should I communicate to my customers about Kinde authentication choices?</strong></summary> Be honest about the security trade-offs without scaring people away. Passwordless is genuinely more secure than passwords, MFA adds real protection (not just security theater), and social sign-in can be both convenient and secure when done right. If you're offering password auth, nudge users toward password managers - most people's password habits are... not great. And here's something most auth providers won't tell you: we store passwords as encrypted hashes that literally cannot be deciphered, so even we can't see what users set. [Password authentication security](/authenticate/authentication-methods/password-authentication/) </details> <details> <summary><strong>How do I ensure my Kinde authentication setup scales with business growth?</strong></summary> Start simple and add complexity as you need it - don't over-engineer from day one. Begin with email auth, then layer in social sign-in, MFA, and enterprise connections as your customer base grows. Use organizations to handle multi-tenant setups where each customer needs their own user management. Set up your foundation at the environment level, then customize per organization when customers have specific needs. And seriously, implement custom domains early if you can - it makes everything smoother later. [Kinde for different business models](/build/set-up-options/kinde-business-model/) </details> <details> <summary><strong>What's the recommended approach for handling user migration from other auth providers to Kinde?</strong></summary> Set up your auth methods in Kinde first, then export and import user data via CSV or JSON. If you import passwords too, your users won't notice anything changed - which is exactly what you want. If you're switching auth methods (like going passwordless), give users a heads up about what's changing. Test everything in a sandbox environment first, and keep an eye out for edge cases like users who change their passwords during the migration window. [Switch to Kinde migration guide](/get-started/switch-to-kinde/switch-to-kinde-for-user-authentication/) </details> ## Advanced integration <details> <summary><strong>How do I implement Kinde custom authentication pages while maintaining security?</strong></summary> You can build your own sign-up and sign-in pages to match your brand perfectly, but we'll still handle the security-critical stuff like verification and MFA. Use connection IDs and login hints in your auth URLs to route users directly to specific authentication methods. Think of it as having your cake and eating it too - custom experience with bulletproof security. Just remember that some screens (password entry, code verification) stay with us because that's where the security magic happens. [Custom authentication pages](/authenticate/custom-configurations/custom-authentication-pages/) </details> <details> <summary><strong>What's the best way to handle cross-subdomain authentication in Kinde, for complex applications?</strong></summary> Custom domains and proper cookie configuration are your best friends here. Set cookies to the root domain instead of subdomains so they're accessible across your entire ecosystem. For PHP apps, we've got helper functions to make this easy. Test everything thoroughly across all your subdomains - nothing's more embarrassing than users getting stuck switching between `app.yoursite.com` and `dashboard.yoursite.com`. [PHP SDK domain configuration](/developer-tools/sdks/backend/php-sdk/) </details> <details> <summary><strong>How should I configure Kinde authentication for different business models (B2C vs B2B)?</strong></summary> B2C is straightforward - configure everything at the business level with easy social sign-in and email auth. B2B gets more interesting because you're serving multiple companies, each with their own needs. Use organizations to create separate tenant management, set up enterprise connections for business customers who need SAML or Entra ID, and keep simpler social auth for any consumer-facing parts of your platform. It's all about matching Kinde auth options to what your customer actually needs. [Business model configuration](/build/set-up-options/kinde-business-model/) </details>

# Authenticate - About auth - User communication in Kinde

> Learn about how Kinde communicates with users through emails and SMS for authentication purposes.

user communication, email, SMS, OTP, verification, Twilio, webhooks
authenticate

Kinde only sends emails or texts to users as part of the authentication experience, for example to send one-time passwords or to verify user identity for self-sign-up. We’ve kept communication features to a bare minimum for authentication, so that we do not send unwanted or unsolicited communication to users, on behalf of your business. ## Emails sent from Kinde The following emails are sent from no-reply@kinde.com. - Invitations to join your business on Kinde when you manually add a new team member - Export data warning emails to ensure only authorized people can get user data out of your business. - (Unless you enter custom email sender details) verification and authentication emails for sign-up, sign-in, multi-factor authentication, and password reset. To configure authentication emails to come from your own email provider, see [Customize email sender](/get-started/connect/customize-email-sender/). ## Kinde does not send emails in these situations - Invitations to users if you add them via API - Invitations to users if you add them in bulk via import - Emails to team members about your Kinde subscription or admin activity If you want certain user events in Kinde to trigger an email, you can set this up with [webhooks](/integrate/webhooks/add-manage-webhooks/). ## Communication when users are added in bulk Our features for adding users in bulk (such as via API or import) are designed with a smooth migration experience in mind. Rather than send confusing emails to existing user bases, we enable a silent transfer of the authentication experience, between your previous supplier and Kinde. That’s why we don’t send emails when users are added to Kinde this way. <Aside> Use [webhooks](/integrate/webhooks/add-manage-webhooks/) to prompt actions triggered by Kinde events </Aside> ## SMS communication for phone authentication Kinde supports [phone authentication](/authenticate/authentication-methods/phone-authentication/) as a primary and secondary authentication factor. To use phone authentication, you need to have a [Twilio](https://www.twilio.com/en-us) account and configure the account details in Kinde. Twilio is a third-party provider who offer bulk messaging services. When a user authenticates via phone number, an SMS containing a one-time passcode is sent. The SMS is in a specific format that cannot be edited. ```text 123456 is your one-time code to sign in to [kinde business URL] #123456 ``` Kinde does not communicate anything else to users via SMS.

# Authenticate - Auth guides - Guide to enterprise auth and user identities

> Understanding why Kinde enforces one enterprise identity per user for security, account integrity, and simplified tenant management.

enterprise identity, SSO, identity provider, IdP, security, account integrity, tenant management
authenticate

At Kinde, each user can only have one enterprise identity provider (IdP) connection as part of their user profile. This is because we want to keep things simple, secure, and reliable. We get asked about this regularly, so this document explains our reasoning from a security and architectural perspective. ## What is an enterprise connection? An enterprise connection allows users to sign in to your product using their organization’s identity provider — such as Okta, Azure AD, or Google Workspace. This enables Single Sign-On (SSO), centralized user management, and improved security for enterprise customers. ## Why only one identity per user? Many customer identity platforms, including Kinde, enforce a one-to-one relationship between a user and an enterprise connection. Here’s why: ### 1. Prevents identity conflicts If a user could sign in through multiple enterprise providers, it becomes difficult to determine whether those identities belong to the same person. This can result in: - Duplicate accounts for the same user - Conflicting user attributes (email, name, roles, etc.) - Confusion around permissions and organization membership Restricting to a single enterprise connection ensures a consistent and predictable identity model. ### 2. Security and account Integrity Allowing multiple enterprise connections introduces significant security risks: - **Risk of account hijacking:** If a user can link multiple IdPs, and identity claims like email or subject ID (`sub`) overlap or are not verified consistently, it becomes possible for unauthorized users to gain access to another user’s account. - **Inconsistent identity claims:** Different IdPs use different formats and identifiers. One provider may use an email address, another a unique internal ID. Reconciling these automatically increases the risk of incorrect mappings and privilege escalation. - **Reduced auditability:** Security audits and access logs rely on a single, traceable identity. If a user can authenticate through multiple IdPs, it becomes harder to guarantee that all actions are traceable to a single, verified identity. - **Clear accountability:** With one connection per user, the responsibility for identity management, password resets, session revocation, and breach response remains clearly with the source identity provider. ### 3. Simplified tenant and access management In multi-tenant applications, each enterprise typically has its own workspace or organization. Supporting one IdP per user: - Keeps tenant boundaries clean - Prevents role or permission leakage between organizations - Simplifies access control logic ## What if someone needs access to multiple organizations? We support users belonging to multiple organizations within Kinde. In edge cases (such as contractors working across companies) we recommend adding [enterprise connections at the organization level](/authenticate/enterprise-connections/enterprise-connections-b2b/). This means the user signs in directly to the relevant organization, with no confusion about where to be routed. This feature is only available on the Kinde Scale plan. If you are not on the relevant plan, other ways to handle this include: - Use separate emails for each organization - Use different auth methods per organization ## Built for security, designed for clarity This choice to allow only one enterprise identity per user aligns with industry best practices and helps keep your users, data, and systems secure. By enforcing this, Kinde provides a stable and trusted identity layer you can build on with confidence. If you have any questions about more advanced SSO or identity configurations, [contact our team](https://kinde.com/contact). We’re happy to help.

# Authenticate - Auth guides - Mixed auth set up for B2B and B2C

> Complete guide to setting up unified authentication for mixed B2B and B2C businesses using Kinde Scale plan features.

B2B, B2C, mixed authentication, enterprise connections, SAML, organizations, home realm discovery
authenticate

If you have an app or site that supports a mix of business customers and direct customers, this guide shows you how to set up authentication in Kinde to meet both these needs. For example, say you run a finance business and you have separate sign-ins for accounting business partners and direct customers. Accounting businesses sign in with an enterprise identity, e.g. SAML and direct customers sign in with email and an OTP. This topic explains how to create a simple, unified experience for both groups. ## You’ll need the Kinde Scale plan To set up authentication for a mixed B2B and B2C business that includes multiple enterprise connections, you need to be on the [Kinde Scale plan](https://kinde.com/pricing/). This is the only Kinde plan that gives you access to the features you need: - Multiple enterprise connections (e.g. SAML) - Advanced organizations - for managing users and access for business customers You get 5 enterprise connections and 5 advanced organizations included with Kinde Scale. You can add more, but costs apply. ## How to build a unified sign-in experience A unified experience is where everyone signs in through the same sign in screen, and they are routed to the relevant workflow for authentication. ![unified sign in](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/a14aa42c-3c66-45de-dc80-ee7c9df41b00/public) This simplifies the sign in experience for all your users, including your enterprise connections. ### Example of a unified authentication experience This is what happens behind the scenes with the auth setup. ![image.png](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/ff106642-c42f-44cf-4a89-84406a717000/public) ### Step 1: Set up auth for your B2C users In this scenario, your direct customers will sign in with email and a one-time-passcode (OTP). To set this up: 1. [Enable email + code authentication in your business.](/authenticate/authentication-methods/passwordless-authentication/) 2. [Set email + code as the sign in method in your default organization.](/authenticate/manage-authentication/organization-auth-experience/) 3. (Optional) [Set an organization policy to allow users to sign up to the default org using an email address](/build/organizations/allow-user-signup-org/). ### Step 2: Set up auth for your B2B users Authentication for business customers can be more complex, with additional security considerations and set up time involved. For example, a partner business may require employees to only access your web app using their business email and for authentication to be centralised with their own identity provider via SAML. Let’s go through the process for setting up 5 SAML enterprise connections for 5 different business customers. 1. [Add 5 separate enterprise connections to Kinde](/authenticate/enterprise-connections/about-enterprise-connections/). E.g. EC1, EC2, EC3, and so on. 1. Configure each connection with the domain information, including email domains in the [home realm discovery](/authenticate/enterprise-connections/about-enterprise-connections/#home-realm-discovery) field. You may need to ask the customer’s IT team for this information. 2. (Recommended) Switch on the **Create user on sign up** option to [enable JIT provisioning](/authenticate/enterprise-connections/provision-users-enterprise/). 2. [Create 5 organizations](/build/organizations/add-and-manage-organizations/), one for each business customer (and connection), and select only [the relevant enterprise connection for each organization](/authenticate/manage-authentication/organization-auth-experience/). For example: | For this org… | Switch on this auth connection… | | -------------- | ------------------------------- | | Organization 1 | EC1 (domain x home realm) | | Organization 2 | EC2 (domain y home realm) | | Organization 3 | EC3 (domain a home realm) | | Organization 4 | EC4 (domain b home realm) | | Organization 5 | EC5 (domain c home realm) | 3. In each organization: 1. Go to **Policies** and add the relevant domain to the **Allowed domains** field. 2. Select **Auto-add users from allowed domains**. This activates JIT provisioning for users signing up from this domain. 3. Select **Save**. With home realm discovery and allowed domains set, when a user enters an email that matches the domain name they will be routed through that enterprise connection. There is no need for them to self-select which connection they belong to. ### Step 3: Enable authentication for your application To achieve the above scenario, all the supported sign-in methods need to be switched on in your application. For example, switch on Email + code, EC1, EC2, EC3, EC4, and EC5. ![Auth options to switch on in Kinde](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/cf3a393d-b977-4de3-2bd1-dae72ec93f00/public) ## Optimize your auth flow This unified model of authentication can be extended to 10’s or 100’s of organizations, all while maintaining the same sign in screen. Other situations you can cater for include: - [Adding MFA for an organization's users](/authenticate/multi-factor-auth/mfa-per-org/) - Adding other [enterprise connections](/authenticate/enterprise-connections/about-enterprise-connections/) (e.g. [Google Workspace](/authenticate/enterprise-connections/custom-saml-google-workspace/) or [Microsoft Entra ID](/authenticate/enterprise-connections/azure/)) - [Auto-assigning user roles](/manage-users/roles-and-permissions/default-user-roles/)

# Authenticate - Auth guides - Pass parameters to identity providers

> Learn how to pass static and dynamic parameters to identity providers during authentication for improved user experience.

upstream params, identity provider, OAuth 2.0, SAML, login_hint, prompt, account switcher
authenticate

You can pass provider-specific parameters to an Identity Provider (IdP) during authentication. These are also known as 'upstream params'. The values your pass can either be static per connection or dynamic per user. There's a number of reason why you might want to use upstream params: - to create a smoother sign in experience - by passing the email through - to offer an account switcher (such as the Google account switcher) during sign in Upstream params are available for OAuth 2.0 connections, e.g. [social connections](/authenticate/social-sign-in/add-social-sign-in/), [Entra ID OAuth 2.0 enterprise connection](/authenticate/enterprise-connections/azure/), and as part of [advanced configurations](/authenticate/enterprise-connections/advanced-saml-configurations/) in SAML connections. ## Limitations Every identity provider has their own set of supported parameters and values, so you'll need to check their documentation to determine which URL parameters are supported. ## Static parameters Static parameters can be useful when you have specific values you always want to pass on to the IDP. These are set in the connecction configuration screen. ![Screen shot of google connection screen and upstream params field](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/3fa86bd8-9005-4022-7118-fc93ce4f4a00/public) The Upstream parameter field accepts JSON and the structure is as follows: ```json { "<param_name_to_pass>": { "value": "<your_hardcoded_value>" } } ``` Replace `<param_name_to_pass>` with the name of the parameter you wish to pass upstream to the IDP. Replace `<your_hardcoded_value>` with the value of the parameter you wish to pass upstream. ### Example: Force the google account selector to display on sign in If you want Google to always show the account selector even if the user is already logged in with a Google account, pass the `prompt=select_account` parameter from Kinde. This is how that would look: ```json { "prompt": { "value": "select_account" } } ``` Now, when your user clicks on the Google button and Kinde creates the URL to redirect to Google, it will append`&prompt=select_account`. ## Dynamic parameters Dynamic parameters cover the case where you don't know the value of the parameter ahead of time, and it needs to be populated on the fly during the auth flow. For example, if you need to pass on a parameter that was provided to Kinde in the auth URL. This is the structure. ```json { "<param_name_to_pass>": { "alias": "<dynamic_param_name>" } } ``` The `alias` keyword tells Kinde which parameter from your auth url to use, and the value to pass upstream to the IDP. Here is an example where we provide `login_hint` as part of the auth URL, where the email [`&login_hint=hello@example.com`](mailto:&login_hint=hello@example.com) is included on the URL. ```html https://<your_kinde_subdomain >.kinde.com/oauth2/auth ?response_type=code &client_id=<your_kinde_client_id> &redirect_uri=<your_app_redirect_url> &scope=openid%20profile%20email &state=abc &login_hint=hello@example.com</your_app_redirect_url ></your_kinde_client_id ></your_kinde_subdomain > ``` In this case both Kinde and the IDP use the parameter name `login_hint` so the configuration is the same on both sides: Add this to the connection configuration: } } ```` In this case we are saying pass the `login_hint` parameter upstream to the IDP with the value Kinde received in the `login_hint` auth url param. So `&login_hint=hello@example.com` would be passed on to the provider. Where the `alias` becomes especially powerful is when you want to re-map a parameter name to match the one an IDP expects. For example, let’s say that our IDP expects `username` instead of `login_hint` for the same value, in this case our JSON would look like this: ```json { "username": { "alias": "login_hint" } } ```` In this case we are saying pass the `username` parameter upstream to the IDP with the value Kinde received in the `login_hint` auth url param. We remap the email value from `login_hint` to `username` and the parameter `&username=hello@example.com` would be passed on to the IDP. ## Kinde-provided aliases When an email address is populated during the auth flow, we make this available via the `login_hint` alias. You might use this if you are using Home realm discovery with an Entra ID OAuth2.0 connection, and you want to pass the URL that the user entered on Kinde as the `login_hint`, upstream to Entra, to prevent the user having to enter their email twice. If the user enters `hello@example.com` in the Kinde email field with the following configuration active, we set the `login_hint` parameter to `hello@example.com` via the Kinde provided alias. ```json { "login_hint": { "alias": "login_hint" } } ``` ## Multiple parameters You can send multple parameters this way and mix-and-match between dynamic and static in the same configuration. For example if the user entered `hello@example.com` and the following was configured: ```json { "prompt": { "value": "login" }, "username": { "alias": "login_hint" } } ``` This would result in `&prompt=login&username=hello@example.com` ## Supported aliases The values which can be used as an `alias` are: - `prompt` - `login_hint` If you need other aliases added, let us know via a [feedback form](https://updates.kinde.com/).

# Authenticate - Authentication methods - About email authentication

> Comprehensive overview of email authentication methods including verification, account linking, and customization options.

email authentication, email verification, account linking, Gravatar, login_hint, profile pictures
authenticate

The most common application signup and sign in method for users is email. Kinde supports a number of approaches to email authentication. You can set up email authentication so that: - users sign up with their preferred email, but don’t need a password - users sign up with their preferred email and set their own password - only [users you invite](/authenticate/custom-configurations/disable-sign-up/) can sign up and sign in using email ## Verification code email from Kinde to your users To verify a user, Kinde sends a verification code to the email they sign up with. If you’ve also enabled passwordless authentication, this is also where the one time code is sent each time they sign in. The verification email has limited customizations. - You can add your own logo - You can change the sender name, but you cannot change the sender email address - You cannot edit the email content - Email content references your [business] name in Kinde. For example: <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/c38710e9-889e-440e-5b6d-3421bb377900/public" alt="" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" /> ## All email sign-ups must verify their email address If your authentication method requires users to sign up with an email, they will be prompted to verify their email address using a one time code. Even if they subsequently sign on using their own password, the user must verify their email the first time by entering a one time code. If a user signs up via a social provider that does not require an email (such as Twitter or Apple), or via another OAuth2 protocol that does not pass the email to us, they will be prompted to enter an email address so their account can be verified. <Aside> The exception for the above is if you import users and the `email_verified` parameter is `true`. </Aside> ## Kinde automatically links accounts with verified emails Unlike some other authentication providers, Kinde automatically matches accounts on sign up by matching verified email addresses. This means that if a user signs up with Google the first time, and they come back and sign up again with Slack, and the same email is detected (and we know they are both verified), then the accounts get linked. This reduces duplication and creates a better experience for users. ## Pre-populate the email field on sign in If you only allow users that you invite to sign up or sign in to your app, you can pre-populate the email field in the sign in window. This can only be achieved by including the `login_hint` parameter as part of the `login` method. It cannot be set in the Kinde UI. When your project knows which user it is trying to authenticate, it can provide their email in this parameter as a hint to Kinde. Passing this hint pre-fills the email box on the sign-up and sign-in screens. ## How profile pictures are passed to Kinde Typically, Kinde receives user profile pictures via the email provider, e.g. Google. If no picture is attached to a profile, Kinde sets the picture to use a Gravatar URL instead. See also [Switch off Gravatar fallback](/authenticate/custom-configurations/authentication-experience/#switch-off-gravatar-fallback-for-profile-pictures).

# Authenticate - Authentication methods - Email deliverability in Kinde

> Guide to email deliverability best practices including custom email senders, authentication records, and troubleshooting delivery issues.

email deliverability, SMTP, SPF, DMARC, DKIM, email authentication, spam prevention
authenticate

Kinde encourages users to configure their own email sender, so that verification and other emails are sent form your own business, and not Kinde. When emails are sent via Kinde, we support the email routing, and are proactive about monitoring verification email deliverability and speed. This topic describes email delivery via Kinde, deliverability factors, and some common reasons why delivery can fail. ## Manage your own email sender By default, when you first start using Kinde, all emails are sent from @kinde.com. But you can set up your environments to use your own email, so users receive authentication emails from @yourbusiness.com. You’ll want to configure this before your production environment goes live. All you need is to add SMTP details in Kinde settings. See [Customize email sender](/get-started/connect/customize-email-sender/). ## Emails sent from Kinde Even if you enter custom sender details, these emails will still be sent from Kinde: - Invitation to join business team - triggered by manual or API addition of team member - Warnings and notifications of data export ## Deliverability factors Email delivery is dependent on a number of factors. ### IP address reputation and blocklists Email providers check against a pool of IP addresses and domain blocklists to help protect against bad actors. They constantly monitor to make sure IP addresses are not on any of these lists. If you experience issues, check that your domain doesn't exist on any of these lists. ### Domain name reputation Every domain name (i.e. `example.com`, `kinde.com`, etc.) has its own reputation score. Newer domains do not have a high score, and this may impact deliverability. ### Setup a real email address Email providers will check if there's an actual mailbox behind the "from address" of an email. Make sure when you set your custom email sender, that you use a real email address such as `notifications@yourbusiness.com`. ### Email content Kinde email content is optimized to (as far as we can) ensure our communications don’t get identified by providers as spam. Maintaining deliverability is one of the reasons we have limited the ability to edit email content. ### SPF, DMARC, and DKIM for email authentication SPF (Sender Policy Framework), DMARC (Domain-based Message Authentication, Reporting, and Conformance), and DKIM (DomainKeys Identified Mail) are email authentication methods used to combat email spoofing, phishing, and other forms of email fraud. These records add a digital signature to every outgoing message, which allows your provider to verify that emails were actually sent from you. Almost all email providers look for these to be set as a strong signal of legitimacy. ### Strengthen email authentication with your provider You and your email provider are ultimately responsible for ensuring the right level security and risk management for email authentication. Because Kinde allows you to use any provider you like, check their documentation to find out if their policies and approach meet your needs. ## Provider-related issues Despite all we can do, verification emails still occasionally end up in spam or quarantined. The cases below are specific, but might help you troubleshoot is they arise. ### Gmail Delivery addresses that are part of Google Workspace can sometimes be delayed by about 4 minutes, due to pre-delivery message scanning. It can help to sign up for Gmail's postmaster tools, to help troubleshoot issues. ### Microsoft (Hotmail / Outlook / Office365) Microsoft Defender's aggressive anti-spam filters sometimes stop verification emails reaching certain Outlook inboxes. Then the email is placed in quarantine and the administrator has to restore it, for it to be delivered. With Kinde, this should be rare, as we only send OTPs and not magic links. Access Outlook Sender Support and check you are following recommendations.

# Authenticate - Authentication methods - Password authentication

> Complete guide to password authentication in Kinde including security features, password strength requirements, and reset options.

password authentication, password strength, password reset, security, hash encryption, MFA
authenticate

Password authentication is where an end user supplies and maintains their own password to access your app or project. Depending on your authentication needs and security requirements, you might be okay to allow users to authenticate with a password. However, we recommend using a more secure method, such as through one-time-passwords, or by adding [multi-factor authentication](/authenticate/multi-factor-auth/about-multi-factor-authentication/) to the sign in experience. ## Passwords and identity verification To reset a password for a user, or allow them to reset their own password, they need to have a [verified contact identit](/authenticate/about-auth/identity-and-verification/)y such as an email in their Kinde profile. You’ll need this to securely set a temporary password or to trigger a password reset for a user. ## Password visibility and encryption The way Kinde is built ensures that user passwords can only be stored as hash-encrypted strings, meaning they are not visible and cannot be deciphered or accessed to be exploited. Neither you in your business or Kinde can see any passwords that a user has set. ## Password strength Kinde supports the following password requirements: - 8 character minimum - Blocking of 1,000,000 most common passwords - 5 incorrect attempts locks account out for 5 minutes - No complexity requirements or character limitations - combined with allowing long passwords, this provides better security and ease of use. For example, it’s harder for a computer to crack `FiremanSoccerPoodleLemon` than `FireSoc!22`, and also easier for a human to remember. If using passwords for authentication, we do recommend adding multi-factor authentication as a requirement or option, for added security. ## Options for resetting a password There are several ways to reset a user’s password. ### The user can select ‘forgot password’ User’s can trigger a password reset by selecting ‘forgot password’ when they attempt to sign in. When they do this, they will be sent a one-time passcode via email. When they enter the code, they will be prompted to reset their password. ### Force a password reset via Kinde or API You can trigger a password reset via the Kinde admin or via API. This is only suitable if you have an email for the user, as they will be sent a one-time passcode when they try to sign in next. They must enter the code to reset their password. See [Reset a user’s password](/manage-users/access-control/reset-user-password/). ### Issue a temporary password You can set a single-use password for new or existing users via the Kinde admin or via the Kinde Management API. Once you set the password, you need to communicate it to the user via your own chosen method - it cannot be sent from Kinde. The user enters the temporary password to sign up or sign in, then they set their own password. See [Set a temporary password](/manage-users/access-control/set-temporary-password/). ## Enable password authentication across apps 1. Go to **Settings > Authentication**. 2. In the **Password** section, select **Configure** on the relevant password tile: **Email + password** or **Username**. A configuration window opens. 3. Scroll to the bottom and switch password authentication on for the apps you want. 4. Select **Save**. ## Enable password authentication for a single app 1. Go to **Settings > Applications**. 2. Select **Configure** on the relevant application tile. 3. Select **Authentication** in the menu. 4. Switch on the password options you want. 5. Select **Save**.

# Authenticate - Authentication methods - Passwordless authentication

> Guide to passwordless authentication using one-time passcodes (OTP) via email or phone, including setup and security considerations.

passwordless authentication, OTP, one-time passcode, email code, phone code, security
authenticate

Passwordless authentication is a type of authentication that does not require end-users to set or maintain passwords for access to an application. Instead, they authenticate using a one-time passcode (OTP). <Aside> The email + passwordless method is switched on by default in all new Kinde businesses </Aside> ## About one-time passcodes (OTPs) Kinde does not support magic links as a password alternative, instead, we prefer to use one-time passcodes (OTPs) as they are more secure, and require manual entry as opposed to a single click. For example, someone with access to your email could click a link to get instant access to an application, but they cannot use the code unless they have initiated the correct sign in flow and have your sign-in identity as well. If you receive the OTP via SMS, someone would need to have your device and unlock code, to access it. A OTP can be issued via email or phone, depending how you have set up authentication. It is also common to use OTPs as a factor in [multi-factor authentication](/authenticate/multi-factor-auth/about-multi-factor-authentication/). Passcodes issued from Kinde expire after 2 hours. ## Set up passwordless authentication 1. In Kinde, go to **Settings >** **Authentication**. 2. In the **Passwordless** section, select **Configure** on the relevant tile. 3. If you select the **Email + code** tile: 1. Select which applications will use this authentication method. 2. Select **Save**. 4. If you select the **Phone** tile: 1. Select which applications will use this authentication method. 2. Select **Save**. 5. If you select the **Username + code** tile: 1. Select which applications will use this authentication method. 2. Select **Save**. <Aside> **You can test this feature** but passwordless phone authentication requires that you have a [Twilio](https://www.twilio.com/en-us) account. You need to enter your Twilio account details and [upgrade to Kinde Pro](https://kinde.com/pricing/) if you want your users to authenticate this way. [Learn more](/authenticate/authentication-methods/phone-authentication/). </Aside> ## If a user does not receive a code It should not happen often, but occasionally users do not receive their passcode. Here's a few suggestions. - Tell the user to check their junk folder - some email providers, systems, and devices have security in place to prevent spam. An OTP from an unknown provider (like Kinde) might get accidentally treated as such. - Once or twice we have come across a domain provider who has added Kinde to a denylist and OTPs from us get rejected. You'll need to contact us so we can investigate and arrange allowlisting. This is a very rare cause of failed OTPs. ## Attack protection settings Kinde allows you to control the number of sign-in attempts a user gets, how long they get locked out after a failed sign-in attempt, etc. See [Attack protection](/build/set-up-options/attack-protection/).

# Authenticate - Authentication methods - Set up phone or SMS authentication

> Complete setup guide for phone/SMS authentication using Twilio, including configuration, MFA integration, and message formatting.

phone authentication, SMS, Twilio, MFA, A2P messaging, 10DLC, verification code
authenticate

You can allow users to use their phone as a primary method for authentication. This is a passwordless method, where the user is sent a verification code via SMS. SMS can also be included as a secondary factor if you have [multi-factor authentication](/authenticate/multi-factor-auth/about-multi-factor-authentication/) set up. <Aside> This feature requires paid third-party services to use. Rates and limitations apply. </Aside> ## (Existing phone auth Twilio users only) Switch on SMS for MFA 1. In Kinde, go to **Settings > Environment > SMS**. 2. Scroll to the bottom and switch on the **Use this service for SMS MFA** option. 3. Select **Save**. ## Benefits of using a third-party SMS service instead of Kinde - Gives you full control over the SMS delivery nuances, such as SenderID, country registrations, and detailed delivery metrics. - You can register dedicated short codes or sender IDs in countries that have strict SMS sending regulations like Ireland, NZ and Canada, which will greatly improve deliverability. - Access to delivery logs and other service quality details for troubleshooting. ## SMS provider requirements (Twilio) SMS authentication requires the services of a messaging provider, in this case, [Twilio](https://www.twilio.com/en-us). You need a [Twilio](https://www.twilio.com/en-us) business account to ensure messaging works for local and overseas phone numbers. Phone authentication interactions are also known as [A2P (Application to Person)](https://www.twilio.com/docs/glossary/what-a2p-sms-application-person-messaging) messaging. Before you implement A2P, check if you need to register your business for 10DLC (10 Digit Long Code) support to be able to send messages, as this is required in some locations. We also recommend you check [Twilio’s guidelines for setting up messaging](https://www.twilio.com/en-us/guidelines/sms), and carefully follow procedures for registration, and SMS policies for all relevant countries. ## What you need <Aside> If you just want to test this feature first, Kinde allows you to send 10 SMS messages per month without setting up Twilio. If you want the feature to be live for your users, you must implement the full Twilio setup. </Aside> You’ll need the following details that are in the dashboard of your [Twilio account](https://www.twilio.com/en-us). - The SID of your Twilio account - The Auth Token for your Twilio account - Your Twilio phone number or the Messaging Service SID (if you set one up) ![Twilio account info](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/1da93a0a-9fd3-437f-5357-be90f3f3c200/public) Refer to the [Twilio documentation](https://www.twilio.com/docs/messaging/services/tutorials/send-messages-with-messaging-services) for assistance setting up. ## Configure phone SMS auth in Kinde After you set this up, you can use SMS for both phone authentication and SMS MFA. 1. In Kinde, go to **Settings > Environment > SMS**. 2. Select the **Default country** that you want to show on the authentication screen when users sign in. 3. Enter the Twilio details from your Twilio account (see above) in the relevant fields. ![twilio details](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/4c857ff9-ff87-44ea-a488-3e2b511caf00/public) 4. In the **SMS source** field, select either the **Use** **Messaging service** or **Use phone number**. Verification codes will be sent from whichever you choose. <Aside> Note that the Twilio messaging service is more suitable for global applications as it detects where the sign in comes from and sends from an appropriate number. </Aside> 5. Depending on your selection in the previous step, enter either the **Messaging service SID** or Twilio **Phone number** in the relevant field. ![Twilio config](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/749a80bc-d6b7-40b0-950a-650c7775b900/public) 6. Select if you want to use a fallback service if the provider service is interrupted. ![option to use kinde sms as fallback](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/9bdd2ef1-c308-4307-c84e-bc8ffdbfe200/public) 7. Select **Save**. ## Switch on phone authentication for an application After you have set up Twilio details, you’re ready to switch on phone or SMS auth for your applications. 1. Go to **Settings > Environment > Authentication**. 2. In the **Passwordless** section, select **Configure** on the **Phone** tile. 3. Switch on the auth method for the applications you want. 4. Select **Save**. ## Switch on SMS as a factor in MFA If MFA is required or optional for your users, you may want to use the Twilio service for SMS MFA. 1. Go to **Settings > Environment > Multi-factor auth**. 2. Under **Additional authentication methods**, switch on **SMS**. 3. Select **Save**. ## SMS message format You can’t customize the code message that user’s receive. We use a standard format as follows, to allow for easier translation. **Your verification code is [xxxxxx]** ## Connection ID When you configure phone authentication, you’ll see that a Connection ID is automatically assigned. If you’re building a [custom authentication experience](/authenticate/custom-configurations/custom-authentication-pages/), you’ll need the ID to trigger the phone authentication workflow.

# Authenticate - Authentication methods - Select authentication options

> Comprehensive guide to configuring all authentication methods in Kinde including email, phone, username, social, and enterprise connections.

authentication setup, email auth, phone auth, username auth, social auth, enterprise auth, SAML, OAuth
authenticate

Kinde supports many authentication options that let you control how users access your applications. You can set different authentication requirements for different applications, and also for different organizations (if you use [organizations](/build/organizations/add-and-manage-organizations/)). Set up all your required authentication methods at the Environment level first. ## Switch on **email authentication** 1. Go to **Settings > Environment > Authentication**. 2. Select **Configure** on the **Email** tile in either the **Passwordless** or **Password** section. 3. In the window that appears, switch the authentication option on or off for each application you have. Note that you **cannot** use passwordless and password authentication for the same app. 4. Select **Save**. ## Switch on phone authentication You can allow users to authenticate using their phone number as their sign in identity. For full details, see [Set up phone authentication](/authenticate/authentication-methods/phone-authentication/). 1. Go to **Settings > Environment > Authentication**. 2. In the **Passwordless** section, select **Configure** on the **Phone** tile. 3. In the window that appears, switch the authentication option on or off for each application you have. 4. Select **Save**. ## Switch on username + password authentication You can allow users to authenticate using a username as their sign-in identity. They will still need to provide an email on sign-up, but will be able to sign in with a username-password combination from then on. Learn more about using [usernames for auth](/authenticate/authentication-methods/username-authentication/). 1. Go to **Settings > Environment > Authentication**. 2. In the **Password** section, select **Configure** on the **Username** tile. 3. In the window that appears, switch the authentication option on or off for each application you have. 4. Select **Save**. ## Switch on username + passwordless authentication You can allow users to authenticate using a username as their sign-in identity. They will still need to provide an email on sign-up, but will be able to sign in with a username-OTP combination from then on. Learn more about using [passwordless auth](/authenticate/authentication-methods/passwordless-authentication/). 1. Go to **Settings > Environment > Authentication**. 2. In the **Passwordless** section, select **Configure** on the **Username + code** tile. 3. In the window that appears, switch the authentication option on or off for each application you have. 4. Select **Save**. ## Switch on **social authentication** 1. Go to **Settings > Environment > Authentication**. 2. In the **Social connections** section, select **Add connection**. 3. In the window that appears, select the social apps you want and then select **Save**. 4. You need to set up the connection to each social app you chose, see [Add social sign in](/authenticate/social-sign-in/add-social-sign-in/). ## Use enterprise or custom authentication Follow the instructions for the relevant authentication method. See: - [Microsoft Entra ID](/authenticate/enterprise-connections/azure/) (was Azure AD) - [SAML](/authenticate/enterprise-connections/custom-saml/) ## Add and manage social and enterprise connections via API Use [Kinde’s management API](/kinde-apis/management#tag/connections) to manage social and enterprise connections. You can view a list of connections, add a new connection, identify a connection, and update existing connections.

# Authenticate - Authentication methods - SMS deliverability in Kinde

> Guide to SMS deliverability including regional considerations, sender ID configuration, and country-specific delivery rates.

SMS deliverability, Twilio, sender ID, regional delivery, 10DLC, A2P messaging
authenticate

Kinde encourages customers to configure their own SMS sender, so that verification, country registrations, sender IDs, and deliverability metrics are controlled and managed by you. When SMS messages are sent via Kinde, we use our regional shared service provider and attempt delivery on a best-effort basis. As Kinde is a service provider, there are limitations when applying for dedicated short codes or sender IDs in countries with strict SMS-sending regulations. This topic describes SMS delivery via Kinde, deliverability factors, and some common reasons why delivery can fail. ## Manage your own SMS sender By default, when you first start using Kinde, all SMS messages are sent from Kinde's shared service provider. We recommend configuring your own SMS sender so that users receive authentication messages branded with your business. Configure this before your production environment goes live. Simply add your SMS details in Kinde settings. See [Set up phone or SMS authentication](/authenticate/authentication-methods/phone-authentication/) for step-by-step instructions. ## Deliverability factors when using Kinde's default SMS shared service provider Kinde provides no guarantees on SMS delivery and attempts delivery as best effort only. ### Countries with known good delivery due to Kinde involvement The following countries have been tested and are known to have good delivery due to Kinde registering with the respective regulatory bodies. - Australia (LONG CODE, SENDER ID) - Canada (LONG CODE) - Great Britain (SENDER ID) - Ireland (SENDER ID) - United States (TOLL FREE) ### Countries with known good delivery without Kinde involvement The following countries have known good delivery without Kinde registering with the respective regulatory bodies. - Generally the rest of the EU - South Africa ### Countries with known bad delivery The following countries have known bad delivery rates. - India - New Zealand - United Arab Emirates ## Sender ID Kinde has set up a shared Sender ID for all customers using the default SMS shared service provider. This cannot be changed. **Sender ID:** `KindeAuth` To brand the Sender ID to your business, you will need to configure your own SMS delivery provider. See [Set up phone or SMS authentication](/authenticate/authentication-methods/phone-authentication/). ## SMS content The content of the SMS is not editable due to strict one-time passcode requirements and industry best practices. An example of the SMS content is below. ``` 123456 is your one-time code to sign in to {Business Name} @business.kinde.com #123456 ```

# Authenticate - Authentication methods - Username authentication

> Guide to username-based authentication including unique constraints, sign-up flow, and integration with password/passwordless methods.

username authentication, unique usernames, case insensitive, sign-up flow, identity verification
authenticate

Along with email and phone number, Kinde supports authentication where a username is the user’s sign-in identity. On sign-up or registration, the user will need to do a one-time validation of their identity via email - for security - but they can subsequently use a username to sign in. <Aside title="Capture other names with properties"> The `username` field is designed for use in the authentication flow, if you want your customers to set a username, display name, or handle as part of their profile in your app, you can add a different property to capture this data. See [Add and manage properties](/properties/work-with-properties/manage-properties/). </Aside> ## Usernames must be unique There are several ways usernames can be added to a user’s profile: - Manually in Kinde - Via API - Self-created by the user on registration - imported with user profiles Kinde treats usernames as case-insensitive. In other words, we ignore case. We do this because it eliminates the possibility of auth issues and fraud when two usernames are identical in every aspect except the case of one of their letters. We are happy to support users choosing an aesthetically pleasing username combination, like `RosyRose` or `BuilderBob`. We just don't also support separate identities for `rosYrosE` and `BUilderbob`. Regardless of how a username is added, it must be unique (in more than case). If a username already exists, an error will be returned. ## The sign-up flow For security reasons, Kinde doesn’t allow fully anonymous users. So when a user signs up, they will need to supply an email, in addition to a username. The email can then be used to verify their identity. The username can be supplied by you, or can be created by the user. <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/c4f7ed33-ef8b-442e-14f0-bc12a4f5c100/public" alt="" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" /> ## The sign-in flow When a user signs in, they enter their username and proceed with a [password](/authenticate/authentication-methods/password-authentication/) or a [passwordless OTP](/authenticate/authentication-methods/passwordless-authentication/). Either way, it’s a quick process for sign in. <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/ce25d6b7-0e5c-4f0c-0851-996a8315fb00/public" alt="" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" /> ## Why an email is required In order to be sure that you are signing up a real person, you need to have a way of contacting new users to verify their identity. Without identity verification, the authentication experience you provide could be vulnerable to security threats, fraud, bots, etc. Once an email is verified, we add this email identity for the user. If the auth method is passwordless, this is where we send the OTPs. An email is also required for [password resets](/manage-users/access-control/reset-user-password/). ## Enable username authentication in Kinde 1. In Kinde, go to **Settings > Authentication**. 2. Select **Configure** on the **Username** (password) or the **username + code** (passwordless) tile. A configuration window opens. 3. Select which apps will support username authentication. 4. Select **Save**. The sign up flow will be updated for the applications you selected. ## Rules for usernames - Usernames must be unique - 2-64 characters, no spaces - Can include letters, numbers, -dashes, \_underscores (no special characters) - Case is ignored. Jane and jane are treated the same. ## One password for multiple identities Users can only have a single password in Kinde. If you allow both email-password and username-password authentication for a user, the password is shared across both their identities. For example, changing a user’s password for username affects their email sign-in and vice-versa. See [the password rules](/authenticate/authentication-methods/password-authentication/#password-strength).

# Authenticate - Custom configurations - Manage organization-level auth features

> Guide to advanced organization features including custom policies, default roles, email senders, custom domains, and organization-level MFA.

advanced organizations, organization policies, default roles, custom email sender, custom domains, organization MFA
authenticate

<Aside type="upgrade"> Only businesses on the [Kinde Scale plan](https://kinde.com/pricing/) can enable advanced organization features. Additional fees apply. </Aside> When you enable advanced organizations features, you can access extended features for individual organizations. Customizations include: - Additional access control via [policies](/build/organizations/organization-access-policies/) - Select [default roles](/manage-users/roles-and-permissions/default-user-roles/#enable-default-roles-in-an-organization) for users who join an organization - Set [custom email sender details](/build/organizations/email-sender-organization/), so users in specific orgs receive OTP and other emails from the custom address (requires own SMTP) - Organization-level [custom domains](/build/domains/organization-custom-domain/) - Organization-level [multi-factor authentication](/authenticate/multi-factor-auth/mfa-per-org/) Read our blog about why you might need [advanced organizations in Kinde](https://kinde.com/blog/authentication/advanced-organizations/). ## Enable advanced organization features <Aside type="warning"> Note: You can activate advanced features for 5 organizations on the Kinde Scale plan. After that, there is a monthly cost for each organization that is enabled to use advanced features. </Aside> 1. In Kinde, go to **Organizations**. 2. Search or browse for the organization you want and select the name to show the org details. 3. Select **Authentication**. 4. In the **Activate advanced organization features** box, select **Activate**. ## Disable advanced organization features <Aside type="warning"> Note that when you disable advanced features, all advanced settings revert to global business settings. This could cause breaking changes in apps that rely on custom authentication for the organization. Your next bill will also be adjusted. </Aside> 1. In Kinde, go to **Organizations**. 2. Search or browse for the organization you want and select the name to show the org details. 3. Scroll to the bottom of the **Details** page and select **Remove advanced org features**. 4. In the confirmation window, follow the prompts.

# Authenticate - Custom configurations - Manage the authentication experience

> Comprehensive guide to customizing the authentication experience including unified sign-up, name requirements, marketing consent, and profile picture settings.

authentication experience, unified sign-up, seamless registration, marketing consent, Gravatar, login_hint
authenticate

Kinde aims to give you as much control of your user’s sign up and sign in experience as possible, without compromising security. Here are some options for customizing the authentication experience in your applications. You’ll find these in Kinde: **Settings > Applications > View details** on your application. <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/f8d6db00-fa71-41d0-7c1c-630508f6c300/public" alt="Application switches for custom sign in behaviour" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" /> ## Use your own sign up and sign in screens Kinde offers custom authentication, allowing you to use your own sign up and sign in screens, bypassing the landing screens provided by Kinde. You can enable this for social sign in, email, phone, enterprise connections, or any combination of these sign up methods you support. See [Custom sign-up and sign-in pages](/authenticate/custom-configurations/custom-authentication-pages/) for more details. ## Create a unified sign-up / registration experience (seamless sign up) You can allow all users to register and sign from the same authentication screen, without forcing them to create an account first. To do this: 1. Update your app to redirect all authentication through the registration flow. To do this, change the link for the `sign in` button to go to the `register` button on the authentication screen. In Next.js, for example, you would change `<LoginLink>` to use `<RegisterLink>` instead. 2. Switch off the requirement to ask for first name and last name on registration (see section below). 3. Go to **Settings > Applications > View details** on your application. Scroll to the **Authentication experience** section. 4. Switch off the **Show 'Already have an account? Sign in' on registration page** option. 5. Go to **Design > Page content**, then select **Sign up page** in the dropdown. Update the copy on the sign up page to cater for both the registration and sign in experience. 6. Select **Save**. The result is: - Users with an account will authenticate - Users without an account will be registered - Nobody will see a prompt to create an account You can do this for any authentication method, e.g. email + password, email + OTP, phone + SMS OTP, social connection, or enterprise connection. ![Example before and after register screen shot](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/03883607-f9f2-4b1a-b3cf-9773d2683400/public) ## Ask for first name and last name on sign up By default, the Kinde sign up flow includes fields for users to enter their first name and last name. However, if you don’t want to collect user’s names, you can easily switch this off. This can make the sign up experience a bit faster, because when a user goes to sign up, all they need is their email, phone number, or their social sign in. **To switch off the name requirement for sign up** 1. Go to **Settings > Applications > View details** on your application. 2. Scroll to the **Authentication experience** section. 3. Switch off **Ask for user first name and last name**. 4. Select **Save**. ## Request consent for marketing on sign up If you want, you can add a checkbox to the sign up screen for collecting user consent to receive marketing communications. See [Request user consent for marketing on sign up](/design/pages/marketing-consent/) for details. ## Switch off Gravatar fallback for profile pictures Typically, Kinde receives user profile pictures via the email provider, e.g. Google. If no picture is attached to a profile, Kinde sets the picture to use a Gravatar URL instead. Gravatar sends us a profile URL and either the user picture (if available) or a blank avatar is displayed in Kinde. To avoid blank avatars and to handle profile pictures a different way, you can switch off the Gravatar fallback. 1. Go to **Settings > Applications** and select **View details** on your application. 2. Scroll to the **Authenticaton experience** section and switch off the **Use Gravatar fallback** option. 3. Select **Save**. Read more about [email authentication](/authenticate/authentication-methods/email-authentication/). ## Pre-populate user identity for sign in Create a smoother sign up and sign in experience for users by passing `login_hint` with the auth URL. This prefills the user’s sign in identity, saving them from manually entering their email or phone number. You might want to do this, for example, if you invite users to sign up via email and you want to reduce friction and make signing in faster. See [Pre-populate user identity on sign in](/authenticate/custom-configurations/prepopulate-identity-sign-in/) for details. ## Include 'escape hatch' URLs for authentication errors You can include URLs in error messages so that users can click them to go back to the sign in screen or your home page. 1. Go to **Settings > Applications** and select **View details** on your application. 2. Set the **Application homepage URI** and the **Application login URI**. 3. Select **Save**.

# Authenticate - Custom configurations - Custom sign-up and sign-in pages

> Step-by-step guide to creating custom authentication pages while maintaining Kinde's security for verification and MFA processes.

custom authentication pages, connection ID, login_hint, social auth, email auth, phone auth, enterprise auth
authenticate

You can host your own custom sign up and sign in pages to use with Kinde. Integrate your own designs for the initial sign up and sign in page, and still get the security of Kinde’s auth (and verification) process. This gives you the best of both worlds: the security of hosted auth, and the ability to customize the initial sign-up experience for your users. <Aside title="Customizing the entire authentication experience"> Bring your own HTML / CSS and JavaScript to our hosted pages [with Kinde's custom UI feature](/design/customize-with-code/customize-with-css-html/). </Aside> ## Custom sign in for social authentication If you only allow users to sign up and sign in with social authentication - such as Google or Apple - then you can achieve a headless-type experience. Users sign up or sign in from your custom screen, then get pushed straight through to the social provider’s account selection screen. For example: <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/20ed27ab-5a0a-47b5-b66e-025013c60400/public" alt="" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" /> ## Custom sign in for email authentication If you allow email sign up and sign in, the initial Kinde screen can be bypassed, but the Kinde code verification screen will still appear before sign in is completed. When a user signs up (say, via email), they do this in fields on your custom sign in screen. Then for verification, they see Kinde’s verification code screen. After that, it’s all you again. <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/b08b9164-775c-4de7-669e-87ebaa329200/public" alt="" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" /> ## Screens that remain securely hosted by Kinde This feature lets you to bypass Kinde’s initial sign in screens, but the following screens are still hosted by Kinde and are part of our secure auth experience. - Enter password or One-time password (OTP) screens (see example above) - Multi-factor authentication screens - The organization switcher (if you support multiple organizations) - The screen where users can choose to create an account if one was not found ## Step 1: Switch on the custom auth option for your application 1. Go to **Settings** > **Applications**. 2. Select **View details** on the application you want to switch on custom auth for. 3. Scroll down and switch on the **Use your own sign-up and sign-in screens** option in the **Authentication experience** section. 4. Select **Save**. ## Step 2: Get the auth method connection ID Each authentication type you have set up in Kinde has a unique **Connection ID** attached to it. You need to add this connection ID to your screen design code, so that the Kinde screens get bypassed when users interact. 1. Go to **Settings > Authentication.** 2. Select **Configure** on the relevant authentication method tile. For example, the **Google** tile under the **Social connections** section. 3. Copy the **Connection ID** and paste it somewhere you can access later. 4. Select **Save** or **Cancel**. 5. Repeat for each authentication method you want to be included on your custom sign in screen. ## Step 3: Add the Connection ID to your design code There are different steps depending on the authentication method you use. Update your code for all that apply. ### Social sign in Add the `connectionId` to the auth url. Here is an example using React: ```jsx <button onClick={() => login({ connectionId: "conn_6a95dec504d34dc286dc80e8df9f6099" }) } > Sign in with Google </button> ``` You can now test if it works by signing in to your project or app. ### Email sign in Add the `connectionId` and `loginHint` params to the auth url. The `login_hint` enables you to pre-populate the email for the user, skipping the step where they have to enter their identity/email. It also tells us where to send their one time password for passwordless verification. Here is an example using React. ```jsx <button onClick={() => login({ connectionId: "conn_e5f80aa5258e4685bf629b38003ee954", loginHint: "dave@kinde.com" }) } > Sign in with email </button> ``` You can now test if it works by signing in to your project or app. ### Phone sign in Add `connectionId` and `loginHint` params to the auth url. The `loginHint` enables you to pre-populate the phone for the user, skipping the step where they have to enter their phone number. It also tells us where to send their one time password for passwordless verification. The `loginHint` needs to be in one of these formats `phone:<intl_number>:<country_code>` or `phone:<+intl_number>:<country_code>`. The ‘+’ symbol is optional, as long as the country code is included. Here is an example using React: ```jsx <button onClick={() => login({ connectionId: "conn_e1d49977648149a2a32fde844f1ff9e5" loginHint: "phone:+61466043123:au" }) } > Sign in with phone </button> ``` You can now test if it works by signing in to your project or app. ### Enterprise sign in (Entra ID or SAML) Add the `connectionId` to the auth url. This takes the user directly to the enterprise authentication process. Here is an example using React: ```jsx <button onClick={() => login({ connectionId: "conn_6a95dec504d34dc286dc80e8df9f6099" }) } > Sign in to [project name] </button> ```

# Authenticate - Custom configurations - Disable self sign-up

> Guide to disabling self sign-up for your business or specific organizations, allowing only selective user addition via import, manual addition, or API.

disable sign-up, self sign-up, invitation only, user management, organization policies
authenticate

You can prevent users from signing up to your business, and only add users selectively. You might do this if you only want to give access to employees or members. Disabling sign-ups applies across an environment. Depending on your Kinde plan, you may can also [manage sign-ups per organization](/build/organizations/allow-user-signup-org/). ## Disable self sign-up for your business 1. Go to **Settings > Environment > Policies**. 2. Switch off the **Allow self-sign up** option. You can then [import users](/manage-users/add-and-edit/import-users-in-bulk/), [add them manually](/manage-users/add-and-edit/add-and-edit-users/), or add them [via the Kinde API](/kinde-apis/management#tag/users/post/api/v1/user). ## Disable self sign-up to an organization You can disable self sign-up per organization. However, if you allow self sign-up in your business (and have not disabled it as per the above procedure), at least one organization must allow sign-ups. 1. Go to **Organizations**. 2. Select the organization you want to disable sign-ups for. 3. Go to **Policies**. 4. Switch off the **Allow org members to be auto-added** option. 5. Select **Save**.

# Authenticate - Custom configurations - Pre-populate user identity on sign in

> Guide to pre-populating user identity fields using login_hint parameter for email, phone, and username authentication to improve user experience.

login_hint, pre-populate, user identity, email, phone, username, authentication UX
authenticate

You can create a smoother sign-up and sign-in experience by passing a login_hint when users authenticate. When the user arrives at the sign-in page, their credentials are pre-filled, saving them time. This works for emails, phone numbers, and usernames. You might want to do this, for example, to reduce friction and make signing up extra easy. ## Enable login_hint Add the `login_hint` parameter to the sign up/sign in request on your app or site. ### Email example ```jsx <button onClick={() => login({ authUrlParams: { login_hint: "dave@kinde.com" } }) } > Continue </button> ``` ### Phone example ```jsx <button onClick={() => login({ authUrlParams: { login_hint: "phone:+61444110110:au" } }) } > Continue </button> ``` ### Username example ```jsx <button onClick={() => login({ authUrlParams: { login_hint: "username:Bob_the_dog" } }) } > Continue </button> ```

# Authenticate - Custom configurations - Proxy your Kinde auth pages through Cloudflare

> Guide to proxying Kinde authentication pages through Cloudflare to leverage advanced security features like WAF and bot mitigation.

Cloudflare proxy, WAF, bot mitigation, custom domain, DNS, SSL, security
authenticate

You can take advantage of Cloudflare’s advanced security features such as their WAF and bot mitigation tools by proxying your Kinde hosted auth pages through Cloudflare. ## What you need - A Cloudflare account - A domain managed in Cloudflare ## Set up the custom domain 1. Set up a custom domain in your Kinde business, see [Use your own custom domain](/build/domains/pointing-your-domain/). 2. Set up DNS records for the domain in Cloudflare. We will change this from DNS once the records have been validated. DNS validation confirms the record before we set the proxy. <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/11ab78a6-3b68-4424-2228-b45806f1a400/public" alt="" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" /> ## Set up the proxy Once you receive the email that the custom domain has been set up in Kinde, go to Cloudflare and change the custom domain record from **DNS only** to **Proxied**. <Aside type="warning" title="Important"> Leave the ACME challenge record as DNS. This is used to verify domain ownership each time the certificate needs to be renewed and cannot be proxied. </Aside> <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/1c91bc73-5252-4062-2bb0-af877e945200/public" alt="" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" /> <Aside type="warning" title="Important"> Ensure your encryption mode in the Cloudflare dashboard is set to either **Full** or **Full (strict)**. For security purposes, Kinde enforces HTTPS on it's web services, which means **Flexible** or **Off** will not work. </Aside> ## Create a Cloudflare Managed Challenge To test the proxied domain, create a WAF rule to show a Cloudflare Managed Challenge on all incoming requests. For example, create a rule to match the hostname of the custom domain used in Kinde and the request originating from Australia. The action is to show a **Managed Challenge**. <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/2aba2c16-a345-4179-3075-52485a126c00/public" alt="" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" />

# Authenticate - Custom configurations - Redirect users

> Guide to redirecting users after authentication using cookies, local storage, or the state parameter for secure post-auth navigation.

user redirect, callback URL, state parameter, CSRF protection, local storage, cookies
authenticate

After authenticating a user in Kinde, you can return them to a specific page within your application. Users are initially redirected back to the requested [Callback url](/get-started/connect/callback-urls/) you have included in your allowlist within Kinde. This is necessary to complete the token exchange and finalize the authentication flow. ## When to set a specific redirect A callback URL is not always where you want users redirected after authentication. You may want users to land on a specific dashboard page, or to trigger authentication if a user tries to access a protected page in your application. In both those cases, you can store a URL to redirect the user back to their intended page (after authentication) to provide a more seamless experience. ## Redirect without an SDK Most of our SDKs include a mechanism for redirecting users. However, if you are not using a Kinde SDK, use one of the following methods. 1. Store the intended URL in a cookie or local storage. 2. Use the `state` parameter. ## Store the URL in a cookie or local storage For single page applications the simplest is probably to leverage local storage to store the desired URL. Prior to redirecting to Kinde: ```jsx localStorage.setItem("nextUrl", "/some-protected-route"); ``` After authentication is complete: ```jsx const nextUrl = localStorage.getItem("nextUrl"); window.location.replace(nextUrl); ``` For server-side applications you can achieve the same thing with a cookie - essentially setting the next URL before redirecting to Kinde and fetching the value post-authentication. The implementation will depend on your language or framework choice. ## Use the state parameter You should be using the state parameter already to protect against CSRF attacks. [(Here's how Kinde uses the State param)](/get-started/learn-about-kinde/kinde-product-security/#csrf-protections-via-state-parameter). Essentially it's a random string that you would store in your application, so when you receive the response from Kinde you can validate it matches the one you sent. Because it is just a string, you can leverage it to store additional information, like the intended destination of your user. 1. Generate a random string in your application. For this example we will use:`BlueFox0101`. 2. Use this string as key for an object with the value of your application state and store this locally. For example: ```jsx { "BlueFox0101" : { nextUrl: '/some-protected-route', } } ``` 3. When you redirect your user to Kinde to complete the authentication flow, include the random string as the `state` param: ```jsx https://<your_kinde_subdomain>.kinde.com/oauth2/auth ?response_type=code &client_id=<your_kinde_client_id> &redirect_uri=<your_app_redirect_url> &scope=openid%20profile%20email &state=BlueFox0101 ``` 4. After the user has authenticated, they will be redirected back to your application and the `state` value will be included in the url: ```jsx https://<your_application>.com/auth/callback ?code=<some_unique_code> &scope=openid%20profile%20email &state=BlueFox0101 ``` 5. As part of your callback processing and response validation, verify that the `state` returned in the URL above matches the random string you stored locally. If it does, retrieve the rest of the application state (like the nextUrl). 6. Use the `code` param to complete the token exchange (as per the [Use Kinde without an SDK](/developer-tools/about/using-kinde-without-an-sdk/#handling-the-callback) guide) and once the exchange is complete use the `nextUrl` to redirect the user. ## **Limitations and considerations** - Choose a storage method based on your application type. | App Type | Recommended storage | | --------------- | ------------------- | | Regular Web App | Cookie or session | | SPA | Local browser | | Native App | Memory or local | - `State` parameter values are not unlimited. `414 Request-URI Too Large` means you should try a smaller value. - Passing URLs in plain text or in any predictable way is unsafe. Ensure that the `state` parameter value is unique and opaque to ensure that it can be used for defence against CSRF and phishing attacks. - If the `state` parameter value is stored in a cookie, it should be signed to prevent forgery. ## A secure way to store redirect information The `state` parameter can mitigate [**CSRF attacks**](https://en.wikipedia.org/wiki/Cross-site_request_forgery) by using a unique and non-guessable value associated with each authentication request about to be initiated. That non-guessable value allows you to prevent the attack by confirming that the value coming from the response, matches the one you sent. The `state` parameter is also a string, so you can encode any information in it. You can send a random value when starting an authentication request and validate the received value when processing the response. You store something on the client application side (in cookies, session, or local storage) that allows you to perform the validation. Kinde SDKs handle `state` generation and validation automatically.

# Authenticate - Custom configurations - Static IP

> Guide to using a static IP address for your Kinde business.

static-ip, infrastructure, whitelist
authenticate

<Aside type="upgrade"> Only businesses on the [Kinde Enterprise plan](https://kinde.com/pricing/) can enable a static IP address for their Kinde business. Additional fees apply. </Aside> For companies who work in highly regulated industries such as government, financial services, or education, it is a common requirement to maintain strict 'whitelists' for accessing the internet. For customers with these requirements, Kinde can provide static IP addresses. ## Dynamic IPs are used by default Kinde uses AWS public cloud to host our services. We make use of AWS's highly scalable infrastructure to ensure the best availability and performance. This infrastructure design means that your Kinde business is assigned a DNS address created during onboarding, which will have a dynamic IP address managed by AWS. You then whitelist the Kinde business domain or your custom domain, to ensure that your customers can access authentication to your product. ## Request a static IP address For Kinde enterprise customers who have strict IP-based whitelists, Kinde can provide a pair of static IP addresses. We use AWS's Global Accellerator to provision 2 IP addresses assigned to your Kinde business and custom domain, which will ensure that the IP addresses are always the same. Please reach out to our team at support@kinde.com to discuss your requirements.

# Authenticate - Device authorization flow - Call your API using device authorization flow

Once you've received an access token from the device authorization flow, you can use it to call your protected APIs. This guide shows you how to validate tokens, handle scopes, and make authenticated API requests. ## Use the access token from the device authorization flow The access token you receive from the device authorization flow is a standard OAuth 2.0 Bearer token. Include it in the `Authorization` header of your API requests: ```bash curl -X GET https://your-api.com/protected-resource \ -H "Authorization: Bearer YOUR_ACCESS_TOKEN" ``` ## Token validation in the device authorization flow Before processing API requests, validate the access token to ensure it's valid and hasn't expired: ### Validate with Kinde's userinfo endpoint ```bash curl -X GET https://<your-subdomain>.kinde.com/oauth2/v2/user_profile \ -H "Authorization: Bearer YOUR_ACCESS_TOKEN" ``` **Success response**: ```json { "sub": "kp_c3143a4b50ad43c88e541d9077681782", "provided_id": "some_external_id", "name": "John Snow", "given_name": "John", "family_name": "Snow", "updated_at": 1612345678, "email": "john.snow@example.com", "email_verified": true, "picture": "https://example.com/john_snow.jpg", "preferred_username": "john_snow", "id": "kp_c3143a4b50ad43c88e541d9077681782" } ``` **Error response** (invalid token): ```json { "error": "invalid_token", "error_description": "The access token is invalid or expired" } ``` ### Validate with your own API You can also validate tokens in your own API by verifying the JWT signature and claims: ```javascript +// Node.js example using jsonwebtoken with JWKS +const jwt = require("jsonwebtoken"); +const jwksClient = require("jwks-rsa"); + +const client = jwksClient({ + jwksUri: "https://<your-subdomain>.kinde.com/.well-known/jwks" +}); + +function getKey(header, callback) { + client.getSigningKey(header.kid, (err, key) => { + const signingKey = key.publicKey || key.rsaPublicKey; + callback(null, signingKey); + }); +} + +function validateToken(token) { + return new Promise((resolve, reject) => { + jwt.verify(token, getKey, { algorithms: ["RS256"] }, (err, decoded) => { + if (err) { + resolve({ valid: false, error: err.message }); + } else { + resolve({ valid: true, user: decoded }); + } + }); + }); +} ``` ## Scope enforcement for device authorization Access tokens include scopes that determine what resources the user can access. Check the required scopes before processing requests: ```javascript // Example: Check if user has required scope function hasRequiredScope(token, requiredScope) { const decoded = jwt.decode(token); const tokenScopes = decoded.scope.split(" "); return tokenScopes.includes(requiredScope); } // Usage if (!hasRequiredScope(accessToken, "read:users")) { return res.status(403).json({error: "Insufficient scope"}); } ``` ## Common API patterns for device authorization ### Protected resource endpoint ```javascript // Express.js example app.get("/api/protected-resource", authenticateToken, (req, res) => { // req.user contains the decoded token payload res.json({ message: "Access granted", user: req.user }); }); function authenticateToken(req, res, next) { const authHeader = req.headers["authorization"]; const token = authHeader && authHeader.split(" ")[1]; if (!token) { return res.status(401).json({error: "Access token required"}); } // Validate token with Kinde fetch("https://<your-subdomain>.kinde.com/oauth2/v2/user_profile", { headers: { Authorization: `Bearer ${token}` } }) .then((response) => { if (!response.ok) { throw new Error("Invalid token"); } return response.json(); }) .then((user) => { req.user = user; next(); }) .catch((error) => { return res.status(401).json({error: "Invalid token"}); }); } ``` ### Error handling for device authorization Handle common token-related errors: ```javascript function handleTokenError(res, error) { switch (error.error) { case "invalid_token": // Token is invalid or expired return res.status(401).json({error: "Please re-authenticate"}); case "insufficient_scope": // Token doesn't have required permissions return res.status(403).json({error: "Insufficient permissions"}); default: return res.status(500).json({error: "Authentication error"}); } } ``` ## Security best practices for device authorization ### Token storage - **Never store tokens in localStorage**: Use secure HTTP-only cookies or memory storage - **Validate tokens server-side**: Always validate tokens on your backend, not just the client ### Rate limiting Implement rate limiting for token validation requests: ```javascript const rateLimit = require("express-rate-limit"); const tokenValidationLimiter = rateLimit({ windowMs: 15 * 60 * 1000, // 15 minutes max: 100, // limit each IP to 100 requests per windowMs message: "Too many token validation requests" }); app.use("/api/protected-resource", tokenValidationLimiter); ``` ### Logging and monitoring Log authentication events for security monitoring: ```javascript function logAuthEvent(token, action, success) { console.log({ timestamp: new Date().toISOString(), action: action, success: success, userId: token.user_id, scopes: token.scope }); } ``` ## Testing your API Test your protected endpoints with the access token: ```bash # Test with curl curl -X GET https://your-api.com/protected-resource \ -H "Authorization: Bearer YOUR_ACCESS_TOKEN" # Test with JavaScript fetch('https://your-api.com/protected-resource', { headers: { 'Authorization': 'Bearer YOUR_ACCESS_TOKEN' } }) .then(response => response.json()) .then(data => console.log(data)); ```

# Authenticate - Device authorization flow - About the device authorization flow

Kinde's device authorization flow adheres to `RFC 8628`, also known as the OAuth 2.0 Device Authorization Grant. It enables authorization for devices with limited input capabilities, such as smart TVs, gaming consoles, or IoT devices. Users authenticate on a secondary device (like a phone or computer) while the primary device receives the access token. ## How the device authentication flow works 1. **Device requests authorization**: The device requests a device code and user code from Kinde. 2. **User authenticates**: The user visits a verification URI on another device and enters the user code. 3. **Device polls for token**: The device polls the token endpoint until authorization is complete. 4. **Access granted**: The device receives an access token and can call protected APIs. ## Endpoints for the device authorization flow ### Device authorization endpoint **URL**: `https://<your-subdomain>.kinde.com/oauth2/device/auth` **Method**: `POST` **Content-Type**: `application/x-www-form-urlencoded` **Parameters**: - `client_id` (optional): Your application's client ID - can be omitted if you have set an application as the default for device flows - `audience` (optional): The audience to use for the request **Response**: ```json { "device_code": "kinde_dc_device_code_here", "user_code": "CSLDFDUU", "verification_uri": "https://<your-subdomain>.kinde.com/device", "verification_uri_complete": "https://<your-subdomain>.kinde.com/device?user_code=CSLDFDUU", "expires_in": 600, "interval": 5, "qr_code": "data:image/png;base64,..." } ``` ### Token endpoint **URL**: `https://<your-subdomain>.kinde.com/oauth2/token` **Method**: `POST` **Content-Type**: `application/x-www-form-urlencoded` **Parameters**: - `grant_type`: `urn:ietf:params:oauth:grant-type:device_code` - `client_id`: Your application's client ID - `device_code`: The device code received from the authorization endpoint **Success response**: ```json { "access_token": "eyJ...", "expires_in": 86400, "scope": "", "token_type": "bearer" } ``` The scope field may be empty because granted scopes are carried in the access token’s scope claim. **Example error response**: ```json { "error": "authorization_pending", "error_description": "The user has not yet completed the authorization" } ``` ## Polling behavior The device must poll the token endpoint at regular intervals until the user completes authentication: - **Initial interval**: Use the `interval` value from the device authorization response (typically 5 seconds). - **Slow down**: If you receive a `slow_down` error, increase the polling interval by 5 seconds. - **Maximum time**: Stop polling after the `expires_in` time (typically 30 minutes). ## Device authorization flow error codes | Error Code | Description | Action | | ----------------------- | ------------------------------------ | ------------------------------ | | `authorization_pending` | User hasn't completed authentication | Continue polling | | `slow_down` | Polling too frequently | Increase interval by 5 seconds | | `access_denied` | User denied the authorization | Stop polling | | `expired_token` | Device code has expired | Request a new device code | | `server_error` | Misconfigured device code | Request a new device code | ## Security considerations for device authorization - **User code format**: User codes are formatted as `XXXXXXXX` for easy entry. - **Verification URI**: Users should verify they're on the correct domain. - **Token expiration**: Access tokens expire after 1 hour by default. ## Specifying an audience in a device authorization request If an `audience` is specified in the request, the access token will include the audience in the `aud` claim. Kinde supports requesting multiple audiences. The API must be authorized for the device authorization application. ## Scopes and permissions for a device authorization request If an audience is specified in the request, any scopes which are belong to that audience that are granted to the user by their role will also be granted to the device. The list of scopes will be displayed on the consent screen. If the user consents, the scopes will be included in the `scope` claim of the access token.

# Authenticate - Device authorization flow - Quick start

The 'Device Authorization Flow' allows users to authenticate on one device (like a TV or smart device) using another device (like a phone or computer). This is perfect for devices with limited input capabilities. In this quick start, you'll learn how to implement the device authorization flow using Kinde in just 5 minutes. ## Prerequisites for the device authorization flow - `curl` or a similar HTTP client ## Step 1: Create a Device Authorization app 1. From the Kinde home page select **Add application**. 2. Enter a name for the application. 3. Choose **Device and IoT**. 4. Select **Save**. 5. Make a note of the Client ID, you'll need this later. ## Step 2: Enable an authentication method for your application 1. Go to **Settings > Authentication**. 2. Select **Configure** on the **Passwordless** > **Email + code** card. 3. Under **Applications** select the application you created in step 1. 4. Select **Save**. ## Step 3: Request a device code Request a device code from Kinde's authorization endpoint: ```bash curl -X POST https://<your-subdomain>.kinde.com/oauth2/device/auth \ -H "Content-Type: application/x-www-form-urlencoded" \ -d "client_id=<YOUR_CLIENT_ID>" ``` The response will include a `device_code`, `user_code`, and `verification_uri`: ```json { "device_code": "kinde_dc_...", "user_code": "CSLDFDUU", "verification_uri": "https://<your-subdomain>.kinde.com/device", "verification_uri_complete": "https://<your-subdomain>.kinde.com/device?user_code=CSLDFDUU", "expires_in": 600, "interval": 5, "qr_code": "data:image/png;base64,..." } ``` ## Step 4: Display the user code Show the `user_code` to the user and provide the `verification_uri_complete` or QR code from the response. The user should: 1. Visit the `verification_uri_complete` URL on their phone or computer. 2. Complete the authentication process. ## Step 5: Poll for the access token While the user is authenticating, poll the token endpoint: ```bash curl -X POST https://<your-subdomain>.kinde.com/oauth2/token \ -H "Content-Type: application/x-www-form-urlencoded" \ -d "grant_type=urn:ietf:params:oauth:grant-type:device_code" \ -d "client_id=<YOUR_CLIENT_ID>" \ -d "device_code=<YOUR_DEVICE_CODE>" ``` Continue polling every 5 seconds (or the `interval` value from the response) until you receive a successful response like: ```json { "access_token": "eyJ...", "expires_in": 86400, "scope": "", "token_type": "bearer" } ``` ## Step 6: Use the access token Once you have received the access token, you can call your protected APIs: ```bash curl -X GET https://your-api.com/protected-resource \ -H "Authorization: Bearer YOUR_ACCESS_TOKEN" ``` ## Default app for device flows When you set up a default app for device flows, this will be the application that is used if no Client ID is specified in the request. 1. Select **Settings** > **Applications** 2. Select the Device Authorization application you want to set as default 3. Select **Set as default** 4. Select **Save**

# Authenticate - Device authorization flow - Troubleshooting device authorization

This guide helps you diagnose and resolve common issues with device authorization flow. Learn how to handle errors, debug problems, and implement proper error recovery. ## Common error codes during device authorization ### authorization_pending **Error**: `authorization_pending` **Description**: The user hasn't completed the authorization process yet. **Solution**: Continue polling the token endpoint. This is normal behavior. ```javascript // Example: Handle authorization_pending if (error === "authorization_pending") { console.log("User has not completed authorization yet. Continue polling..."); // Wait for the specified interval before next poll setTimeout(pollForToken, interval * 1000); } ``` ### slow_down **Error**: `slow_down` **Description**: You're polling too frequently. **Solution**: Increase the polling interval by 5 seconds. ```javascript // Example: Handle slow_down if (error === "slow_down") { console.log("Polling too fast. Increasing interval..."); interval += 5; // Increase interval by 5 seconds setTimeout(pollForToken, interval * 1000); } ``` ### access_denied **Error**: `access_denied` **Description**: The user denied the authorization request. **Solution**: Stop polling and inform the user they need to try again. ```javascript // Example: Handle access_denied if (error === "access_denied") { console.log("User denied authorization"); showErrorMessage("Authorization was denied. Please try again."); stopPolling(); } ``` ### expired_token **Error**: `expired_token` **Description**: The device code has expired (typically after 30 minutes). **Solution**: Request a new device code. ```javascript // Example: Handle expired_token if (error === "expired_token") { console.log("Device code expired"); showErrorMessage("This code has expired. Please request a new one."); requestNewDeviceCode(); } ``` ## Polling mistakes during device authorization ### Too frequent polling **Problem**: Polling more frequently than the recommended interval. **Solution**: Always respect the `interval` value from the device authorization response. ```javascript // Good: Respect the interval function pollForToken(deviceCode, interval = 5) { setTimeout(() => { // Make token request checkTokenStatus(deviceCode); }, interval * 1000); } // Bad: Polling too frequently function pollForToken(deviceCode) { setInterval(() => { // This polls every 1 second - too frequent! checkTokenStatus(deviceCode); }, 1000); } ``` ### Not handling `slow_down` properly **Problem**: Not increasing the interval when receiving `slow_down` errors. **Solution**: Implement exponential backoff. ```javascript let currentInterval = 5; // Start with 5 seconds function pollForToken(deviceCode) { checkTokenStatus(deviceCode).then((response) => { if (response.error === "slow_down") { currentInterval += 5; // Increase by 5 seconds console.log(`Increasing interval to ${currentInterval} seconds`); } // Continue polling with updated interval setTimeout(() => pollForToken(deviceCode), currentInterval * 1000); }); } ``` ### Not stopping on errors **Problem**: Continuing to poll after receiving fatal errors. **Solution**: Stop polling for non-recoverable errors. ```javascript function pollForToken(deviceCode) { checkTokenStatus(deviceCode).then((response) => { if (response.error) { switch (response.error) { case "authorization_pending": // Continue polling setTimeout(() => pollForToken(deviceCode), interval * 1000); break; case "slow_down": // Increase interval and continue interval += 5; setTimeout(() => pollForToken(deviceCode), interval * 1000); break; case "access_denied": case "expired_token": // Stop polling - these are fatal errors stopPolling(); handleError(response.error); break; } } else { // Success - stop polling handleSuccess(response); } }); } ``` ## Network issues during device authorization ### Connection timeouts **Problem**: Network requests timing out. **Solution**: Implement proper timeout handling and retry logic. ```javascript function checkTokenStatus(deviceCode) { return fetch("https://<your-subdomain>.kinde.com/oauth2/token", { method: "POST", headers: { "Content-Type": "application/x-www-form-urlencoded" }, body: new URLSearchParams({ grant_type: "urn:ietf:params:oauth:grant-type:device_code", client_id: "<YOUR_CLIENT_ID>", device_code: deviceCode }), timeout: 10000 // 10 second timeout }) .then((response) => response.json()) .catch((error) => { console.error("Network error:", error); // Retry after a delay setTimeout(() => checkTokenStatus(deviceCode), 5000); }); } ``` ### DNS resolution issues **Problem**: Cannot resolve the Kinde domain. **Solution**: Verify your domain configuration and network connectivity. ```bash # Test DNS resolution nslookup <your-subdomain>.kinde.com # Test connectivity curl -I https://<your-subdomain>.kinde.com/oauth2/v2/device_authorization ```

# Authenticate - Enterprise connections - Manage enterprise connections

> Comprehensive overview of enterprise authentication connections including SAML, Microsoft Entra ID, Google Workspace, Okta, and Cloudflare with provisioning options.

enterprise connections, SAML, Microsoft Entra ID, Google Workspace, Okta, Cloudflare, SSO, JIT provisioning
authenticate

Enterprise authentication is a common method for managing user access to systems in large organizations. Kinde supports a number of enterprise connection types, including: - [Custom SAML](/authenticate/enterprise-connections/custom-saml/) - [Microsoft Entra ID](/authenticate/enterprise-connections/azure/) (was Azure AD) WS Federated or Open ID - [Microsoft Entra ID (SAML)](/authenticate/enterprise-connections/entra-id-saml/) - [Google Workspace](/authenticate/enterprise-connections/custom-saml-google-workspace/) (via SAML) - [Okta](/authenticate/enterprise-connections/okta-saml-connection/) (via SAML) - [Cloudflare](/authenticate/enterprise-connections/cloudflare-saml/) (via SAML) - [LastPass](/authenticate/enterprise-connections/lastpass-sso/) (via SAML) <Aside type="upgrade"> The number of enterprise connections you can have depends on your [Kinde plan](https://kinde.com/pricing/). </Aside> ## Provisioning for enterprise connections Kinde offer a number of provisioning options for enterprise connections, including **just in time (JIT)** provisioning and **pre-provisioning** options. See [Provisioning users with enterprise connections](/authenticate/enterprise-connections/provision-users-enterprise/) ## How identities are handled in enterprise connections Users with enterprise identities in Kinde can’t also have other identity types in Kinde. E.g. a user can have an email identity and a social identity. But if a user has an enterprise identity, they cannot have other identities. In this case, identity information is sourced with the identity provider (IdP) and is managed via the identity provider, not in Kinde. Learn more about [identities in Kinde](/authenticate/about-auth/identity-and-verification/). ## Enterprise connections for B2B businesses Many businesses have businesses for customers (B2B), and use Kinde organizations to manage authentication and access. Kinde lets you set a number of enterprise authentication features at the organization level, see [Enterprise authentication for B2B](/authenticate/enterprise-connections/enterprise-connections-b2b/). ## Session sign out behavior When enterprise connection users sign out, they are only signed out of the Kinde session, they are not signed out of the identity provider. We do not force sign out of the IdP because this could break existing sessions the user is signed into, for other applications. This behavior also applies for social connections, where a third party is the identity provider. ## Routing in enterprise connections When users sign up via an enterprise connection with single-sign-on (SSO), they are routed to the identity provider (IdP) for identity verification. This happens when they select the SSO button on the home screen. You can set up a more seamless routing option using home realm discovery. ### Home realm discovery Home realm discovery routes users based on their email domain. So when a user enters their email and selects the continue button, they are routed to their IdP based on the email domain, to authenticate. For example if the user enters [chris@acme.com](mailto:chris@acme.com) Kinde checks which IdP uses the [**acme.com**](http://acme.com/) domain and silently verifies his identity. He only signs in once. Note that this feature has nothing to do with security or access control and everything to do with routing. Not to be confused with setting access restrictions for [domain allowlists](/authenticate/enterprise-connections/enterprise-connections-b2b/). Learn more about [home realm discovery](/authenticate/enterprise-connections/home-realm-discovery/). ## Show or hide the SSO sign-in button on the auth page When you set up enterprise auth in Kinde, an SSO button appears on the authentication page which is linked to the IdP by default. Users can select this as a sign up method, similar to how they might select a Google or Facebook sign-in option. For a more seamless experience, you can hide the SSO button by entering a home realm domain for the connection (more info above). Users will be routed silently via their IdP when they enter their credentials. If you have multiple enterprise auth methods (E.g. SAML and Entra ID), you may not want to show multiple SSO buttons. Here's the options for showing and hiding, depending how many enterprise auth methods you add: ### (Option 1) Hide all SSO buttons If you configure home realm discovery in each enterprise auth method, all SSO buttons will be hidden by default. The user enters their credentials and they are silently authenticated against the relevant IdP based on email domain. ### (Option 2) Show a universal SSO button for all If you would prefer users explicitly choose to sign in with SSO, you can add a universal button to the sign in screen. 1. Go to **Settings > Applications > Your application**. 2. On the **Details** page scroll down to the **Authentication experience** section. 3. Switch on **Show 'Sign in with SSO' button**. Users click the universal button, enter their credentials, and get routed silently to the IdP for verification. ## Enterprise connections only allow service provider log in, not identity provider log in If you run a B2B business, you might allow your business customers to use their own identity provider setup (like Okta SAML) to access your app. When you set up an enterprise connection to support this, make them aware they can only sign in via your app's auth gateway, with Kinde as the auth service provider. The customer cannot sign in to your app via their own connection setup - also known as IdP-initiated login. ## Disable an enterprise connection <Aside type="danger"> Before you disable a connection, make sure that there are no users relying on it for authentication. Once disabled, the sign in option becomes unavailable to users. </Aside> 1. Navigate to the connection in Kinde. Via **Organization > Authentication** or via **Settings > Authentication**. 2. For an organization-level connection: 1. Select the three dots menu on the connection tile. 2. Select **Disable connection**. 3. Confirm the action in the confirmation window. 3. For an enterprise level connection: 1. Select **Configure** on the connection tile. 2. Scroll down and disable the connection for each application. 3. Select **Save**. Confirm the action in the confirmation message. ## Delete an enterprise connection <Aside type="danger"> Before you delete a connection, make sure that there are no users relying on it for authentication. Once deleted, the sign in option becomes unavailable to users. This action can’t be reversed. </Aside> 1. Navigate to the connection in Kinde. Via **Organization > Authentication** or via **Settings > Authentication**. 2. Select the three dots menu on the connection tile. 3. Select **Delete connection**. 4. Confirm the action in the confirmation window.

# Authenticate - Enterprise connections - Advanced SAML configurations

> Advanced SAML configuration options including Name ID formats, signing algorithms, protocol bindings, and upstream parameters for enterprise authentication.

SAML, Name ID, signing algorithm, protocol binding, upstream parameters, RSA-SHA256, HTTP POST binding
authenticate

When you set up a SAML connection, you might need to include advanced configurations to meet identity provider requirements, and to get the connection running properly and securely. Here's some of the advanced options you will come across when setting up a connection. ## Name ID Name ID (Name Identifier) is a key element in a SAML assertion that uniquely identifies the user (subject) within a given SAML context. It is included in the `Subject` element of the SAML assertion and is critical for identifying and linking user identities between your Identity Provider (IdP) and Kinde. Available Name ID formats: - **Unspecified**: No particular format is required - **EmailAddress**: A user is identified by their email address - **Persistent**: A stable, opaque identifier intended to remain consistent across sessions - **Transient**: A short-lived identifier, often used in single sign-on (SSO) scenarios for one-time use The Name ID you select in Kinde must be supported and configured in your IdP. ## Sign request algorithm The Sign Request Algorithm defines the cryptographic algorithm used to sign SAML requests (AuthnRequest). Signing ensures the authenticity and integrity of SAML messages. Available algorithms: - **RSA-SHA256**: A commonly used and secure option. - **RSA-SHA1**: Older and less secure; often deprecated. Secure configurations favor SHA256 or stronger algorithms to protect against vulnerabilities. ## Protocol binding Protocol Binding refers to the transport mechanism used to send the SAML authentication request from Kinde to your IdP. Common Binding Types: - **HTTP Redirect Binding**: The SAML request is sent as a URL parameter using a GET request. It is lightweight but limited in message size. - **HTTP POST Binding**: The SAML request is sent via an HTML form using the POST method. It supports larger payloads and is commonly used for transmitting signed requests. The choice of binding affects security, performance, and compatibility. POST Binding is generally preferred for secure communications due to its ability to handle signed messages and larger payloads. ## Key attributes Key Attributes are additional pieces of information about the user that come from your IdP to Kinde. These attributes provide more context about the authenticated user and are often used for access control or personalization. Kinde-supported key attributes: - Email Address: The user’s email, often used for identification or communication. - First Name / Last Name: Used for personalization or internal system mapping. - User ID: The attribute in the SAML token that contains the user ID. Only configure key attributes if supported by your IdP. ## Upstream parameters You can pass provider-specific parameters to an Identity Provider (IdP) during authentication. These are also known as 'upstream params'. The values your pass can either be static per connection or dynamic per user. You can use upstream params to create a smoother sign in experience - by passing the email through, or to offer an account switcher (such as the Google account switcher) during sign in. Note that every identity provider has their own set of supported parameters and values, so you'll need to check their documentation to determine which URL parameters are supported. For more information, see [Pass parameters to identity providers](/authenticate/auth-guides/pass-params-idp/).

# Authenticate - Enterprise connections - MS Entra ID (was Azure AD) enterprise auth

> Step-by-step guide to setting up Microsoft Entra ID (formerly Azure AD) enterprise authentication with WS Federated and OAuth 2.0 protocols.

Microsoft Entra ID, Azure AD, WS Federated, OAuth 2.0, enterprise auth, group sync, upstream params
authenticate

Kinde supports the use of Microsoft Entra ID as an authentication method. We support WS Federated and OAuth2.0 (follow the topic below), and [Microsoft Entra ID SAML](/authenticate/enterprise-connections/entra-id-saml/) which is covered in a separate topic. If you [import users into Kinde](/manage-users/add-and-edit/import-users-in-bulk/), their Entra ID will be picked up and matched to the relevant connection based on their email address, for a seamless transition to Kinde. You can also pass [upstream params](/authenticate/auth-guides/pass-params-idp/) to the IdP as part of this procedure. <Aside> **Microsoft Entra ID** used to be known as **Microsoft Azure AD**. [More information](https://learn.microsoft.com/en-gb/azure/active-directory/fundamentals/new-name). </Aside> ## Before you begin - Register an app in the [Microsoft Entra Admin Center](https://entra.microsoft.com/#home) See the docs [here](https://learn.microsoft.com/en-us/entra/identity-platform/quickstart-register-app/). - Copy the Client ID and Client Secret from the Microsoft app. - We recommend you test connections in a non-production environment before activating in a live environment. ## Step 1: Add and configure the connection in Kinde <Aside> You can make a connection available only to a specific organization, or you can create it so it can be used across any organization in your business. </Aside> ### Add a connection for a specific organization 1. Go to **Organizations** and open the organization. 2. In the menu, select **Authentication**, then select **Add connection**. 3. In the **Add connection** window, select **New enterprise connection**, then click **Next**. 4. Select the Microsoft connection type you want (WS Federated or OAuth2.0) and then select **Next**. 5. Next: 'Step 2: Configure the connection'. ### Add a connection that can be shared across multiple organizations 1. Go to **Settings > Environment > Authentication**. 2. Scroll to the **Enterprise connection** section and select **Add connection**. The **Add connection** window opens. 3. Select the Microsoft connection type you want (WS Federated or OAuth2.0) and then select **Save**. 4. Next: 'Step 2: Configure the connection'. ## Step 2: Configure the connection 1. Enter a **Connection name.** Make this something you can easily identify, especially if you are adding multiple connections for different business customers. <Aside type="warning"> If you plan to import users into Kinde, make sure the connection name matches the connection name in the Entra ID record. </Aside> 2. Enter your **Microsoft Entra domain.** ![Configure screen](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/27b313dc-73c7-4bd5-927f-f8f3d5121800/public) 3. Enter the **Client ID** and **Client secret** as they appear in the MS Entra application. Make sure you use the **Value** of the client secret. 4. Enter **Home realm domains**. This speeds up the sign in process for users of those domains. Note that all home realm domains must be unique across all connections in an environment. For more information about how, see [Home realm domains or IdP discovery](/authenticate/enterprise-connections/home-realm-discovery/). 5. If you use home realm domains, the sign in button is hidden on the auth screen by default. To show the SSO button, select the **Always show sign-in button** option. 6. If you want, select the **Use common endpoint** option. Recommended if you use multi-tenancy. ![Provisioning config for entra oauth2](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/c92fad8c-8c81-4481-e891-670a310fe300/public) 7. Select **Extended profile** if you want to sync the additional information stored in a user’s Microsoft profile to their Kinde user profile. Extended attributes data is included in the `extra_claims` object of the access token. 8. If you want to sync user groups, select **Get user groups**. Recommended if you manage permissions and access via user groups in Microsoft. You also need to do some additional setup, see below. 9. Select if you want to treat this connection as a trusted provider. A [trusted provider](/authenticate/about-auth/identity-and-verification/) is one that guarantees the email they issue is verified. We recommend leaving this off for maximum security. 10. If you want, select **Sync user profiles and attributes on sign in**. Recommended to keep Kinde user profile data in sync with user profile data from Microsoft. If you choose this option, ensure that the global profile sync preference is also switched on in **Settings > Environment > Policies**. 11. If you want to enable just-in-time (JIT) provisioning, select the **Create a user record in Kinde** option. This saves time adding users manually or via API later. 12. Add any [upstream params](/authenticate/auth-guides/pass-params-idp/) that you want to pass to the IdP. 13. Copy the **Callback URL**. You’ll need to enter this in your Entra ID app. 14. Select **Save**. ## Step 3: Add the callback URL to your Entra ID app 1. Open your application in the [Portal](https://entra.microsoft.com/#home). 2. Select the **Redirect URIs** links on the right. 3. Select **Add URI**. 4. In the relevant field, enter your callback URL (from the 'Configure the connection' procedure above) 5. Select **Save**. ## Step 4: Enable the connection in Kinde Make sure you test the connection before enabling in production for your users. 1. Open the connection configuration page in Kinde. 2. Switch on the connection. This will make it instantly available to users if this is your production environment. 1. For environment-level connections, scroll down and select the apps that will use the auth method. 2. For organization-level connections, scroll down and select if you want to switch this on for the org. 3. Select **Save**. ## (Optional) Sync Entra ID groups with Kinde ### Add groups claim to MS Entra ID app 1. Open your application in the [Portal](https://entra.microsoft.com/#home). 2. Go to **Token configuration** in the left menu. 3. Select **Add groups claim**. 4. In the window that appears, select the groups to be included in tokens. ![image of edit groups claim screen](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/fed278be-bdcd-43b6-7130-8c866928b700/public) 5. If you want, customize the token properties by type. 6. Save your changes. For reference, see this Microsoft doc about [configuring optional claims](https://learn.microsoft.com/en-us/entra/identity-platform/optional-claims?tabs=appui/) ### Customize ID token in Kinde 1. Open your application in Kinde. 2. Go to **Tokens**. 3. Scroll to **Token customization** and select **Configure** on the **ID tokens** tile. 4. Switch on **Social identity** as an additional claim. 5. Select **Save**. ### Access group info in tokens - ID token - `ext_provider > claims > profile > groups` - Access token - `ext_groups` ## Step 4: Test the connection 1. Go to your test application and attempt to sign in. 2. If you left the **Home realm domains** field blank in Kinde, when you launch your application, you should see a button to sign in. Click it and go to step 4. 3. If you completed the **Home realm domains** field, you should be redirected immediately to your IdP sign in screen. 4. Enter your IdP details and complete any additional authentication required.

# Authenticate - Enterprise connections - Use Cloudflare as a SAML identity provider

> Step-by-step guide to integrating Cloudflare as a SAML identity provider with Kinde for enterprise authentication and access control.

Cloudflare, SAML, identity provider, IdP, Zero Trust, enterprise auth, SSO, access policies
authenticate

If you use Cloudflare to centralize authentication and authorization in your business, you can integrate Kinde as a service provider for these processes. This gives you the benefits of Kinde’s robust auth capabilities, while keeping the familiar Cloudflare structure. You need to set up an enterprise connection in Kinde for this, and add a Cloudflare application. We recommend setting up and testing the connection in a non-production environment before making available to users. ## Advanced configurations Depending on your SAML set up, you may need to include advanced configurations for your connection. See [Advanced SAML configurations](/authenticate/enterprise-connections/advanced-saml-configurations/) ## Step 1: Add the connection in Kinde <Aside> You can make a connection available only to a specific organization, or you can create it so it can be used across any organization in your business. </Aside> ### Add a connection for a specific organization 1. Go to **Organizations** and open the organization. 2. In the menu, select **Authentication**, then select **Add connection**. 3. In the **Add connection** window, select **New enterprise connection**, then click **Next**. 4. Select the Cloudflare connection and then select **Next**. 5. Next: 'Step 2: Configure the connection'. ### Add a connection that can be shared across multiple organizations 1. Go to **Settings > Environment > Authentication**. 2. Scroll to the **Enterprise connection** section and select **Add connection**. The **Add connection** window opens. 3. Select the Cloudflare connection and then select **Next**. 4. Next: 'Step 2: Configure the connection'. ## Step 2: Configure the connection 1. Enter a name for the connection. It should match the connection name in Cloudflare. 2. Enter a random string value for Entity ID, for e.g. `870sa9fbasfasdas23aghkhc12zasfnasd`. 3. Enter the **IdP metadata URL**. This URL comes from your identity provider. ![optional fields for saml](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/4f1851db-5c34-496b-ced1-07c1cd272b00/public) 4. Enter a **sign in URL** if your IdP requires a specific URL. 5. If you want, select the **Sign request algorithm** and **Protocol binding**. The options you choose will depend on what your identity provider prefers or requires. 6. Select a **Name ID** format. This helps identify and link user identities between your IdP and Kinde. 7. Enter an **Email key attribute**. This is the attribute in the SAML token that contains the user’s email. Setting this value ensures that the email address returned in the SAML response is correctly retrieved. We do not recommend leaving this field blank, but if you do we will set ‘email’ as the attribute. 8. (Optional) Add a first name and last name key attribute. ![Home realm domains in SAML configuration](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/dbdccca5-2e6c-4dd8-eaec-e029574daf00/public) 9. Enter any relevant **Home realm domains**. This is how SAML recognizes a user’s credentials and routes them to the correct sign in page. Note that home realm domains need to be unique across all connections in an environment. [Read more about home realm domains](/authenticate/enterprise-connections/home-realm-discovery/). 10. If you use home realm domains, the sign in button is hidden on the auth screen by default. To show the SSO button, select the **Always show sign-in button** option. ![ACS URL and custom domain option](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/885eda9c-ca4f-4340-db17-224023b8c300/public) 11. Copy the relevant reply URL: 1. If you don't use a custom domain, copy the **ACS URL**. 2. If you do use a custom domain, select the **Use custom domain instead** option and copy the custom domain URL. Later, add this URL to your identity provider configuration. 12. If you want to enable just-in-time (JIT) provisioning for users, select the **Create a user record in Kinde** option. This saves time adding users manually or via API later. ![Provisioning configuration for SAML](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/947baea7-bfd4-48b7-de2d-5b041b8c8300/public) 13. (Temporary feature) Select if you want to treat this connection as a trusted provider. A [trusted provider](/authenticate/about-auth/identity-and-verification/) is one that guarantees the email they issue is verified. 14. (Optional) In the **Sign SAML request** section, paste in the **Signed certificate** and **Private key**. You may have got these from your IdP or you may have generated yourself (see procedure above). 15. Enter any [upstream params](/authenticate/enterprise-connections/advanced-saml-configurations/#upstream-parameters) that you want to pass to the identity provider. Not all providers support this, so check their documentation first. 16. Select **Save**. ## Step 3: Add and configure your Cloudflare application 1. Sign in to your Cloudflare account. 2. In the menu, select **Zero trust**. 3. Go to **Access > Applications**, then select **Add an application**. 4. Select SaaS as the type of application. The **Add application** window opens. ![Application settings](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/7a600656-63c7-42a1-73c6-8780c6d4f400/public) 5. Enter an application name or select an application. 6. Choose **Select SAML** for the authentication protocol. 7. Select **Add Application**. The **Configure application** page opens. ![Configure application in Cloudflare](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/64549f6e-4a94-41a0-7018-0fb7b7becf00/public) 7. Add the **Entity ID** and **ACS URL** from Kinde. 8. Copy the **SAML Metadata endpoint** to your clipboard. You'll need to enter this back in Kinde. 9. Scroll through the other sections and then select **Save configuration**. The **Add policies** page opens. 10. Add a policy to define who can access your application. You might do this via an allowlist and groups, or other strategy. 11. Complete any other relevant sections of the window, and then select **Done**. ![Screen shot of Application list in Cloudflare](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/c11f72f1-22ff-428c-a7db-a13493ea5f00/public) ## Step 4: Finish setting up your Cloudflare connection 1. Open the connection in Kinde. Via **Organization > Authentication** or via **Settings > Authentication**. 2. Scroll to the **IdP metadata URL** field and paste the **Metadata URL** you copied from your Cloudflare app. 3. Switch on the connection. This will make it instantly available to users if this is your production environment. 1. For environment-level connections, scroll down and select the apps that will use the auth method. 2. For organization-level connections, scroll down and select if you want to switch this on for the org. 4. Select **Save**.

# Authenticate - Enterprise connections - Custom SAML with Google Workspace

> Step-by-step guide to setting up Google Workspace SAML authentication including metadata file hosting and Admin Console configuration.

Google Workspace, SAML, enterprise auth, metadata hosting, Admin Console, SSO
authenticate

You can set up SAML to work with your Google Workspace. ## Hosting the SAML metadata XML file Google does not support hosting your SAML metadata XML file on their web services, but Kinde requires access to the file via URL so that certificates are always up to date. We recommend you host the file on a public web service that can be accessed by Kinde. For example, you could use an [AWS S3](https://aws.amazon.com/s3/) bucket, [Cloudflare R2](https://developers.cloudflare.com/r2/), or public website. ## Advanced configurations Depending on your SAML set up, you may need to include advanced configurations for your connection. See [Advanced SAML configurations](/authenticate/enterprise-connections/advanced-saml-configurations/). ## Step 1: Add Google Workspace SAML in Kinde You can make a connection available only to a specific organization, or you can create it so it can be used across any organization in your business. ### Add a connection for a specific organization 1. Go to **Organizations** and open the organization. 2. In the menu, select **Authentication**, then select **Add connection**. 3. In the **Add connection** window, select **New enterprise connection**, then click **Next**. 4. Select the connection type you want and then select **Next**. 5. Next: 'Step 2: Configure the connection'. ### Add a connection that can be shared across multiple organizations 1. Go to **Settings > Environment > Authentication**. 2. Scroll to the **Enterprise connection** section and select **Add connection**. The **Add connection** window opens. 3. Select the connection type you want and then select **Next**. 4. Next: 'Step 2: Configure the connection'. ## Step 2: Configure the connection 1. Enter the **Connection name**. This name is what will appear on the button on the authentication screen. We will call it ‘Google Workspace’ for this example. 2. Enter an **Entity ID**. This field can be any mix of numbers and letters, as long as it matches your IdP configuration. Copy this somewhere you can access it later. 3. If you are adding this connection to a live environment, you will be prompted to enter an **IdP Metadata URL** before you can save. If you are not sure of the file location, enter any URL and we will update this later. ![connection window](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/4fa556a1-7f8e-4926-d7ef-a274409e7700/public) 4. Enter a **sign in URL** if your IdP requires a specific URL. 5. If you want, select the **Sign request algorithm** and **Protocol binding**. The options you choose will depend on what your identity provider prefers or requires. 6. Select a **Name ID** format. This helps identify and link user identities between your IdP and Kinde. 7. Enter an **Email key attribute**. This is the attribute in the SAML token that contains the user’s email. Setting this value ensures that the email address returned in the SAML response is correctly retrieved. We do not recommend leaving this field blank, but if you do we will set ‘email’ as the attribute. 8. (Optional) Add a first name and last name key attribute. ![Home realm domains in SAML configuration](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/dbdccca5-2e6c-4dd8-eaec-e029574daf00/public) 9. Enter any relevant **Home realm domains**. This is how SAML recognizes a user’s credentials and routes them to the correct sign in page. Note that home realm domains need to be unique across all connections in an environment. [Read more about home realm domains](/authenticate/enterprise-connections/home-realm-discovery/). 10. If you use home realm domains, the sign in button is hidden on the auth screen by default. To show the SSO button, select the **Always show sign-in button** option. ![ACS URL and custom domain option](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/885eda9c-ca4f-4340-db17-224023b8c300/public) 11. Copy the relevant reply URL: 1. If you don't use a custom domain, copy the **ACS URL**. 2. If you do use a custom domain, select the **Use custom domain instead** option and copy the custom domain URL. Later, add this URL to your identity provider configuration. 12. If you want to enable just-in-time (JIT) provisioning for users, select the **Create a user record in Kinde** option. This saves time adding users manually or via API later. ![Provisioning configuration for SAML](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/947baea7-bfd4-48b7-de2d-5b041b8c8300/public) 13. (Temporary feature) Select if you want to treat this connection as a trusted provider. A [trusted provider](/authenticate/about-auth/identity-and-verification/) is one that guarantees the email they issue is verified. 14. (Optional) In the **Sign SAML request** section, paste in the **Signed certificate** and **Private key**. You may have got these from your IdP or you may have generated yourself (see procedure above). 15. Enter any [upstream params](/authenticate/enterprise-connections/advanced-saml-configurations/#upstream-parameters) that you want to pass to the identity provider. Not all providers support this, so check their documentation first. 16. Select **Save**. ## Step 3: Configure Google Workspace Admin Console 1. Sign in to your [Google Workspace Admin Console](https://admin.google.com/). 2. In the main menu, go to **Apps > Web and Mobile Apps**. 3. Select **Add App > Add custom SAML app.** ![adding custom saml app](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/d02e7219-70e1-437c-41b3-b60263568900/public) 4. Complete the **App details** window: 1. Enter a name in the **App name** field. 2. Enter a **Description** for the app. 3. If you want, upload an icon for the app. 4. Select **Continue**. ![identity details](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/859218b5-4ca0-4fab-2475-3146088dc700/public) 5. Copy the **Google Identity Provider details** by selecting **DOWNLOAD METADATA** under Option 1. This is the file you will need to upload to a file storage location and provide a URL to finish setting up in Kinde. 6. Select **Continue**. ![Service provider details](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/91f8d1a9-bcd0-4b11-702e-c4593ac73d00/public) 7. Enter the **Service provider details**: 1. Enter or paste in the **ACS URL** you copied from Kinde earlier. 2. Enter or paste the **Entity ID**, this needs to match what was entered in Kinde earlier. 3. Set the **Name ID format** as **EMAIL**. 4. Select **Continue**. 8. On the **Attribute mapping** page, select **Finish**. 9. If you want to grant access to other users, select the chevron in the right corner of the **User access** panel. This opens additional options. ![user access panel](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/c7e3c185-e1db-49b2-8e02-25ca7320cf00/public) 10. If you want, you can change the access to suit your organization’s needs. You can do this per Organizational unit or switch **ON for everyone.** 11. Select **Save**. ## Step 4: Upload metadata file As mentioned at the start, you need to upload the **metadata file** that you downloaded, to somewhere publicly accessible. This is because Google does not provide a publicly available URL for the metadata file. 1. Upload the metadata file to your storage location. 2. Copy the URL for the file. ## Step 5: Complete Kinde configuration 1. Open the connection's configuration page in Kinde. 2. In the **IdP metadata URL** field, paste the URL for the metadata file. 3. Switch on the connection. This will make it instantly available to users if this is your production environment. 1. For environment-level connections, scroll down and select the apps that will use the auth method. 2. For organization-level connections, scroll down and select if you want to switch this on for the org. 4. Select **Save**. ## Test the connection Once you have completed the above steps, you should be able to see a **Google Workspace** sign-in button on your product’s authentication screen. Note: if you gave the enterprise connection a different name in Kinde, the button will have the name you entered. If you can’t see the button: - Check that the metadata URL and other connection details are correct in Kinde. - Check that user access is set up in your app, in the Google Workspace Console. Try to sign in and hopefully - success!!

# Authenticate - Enterprise connections - Custom authentication with SAML

> Complete guide to setting up custom SAML authentication with any identity provider including certificate generation, advanced configurations, and testing.

SAML, custom SAML, identity provider, IdP, service provider, SP, certificate, private key, JIT provisioning
authenticate

In Kinde, you can use SAML as your authentication protocol. Kinde acts as a service provider (SP), so you still need to bring your own identity provider (IdP) to set it up. Identity providers can include Google, Microsoft, Cloudflare, and others. Note: Since there are differences between set ups for each IdP, we are unable to provide full details on how to configure them all to connect with Kinde. However, the fields we mention below, should have similar names in your IdP. Some concepts are explained in the [advanced SAML configurations](/authenticate/enterprise-connections/advanced-saml-configurations/) topic. ## User provisioning Before you set up SAML, you can [import users in bulk](/manage-users/add-and-edit/import-users-in-bulk/), add them via [API](/kinde-apis/management#tag/users/post/api/v1/user), or [manually](/manage-users/add-and-edit/add-and-edit-users/) in Kinde. Alternatively, you can also take advantage of just-in-time (JIT) provisioning (Step 13 below) when you set up the connection. ## (Optional) Signed certificate and private key You can increase SAML security by adding a certificate and private key pair to your setup. Your IdP will check that the certificate and private key matches, each time a user authenticates this way. You can obtain the certificate and key from your IdP or you can generate yourself, see below. ### Generate a certificate and private key pair 1. In your preferred system, run a command to generate a certificate and key. For example, on \*nix systems, the command is: `openssl req -x509 -nodes -sha256 -days 3650 -newkey rsa:2048 -keyout private_key.key -out certificate.crt`. 2. This command may also work in other systems, such as WSL on Windows. Alternatively, you can try installing openssl binaries for your system. 3. Once the files are generated, save them locally. 4. Add the certificate to your IdP settings. The certificate there and the one in Kinde must match exactly. Instructions for how to do this varies, depending on your IdP. 5. Copy the certificate and private key details into Kinde as per the procedure below. ## Advanced configurations Depending on your SAML set up, you may need to include advanced configurations for your connection. See [Advanced SAML configurations](/authenticate/enterprise-connections/advanced-saml-configurations/) ## Step 1: Add SAML connection in Kinde ### Add a connection for a specific organization 1. Go to **Organizations** and open the organization. 2. In the menu, select **Authentication**, then select **Add connection**. 3. In the **Add connection** window, select **New enterprise connection**, then click **Next**. 4. Select the connection type you want and then select **Next**. 5. Next: 'Step 2: Configure the connection'. ### Add a connection that can be shared across multiple organizations 1. Go to **Settings > Environment > Authentication**. 2. Scroll to the **Enterprise connection** section and select **Add connection**. The **Add connection** window opens. 3. Select the connection type you want and then select **Next**. 4. Next: 'Step 2: Configure the connection'. ## Step 2: Configure the connection 1. Enter a name for the connection. It must match the name in your SAML setup. 2. Enter an **Entity ID.** This is a value you can make up using a random alphanumeric string, e.g. `5836g209gbhw09r8y0913`. The Entity ID you enter here must be configured exactly the same in your identity provider (unless your IdP is Microsoft Azure). ![SAML configuration screen](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/740dba80-b1a3-410e-f03b-c07e9261f000/public) 3. If Microsoft is your provider and your app is a bit older, you may need to add `spn:` to the beginning of the **Entity ID** string in Kinde, e.g. `spn:5836g209gbhw09r8y0913`. This is not required for newly created apps. 4. Enter the **IdP metadata URL**. This URL comes from your identity provider. ![optional fields for saml](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/4f1851db-5c34-496b-ced1-07c1cd272b00/public) 5. Enter a **sign in URL** if your IdP requires a specific URL. 6. If you want, select the **Sign request algorithm** and **Protocol binding**. The options you choose will depend on what your identity provider prefers or requires. 7. Select a **Name ID** format. This helps identify and link user identities between your IdP and Kinde. 8. Enter an **Email key attribute**. This is the attribute in the SAML token that contains the user’s email. Setting this value ensures that the email address returned in the SAML response is correctly retrieved. We do not recommend leaving this field blank, but if you do we will set ‘email’ as the attribute. 9. (Optional) Add a first name and last name key attribute. ![Home realm domains in SAML configuration](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/dbdccca5-2e6c-4dd8-eaec-e029574daf00/public) 10. Enter any relevant **Home realm domains**. This is how SAML recognizes a user’s credentials and routes them to the correct sign in page. Note that home realm domains need to be unique across all connections in an environment. [Read more about home realm domains](/authenticate/enterprise-connections/home-realm-discovery/). 11. If you use home realm domains, the sign in button is hidden on the auth screen by default. To show the SSO button, select the **Always show sign-in button** option. ![ACS URL and custom domain option](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/885eda9c-ca4f-4340-db17-224023b8c300/public) 12. Copy the relevant reply URL: 1. If you don't use a custom domain, copy the **ACS URL**. 2. If you do use a custom domain, select the **Use custom domain instead** option and copy the custom domain URL. Later, add this URL to your identity provider configuration. 13. If you want to enable just-in-time (JIT) provisioning for users, select the **Create a user record in Kinde** option. This saves time adding users manually or via API later. ![Provisioning configuration for SAML](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/947baea7-bfd4-48b7-de2d-5b041b8c8300/public) 14. (Temporary feature) Select if you want to treat this connection as a trusted provider. A [trusted provider](/authenticate/about-auth/identity-and-verification/) is one that guarantees the email they issue is verified. 15. (Optional) In the **Sign SAML request** section, paste in the **Signed certificate** and **Private key**. You may have got these from your IdP or you may have generated yourself (see procedure above). 16. Enter any [upstream params](/authenticate/enterprise-connections/advanced-saml-configurations/#upstream-parameters) that you want to pass to the identity provider. Not all providers support this, so check their documentation first. 17. Switch on the connection. This will make it instantly available to users if this is your production environment. 1. For environment-level connections, scroll down and select the apps that will use the auth method. 2. For organization-level connections, scroll down and select if you want to switch this on for the org. 18. Select **Save**. Next: Complete any additional configuration in your identity provider’s settings, such as adding the **Entity ID** and **return URL**. ## Step 3: Test the connection Once you have entered the ACS URL in your identity provider, the connection should be enabled. 1. Go to your test application and attempt to sign in. 2. If you left the **Home realm domains** field blank in Kinde, when you launch your application, you should see a button to sign in. Click it and go to step 4. 3. If you completed the **Home realm domains** field, you should be redirected immediately to your IdP sign in screen. 4. Enter your IdP details and complete any additional authentication required.

# Authenticate - Enterprise connections - Enterprise connections for B2B

> Guide to setting up enterprise connections for B2B businesses including organization-level connections and domain-based access control.

B2B, enterprise connections, organization-level, domain restrictions, JIT provisioning, allowed domains
authenticate

<Aside type="upgrade"> For multiple enterprise connections and other advanced organization features, you may need to [upgrade your plan](https://kinde.com/pricing/) </Aside> Enterprise connections are common for B2B setups where each business customer is represented as an organization in Kinde, and that organization is linked to one or more connections. There are two different ways to scope an enterprise connection and restrict it to the organization level. - When the `org_code` is passed to Kinde as part of the authentication url, the correct sign-in options are shown. - Users can only self-join the organization if this was enabled as part of the connection configuration. - Organization access is locked down to allow access based only on connection - including switches between organizations. - If you are using home realm discovery, connections do not have to be enabled at the application level to support redirects to the correct IDP. This behaviour is domain-agnostic and is purely concerned with the connection being used. ## (Recommended) Create the enterprise connection in the Kinde organization The easiest way to restrict an enterprise connection to an organization, is to add the connection to the organization and not create it as a shared connection (at the environment level). To do this, follow the relevant procedure for adding a connection in the relevant topic. ## Select a shared enterprise connection for the organization 1. Open the relevant organization in Kinde and select **Authentication** in the menu. 2. Add a connection and select **existing connection**. Switch on the relevant enterprise connection from the list. 3. Select **Save**. ## Org provisioning and access via allowed domains To manage organization access, you can [set policies](/build/organizations/organization-access-policies/) that restrict access to a list of allowed domains. You can also enable just-in-time (JIT) provisioning via allowed domains. 1. Open the relevant organization in Kinde and select **Policies** in the menu. 2. Select **Allow org members to be auto-added**. 3. Enter all the allowed domains in the **Allowed domains** list. 4. Enable JIT provisioning for all new organization members by selecting **Auto-add users from allowed domains**. 5. Select **Save**. Here’s what happens: - When the `org_code` is passed to Kinde as part of the authentication url, the correct sign-in option is shown. - Kinde checks that users belong to one of the allowed domains before authorizing access. - The user joins the organization if the domain matches any of the allowed domains. - Because this check only happens during sign up, you can still separately add users with email domains which fall outside of this restriction. This can be useful if you wish to add contractors or auditors who may have email addresses not in the domain allowlist. <Aside> If both enterprise connection and domain restrictions are in place, both checks must be successful. </Aside> ## Enterprise connections only allow service provider log in, not identity provider log in If you set up an enterprise connection for a customer using their IdP credentials, they can only sign in to your app via your app, with Kinde as the auth service provider. The customer cannot sign in to your app via their own connection setup - known as IdP-initiated login.

# Authenticate - Enterprise connections - MS Entra ID (SAML) enterprise connection

> Step-by-step guide to setting up Microsoft Entra ID SAML enterprise authentication including application configuration and group synchronization.

Microsoft Entra ID, SAML, Azure AD, enterprise application, group claims, federation metadata
authenticate

Kinde supports the use of Microsoft Entra ID (SAML) as an enterprise-level authentication method. This service used to be Azure AD. If you are [importing users into Kinde](/manage-users/add-and-edit/import-users-in-bulk/), their Entra ID will be picked up and matched to the relevant connection based on their email address, for a seamless transition to Kinde. <Aside> **Microsoft Entra ID** is the new name for **Microsoft** **Azure AD**, which is Microsoft’s enterprise authentication service. This doc may contain some mixed references. [More information](https://learn.microsoft.com/en-gb/azure/active-directory/fundamentals/new-name). </Aside> ## Before you begin - You need a Microsoft developer account to register an application. - Test the connection in a non-production environment before activating in a live environment. ## Advanced configurations Depending on your SAML set up, you may need to include advanced configurations for your connection. See [Advanced SAML configurations](/authenticate/enterprise-connections/advanced-saml-configurations/). ## Step 1: Add the connection in Kinde <Aside> You can make a connection available only to a specific organization, or you can create it so it can be used across any organization in your business. </Aside> ### Add a connection for a specific organization 1. Go to **Organizations** and open the organization. 2. In the menu, select **Authentication**, then select **Add connection**. 3. In the **Add connection** window, select **New enterprise connection**, then click **Next**. 4. Select the Microsoft connection type you want and then select **Next**. Currently we support WS Federated and OpenID types. 5. Next: 'Step 2: Configure the connection'. ### Add a connection that can be shared across multiple organizations 1. Go to **Settings > Environment > Authentication**. 2. Scroll to the **Enterprise connection** section and select **Add connection**. The **Add connection** window opens. 3. Select the Microsoft connection type you want and then select **Next**. Currently we support WS Federated, SAML, and OpenID types. 4. Next: 'Step 2: Configure the connection'. ## Step 2: Configure the connection in Kinde 1. Enter a **Connection name.** Make this something you can easily identify, especially if you are adding multiple connections for different business customers. <Aside type="warning"> If you plan to import users into Kinde, make sure the connection name matches the connection name in the Entra ID record. </Aside> 2. For the **Entity ID**, enter a random string like `hEb876ZZlkg99Dwat64Mnbvyh129`. Make a copy of the string as you will add this to your SAML application later. Note that some older Entra ID tenants require the Entity ID to have a prefix of `spn:` If your connection fails, this could be why. 3. Enter the **IdP metadata URL**. This URL comes from your identity provider. If you don't know it, enter any URL and update this later. 4. Enter a **sign in URL** if your IdP requires a specific URL. ![optional fields for saml](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/4f1851db-5c34-496b-ced1-07c1cd272b00/public) 5. If you want, select the **Sign request algorithm** and **Protocol binding**. The options you choose will depend on what your identity provider prefers or requires. 6. Select a **Name ID** format. This helps identify and link user identities between your IdP and Kinde. 7. Enter an **Email key attribute**. This is the attribute in the SAML token that contains the user’s email. Setting this value ensures that the email address returned in the SAML response is correctly retrieved. We do not recommend leaving this field blank, but if you do we will set ‘email’ as the attribute. 8. (Optional) Add a first name and last name attribute. 9. Enter **Home realm domains**. This speeds up the sign in process for users of those domains. Note that all home realm domains must be unique across all connections in an environment. For more information, see [Home realm domains or IdP discovery](/authenticate/enterprise-connections/home-realm-discovery/). ![SAML configuration screen](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/dbdccca5-2e6c-4dd8-eaec-e029574daf00/public) 10. If you use home realm domains, the sign in button is hidden on the auth screen by default. To show the SSO button, select the **Always show sign-in button** option. 11. Copy the relevant reply URL: 1. If you don't use a custom domain, copy the **ACS URL**. 2. If you do use a custom domain, select the **Use custom domain instead** option and copy the custom domain URL. Later, add this URL to your identity provider configuration. ![ACS URL and custom domain option](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/885eda9c-ca4f-4340-db17-224023b8c300/public) 12. If you want to enable just-in-time (JIT) provisioning, select the **Create a user record in Kinde** option. This saves time adding users manually or via API later. 13. Select if you want to treat this connection as a trusted provider. A [trusted provider](/authenticate/about-auth/identity-and-verification/) is one that guarantees the email they issue is verified. We recommend leaving this off for maximum security. 14. Enter any [upstream params](/authenticate/enterprise-connections/advanced-saml-configurations/#upstream-parameters) that you want to pass to the identity provider. Not all providers support this, so check their documentation first. 15. Select **Save**. ## Step 3: Create and configure an Entra ID enterprise application 1. On the [Microsoft Entra admin center](https://entra.microsoft.com/#home) home screen, select **Applications > Enterprise Applications**. 2. Select **New application** and in the next screen select **Create your own application**. A side panel opens. 3. Enter the name for the application. 4. Select the **Integrate any other application you don't find in the gallery (Non-gallery)** option and then select **Create**. It can take a few seconds for the application to be created. 5. Select **Get started** on the **2. Set up single sign on** tile, then select the SAML tile. 6. Edit the **Basic SAML Configuration**. The side panel opens. ![SAML config side panel](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/cb24d39d-07a8-4622-bf7f-2f8eeca1fb00/public) 7. Select **Add identifier**, then enter the same random string like you did previously for the Entity ID in Kinde. E.g. `hEb876ZZlkg99Dwat64Mnbvyh129`. 8. Select **Add reply URL** and paste the ACS URL that you copied from the connection configuration screen in Kinde, then select **Save**. 9. Close the panel. 10. Select **Edit** on the **Attributes & Claims** section. Copy the values of the identifiers (Principal name, Given name, Surname), for example: ![Example identifiers to copy](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/79037f34-5b20-443f-39ca-d3cb70e9b800/public) 11. In the **SAML certificates** section, copy the **App federation metadata URL**. You'll add this as the **IdP metadata URL** in the Kinde connection. 12. Download the Federation metadata XML file. This is the SAML signed certificate. ## Step 4: Finish configuring the connection in Kinde 1. Open the SAML connection in Kinde. Via **Organization > Authentication** or via **Settings > Authentication**. 2. Paste in the data you got from the SAML app: - IdP metadata URL 3. Update the attributes - Email key attribute (Email), such as `http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress` - First name attribute (Given name), such as `http://schemas.xmlsoap.org/ws/2005/05/identity/claims/givenname` - Last name attribute (Surname), such as `http://schemas.xmlsoap.org/ws/2005/05/identity/claims/surname` 4. (Optional) if you want to sign the SAML httpRequest: 1. Open the **Federation Metadata XML** file in a text editor. 2. Copy the certificate and private contents of the file to the Sign SAML request section. 5. Paste them into the **Signing certificate** field in the Kinde connection. 6. Switch on the connection. This will make it instantly available to users if this is your production environment. 1. For environment-level connections, scroll down and select the apps that will use the auth method. 2. For organization-level connections, scroll down and select if you want to switch this on for the org. 7. Select **Save**. ## Step 5: Test the connection Make sure you test the connection before enabling in production for your users. 1. Go to your test application and attempt to sign in. 2. If you left the **Home realm domains** field blank in Kinde, when you launch your application, you should see a button to sign in. Click it and go to step 4. 3. If you completed the **Home realm domains** field, you should be redirected immediately to your IdP sign in screen. 4. Enter your IdP details and complete any additional authentication required. ## Sign out behaviour for user session If your users sign in via the Entra ID (formerly Azure AD) enterprise connection in Kinde, when they sign out, they are just signing out of Kinde. They are not fully being signed out of Entra ID. It also works this way for social connections, where a third party is the identity provider. ## (Optional) Sync Entra ID groups with Kinde ### Add groups claim to MS Entra ID app 1. Open your application in the [MS Azure Portal](https://portal.azure.com/). 2. Go to **Token configuration** in the left menu. 3. Select **Add groups claim**. 4. In the window that appears, select the groups to be included in tokens. ![image of edit groups claim screen](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/fed278be-bdcd-43b6-7130-8c866928b700/public) 5. If you want, customize the token properties by type. 6. Save your changes. For reference, see this Microsoft doc about [configuring optional claims](https://learn.microsoft.com/en-us/entra/identity-platform/optional-claims?tabs=appui/) ### Customize ID token in Kinde 1. Open your application in Kinde. 2. Go to **Tokens**. 3. Scroll to **Token customization** and select **Configure** on the **ID tokens** tile. 4. Switch on **Social identity** as an additional claim. 5. Select **Save**. ### Access group info in tokens - ID token - `ext_provider > claims > profile > groups` - Access token - `ext_groups`

# Authenticate - Enterprise connections - Home realm or IdP discovery

> Guide to home realm discovery (HRD) for seamless enterprise authentication routing based on email domains and identity provider selection.

home realm discovery, HRD, IdP discovery, email domain routing, enterprise auth, SSO button
authenticate

Home realm discovery (HRD) provides a seamless sign-in experience for your enterprise auth users. When HRD is configured and a user sign in, Kinde checks which IdP or connection group a user belongs to, before authenticating them. It is also known as Identity Provider or IdP discovery. When HRD is set up in Kinde, users are authenticated based on the **Home Realm Domain** (email domain) that is entered. HRD is usually applied where your identity provider (IdP) is a third party, such as Microsoft Entra ID, Google, Cloudflare, etc, and you are using an enterprise or SAML auth setup. By default, Kinde provides a universal login page where users of any enterprise connection can sign in. They are then silently routed and verified via the relevant IdP. ## How it works When you set up a [Microsoft Entra ID](/authenticate/enterprise-connections/azure/) or [custom SAML](/authenticate/enterprise-connections/custom-saml/) connection, you’ll configure the home realm (or domains) to be recognized during authentication. All home realm domains must be unique across all connections in the environment. If HRD is not in place, the end-user must select the relevant log in button to be taken through to the right authentication URL. When you apply HRD in Kinde, the end-user is recognized and authenticated based on their email domain, without having to select or click anything. For example, you could configure two different connections as follows: - Email addresses ending with `enterpriseA.com` use SAML connection A - Email addresses ending with `enterpriseB.com` use Entra ID connection B In the back end, the end-user is linked to the correct identity provider via the connection, and they are silently authenticated. So when Jude Watson arrives at the sign in window and enters `judewatson@enterpriseA.com`, they are routed to the IdP for SAML connection A, and authenticated. ## Showing or hiding the sign in buttons Even if you have set up HRD, you can choose to show an SSO sign in button so the user has to click to proceed. Learn more [here](/authenticate/enterprise-connections/about-enterprise-connections/#show-or-hide-the-sso-sign-in-button-on-the-auth-page).

# Authenticate - Enterprise connections - Use LastPass as a SAML identity provider

> Step-by-step guide to integrating LastPass as a SAML identity provider with Kinde for enterprise authentication and access control.

LastPass, SAML, identity provider, IdP, enterprise auth, SSO, access policies
authenticate

If you use LastPass to centralize authentication and authorization in your business, you can integrate Kinde as a service provider for these processes. This gives you the benefits of Kinde’s robust auth capabilities, while keeping the familiar LastPass structure. ## Before you begin Here's what you need to do before you add the connection: - Sign up for a LastPass business account to add a LastPass application. - Generate a SAML Metadata XML file as LastPass does not support hosting this for you (more information below). ## Recommendations - Open the Kinde Enterprise connection in one browser tab, and the LastPass app configuration in another tab, as you will need to copy connection information across between them. - Set up and testing the connection in a non-production environment before making available to users. ## Advanced configurations Depending on your SAML set up, you may need to include advanced configurations for your connection. See [Advanced SAML configurations](/authenticate/enterprise-connections/advanced-saml-configurations/) ## Step 1: Add the connection in Kinde <Aside> You can make a connection available only to a specific organization, or you can create it so it can be used across any organization in your business. </Aside> ### Add a connection for a specific organization 1. Go to **Organizations** and open the organization. 2. In the menu, select **Authentication**, then select **Add connection**. 3. In the **Add connection** window, select **New enterprise connection**, then click **Next**. 4. Select the LastPass connection and then select **Next**. 5. Next: 'Step 2: Configure the connection'. ### Add a connection that can be shared across multiple organizations 1. Go to **Settings > Environment > Authentication**. 2. Scroll to the **Enterprise connection** section and select **Add connection**. The **Add connection** window opens. 3. Select the LastPass connection and then select **Next**. 4. Next: 'Step 2: Configure the connection'. ## Step 2: Configure the connection 1. Enter a name for the connection. It should match the connection name in LastPass. 2. Enter a random string value for Entity ID, for e.g. `870sa9fbasfasdas23aghkhc12zasfnasd`. 3. Enter the **IdP metadata URL**. This URL comes from your identity provider. ![optional fields for saml](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/4f1851db-5c34-496b-ced1-07c1cd272b00/public) 4. Enter a **sign in URL** if your IdP requires a specific URL. 5. If you want, select the **Sign request algorithm** and **Protocol binding**. The options you choose will depend on what your identity provider prefers or requires. 6. Select `Email` as the **Name ID** format. This helps identify and link user identities between your IdP and Kinde. 7. Enter `emailAddress` as the **Email key attribute**. This is the attribute in the SAML token that contains the user’s email. Setting this value ensures that the email address returned in the SAML response is correctly retrieved. 8. (Optional) Add a first name and last name key attribute. This is not necessary for LastPass. ![Home realm domains in SAML configuration](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/dbdccca5-2e6c-4dd8-eaec-e029574daf00/public) 9. Enter any relevant **Home realm domains**. This is how SAML recognizes a user’s credentials and routes them to the correct sign in page. Note that home realm domains need to be unique across all connections in an environment. [Read more about home realm domains](/authenticate/enterprise-connections/home-realm-discovery/). 10. If you use home realm domains, the sign in button is hidden on the auth screen by default. To show the SSO button, select the **Always show sign-in button** option. ![ACS URL and custom domain option](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/885eda9c-ca4f-4340-db17-224023b8c300/public) 11. Copy the relevant reply URL: 1. If you don't use a custom domain, copy the **ACS URL**. 2. If you do use a custom domain, select the **Use custom domain instead** option and copy the custom domain URL. Later, add this URL to the LastPass configuration. 12. If you want to enable just-in-time (JIT) provisioning for users, select the **Create a user record in Kinde** option. This saves time adding users manually or via API later. ![Provisioning configuration for SAML](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/947baea7-bfd4-48b7-de2d-5b041b8c8300/public) 13. (Temporary feature) Select if you want to treat this connection as a trusted provider. A [trusted provider](/authenticate/about-auth/identity-and-verification/) is one that guarantees the email they issue is verified. 14. (Optional) In the **Sign SAML request** section, paste in the **Signed certificate** and **Private key**. You may have got these from your IdP or you may have generated yourself (see procedure above). 15. Enter any [upstream params](/authenticate/enterprise-connections/advanced-saml-configurations/#upstream-parameters) that you want to pass to the identity provider. Not all providers support this, so check their documentation first. 16. Select **Save**. ## Step 3: Add and configure your LastPass application View the [LastPass docs](https://support.lastpass.com/s/document-item?language=en_US&bundleId=lastpass&topicId=LastPass/uac_applications_sso_apps.html&_LANG=enus) for the full procedure. 1. Sign in to your LastPass business account. 2. In the menu, select **AdminConsole**. 3. Go to **Applications**, then select **SSO apps**. 4. Select **Search the catalogue**. A side panel slides out. ![Initialize SAML keys in LastPass](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/b11e3815-b261-4960-e4c3-6d26ce297800/public) 6. Follow the prompt to initialize SAML keys. This will take up to 15 minutes to process. 7. Refresh the page and select **Search the catalogue** again. The side panel slides out showing a list. 8. Scroll and select **Custom service**. 9. Select **Add a new domain** if prompted. The configuration panel opens. ![Add app name](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/c87f07cb-3284-4ddd-f346-7e8b2dfd8400/public) 10. Enter a **Name** and select which groups will be able to sign in using this SSO connection. 11. At the top of the **Configuration section** select **Export SAML IdP Metadata**. 12. Select Copy or download, then select **OK**. ![Configure application in LastPass](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/bf384b65-ff19-490d-974d-34d807519700/public) 13. In the **Service Provider entity ID** field, enter the random ID you generated for the **Entity ID** in Kinde. 14. In the **Assertion consumer service** field, enter the **ACS URL** or your custom domain, from Kinde. 15. Make sure the **Name ID format** is `emailAddress` and the **Name ID** is `Email address'. 16. Enter any custom attributes required. ![Custom attributes in LastPass](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/cd749576-b884-42e9-d7cb-caf6bca32400/public) 17. Select **View key** under the **Key field**. 18. Copy the key. You will need this to finishe setting up the Kinde connection. 19. Make sure the **Service is enabled** option is selected. 20. Select **Save**. ## Step 4: Finish setting up your LastPass connection in Kinde 1. Open the connection in Kinde. Go to **Organization > Authentication** or via **Settings > Authentication**. 2. In the **IdP metadata URL** field paste the **IDP Entity ID** you copied from LastPass. 3. In the **Sign-in URL** field paste the **Single Sign-on URL** you copied from LastPass. 4. In the **Signing certificate** field paste the **IDP Metadata XML** file content. [@Viv not sure about this - is this where hosting the certificate is advised??] 5. In the **Private key** field paste in the **Key** you copied from LastPass. 6. Switch on the connection. This will make it instantly available to users if this is your production environment. 1. For environment-level connections, scroll down and select the apps that will use the auth method. 2. For organization-level connections, scroll down and select if you want to switch this on for the org. Note that it will be automatically available for all apps if you choose this option. 7. Select **Save**. Test the connection works by trying to sign in to your test environment using this method. Re-test when you deploy the option to users.

# Authenticate - Enterprise connections - Mapping and syncing users for enterprise auth

> Guide to mapping and syncing users for enterprise authentication including user ID mapping, profile sync, and webhook integration.

user mapping, user syncing, enterprise auth, webhooks, profile sync, user ID, API integration
authenticate

When you use Kinde to authenticate users via an enterprise connection such as SAML, you also need a way for users to be identified in Kinde so they match the identities stored in your Identity Provider (IdP). In general, an email address can be used to map users across systems, but because enterprise connection users can have aliases and proxy addresses, there are better ways to keep identities in sync. Here’s how we recommend mapping user profiles and keeping them synced for enterprise connections. ## Map the Kinde user ID to your product When users are imported or added to Kinde, a unique user ID is generated. For example, `kp:1876b10742894a0c9M8e725048e7a323`. We recommend you map each user’s Kinde ID back to your product, and use this as the primary auth identifier. This will keep profiles in sync and support a seamless authentication experience. ### Get Kinde user IDs via API You can access user IDs [via the API](http://localhost:4321/kinde-apis/management#tag/users/post/api/v1/users/{user_id}/identities) by calling GET `/api/v1/users`. This will return a response with a users array with the following data: ```json { "code": "string", "message": "string", "users": [ { "id": "string", "provided_id": "string", "email": "string", "username": "string", "last_name": "string", "first_name": "string", "is_suspended": true, "picture": "string", "total_sign_ins": 0, "failed_sign_ins": 0, "last_signed_in": "string", "created_on": "string", "organizations": ["string"], "identities": [ { "type": "string", "identity": "string" } ] } ], "next_token": "string" } ``` Where: - `id` is the kinde ID - `provided_id` is the ID you may have provided when you imported your users. This ID can also be useful to match imported users to your local database records. ## Switch on profile sync As part of your business authentication setup, we recommend switching on user profile sync to keep enterprise and social profiles up to date across providers. 1. Go to **Settings > Policies**. 2. Switch on **Sync user profiles on sign in**. 3. Select **Save**. ## Sync users with webhooks Webhooks are a method of being notified when an event occurs in Kinde, e.g. a user is created. You can [register your own endpoint URLs](/integrate/webhooks/add-manage-webhooks/) in Kinde, and each time the event occurs, data for that event will be sent to your endpoint. Here’s some examples of webhook events that can be used to keep your users in sync: - `user.created` - when a user is created in Kinde either via the admin UI or registering - `user.updated` - when a user is added to an organization, or their roles or permissions change - `user.deleted` - when a user is deleted via the UI or via the API Here’s an example json schema for user.updated that could be used to sync your data: ```json { "id": "et_018df239698d29177684be3f5ad1266d", "code": "user.updated", "name": "User updated", "origin": "kinde", "schema": { "$id": "https://kinde.com/user.updated.schema.json", "type": "object", "title": "User Updated Webhook Event", "$schema": "https://json-schema.org/draft/2020-12/schema", "properties": { "data": { "type": "object", "properties": { "user": { "type": "object", "properties": { "id": { "type": "string", "pattern": "kp[:_][0-9a-f]{32}", "description": "ID of the user" }, "phone": { "type": ["null", "string"] }, "last_name": { "type": ["string", "null"], "description": "The users updated last name" }, "first_name": { "type": ["string", "null"], "description": "The users updated first name" }, "is_suspended": { "type": "boolean", "description": "The users updated status" }, "organizations": { "type": ["array", "null"], "items": [ { "type": "object", "properties": { "code": { "type": "string", "pattern": "org[:_][0-9a-f]{11}" }, "roles": { "type": ["array", "null"], "items": [ { "type": "object", "properties": { "id": { "type": "string", "format": "uuid" }, "key": { "type": "string" } } } ] }, "permissions": { "type": ["array", "null"], "items": [ { "type": "object", "properties": { "id": { "type": "string", "format": "uuid" }, "key": { "type": "string" } } } ] } } } ] }, "is_password_reset_requested": { "type": "boolean", "description": "The users updated password reset status" } }, "description": "User event data" } }, "description": "Webhook event data" }, "type": { "constant": "user.updated" }, "source": { "enum": ["api", "admin"], "description": "Source of the action" }, "event_id": { "type": "string", "pattern": "event_[0-9a-f]{32}", "description": "ID of the event" }, "timestamp": { "type": "string", "format": "date-time", "description": "Datetimestamp of the action" } }, "description": "Webhook detail the user updated event" }, "version": 1 } ``` You can see a full list of events in the Kinde UI under **Settings > Webhooks**, or by calling the [Kinde management API](/kinde-apis/management#tag/webhooks) which also provides the JSON schema GET `/api/v1/event_types`. Read more [about webhooks](/integrate/webhooks/about-webhooks/).

# Authenticate - Enterprise connections - Use Okta as a SAML identity provider

> Step-by-step guide to integrating Okta as a SAML identity provider with Kinde, including application setup and troubleshooting.

Okta, SAML, identity provider, IdP, enterprise auth, SSO, application assignment
authenticate

If you use Okta to centralize authentication and authorization in your business, you can integrate Kinde as a service provider for these processes. This gives you the benefits of Kinde’s robust auth capabilities, while keeping the familiar Okta structure. You need to set up an enterprise connection in Kinde for this, and add an Okta application. See steps below. ## Advanced configurations Depending on your SAML set up, you may need to include advanced configurations for your connection. See [Advanced SAML configurations](/authenticate/enterprise-connections/advanced-saml-configurations/). ## Step 1: Add an Okta connection in Kinde ### Add a connection for a specific organization 1. Go to **Organizations** and open the organization. 2. In the menu, select **Authentication**, then select **Add connection**. 3. In the **Add connection** window, select **New enterprise connection**, then click **Next**. 4. Select the Okta connection and then select **Next**. 5. Next: 'Step 2: Configure the connection'. ### Add a connection that can be shared across multiple organizations 1. Go to **Settings > Environment > Authentication**. 2. Scroll to the **Enterprise connection** section and select **Add connection**. The **Add connection** window opens. 3. Select the Okta connection and then select **Save**. 4. On the tile for the new connection, select **Configure**. 5. Next: 'Step 2: Configure the connection'. ## Step 2: Configure the connection 1. Enter a name for the connection. 2. Enter a random value for the **Entity ID**, e.g. `870sa9fbasfasdas23aghkhc12zasfnasd`. ![Okta connection config window](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/a06249d4-d368-43f7-bba1-9df10d80aa00/public) 3. Enter the **IdP metadata URL**. This URL comes from your identity provider. If you haven't set up your app yet, you can add this later. ![optional fields for saml](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/4f1851db-5c34-496b-ced1-07c1cd272b00/public) 4. Enter a **sign in URL** if your IdP requires a specific URL. 5. If you want, select the **Sign request algorithm** and **Protocol binding**. The options you choose will depend on what your identity provider prefers or requires. 6. Select a **Name ID** format. This helps identify and link user identities between your IdP and Kinde. 7. Enter an **Email key attribute**. This is the attribute in the SAML token that contains the user’s email. Setting this value ensures that the email address returned in the SAML response is correctly retrieved. We do not recommend leaving this field blank, but if you do we will set ‘email’ as the attribute. 8. (Optional) Add a first name and last name key attribute. ![Home realm domains in SAML configuration](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/dbdccca5-2e6c-4dd8-eaec-e029574daf00/public) 9. Enter any relevant **Home realm domains**. This is how SAML recognizes a user’s credentials and routes them to the correct sign in page. Note that home realm domains need to be unique across all connections in an environment. [Read more about home realm domains](/authenticate/enterprise-connections/home-realm-discovery/). 10. If you use home realm domains, the sign in button is hidden on the auth screen by default. To show the SSO button, select the **Always show sign-in button** option. ![ACS URL and custom domain option](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/885eda9c-ca4f-4340-db17-224023b8c300/public) 11. Copy the relevant reply URL: 1. If you don't use a custom domain, copy the **ACS URL**. 2. If you do use a custom domain, select the **Use custom domain instead** option and copy the custom domain URL. Later, add this URL to your identity provider configuration. 12. If you want to enable just-in-time (JIT) provisioning for users, select the **Create a user record in Kinde** option. This saves time adding users manually or via API later. ![Provisioning configuration for SAML](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/947baea7-bfd4-48b7-de2d-5b041b8c8300/public) 13. (Temporary feature) Select if you want to treat this connection as a trusted provider. A [trusted provider](/authenticate/about-auth/identity-and-verification/) is one that guarantees the email they issue is verified. 14. (Optional) In the **Sign SAML request** section, paste in the **Signed certificate** and **Private key**. You may have got these from your IdP or you may have generated yourself (see procedure above). 15. Enter any [upstream params](/authenticate/enterprise-connections/advanced-saml-configurations/#upstream-parameters) that you want to pass to the identity provider. Not all providers support this, so check their documentation first. 16. Select **Save**. ## Step 3: Add and configure your Okta application 1. Sign in to the Okta admin console. 2. Select **Applications > Applications**. ![Okta config window](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/63dee3f1-b0ba-4961-33e9-a8f928a07d00/public) 3. Select **Create App Integration**. The **Sign-in method** options opens. 4. Select SAML 2.0 and then select **Next**. The app’s general settings opens. ![Okta console](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/ff6393ec-43bb-4b25-e12c-26f7a05aa800/public) 5. Add a name in the **App name** field then select **Next**. The **Configure SAML** screen opens. ![Okta config screen](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/bb3bf35b-3322-433e-8224-5297a71da300/public) 6. In the **SAML settings** section, enter the following values: 1. **Single sign-on URL:** Paste the **Assertion Customer Service (ACS) URL** you copied from Kinde. 2. **Audience URI (SP Entity ID)**: Paste the **Entity ID** you copied from Kinde. 3. **Name ID format:** Select **EmailAddress**. 4. **Application username**: Select **Email**. 5. Leave all other options to their default value and select **Next**. 7. Select **Finish**. You will be redirected to the newly created application in Okta. 8. Select the **Sign on** tab and copy the metadata URL. ![Metadata URL in Okta](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/9bdcb215-054e-45c1-11a7-2df2f4be7800/public) ## Step 4: Finish setting up your SAML connection in Kinde 1. Open the connection in Kinde. Via Organization > Authentication or via Settings > Authentication. 2. Scroll to the **IdP metadata URL** field and paste the **Metadata URL** you copied from Okta. 3. Enter the signed certificate and key information if you have it. You can do this later as well. 4. Switch on the connection. This will make it instantly available to users if this is your production environment. 1. For environment-level connections, scroll down and select the apps that will use the auth method. 2. For organization-level connections, scroll down and select if you want to switch this on for the org. 5. Select **Save**. You can now use Okta as an IdP for the selected applications. ## Troubleshooting the connection If you get an error in Okta that says **User is not assigned to this application**, it means you need to assign a user or group to your Okta application. 1. Go to the **Applications** section in your Okta Admin Console. 2. Select the SAML 2.0 app you set up. 3. Under the **Assignments** tab, click **Assign > Assign to People or Assign to Groups**. 4. Choose the user or group you want to assign to this application and save your changes.

# Authenticate - Enterprise connections - Provisioning users for enterprise connections

> Comprehensive guide to user provisioning for enterprise connections including JIT provisioning, pre-provisioning, and troubleshooting SSO issues.

user provisioning, JIT provisioning, enterprise connections, SSO, identity management, troubleshooting
authenticate

When you set up Kinde with enterprise authentication like SAML or Cloudflare, you’ll want to make sure that users are set up with the correct access and identity from day one. How you do this depends on how you ‘provision’ their enterprise user identity. Users in Kinde are able to have multiple identities to support all the ways they can sign in, such as via email, social sign-in, etc. However, users managed through enterprise connections can only have an enterprise identity. ## Just-in-time (JIT) provisioning for user creation (recommended) JIT provisioning is the simplest way to add users to Kinde and allow them to authenticate. Rather than importing or pre-provisioning, your users are added to Kinde at the point of their first authentication. To enable JIT provisioning, select the **Create a user record in Kinde** option when you set up your enterprise connection. ![option for JIT in the enterprise connection screen](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/74717fdb-d6d2-4f0b-dcf6-2aef95cb7600/public) The first time the user authenticates, Kinde creates a new user record for them with the identity information passed from your IdP. ## Pre-provision or pre-create users Sometimes, JIT provisioning is not the right path or may not be possible. For example: - The user already exists in Kinde and you're switching the auth method to SSO. - You are importing users from another system and there is existing data related to the user you also wish to import. - You only want to add a sub-set of users from your directory. ### Add users to Kinde In all these cases, the users must first exist in Kinde to implement enterprise SSO. You can add users to Kinde [via import](/manage-users/add-and-edit/import-users-in-bulk/) or [via API](/kinde-apis/management#tag/users/post/api/v1/user). All users must have an email address that matches their email with the IdP. This is not necessarily the email identity for sign in, it is purely for initial matching against the IDP provided email. <Aside title="Users who sign on through multiple enterprise connections"> It’s possible that you manage users who can sign in via multiple enterprise connections. In these cases, the user must have a separate profile for each enterprise connection. </Aside> ### Provisioning method 1: Assign a connection identity to a user (recommended) This method of provisioning requires you to add the enterprise connection as part of the user’s identity in Kinde. **Add the enterprise connection identity via API** Post identity details to this endpoint `POST /api/v1/users/{user_id}/identities` with `enterprise` as the type and the `connection_id`. For more information, see [Create identity](https://docs.kinde.com/kinde-apis/management/#tag/users/post/api/v1/users/{user_id}/identities). You can search connections via API and filter them by domain. This can help you obtain the connection ID. **Add the enterprise connection identity manually** 1. Open a user’s profile and select **Add identity**. 2. In the window that appears, select **Enterprise SSO** as the **Identity type**. 3. Select the relevant **Enterprise connection** from the list. 4. Enter the user’s email as it appears in the identity provider directory. 5. Select **Save**. The user’s profile is updated to show only the enterprise connection identity. ### Provisioning method 2: Set the connection to trust emails from the IDP A slightly less secure option is to set the enterprise connection to trust emails from your IdP. This does save you adding and linking users as per method 1 above, but it also overrides any existing identity information in Kinde (such as email or phone number) with the connection data from the IdP. To employ this method, select the **Trust email addresses provided by this connection** option in the connection configuration. **Settings > Authentication > Enterprise connections > Configure.** ![Screen shot of trust emails switch](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/92f20fc4-7dcb-4ce1-9fb2-74b4db67e200/public) When the user signs in with an SSO connection that provides an email that matches the pre-provisioned users email, we will automatically combine the users. Their original email identity will be removed and from this point on they can only authenticate via the SSO connection. ## Troubleshoot SSO issues **We can’t find your account** If a user goes to sign in and encounters the ’We can’t find your account’ message, it could be because **Self-joining** for the organization is switched off. This is the right behaviour if you don’t want users without the `org_id` to join the org, but the message is confusing. Switch this on via **Organization > Policies**. **Duplicate identities** If duplicate identities are created for users in Kinde, it may because the **Trust email addresses provided by this connection** option is not switched on in the connection configuration. **Customer's SSO auth not working** Some B2B businesses allow their customers to sign in using their own enterprise SSO. When setting this up, a common mistake is that they supply incorrect values for the Client ID and Client Secret, based on the identity provider information. Double check these if you come across connection issues.

# Authenticate - Enterprise connections - Refresh SAML certificate

> Quick guide to refreshing SAML certificates and private keys for enterprise authentication security maintenance.

SAML certificate, private key, certificate refresh, enterprise auth, security maintenance
authenticate

If you secure your authentication setup with SAML certificate and private key, you’ll need to update or refresh these periodically. Your IdP might issue new certificates, or you can generate a certificate and private key yourself. See the [main SAML topic](/authenticate/enterprise-connections/custom-saml/#optional-signed-certificate-and-private-key). 1. In Kinde, go to **Settings > Authentication**. 2. In the **Enterprise connections** section, select **Configure** on the SAML tile. 3. Scroll to the **Sign SAML request** section and override the **Signing certificate** and **Private key** with the new certificate content. 4. Select **Save**.

# Authenticate - Manage authentication - Change authentication for an application

> Guide to configuring different authentication methods for different applications including mobile apps and platform-specific auth.

application authentication, mobile auth, platform-specific auth, Google auth, Apple auth
authenticate

If you want, you can select different authentication methods for different applications. You might want to do this, for example, so users sign in with Google for your Android app and Apple for your iOS app. You first need to [set up all your auth methods](/authenticate/authentication-methods/set-up-user-authentication/) and [set up each application](/build/applications/add-and-manage-applications/). 1. Go to **Settings > Environment > Applications**. 2. Select **View details** on the application you want to edit. 3. In the **Application details** screen, select **Authentication** in the left menu. 4. Use the toggle switches to change the authentication methods for the app. 5. If there is a method that you want that is not listed, [set it up](/authenticate/authentication-methods/set-up-user-authentication/). 6. When you’re finished, select **Save**. 7. Repeat for each application.

# Authenticate - Manage authentication - Build a switch to navigate between organizations

> Step-by-step guide to building an organization switcher for B2B applications using ID tokens and React components.

organization switcher, B2B, ID tokens, React, multi-organization, org navigation
authenticate

A common pattern in B2B products is for users who belong to multiple organizations to be able to switch between them. This topic demonstrates how to achieve this. ## Step 1: Add org data to ID tokens The first step is to include a list of organizations a user belongs to, in their ID token. 1. In Kinde, open the application you want to enable a switcher for. For example, go to **Settings > Applications > [View details] > Tokens.** 2. Scroll down to the **Token customization** section and select **Configure** on the **ID token** card. The **Customize ID token** window opens. <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/60ed313e-8250-4b33-0645-51a97ccc6d00/public" alt="" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" /> 3. Select the **Organizations (array)** checkbox in the **Additional claims** section. 4. Select **Save**. This adds the organization `id` and `name` to the user’s ID token, in the following format: ```jsx "organizations": [ { "id": "org_4ba6821b521", "name": "Golden Finance" }, { "id": "org_b7226a3b5f0", "name": "UTM Bank" }, { "id": "org_16374a4fc3f", "name": "Trueblue Pty Ltd" } ] ``` You can now extract the `organizations` claim from ID tokens in the way you normally would. Typically the SDK you are using will have a method for this. For example, in React you could use: ```jsx const { getClaim } = useKindeAuth() getClaim('organizations', 'idToken').then((organizations) => { console.log('value:', organizations?.value) }) ``` ## Step 2: Build the switcher To build a simple list of orgs, use something like the following React example. You’ll need to include a call to the `login` method for each organization, passing in the id. In this example, we’ve also included a check to see if this is the current organization. ```jsx const { login, getClaim, getOrganization } = useKindeAuth() const [orgs, setOrgs] = useState<{ id: string; name: string }[]>([]) const [currentOrgCode, setCurrentOrgCode] = useState<string | null>(null) useEffect(() => { getClaim('organizations', 'idToken').then((organizations) => { setOrgs(organizations?.value ?? []) }) getOrganization().then((org) => { setCurrentOrgCode(org) }) }, [getClaim, getOrganization]) <ul> {orgs.map((item) => ( <li key={item.id}> <button onClick={() => login({ orgCode: item.id })} type='button'> {item.name} {currentOrgCode === item.id ? ' (Current)' : null} </button> </li> ))} </ul> ``` With some extra styling, a switcher might look something like this: <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/762446ab-6ce7-4e6f-746f-d2ca87efee00/public" alt="" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" />

# Authenticate - Manage authentication - Set custom authentication per organization

> Guide to setting custom authentication methods per organization including shared connections and enterprise connections for B2B customers.

organization authentication, custom auth, shared connections, enterprise connections, B2B auth
authenticate

<Aside type="upgrade"> Depending what auth you set up in an organization, you may need to [upgrade your Kinde plan](https://kinde.com/pricing/), for example, for enterprise connections. Charges also apply for each organization that uses [advanced org features](/authenticate/custom-configurations/advanced-organization/). </Aside> You can set different authentication methods for each organization you manage in Kinde. You might want to do this if your customers are businesses that require unique auth setups. ## Environment-level and organization-level auth methods Most authentication methods need to be [set up at the environment level](/authenticate/authentication-methods/set-up-user-authentication/), including social sign in and core mthods such as passwordless, phone auth, etc. These are known as 'Shared connections'. You might also have [organization-level enterprise connections](/authenticate/enterprise-connections/enterprise-connections-b2b/), which are unique to an organization. The way each of these connection types is managed, is very similar. ## Set authentication methods for an organization This procedure covers adding shared connections, but you can also [add enterprise connections directly to an organization](/authenticate/enterprise-connections/about-enterprise-connections/). <Aside type="warning"> When you set authentication for an organization, it completely overrides the auth pattern set at the environment level. Nothing is inherited, except which methods are available to select for the organization. </Aside> 1. In Kinde, view details of the organization. 2. Select **Authentication** in the menu. 3. Activate the advanced features for this org, if you haven’t already. 4. Select **Add connection**. The **Add connection** window opens. 5. Select **Existing connection**, then select **Next**. A list of all existing connections appears. 6. Use the switches to enable and disable authentication methods for the organization. 7. When you’ve finished making changes, select **Save**. ## Disable authentication method for an organization If you remove an auth method for an organization, users can use any remaining methods to authenticate. If you remove all authentication methods, the organization will revert back to using the default auth set up from the environment level. <Aside type="warning"> Removing an authentication method could cause breaking changes for users of the connection. Make sure users have an alternative method of sign in. </Aside> 1. In Kinde, view details of the organization. 2. Select **Authentication** in the menu. 3. Select the three dots menu on the connection you want to remove, and select **Disable connection**. 4. A confirmation window opens. 5. Confirm that you want to disable the connection. For shared connections, the connection can be easily added back. For org-level enterprise connection, the connection can be re-enabled.

# Authenticate - Manage authentication - Session management per organization

> Guide to managing Kinde authenticated sessions at the organization level including session persistence and inactivity timeouts for enterprise customers.

organization session management, SSO session, session cookies, inactivity timeout, enterprise auth
authenticate

<Aside type="upgrade"> You may need to upgrade your plan to use this feature </Aside> If you are on the Kinde Scale plan, you can change Kinde authenticated session configuration at the organization level as well as the environment level. An authenticated session (or SSO session) is the time during which a user is authenticated via Kinde, regardless of their activity. You can define if a session persists even after a browser is closed, and how long can lapse before making the organization's user re-authenticate. These settings only apply to Kinde sessions and not sessions you maintain through your own application. ## Limitations of Kinde session configuration - Session cookies are not destroyed when a tab is closed, the full browser window must be closed. - Modern browsers usually allow session restoration. Restoring a browser session can also restore a session cookie. ## Manage SSO session behaviors and policies per organization When you change session settings at the organization level, this overrides session settings at the environment level. 1. In Kinde, go to **Organizations** and open the organization whose session settings you want to configure. 2. Select **Sessions** in the side menu. 3. In the **SSO sessions** section, decide on the policy for session cookies. A persistent session leaves the cookie active when the browser is closed. A non-persistent session is terminated when the browser window closes (unless the limitations listed above apply). 4. In the **Session inactivity timeout** section, set how long a session can be inactive before prompting re-authentication. This setting is applied in seconds - where 3,600 seconds is one hour; 86,400 seconds is one day. 5. When you're finished, select **Save**. The session settings will now be applied to members of this organization. ## Manage organization session behavior via API Use this endpoint to update session settings [via API](https://docs.kinde.com/kinde-apis/management/#tag/organizations/patch/api/v1/organizations/{org_code}/sessions/). `PATCH /api/v1/organizations/{org_code}/sessions`

# Authenticate - Manage authentication - Session management

> Guide to managing Kinde authenticated sessions including session persistence, inactivity timeouts, and browser session behavior.

session management, SSO session, session cookies, inactivity timeout, browser session
authenticate

You can manage Kinde authenticated sessions via your application settings. An authenticated session (or SSO session) is the time during which a user is authenticated via Kinde, regardless of their activity. You can define if a session persists even after a browser is closed, and how long can lapse before making a user re-authenticate. These settings only apply to Kinde sessions and not sessions you maintain through your own application. If you want, you can [change session settings for an organization](/authenticate/manage-authentication/session-management-per-organization/), without affecting other organizations. ## Limitations - Session cookies are not destroyed when a tab is closed, the full browser window must be closed. - Modern browsers usually allow session restoration. Restoring a browser session can also restore a session cookie. ## Manage SSO session behaviors and policies 1. Go to **Settings > Environment > Applications.** 2. Select **View details** on the application tile. 3. Select **Sessions** in the side menu. 4. In the **SSO sessions** section, decide on the policy for session cookies. A persistent session leaves the cookie active when the browser is closed. A non-persistent session is terminated when the browser window closes (unless the limitations listed above apply). 5. In the **Session inactivity timeout** section, set how long a session can be inactive before prompting re-authentication. This setting is applied in seconds - where 3,600 seconds is one hour; 86,400 seconds is one day. 6. When you're finished, select **Save**.

# Authenticate - Manage authentication - Sign users in to last organization

> Guide to automatically signing users into their most recent organization instead of showing an organization switcher for improved UX.

last organization, organization switcher, B2B, user experience, automatic sign-in
authenticate

A common pattern in B2B products is for users who belong to multiple organizations, to be able to [switch between them](/authenticate/manage-authentication/navigate-between-organizations/). However, if you have a switcher in your application, you may want users to be signed in to the most recent organization instead. If you switch this function on, users will not be shown an organization switcher on the authentication screen, and instead will be signed in to the most recent organization. ## Sign users in to the last used organization 1. In Kinde, go to **Settings > Policies**. 2. In the **Sign in** section, select the **Sign users in to most recent org** option. 3. Select **Save**.

# Authenticate - Manage authentication - Keep your product in sync with Kinde

> Comprehensive guide to keeping your application in sync with Kinde using refresh tokens, API calls, and webhooks for real-time data consistency.

sync with Kinde, refresh tokens, API integration, webhooks, token claims, real-time sync
authenticate

Kinde’s main object delivery method is to include claims in ID and access tokens when a user authenticates. This is a very efficient delivery method because as soon as a user signs in, you have everything you need to give them access, including their permissions. A minor downside of relying on claims, is that tokens go stale and data can get out of sync, and users may not be able to see the updates you make until they are issued a new token. This is the classic ‘eventual consistency’ problem. If you make frequent updates to permissions, flags, or other objects, this is likely an issue for you and your users, and this topic will help. Here are some options. ## Sync using refresh tokens You can use [refresh tokens](/build/tokens/refresh-tokens/) to extend the longevity of an access token. A refresh token is a way to request a new access token, without disrupting a session. Most of our SDKs handle refreshing tokens for you automatically. ### Auto-updating of token claims For optimum performance our tokens are cached, so that when a new access token is issued it contains the same claims as the previous token. A token cache becomes invalid, however, when user information is updated in the UI or via API. This includes updates to profile information, organization membership, roles, permissions, properties, and user-level feature flags. So when you use a refresh token to renew the access token (and user info has been updated), the claims will also be updated. One way to minimize periods of inconsistency is to set a low value for the [access token lifetime](/build/tokens/configure-tokens/), to trigger a refresh token. ### Force-update of token claims There are events that do not trigger individual users tokens to be updated. These include: - Feature flag changes at an organization or environment level that are inherited by a user - Permissions added to a role that the user has For these type of changes you can force a token update using your backend to call the [Refresh User Claims](/kinde-apis/management#tag/users/post/api/v1/users/{user_id}/refresh_claims) endpoint of our Kinde management API. This invalidates the cache for a specific user and means the next time an access token is issued for that user the claims will reflect the current state in Kinde. ## Sync through the Kinde Management API You can use the Kinde management API to keep your product in sync with Kinde. Calls to the API are always real time, meaning you have a few sync options. ### Force a real-time update Even if you are using refresh tokens (above), there might be a few sensitive areas of your application where immediate consistency is vital, for example checking a permission for a payments flow. To deal with this, you could make a call to out to the permissions API when that flow is triggered. This gives you the additional security of real time data where it counts. ### Periodic polling Another option for syncing is to make an initial call to the API when your user logs in and store the claim information locally. Then, periodically poll the API to update your stored claim with a real-time response. This could be overkill for things that are not mission-critical, but might be useful for important areas like permissions. ### Refresh user claims endpoint As mentioned above, the [Refresh User Claims](/kinde-apis/management#tag/users/post/api/v1/users/{user_id}/refresh_claims) API endpoint can be used to invalidate the cache for a user, which will ensure they receive updated claims on the next token refresh. ## Webhooks Webhooks let you subscribe your own url endpoints to events, and receive updates as they occur. Events refer to activities that occur within your Kinde business, for example user creation, updates to users, etc. When an event occurs, such as `user.created`, Kinde sends all the event data to any subscribed endpoints. You can then trigger your own application code in response, or just maintain your own copy of the event data. Webhooks can be managed directly in the Kinde admin area, or by using the Kinde Management API Webhook endpoints. ### Webhook subscription events Call the `/api/v1/event_types` endpoint in the Kinde Management API to view the full list of available events and the schema for the data you receive. See the [webhooks documentation](/integrate/webhooks/about-webhooks/) for more information.

# Authenticate - Manage authentication - Authenticated sessions across multiple applications

> Guide to sharing authenticated sessions across multiple applications using SSO cookies, refresh tokens, and multi-domain authentication.

multi-application sessions, SSO cookies, refresh tokens, offline scopes, multi-domain auth
authenticate

Kinde supports shared authenticated sessions across applications. For example, in a scenario where you have multiple apps running on separate subdomains, and you want to share a session between apps without prompting the user to sign in again. ## Session cookies On the first sign in, Kinde creates an SSO cookie for the authenticated user. Until this cookie expires or you request that the user signs in again (using the [prompt parameter](/developer-tools/about/using-kinde-without-an-sdk/#prompt)), all your apps can initiate sign in requests without prompting. ## Offline scopes and refresh tokens If you include an `offline` scope in your request, you can maintain long-running sessions via refresh tokens. This works both in back-end apps and in web apps. Kinde supports short-lived refresh and refresh token rotation for increased security of browser-based and mobile apps. In this case, on page reload, the SDK will resume the session via the refresh token exchange. [About refresh tokens](/build/tokens/refresh-tokens/) See also [multi-domain authentication](/authenticate/about-auth/about-authentication/#multi-domain-authentication). ## Set up overview 1. Create two or more Kinde apps. 2. Enable the same authentication method for both apps. 3. In each app, create a link to the other app using the applicable `login` method. You might do this using an application switcher, for example. 4. Sign in to one app. 5. Select a link to sign in to the second app. You should be signed in to the second app without re-authentication. ## Example Say you are signed into your **Admin app** and want to switch to the **Employee app**. Here’s how it might look. <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/6a56c72a-21ea-4bc7-6b6d-f79efd1bda00/public" alt="" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" /> As long as an authenticated session exists, users should be able to move seamlessly between applications.

# Authenticate - Multi factor auth - About multi-factor authentication

> Comprehensive overview of multi-factor authentication (MFA) including available factors, user experience, recovery codes, and organization-level enforcement.

multi-factor authentication, MFA, authenticator app, SMS, email, recovery codes, security
authenticate

To increase security for your product, you can enable multi-factor authentication (MFA). This means that your users sign in using at least two authentication methods, for example, password _plus_ verification code. If you don't want to apply MFA settings for all users, you can set [MFA per organization](/authenticate/multi-factor-auth/mfa-per-org/) if you're on the Kinde Scale plan. ## **Available MFA factors** Kinde supports the following secondary factors for MFA. - **Email** - users are sent a one-time-password (OTP) via email - **SMS** - users receive a one-time-password (OTP) via SMS - **Authenticator app** - users receive a verification code via an authentication app. You might recommend a specific app or allow users to choose. We recommend against choosing a secondary factor that is the same as the primary auth method. For example, if the primary method is email/passwordless, then choose SMS or Authenticator app as the secondary factor. ## **The MFA experience for users** If you make MFA optional, users will be prompted to opt in to MFA when they next sign in. If mandatory or after they opt in, users will be prompted to use (or choose) a secondary authentication method, through which they will receive a verification code. They will also be offered a set of recovery codes (See below). We suggest you advise users ahead of time if you are changing your sign-in requirements, and if you require them to download an authenticator app such as Google Authenticator. ### MFA **using an authenticator app** - On first time use, the user can scan a QR code to enable the verification method and get a verification code sent to their app of choice. - On subsequent sign in, a verification code will appear in their authenticator app of choice, or they can use a recovery code to sign in. ### MFA **using email verification** - A code is sent to their email that they need to enter into the verification code field on the sign up / sign in screen. ### MFA **using SMS verification** - A code is sent via SMS that the user must enter into the verification code field on the sign up / sign in screen. ## **Recovery codes** When a user signs in for the first time, or signs up as a new user (and MFA is activated), they will be offered a set of recovery codes that they can store for future use. They can then use a recovery code if they don’t have access to their device or authenticator app. ## MFA can be enforced for individual organizations Customers on the Kinde Scale plan are able to set MFA at the organization level. This is especially useful for B2B businesses who have many organizations, with varying auth requirements. See [Set MFA for an organization](/authenticate/multi-factor-auth/mfa-per-org/).

# Authenticate - Multi factor auth - Enable multi-factor authentication

> Step-by-step guide to enabling multi-factor authentication including mandatory and optional settings for enhanced security.

enable MFA, multi-factor authentication, mandatory MFA, optional MFA, security setup
authenticate

Add security to the authentication process by enabling multi-factor authentication (MFA). MFA means users sign in using at least two authentication factors, for example, password _plus_ SMS code. You can make MFA mandatory for users, or optional. Kinde supports the following secondary factors. - **Email** - users are sent a one-time-password (OTP) via email. - **SMS** - users receive a one-time-password (OTP) via SMS. - **Authenticator app** - users receive a verification code via an authentication app. We recommend against enabling a secondary factor that is the same as the primary auth method. ## **Set up MFA** When you set up MFA using this procedure, it will apply to all users in the environment. If you want, you can [enforce MFA for individual organizations](/authenticate/multi-factor-auth/mfa-per-org/), so it only affects users in that organization. 1. In Kinde, go to **Settings > Environment >** **Multi-factor auth**. 2. To make MFA mandatory, in the **Require multi-factor authentication** section, select **Yes**. Users will be required to set up MFA when they first sign up or next sign in. 3. To make MFA optional, in the **Require multi-factor authentication** section, select **Optional**. Users will have the option to set up MFA when they first sign up or next sign in. 4. Select the additional authentication options that you want to be available to your users. Such as an authenticator app, email, or SMS. 5. Select **Save**. Users will now be directed to use multi-factor authentication when they sign in.

# Authenticate - Multi factor auth - Set multi-factor authentication for an organization

> Advanced guide to setting multi-factor authentication per organization including role exemptions and enterprise connection exemptions for B2B customers.

organization MFA, role exemptions, enterprise connections, B2B MFA, advanced org features
authenticate

<Aside type="upgrade"> This is an advanced org feature that is only available on the [Kinde Scale plan](https://kinde.com/pricing/). You can set multi-factor auth for 5 organizations and then charges apply for each organization that uses [advanced org features](/authenticate/custom-configurations/advanced-organization/). </Aside> As part of being able to set unique authentication methods for an organization, you can also set how multi-factor authentication (MFA) works per organization. You might want to use MFA for some of your orgs, such as for business customers that require their users to have MFA as part of sign in. This is common in finance and government sectors. As part of this feature, you can: - exempt certain roles within the organization from having to use MFA. For example, you may only want Admins to use MFA. - exempt MFA authentication for certain enterprise connection types, such as SAML authentication. You might want to do this if MFA is already set up with the enterprise auth provider. ## Configure environment-level MFA settings If you do not want every organization in your business to use MFA, you must switch off the environment-level requirement. In Kinde, go to **Settings > Environment > Multi-factor auth**. ![Screen shot of Require MFA switches](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/78708a19-58c6-4cdd-a1e7-0c34c88dfb00/public) - Select **No** - If you want MFA to be applied in only some organizations or for some connections in your business. You will then need to set MFA in each organization separately. - Select **Yes** or **Optional** - If you want everyone, in every organization to use MFA’. Note that if you select **Yes** here, MFA will apply in all organizations regardless of what you set at the organization level. Whatever you select here, you can still exempt roles from MFA per organization. ## Switch on MFA for an organization MFA methods selected here will replace those selected at the environment level. 1. In Kinde, go to **Organizations**. 2. Browse or search for the organization. 3. In the list, select the organization to open the **Details** page. 4. Select **Multi-factor auth** in the menu. 5. If applicable, activate the advanced organization feature. 6. Toggle the **Enforce multi-factor authentication for this organization** switch on. 7. Select the authentication **Methods**. You can choose more than one. 8. Select **Save**. ## Add and remove exempt roles from MFA You need to have roles set up in Kinde. 1. In the **Exempt roles** section of the MFA page for the organization. 2. Select **Add exempt role** and select a role from the list. 3. Press **Enter**. 4. Repeat step 2 to add more roles. 5. You can remove an exempt role by selecting the three dots menu and selecting **Remove**. 6. Select **Save**. If a user has a mix of exempt and non-exempt roles, MFA will apply as default. ## Add and remove exempt enterprise connections from MFA You need to have enterprise connections set up in Kinde. 1. In the **Exempt enterprise connections** section of the MFA page for the organization. 2. Select **Add exempt enterprise connection** and select a connection from the list. 3. Press Enter. 4. Repeat step 2 to add more connections. 5. You can remove an exempt connection by selecting the three dots menu and selecting **Remove**. 6. Select **Save**. If a user signs in via Okta (exempt) and has an Admin role (not exempt), they will not be prompted for MFA. ## Switch off MFA for an organization This procedure only works if you have also switched off the environment-level setting for MFA. <Aside type="warning"> If users are already authenticating via MFA in the organization, switching it off may cause breaking changes. </Aside> 1. In Kinde, go to **Organizations** and browse or search for the organization. 2. In the list, select the organization to open the **Details** page. 3. Select **Multi-factor auth** in the menu. 4. Toggle the **Enforce multi-factor authentication for this organization** switch off. 5. Select **Save**.

# Authenticate - Social sign in - Add and manage social connections

> Comprehensive guide to adding and managing social sign-in connections including setup, security considerations, and provider-specific configurations.

social sign-in, social connections, OAuth, client ID, client secret, trusted providers
authenticate

Social connections enable you to sign up and sign in users with credentials from their existing social accounts, such as Google or GitHub. An advantage of social sign in is that users don't have to create new credentials to use your app or service, making it more convenient and secure for them. If they have a gravatar picture associated with their social account, it will flow through to Kinde. <Aside type="warning" title="Social sign in for production environments"> Before you make your production environment live, you must add your own social app's Client ID and Client secret in the Kinde connection (as per below). Do not use Kinde's app credentials by leaving the fields blank, as this poses a security and performance risk, and makes it difficult to change auth providers without service disruptions for your users. </Aside> ## Set up a social connection Follow the docs below for each social provider you want to use. This will give you the `Client ID` and `Client secret` (keys) you need to set up each auth method on the Kinde side. - [Apple](/authenticate/social-sign-in/apple/) - [Bitbucket](/authenticate/social-sign-in/bitbucket-sso/) - [Discord](/authenticate/social-sign-in/discord/) - [Facebook](/authenticate/social-sign-in/facebook/) - [GitHub](/authenticate/social-sign-in/github/) - [GitLab](/authenticate/social-sign-in/gitlab/) - [Google](/authenticate/social-sign-in/google/) - [LinkedIn](/authenticate/social-sign-in/linkedin/) - [Microsoft](/authenticate/social-sign-in/microsoft-sso/) - [Roblox](/authenticate/social-sign-in/roblox-sso/) - [Slack](/authenticate/social-sign-in/slack/) - [Twitch](/authenticate/social-sign-in/twitch/) - [Twitter](/authenticate/social-sign-in/twitter/) - [Xero](/authenticate/social-sign-in/xero-sso/) ### When an email is not provided Some social providers don't require an email for sign up, e.g. X. When a user signs up or in with one of these providers, Kinde will ask for an email (just once). This is so we can verify the user's identity and be sure it's a genuine sign up. We treat social identities different to email identities in Kinde, and record social providers as a social identity in their user profile. For more information, see [User identity and verification](/authenticate/about-auth/identity-and-verification/). ## Trusting emails from social providers There's no guarantee that the email kept on file with a social provider remains current. Because of this, Kinde does not automatically treat social provider emails as 'trusted', and therefore we do not automatically sync email profiles. When you add a social connection, you can choose whether to 'trust' provider emails for each connection type. For more information, see [User identity and verification](/authenticate/about-auth/identity-and-verification/#trusting-emails-from-providers). ## Delete a social connection <Aside type="danger"> Before you delete a connection, make sure that there are no users relying on it for authentication. Once deleted, the sign in option becomes unavailable to users. This action can’t be reversed. </Aside> 1. In Kinde, go to **Settings > Environment > Authentication**. 2. Scroll down to the **Social connections** section and select the three dots on the tile for the connection, then select **Delete connection**. 3. In the confirmation window, select **Delete connection**. ## Manage social connections via API You can [add, update, and delete social connections via the Kinde management API](/kinde-apis/management#tag/connections) using predefined endpoints.

# Authenticate - Social sign in - Apple social sign in

> Complete guide to setting up Apple social sign-in including Apple Developer account setup, Services ID configuration, and JWT client secret generation.

Apple sign-in, Apple Developer, Services ID, JWT, client secret, private key, token renewal
authenticate

You can enable users to sign up and sign in using their Apple credentials. <Aside type="warning" title="For Apple auth in production"> You MUST set up an Apple app and use the provided Client ID and Client secret in the Kinde Apple connection. Do not use Kinde's credentials (leave the Client ID and Client secret blank) for third party SSO apps in your production environment. This adds a security and performance risk for your business, and makes it difficult to change auth providers without service disruptions for your users. </Aside> It's also important to note that Apple limits the information it passes when users sign up this way. Avatars and profile pictures do not flow through to the auth experience in Kinde. The user's email may also be excluded, depending how they have their Apple ID set up. ## **What you need** - An [Apple Developer account](https://developer.apple.com/) including a subscription to the Apple developer program - Your Kinde callback URL (see below) - Some developer know-how ## **Copy the callback URL from Kinde** 1. In Kinde, go to **Settings** > **Authentication**. 2. If you have not yet added the Apple connection, select **Add connection**, select **Apple**, then **Next**. 3. In the **Callback URL** section: 1. If you use Kinde’s domain as your default, copy the **Kinde domain** URL. 2. If you use custom domains, select the **Use custom domain instead** switch. 3. If you have only one custom domain, copy the **Custom domain** URL. If you have custom domains for multiple organizations, select each one from the list and copy the callbacks for each. You need to enter all custom domain callbacks in the provider app. 4. Select **Save**. 5. Use the copied Callback URLs to set up the app, see below. ## **Configure sign in for your app** <Aside> The following procedures refer to several types of IDs including App ID and Services ID. Take care to follow the steps exactly, to avoid errors. </Aside> ### **Set up your app** 1. In your Apple developer account, go to **Identifiers**. 2. Select the plus (+) icon next to **Identifiers**. 3. Select **App IDs**, then select **Continue**. 4. Select **App**, then select **Continue.** 5. Enter a description and Bundle ID. 6. In the **Capabilites** list, select **Sign in with Apple**. 7. Select **Register**. ### **Register** **services** 1. Select the plus icon (+) next to **Identifiers**. 2. Select **Services ID**, then select **Continue.** 3. Enter a description and identifier (make a note of this because it will be used as the Client ID). 4. Select **Register.** ### **Configure domains** 1. Click on the newly created service to edit. 2. Check the box to enable **Sign In with Apple** and click **Configure.** 3. In the **Domains and Subdomains** field, enter your Kinde URL, e.g. `yourdomain.kinde.com` (excluding the https:// protocol) 4. In the **Return URLs** field, enter your Kinde callback URL or custom domain callback URL, e.g. `https://yourdomain.kinde.com/login/callback`. 5. Add additional entries for all your organization custom domain callbacks, e.g. `account.customdomainone.com/login/callback`, `account.customdomaintwo.com/login/callback`, etc. 6. Select **Next**, then select **Done.** 7. In the **Edit your Services ID Configuration** window, select **Continue**, then select **Save.** ### **Set up keys** 1. Select **Keys** in the left hand menu and click the plus icon (+) next to the page title. 2. Enter a **Key Name**. 3. Select **Sign In with Apple** and next to this option, select **Configure**. 4. Select your app from the Primary App ID field, then select **Save.** 5. Select **Continue** then select **Register.** 6. Download your key as per the screen instructions. You will need this to generate the client secret. 7. When you have downloaded the key, select **Done**. ### **Generate the client secret** There are several ways to generate the client secret. An example is provided below. _**Example using Ruby**_ You can use open source libraries for creating and signing JWT tokens for your client secret (see [JWT.io](https://jwt.io/)). The below steps provide an example of accomplishing this using Ruby. 1. Install jwt using the following command: `gem install jwt`. 2. Create a file titled `client_secret.rb` and replace the empty values in your script as follows: - `key_file` is the p8 file containing your private key that you downloaded. - `team_id` can be found in the top right of your apple developer account under your name. - `client_id` is the identifier used for the service. - `key_id` was provided on the key creation screen. ```ruby require 'jwt' key_file = 'key.txt' team_id = '' client_id = '' key_id = '' ecdsa_key = OpenSSL::PKey::EC.new IO.read key_file headers = { 'kid' => key_id } claims = { 'iss' => team_id, 'iat' => Time.now.to_i, # Note that this is the maximum exp value of 6 months 'exp' => Time.now.to_i + 86400*180, 'aud' => 'https://appleid.apple.com', 'sub' => client_id, } token = JWT.encode claims, ecdsa_key, 'ES256', headers puts token ``` 3. Run the script with ruby `client_secret.rb` and copy the generated `client_secret`. 4. Add these credentials into Kinde. ## **Add credentials to Kinde** 1. In Kinde, go to **Settings** > **Authentication**. 2. On the Apple tile, select **Configure**. 3. Paste the **Client ID** (Service ID) and **Client secret** (Private key) into the relevant fields. 4. Select if you want to treat this connection as a trusted provider. A [trusted provider](/authenticate/about-auth/identity-and-verification/) is one that guarantees the email they issue is verified. We recommend leaving this off for maximum security. 5. Add any [upstream params](/authenticate/auth-guides/pass-params-idp/) that you want to pass to the IdP. 6. Select which apps will use Apple sign in. 7. Select **Save**. Users will now see Apple as an option to sign up and sign in to your product. ## **Renew Apple token periodically** To continue to enable users to sign in with Apple, you will need to periodically renew the Apple token by generating a new client secret. Usually every six months. To do this, repeat the procedures from **Set up keys** to **Add credentials to Kinde**, above. ## **Third party references for this article** We do our best to test all our procedures, but sometimes third party companies change things without us knowing. Here’s the sources we used to create this article. - [Validating “Sign in with Apple” Authorization Code](https://p.agnihotry.com/post/validating_sign_in_with_apple_authorization_code/) - [Configuring your environment for Sign in with Apple](https://developer.apple.com/documentation/sign_in_with_apple/configuring_your_environment_for_sign_in_with_apple) - [Sign in with Apple REST API](https://developer.apple.com/documentation/sign_in_with_apple/sign_in_with_apple_rest_api) - [Apple Developer Center](https://developer.apple.com/)

# Authenticate - Social sign in - Bitbucket social sign in

> Step-by-step guide to setting up Bitbucket social sign-in including Bitbucket app creation, OAuth configuration, and Kinde integration.

Bitbucket sign-in, Bitbucket app, OAuth, client ID, client secret, callback URL, permissions
authenticate

You can enable users to sign up and sign in using their Bitbucket credentials. To enable this, follow all the steps below to create a Bitbucket app and configure credentials in Kinde. <Aside type="warning" title="Social sign in for production environments"> Before you make your production environment live, you must add your own social app's Client ID and Client secret in the Kinde connection (as per below). Do not use Kinde's app credentials by leaving the fields blank, as this poses a security and performance risk, and makes it difficult to change auth providers without service disruptions for your users. </Aside> ## **Get your Kinde callback URL** 1. In Kinde, go to **Settings** > **Authentication**. 2. In the **Social connections** section, select **Add connection.** 3. In the window that appears, select **Bitbucket,** then select **Next**. 4. In the **Callback URL** section: 1. If you use Kinde’s domain as your default, copy the **Kinde domain** URL. 2. If you use custom domains, select the Use custom domain instead switch. 3. If you have only one custom domain, copy the Custom domain URL. If you have custom domains for multiple organizations, select each one from the list and copy the callbacks for each. You need to enter all custom domain callbacks in the Bitbucket app. 5. Select **Save**. 6. Use the copied Callback URL to set up the app, see below. ## **Create and configure a Bitbucket app** 1. Create an account on [https://bitbucket.org/](https://bitbucket.org/). 2. Go to **Workspaces** if you are not automatically directed. 3. Create a workspace. 4. Enter a **Name** and **ID**. 5. Open **Settings** > **Apps and features** > **oauth consumers.** 6. Add a consumer. 7. Enter a name and add the callback URLs copied from your Kinde app. Add entries for all your organization custom domain callbacks, e.g. `account.customdomainone.com/login/callback`, `account.customdomaintwo.com/login/callback`, etc. 8. Under **Permissions**, in the **Account** section, select **email** and **read.** 9. Select **Save**. 10. Go back to **Apps and features** > **oauth consumers.** 11. Select the workspace you’ve just created and copy the key (client id) and secret (client secret) to paste into the kinde app. ## **Add Bitbucket app credentials to Kinde** 1. In Kinde, go to **Settings** > **Authentication**. 2. On the **Bitbucket** tile, select **Configure**. 3. Paste the **Client ID** (key) and **Client secret** (secret) into the relevant fields. 4. Select if you want to treat this connection as a trusted provider. A [trusted provider](/authenticate/about-auth/identity-and-verification/) is one that guarantees the email they issue is verified. We recommend leaving this off for maximum security. 5. Add any [upstream params](/authenticate/auth-guides/pass-params-idp/) that you want to pass to the IdP. 6. Select which applications will allow Bitbucket social sign in. 7. Select **Save**. Users will now see Bitbucket as an option to sign up and sign in to the selected applications.

# Authenticate - Social sign in - Discord social sign in

> Step-by-step guide to setting up Discord social sign-in including Discord app creation, OAuth configuration, and Kinde integration.

Discord sign-in, Discord app, OAuth, client ID, client secret, callback URL
authenticate

You can enable users to sign up and sign in using their Discord credentials. To enable this, you’ll need a Discord app and some developer know-how. <Aside type="warning" title="Social sign in for production environments"> Before you make your production environment live, you must add your own social app's Client ID and Client secret in the Kinde connection (as per below). Do not use Kinde's app credentials by leaving the fields blank, as this poses a security and performance risk, and makes it difficult to change auth providers without service disruptions for your users. </Aside> ## **Get your Kinde callback URL** 1. In Kinde, go to **Settings** > **Authentication**. 2. In the **Social connections** section, select **Add connection.** 3. In the window that appears, select **Discord,** then select **Next**. 4. In the **Callback URL** section: 1. If you use Kinde’s domain as your default, copy the **Kinde domain** URL. 2. If you use custom domains, select the Use custom domain instead switch. 3. If you have only one custom domain, copy the Custom domain URL. If you have custom domains for multiple organizations, select each one from the list and copy the callbacks for each. You need to enter all custom domain callbacks in the Discord app. 5. Select **Save**. 6. Use the copied Callback URL to set up the app, see below. ## Create and configure a Discord app 1. Log in to the [Discord developer site](https://discord.com/developers/applications/) and create a new app. 2. Give it a name and then go to **OAuth2** in the side menu. 3. In **OAuth2 > General**, copy the **Client ID** and **Client secret** somewhere you can access it later. If the client secret is not showing, select **Reset Secret**. 4. Paste in the **Callback URLs** (the ones you copied above), e.g. `https://yourdomain.kinde.com/login/callback`. Add entries for all your organization custom domain callbacks, e.g. `account.customdomainone.com/login/callback`, `account.customdomaintwo.com/login/callback`, etc. 5. Save your changes. ## **Add Discord credentials to Kinde** 1. In Kinde, go to **Settings** > **Authentication**. 2. On the **Discord** tile, select **Configure**. 3. Paste the **Client ID** and **Client secret** from the Discord app into the relevant fields. 4. Select if you want to treat this connection as a trusted provider. A [trusted provider](/authenticate/about-auth/identity-and-verification/) is one that guarantees the email they issue is verified. We recommend leaving this off for maximum security. 5. Add any [upstream params](/authenticate/auth-guides/pass-params-idp/) that you want to pass to the IdP. 6. Select which applications will allow Discord social sign in. 7. Select **Save**. Users will now see Discord as an option to sign up and sign in to the selected applications.

# Authenticate - Social sign in - Facebook social sign in

> Comprehensive guide to setting up Facebook social sign-in including Meta app creation, OAuth configuration, and Kinde integration.

Facebook sign-in, Meta app, OAuth, client ID, client secret, callback URL, Facebook Login for Business
authenticate

You can enable users to sign up and sign in using their Facebook credentials. To enable this, you’ll need a Facebook app and some developer know-how. <Aside type="warning" title="Social sign in for production environments"> Before you make your production environment live, you must add your own social app's Client ID and Client secret in the Kinde connection (as per below). Do not use Kinde's app credentials by leaving the fields blank, as this poses a security and performance risk, and makes it difficult to change auth providers without service disruptions for your users. </Aside> ## **Copy the callback URL from Kinde** 1. In Kinde, go to **Settings** > **Authentication**. 2. If you have not yet added the Facebook social connection, select **Add connection** in the **Social authentication** section. 3. Select **Facebook**, then **Next**. 4. In the **Callback URL** section: 1. If you use Kinde’s domain as your default, copy the **Kinde domain** URL. 2. If you use custom domains, select the **Use custom domain instead** switch. 3. If you have only one custom domain, copy the Custom domain URL. If you have custom domains for multiple organizations, select each one from the list and copy the callbacks for each. You need to enter all custom domain callbacks in the Meta app. 5. Select **Save**. 6. Use the copied Callback URLs to set up the app, see below. <Aside> If you use Facebook Login for Business, some of the app creation and configuration steps might be different than those outlined below. See [Meta's documentation](https://developers.facebook.com/docs/facebook-login/facebook-login-for-business/) for detailed guidance. </Aside> ## **Create a Meta app** The following steps were correct when we published this, but third-party providers sometimes change things. [Here’s the Meta Developer docs](https://developers.facebook.com/docs/facebook-login/) in case you get stuck. 1. Go to the [Facebook/Meta developer space](https://developers.facebook.com/) and select **My apps**, then **Create app**. 2. On the **Business portfolio** page, select **Next**. 3. On the **Use cases** page, select **Authenticate and request data from users with Facebook Login** option and then select **Next.** 4. Follow the prompts and enter the app details, then select **Create app**. 5. In the confirmation window that appears, select **View dashboard**. 6. Under **App settings**, select **Basic** and copy the client ID and client Secret (labeled as **App ID** and **App Secret**) and paste them in a text file or somewhere you can easily copy them. ## **Configure the Meta app** The following steps were correct when we published this, but third party providers sometimes changes things. [Here’s the Meta Developer docs](https://developers.facebook.com/docs/facebook-login/) in case you get stuck. 1. In your Meta app dashboard, select **Use cases** then select **Configure** on the **Authentication and account creation** tile. 2. On the **Permissions** tab, make sure `email` and `public_profile` are selected. 3. On the **Settings** tab, add your callback URL in the **Redirect URI** field. E.g. `https://domain.kinde.com/login/callback` 4. Select **Save changes** at the bottom of the screen. 5. Go back to the Dashboard page (home icon). 6. In **App settings**, select **Basic**. 1. Paste your Kinde domain URL in the **App domains** field, but **do not** include the https/http or path. For example, paste `yourdomain.kinde.com`. 2. Add other details such as app icon, category, terms of service and privacy policy link. 3. Select **Save changes**. 7. Go to **Settings** > **Advanced.** 8. Under **Domain manager**, select **Add a domain** to add your Kinde domain. 1. When you add the domain here (include the https/http part of the URL). 2. Under the **Security** section, ensure the **Require app secret** switch is turned off. 3. Add any other relevant information. 4. Select **Save changes**. 9. Next, you'll need to complete the preparation tasks and submit your app for approval. Note that this requires providing business documentation, contacts, etc. See the **Review** area for more information. 10. Once the approval process is complete, you can publish the app. See the [Meta/Facebook docs](https://developers.facebook.com/docs/development/create-an-app/) for more information about apps. ## **Create a product in your Meta app** The following steps were correct when we published this, but third party providers sometimes changes things. [Here’s the Meta Developer docs](https://developers.facebook.com/docs/facebook-login/) in case you get stuck. 1. In your app dashboard, select **Add product**. 2. Select the **Opt in Facebook Login for Business** prompt**.** 3. When prompted, select **Switch to Facebook Login for business**. 4. In the confirmation window, select **Certain permissions aren’t available with this product** as the reason. 5. In the **Select the permissions you require** field that appears, select **email** and **public_profile**. 6. Select **Switch to Facebook Login**. 7. Enter the Kinde callback URLs in the **Valid OAuth Redirect URLs field**. Add entries for all your organization custom domain callbacks, e.g. account.customdomainone.com/login/callback, account.customdomaintwo.com/login/callback, etc. 8. Select **Save Changes**. 9. In the red warning message at the top of the page, select **Get Advanced Access**. The **Permissions and Features** page opens. 10. Next to the **email** entry: 1. Select **Request advanced access**. 2. In the confirmation window, select the checkbox and enter your facebook password. 3. Select **Submit**. 11. Next to the **public_profile** entry: 1. Select **Request advanced access**. 2. In the confirmation window, select the checkbox and enter your Facebook password. 3. Select **Submit**. ## **Add Facebook credentials to Kinde** 1. In Kinde, go to **Settings** > **Authentication**. 2. On the **Facebook** tile, select **Configure**. 3. Paste the **Client ID** and **Client secret** from the Facebook app into the relevant fields. 4. Select if you want to treat this connection as a trusted provider. A [trusted provider](/authenticate/about-auth/identity-and-verification/) is one that guarantees the email they issue is verified. We recommend leaving this off for maximum security. 5. Add any [upstream params](/authenticate/auth-guides/pass-params-idp/) that you want to pass to the IdP. 6. Select which applications will allow Facebook SSO. 7. Select **Save**. Users will now see Facebook as an option to sign up and sign in to the selected applications. ### When an email is not provided Facebook does not require an email for sign up, but Kinde does. So if a user signs up with Facebook and an email is not detected, we will ask for one. The user only needs to provide their email once, then they can sign in via Facebook without disruption. If the email they provide is already detected in Kinde, we will automatically link the accounts so as not to duplicate.

# Authenticate - Social sign in - GitHub social sign in

> Step-by-step guide to setting up GitHub social sign-in including GitHub app creation, OAuth configuration, and Kinde integration.

GitHub sign-in, GitHub app, OAuth, client ID, client secret, callback URL, webhooks
authenticate

You can enable users to sign up and sign in using their GitHub credentials. To enable this, you’ll need some technical know-how and a [GitHub app](https://docs.github.com/en/apps/creating-github-apps/about-creating-github-apps/about-creating-github-apps) and credentials. <Aside type="warning" title="Social sign in for production environments"> Before you make your production environment live, you must add your own social app's Client ID and Client secret in the Kinde connection (as per below). Do not use Kinde's app credentials by leaving the fields blank, as this poses a security and performance risk, and makes it difficult to change auth providers without service disruptions for your users. </Aside> ## **Get the Kinde callback URL** 1. In Kinde, go to **Settings** > **Authentication**. 2. In the **Social Connections** section, select **Add connection**. 3. In the window that appears, select **GitHub**, then select **Next**. 4. In the **Callback URL** section: 1. If you use Kinde’s domain as your default, copy the **Kinde domain** URL. 2. If you use custom domains, select the **Use custom domain instead** switch. 3. If you have only one custom domain, copy the Custom domain URL. If you have custom domains for multiple organizations, select each one from the list and copy the callbacks for each. You need to enter all custom domain callbacks in the provider app. 5. Select **Save**. 6. Use the copied Callback URL to set up the app, see below. ## **Create GitHub app** 1. Sign in to your GitHub account, select the **Account** dropdown menu at the top right corner, and choose **Settings**. 2. From the menu on the left, select **Developer settings**. ([https://github.com/settings/apps](https://github.com/settings/apps)) 3. Select **GitHub Apps** and then select **New GitHub app**. 4. Give the app a name. 5. Enter your app’s **Homepage URL**. 6. Enter or paste the Kinde callback URLs you copied earlier, into the **Authorization callback URL** field. Add entries for all your organization custom domain callbacks, e.g. account.customdomainone.com/login/callback, account.customdomaintwo.com/login/callback, etc. 7. Select the **Request user authorization (OAuth) during installation** option**.** 8. In the **Webhooks** section, deselect the Webhook **Active** option (unless you want to add webhook URL details). 9. (Recommended) In the **Permissions** section, open the **Account permissions** options and change the **Email addresses** access to **Read only**. This enables Kinde to more easily match up user accounts with access to all the users' email addresses. <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/91a0d647-35d8-450b-26d2-21b5c8dca400/public" alt="" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" /> 10. Select **Create GitHub App**. The app is created. ## Copy Client ID and Client secret 1. On the App you just created, select **Edit**. 2. Copy the **Client ID.** 3. Select **Generate a new client secret**. 4. Copy these values to a text file or other temporary and secure place for adding to Kinde. ## **Add GitHub credentials to Kinde** 1. In Kinde, go to **Settings** > **Authentication**. 2. On the GitHub tile, select **Configure**. 3. Paste the **Client ID** and **Client secret** into the relevant fields. 4. Select if you want to treat this connection as a trusted provider. A [trusted provider](/authenticate/about-auth/identity-and-verification/) is one that guarantees the email they issue is verified. We recommend leaving this off for maximum security. 5. Add any [upstream params](/authenticate/auth-guides/pass-params-idp/) that you want to pass to the IdP. 6. Select which applications will use GitHub sign in. 7. Select **Save**. Users will now see GitHub as an option to sign up and sign in to your product.

# Authenticate - Social sign in - GitLab social sign in

> Step-by-step guide to setting up GitLab social sign-in including GitLab app creation, OAuth configuration, and Kinde integration.

GitLab sign-in, GitLab app, OAuth, client ID, client secret, callback URL, scopes
authenticate

You can enable users to sign up and sign in using their GitLab credentials. To enable this, you’ll need some technical know-how and a GitLab app and credentials. Here’s some [GitLab docs](https://docs.gitlab.com/ee/integration/oauth_provider.html) that might help. <Aside type="warning" title="Social sign in for production environments"> Before you make your production environment live, you must add your own social app's Client ID and Client secret in the Kinde connection (as per below). Do not use Kinde's app credentials by leaving the fields blank, as this poses a security and performance risk, and makes it difficult to change auth providers without service disruptions for your users. </Aside> ## **Get the Kinde callback URL** 1. In Kinde, go to **Settings** > **Authentication**. 2. In the **Social Connections** section, select **Add connection**. 3. In the window that appears, select **GitLab**, then select **Next**. 4. In the **Callback URL** section: 1. If you use Kinde’s domain as your default, copy the **Kinde domain** URL. 2. If you use custom domains, select the **Use custom domain instead** switch. 3. If you have only one custom domain, copy the Custom domain URL. If you have custom domains for multiple organizations, select each one from the list and copy the callbacks for each. You need to enter all custom domain callbacks in the GitLab app. 5. Select **Save**. 6. Use the copied Callback URL to set up the app, see below. ## **Create GitLab app** 1. Sign in to your GitLab account and follow [these instructions](https://docs.gitlab.com/ee/integration/oauth_provider.html) for adding a group-owned or user-owned application. 2. Ensure these scopes are enabled in your application: `read_user`, `openid`, `profile`, `email`. 3. Paste the Kinde callback URL in the **Redirect URI** field. Add additional entries for all your organization custom domain callbacks, e.g. `account.customdomainone.com/login/callback`, `account.customdomaintwo.com/login/callback`, etc. 4. Select **Save**. 5. Copy the **Application ID** and **Secret**, and paste them where you can access them later. ## **Add GitLab credentials to Kinde** 1. In Kinde, go to **Settings** > **Authentication**. 2. On the GitLab tile, select **Configure**. 3. Paste the **Client ID** (**Application ID**) and **Client secret** (**Secret**) into the relevant fields. 4. Select if you want to treat this connection as a trusted provider. A [trusted provider](/authenticate/about-auth/identity-and-verification/) is one that guarantees the email they issue is verified. We recommend leaving this off for maximum security. 5. Add any [upstream params](/authenticate/auth-guides/pass-params-idp/) that you want to pass to the IdP. 6. Select which applications will have a GitLab sign in option. 7. Select **Save**. Users will now see GitLab as an option to sign up and sign in to your product.

# Authenticate - Social sign in - Google social sign in

> Step-by-step guide to setting up Google social sign-in including Google Cloud project setup, OAuth credentials, and Kinde integration.

Google sign-in, OAuth, Google Cloud, client ID, client secret, callback URL, webview limitations
authenticate

You can enable users to sign up and sign in using their Google credentials. To set this up, you need a Google cloud account and project, and a little technical know-how. <Aside type="warning" title="Social sign in for production environments"> Before you make your production environment live, you must add your own social app's Client ID and Client secret in the Kinde connection (as per below). Do not use Kinde's app credentials by leaving the fields blank, as this poses a security and performance risk, and makes it difficult to change auth providers without service disruptions for your users. </Aside> Note that Google has provided a topic about [Google’s Create authorization credentials](https://developers.google.com/identity/sign-in/web/sign-in#create_authorization_credentials), but the steps don’t quite work. Until they update their docs, we recommend you use ours. <Aside title="Google does not allow sign in auth to work in webview"> Before connecting Google as a sign in option, be aware that Google does not support auth in webview. This means if a user opens a sign in window to your app in a webview (say via Instagram or from Facebook) they will receive an error. </Aside> ## **Before you begin** 1. Create a [Google Cloud](https://cloud.google.com/) account. 2. Create a [Google Project](https://cloud.google.com/resource-manager/docs/creating-managing-projects#console). 3. Get Google credentials (see below). ### **Get the Kinde Callback URL** 1. Sign in to Kinde. 2. Go to the **Settings** page and select **Authentication**. 3. In the **Social connections** section, select **Add connection.** 4. In the window that opens, select **Google**, then select **Next**. 5. In the **Callback URL** section: 1. If you use Kinde’s domain as your default, copy the Kinde domain URL. 2. If you use custom domains, select the **Use custom domain instead** switch. 3. If you have only one custom domain, copy the Custom domain URL. If you have custom domains for multiple organizations, select each one from the list and copy the callbacks for each. You need to enter all custom domain callbacks in the Google app. 6. Select **Save**. 7. Use the copied Callback URL to set up the app, see below. ## **Get Google credentials** 1. Navigate to the [Google Cloud](https://cloud.google.com/) home page. 2. Click **Console** in the top menu bar. 3. In the left menu, select **APIs & Services.** 4. If you are prompted to, create a new project. 5. Select **OAuth consent** **screen.** 6. Select if your project is **Internal** or **External,** then select **Create**. <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/412af691-19cd-45b2-3af7-f5db15677a00/public" alt="" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" /> 7. Complete all the app details (noting that you may need to go through the verification process if you upload a logo). 8. Select **Save** **and Continue**. 9. In the **Scopes** step, select **Add or remove scopes.** 10. In the screen that appears, add the following non-sensitive scopes: `./auth/userinfo.email` and `./auth/userinfo.profile` then select **Update**. 11. Select **Save and continue.** 12. Add test users if you want, then select **Save and continue**. 13. Back in the main menu, select **Credentials**. 14. Click **Create Credentials** at the top of the page and select **OAuth client ID**. 15. In the **Web application** dropdown menu, choose **Web Application**. <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/3518f0a9-6232-41b8-2e37-0293fed41200/public" alt="" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" /> 16. Name your OAuth 2.0 client. 17. Add your **Authorized redirect URIs**. These are the Callback URLs you copied in the previous procedure. Add entries for all your organization custom domain callbacks, e.g. `account.customdomainone.com/login/callback`, `account.customdomaintwo.com/login/callback`, etc. 18. Click **Create**. 19. Copy your **Client ID** and **Client Secret** from the confirmation window. ## **Add Google credentials to Kinde** 1. In Kinde, go to **Settings** and select **Authentication**. 2. On the Google tile, select the **Configure** link. 3. Paste your **Client ID** and **Client Secret** into the two fields. 4. Select if you want to treat this connection as a trusted provider (this is on by default for Google). A [trusted provider](/authenticate/about-auth/identity-and-verification/) is one that guarantees the email they issue is verified. We recommend leaving this off for maximum security. 5. Add any [upstream params](/authenticate/auth-guides/pass-params-idp/) that you want to pass to the IdP. For example, you can pass a param that forces the Google account selector to display. 6. Select which applications to switch this on for. 7. Select **Save**. Your users will now be able to sign in using their Google credentials.

# Authenticate - Social sign in - LinkedIn social sign in

> Step-by-step guide to setting up LinkedIn social sign-in including LinkedIn app creation, OpenID Connect configuration, and Kinde integration.

LinkedIn sign-in, OpenID Connect, OAuth, client ID, client secret, callback URL, LinkedIn developer
authenticate

You can enable users to sign up and sign in using their LinkedIn credentials. To enable this, you’ll need a LinkedIn app and some developer know-how. <Aside type="warning" title="Social sign in for production environments"> Before you make your production environment live, you must add your own social app's Client ID and Client secret in the Kinde connection (as per below). Do not use Kinde's app credentials by leaving the fields blank, as this poses a security and performance risk, and makes it difficult to change auth providers without service disruptions for your users. </Aside> ## **Get the Kinde Callback URL** 1. Sign in to Kinde. 2. Go to the **Settings** page and select **Authentication**. 3. In the **Social connections** section, select **Add connection.** 4. In the window that opens, select **LinkedIn**, then select **Next**. 5. In the **Callback URL** section: 1. If you use Kinde’s domain as your default, copy the **Kinde domain** URL. 2. If you use custom domains, select the Use custom domain instead switch. 3. If you have only one custom domain, copy the Custom domain URL. If you have custom domains for multiple organizations, select each one from the list and copy the callbacks for each. You need to enter all custom domain callbacks in the LinkedIn app. 6. Select **Save**. 7. Use the copied Callback URLs to set up the app, see below. ## **Create a LinkedIn app and set up** 1. Go to the [LinkedIn developer space](https://developer.linkedin.com/) and select **Create app**. 2. Complete the details, including name, logo, company LinkedIn page, privacy policy link, etc. 3. Select **Create app**. 4. In the **Products** tab, select **Request access** on the **Sign in with LinkedIn using OpenID Connect** tile. 5. In the dialog that opens, agree to the terms and conditions to continue. You can now view the endpoints. ## **Configure your LinkedIn app** 1. Go to the **Auth** tab. 2. In the **Auth 2.0 settings** area, select the edit icon next to the **Authorized redirect URLs for your app.** 3. Paste the **Callback URLs** you copied from Kinde in the first procedure. Add entries for all your organization custom domain callbacks, e.g. account.customdomainone.com/login/callback, account.customdomaintwo.com/login/callback, etc. 4. In the same tab, copy the **Client ID** and **Client Secret** and paste them in a text file or somewhere you can easily copy them. For additional help, see the [LinkedIn docs](https://learn.microsoft.com/en-gb/linkedin/consumer/integrations/self-serve/sign-in-with-linkedin). ## **Add LinkedIn credentials to Kinde** 1. In Kinde, go to **Settings** > **Authentication**. 2. On the **LinkedIn** tile, select **Configure**. 3. Paste the **Client ID** and **Client secret** from the LinkedIn app into the relevant fields. 4. Select if you want to treat this connection as a trusted provider. A [trusted provider](/authenticate/about-auth/identity-and-verification/) is one that guarantees the email they issue is verified. We recommend leaving this off for maximum security. 5. Add any [upstream params](/authenticate/auth-guides/pass-params-idp/) that you want to pass to the IdP. 6. Select which applications will allow LinkedIn SSO. 7. Select **Save**. Users will now see LinkedIn as an option to sign up and sign in to the selected applications.

# Authenticate - Social sign in - Microsoft social sign in

> Step-by-step guide to setting up Microsoft social sign-in including Azure app registration, OAuth configuration, and Kinde integration.

Microsoft sign-in, Azure, Entra ID, app registration, OAuth, client ID, client secret, home realm
authenticate

You can enable users to sign up and sign in using their Microsoft credentials. To enable this, you’ll need a Microsoft Azure account and some developer know-how. <Aside type="warning" title="Social sign in for production environments"> Before you make your production environment live, you must add your own social app's Client ID and Client secret in the Kinde connection (as per below). Do not use Kinde's app credentials by leaving the fields blank, as this poses a security and performance risk, and makes it difficult to change auth providers without service disruptions for your users. </Aside> ## **Get the Kinde Callback URL** 1. Sign in to Kinde. 2. Go to the **Settings** page and select **Authentication**. 3. In the **Social connections** section, select **Add connection.** 4. In the window that opens, select **Microsoft**, then select **Next**. 5. In the **Callback URL** section: 1. If you use Kinde’s domain as your default, copy the **Kinde domain** URL. 2. If you use custom domains, select the **Use custom domain instead** switch. 3. If you have only one custom domain, copy the Custom domain URL. If you have custom domains for multiple organizations, select each one from the list and copy the callbacks for each. You need to enter all custom domain callbacks in the Microsoft app. 6. Select **Save**. 7. Use the copied Callback URL to set up the app, see below. ## Register a Microsoft app and set up 1. Go to your account at [https://portal.azure.com/](https://portal.azure.com/). 2. Navigate to **Entra ID**. You can do this from links on the main screen or in the left side menu. 3. Select **Add+ > App registration** or go to **Manage > App registrations > New registration**. 4. Enter a name for the app. 5. Select a **Supported account types option**. In testing, we selected **Accounts in any organizational directory and personal Microsoft accounts**. 6. In the **Redirect URI (optional)** section, select **Web** in the **Select a platform** dropdown. 7. Enter the **Callback URL** from Kinde. The ones you copied in the procedure above. Add additional entries for all your organization custom domain callbacks, e.g. account.customdomainone.com/login/callback, account.customdomaintwo.com/login/callback, etc. 8. Select **Register**. Details of your new app appear. 9. Copy the **Application (client) ID** and paste it in a text file or somewhere you can easily access it again. 10. Select **Certificates and secrets** from the left menu, select + **New client secret.** 11. Enter a name and give it an expiry date (or accept the default), then select **Add**. Details of the secret are generated. 12. Copy the value in the **Value** column and paste it in a text file or somewhere you can easily access it again. Make sure you copy from the **Value** column, not the **Secret ID** column. ## Add Microsoft app credentials to Kinde 1. In Kinde, go to **Settings** > **Authentication**. 2. In the **Social connections** section, on the **Microsoft** tile, select **Configure**. 3. Paste the **Client ID** (Application (client) ID) and **Client secret value** (that you copied from the **Value** column at step 12 above) into the relevant fields. 4. Select if you want to treat this connection as a trusted provider. A [trusted provider](/authenticate/about-auth/identity-and-verification/) is one that guarantees the email they issue is verified. We recommend leaving this off for maximum security. 5. When a user signs in with an email that matches an existing home realm domain (i.e. part of an enterprise connection), you can allow them to sign in using their existing credentials, rather than creating a new identity in Kinde. To make this happen automatically, select the **Auto redirect home realm users** option. 6. Add any [upstream params](/authenticate/auth-guides/pass-params-idp/) that you want to pass to the IdP. 7. Select which applications will allow Microsoft social SSO. 8. Select **Save**. Users will now see Microsoft as an option to sign up and sign in to the selected applications.

# Authenticate - Social sign in - Roblox social sign in

> Step-by-step guide to setting up Roblox social sign-in including Roblox app creation, OAuth configuration, and Kinde integration.

Roblox sign-in, Roblox app, OAuth, client ID, client secret, callback URL
authenticate

You can enable users to sign up and sign in using their Roblox credentials. To enable this, you’ll need some technical know-how and a Roblox app. <Aside type="warning" title="Social sign in for production environments"> Before you make your production environment live, you must add your own social app's Client ID and Client secret in the Kinde connection (as per below). Do not use Kinde's app credentials by leaving the fields blank, as this poses a security and performance risk, and makes it difficult to change auth providers without service disruptions for your users. </Aside> ## Get your Kinde callback URL 1. In Kinde, go to **Settings** > **Authentication**. 2. In the **Social connections** section, select **Add connection.** 3. In the window that appears, select **Roblox,** then select **Next**. 4. In the **Callback URL** section: 1. If you use Kinde’s domain as your default, copy the **Kinde domain** URL. 2. If you use custom domains, select the **Use custom domain instead** switch. 3. If you have only one custom domain, copy the **Custom domain** URL. If you have custom domains for multiple organizations, select each one from the list and copy the callbacks for each. You need to enter all custom domain callbacks in the Roblox app. 5. Select **Save**. 6. Use the copied Callback URLs to set up the app, see below. ## Create and configure a Roblox app 1. Sign up for a [Roblox](https://www.roblox.com/) account. 2. Follow [these instructions](https://create.roblox.com/docs/cloud/open-cloud/oauth2-registration/) to create an OAuth 2.0 app in Roblox. 3. Make sure you enable the `open id` and `profile` scopes. 4. Copy the app **Client ID** and **Secret**. You need these to set up Roblox in Kinde. ## Add Roblox credentials to Kinde You don’t need to wait for app approval to finish configuring Roblox in Kinde. 1. In Kinde, go to **Settings** > **Authentication**. 2. On the **Roblox** tile, select **Configure**. 3. Paste the **Client ID** and **Secret** from the Roblox app into the relevant fields. 4. Select if you want to treat this connection as a trusted provider. A [trusted provider](/authenticate/about-auth/identity-and-verification/) is one that guarantees the email they provide is verified. We recommend leaving this off for maximum security. Depending on your selection, here’s the behaviour in Kinde: - trusted off + existing email - creates new user, only updates people_profiles - trusted off + new email - creates new email identity (adds to people_identities) - trusted on + existing email - merges accounts w/existing user - trusted on + new email - creates new email identity (adds to people_identities) 5. Add any [upstream params](/authenticate/auth-guides/pass-params-idp/) that you want to pass to the IdP. 6. Select which applications will allow Roblox social sign in. 7. Select **Save**. Users will now see Roblox as an option to sign up and sign in to the selected applications.

# Authenticate - Social sign in - Slack social sign in

> Step-by-step guide to setting up Slack social sign-in including Slack app creation, OAuth configuration, and Kinde integration.

Slack sign-in, Slack app, OAuth, client ID, client secret, callback URL, scopes
authenticate

You can enable users to sign up and sign in using their Slack credentials. To enable this, you’ll need some technical know-how and a Slack app. <Aside type="warning" title="Social sign in for production environments"> Before you make your production environment live, you must add your own social app's Client ID and Client secret in the Kinde connection (as per below). Do not use Kinde's app credentials by leaving the fields blank, as this poses a security and performance risk, and makes it difficult to change auth providers without service disruptions for your users. </Aside> ## **Copy the callback URL from Kinde** 1. In Kinde, go to **Settings** > **Authentication**. 2. If you have not yet added the Slack social connection, select **Add connection** in the **Social authentication** section. 3. Select Slack, then **Next**. 4. In the **Callback URL** section: 1. If you use Kinde’s domain as your default, copy the **Kinde domain** URL. 2. If you use custom domains, select the Use custom domain instead switch. 3. If you have only one custom domain, copy the Custom domain URL. If you have custom domains for multiple organizations, select each one from the list and copy the callbacks for each. You need to enter all custom domain callbacks in the Slack app. 5. Select **Save**. 6. Use the copied Callback URL to set up the app, see below. ## **Create a Slack app** 1. Go to [Slack API Applications](https://api.slack.com/apps) and log in to your workspace. 2. Select **Create an App**. The **Create an app** window opens. 3. Choose how you’d like to configure your app’s scopes and settings. 4. If you are not sure, choose the **From scratch** option. 5. Enter your **App Name** and **Select a workspace**. 6. Click **Create App**. Your app is created. 7. Scroll to the **App Credentials** section and copy the **Client ID** and **Client Secret** and paste them in a text file or somewhere you can easily copy them. ### **Configure your Slack app** 1. In your Slack app, go to the **OAuth & Permissions** section. 2. Scroll to the **Redirect URLs** area and add the callback URLs you got from Kinde, then select **Save URLs**. Add additional entries for all your organization custom domain callbacks, e.g. account.customdomainone.com/login/callback, account.customdomaintwo.com/login/callback, etc. 3. To define what info will be shared when a user signs up or signs in with Slack, scroll to the **Scopes** section. 4. In the **User Token Scopes** area, select **Add an OAuth Scope** and from the dropdown menu choose **users.profile:read**. 5. Scroll up to the **OAuth Tokens for Your Workspace** section and select **Install to Workspace**. And when prompted, select **Allow**. 6. Select **Manage distribution** on the left and go to the **Share Your App with Other Workspaces** section. 7. Select **Remove Hard Coded Information** and in the area that appears, select the **I’ve reviewed and removed any hard-coded information** option. 8. Select **Activate Public Distribution**. Your app is now ready to use. ### **Add Slack credentials to Kinde** 1. In Kinde, go to **Settings** > **Authentication**. 2. On the Slack tile, select **Configure**. 3. Paste the **Client ID** and **Client secret** from the Slack app into the relevant fields. 4. Select if you want to treat this connection as a trusted provider. A [trusted provider](/authenticate/about-auth/identity-and-verification/) is one that guarantees the email they issue is verified. We recommend leaving this off for maximum security. 5. Add any [upstream params](/authenticate/auth-guides/pass-params-idp/) that you want to pass to the IdP. 6. Select which applications will allow Slack SSO. 7. Select **Save**. Users will now see Slack as an option to sign up and sign in to the selected applications.

# Authenticate - Social sign in - Twitch social sign in

> Step-by-step guide to setting up Twitch social sign-in including Twitch app registration, OAuth configuration, and Kinde integration.

Twitch sign-in, Twitch app, OAuth, client ID, client secret, callback URL, 2FA
authenticate

You can enable users to sign up and sign in using their Twitch credentials. To enable this, you’ll need a Twitch account and some developer know-how. <Aside type="warning" title="Social sign in for production environments"> Before you make your production environment live, you must add your own social app's Client ID and Client secret in the Kinde connection (as per below). Do not use Kinde's app credentials by leaving the fields blank, as this poses a security and performance risk, and makes it difficult to change auth providers without service disruptions for your users. </Aside> ## **Before you begin** **Enable Twitch 2FA** — Sign up for a Twitch account and [enable two-factor authentication](https://help.twitch.tv/s/article/two-factor-authentication?language=en_US) (2FA). You will need your mobile number and an authenticator app e.g. Google authenticator, to do this. ## **Get the Kinde callback URL** 1. In Kinde, go to **Settings** > **Authentication**. 2. In the **Social authentication** section, select **Add connection.** 3. Select **Twitch** and then select **Next.** 4. In the **Callback URL** section: 1. If you use Kinde’s domain as your default, copy the **Kinde domain** URL. 2. If you use custom domains, select the **Use custom domain instead** option. 3. If you have only one custom domain, copy the Custom domain URL. If you have custom domains for multiple organizations, select each one from the list and copy the callbacks for each. You need to enter all custom domain callbacks in the Twitch app. 5. Select **Save**. 6. Use the copied Callback URLs to set up the app, see below. ## **Register a Twitch app** 1. Go to the [Twitch developer console](https://dev.twitch.tv/) and select **Applications**. 2. Select **Register your application**. 3. Enter a name and the Kinde callback URLs you copied above. Add entries for all your organization custom domain callbacks, e.g. `account.customdomainone.com/login/callback`, `account.customdomaintwo.com/login/callback`, etc. 4. Select the **Category** as an **Application Integration**. 5. Select **Create**. See the [Twitch docs](https://dev.twitch.tv/docs/authentication/register-app#registering-your-app) for additional help. ## **Get app Client ID and Client secret** 1. In the **Application** section in Twitch, select **Manage** next to your application. 2. Copy the **Client ID.** 3. Select **New secret** and when prompted, confirm. 4. Copy and paste the **Client ID** and **Client Secret** into a text file or somewhere you can easily copy them. ## **Add Twitch credentials to Kinde** 1. In Kinde, go to **Settings** > **Authentication**. 2. On the Twitch tile, select **Configure**. 3. Paste the **Client ID** and **Client secret** from the app into the relevant fields. 4. Select if you want to treat this connection as a trusted provider. A [trusted provider](/authenticate/about-auth/identity-and-verification/) is one that guarantees the email they issue is verified. We recommend leaving this off for maximum security. 5. Add any [upstream params](/authenticate/auth-guides/pass-params-idp/) that you want to pass to the IdP. 6. Select which applications will allow Twitch SSO. 7. Select **Save**. Users will now see Twitch as an option to sign up and sign in to the selected applications. ## When an email is not provided Twitch does not require an email for sign up, but Kinde does. So if a user signs up with Twitch and an email is not detected, we will ask for one. The user only needs to provide their email once, then they can sign in via Twitch without disruption. If the email they provide is already detected in Kinde, we will automatically link the accounts so as not to duplicate.

# Authenticate - Social sign in - X (formerly Twitter) social sign in

> Step-by-step guide to setting up X (formerly Twitter) social sign-in including X developer platform app creation, OAuth configuration, and Kinde integration.

X sign-in, Twitter sign-in, X developer platform, OAuth, client ID, client secret, callback URL
authenticate

You can enable users to sign up and sign in using their X credentials. To enable this, you’ll need an X developer platform account and some developer know-how. <Aside type="warning" title="Social sign in for production environments"> Before you make your production environment live, you must add your own social app's Client ID and Client secret in the Kinde connection (as per below). Do not use Kinde's app credentials by leaving the fields blank, as this poses a security and performance risk, and makes it difficult to change auth providers without service disruptions for your users. </Aside> <Aside> You may notice X still has mixed URLs and messaging for the name change from Twitter on their own site. We refer to X in this document. </Aside> ## **Create an X app** Sign up for a X developer platform account and [add your app](https://developer.twitter.com/en/portal/dashboard). If you are signing up for the first time, you will be given a default app. If you already have apps, you’ll need to create a project and then add the new app within that project. ## **Get the Kinde callback URL** 1. In Kinde, go to **Settings** > **Authentication**. 2. In the Social connections section, select **Add connection.** 3. In the window that appears, select **X**, then select **Next**. 4. In the **Callback URL** section: 1. If you use Kinde’s domain as your default, copy the **Kinde domain** URL. 2. If you use custom domains, select the **Use custom domain instead** switch. 3. If you have only one custom domain, copy the **Custom domain** URL. If you have custom domains for multiple organizations, select each one from the list and copy the callbacks for each. You need to enter all custom domain callbacks in the X app. 5. Select **Save**. 6. Use the copied Callback URL to set up the app, see below. ## **Set up your X app** 1. Sign in to the [X Developer Platform](https://developer.twitter.com/). 2. In the side menu, select **Projects & apps** and then select your app. 3. In the **User authentication settings** section, select **Set up**. 4. Set the **App Permissions.** 5. Switch on **Request email from users.** 6. Select the **Type of App** as **Native app**. 7. Enter the Kinde callback URL you copied earlier. Add entries for all your organization custom domain callbacks, e.g. `account.customdomainone.com/login/callback`, `account.customdomaintwo.com/login/callback`, etc. 8. Enter your Kinde domain URL, e.g. `https://yourdomain.kinde.com`. 9. Enter details in other fields if you wish. 10. Select **Save**. 11. Select the **Key and tokens** tab at the top of the page. 12. Copy the **Client ID** and **Client Secret** from the **Oauth2.0** section and paste them into a text doc or other place where you can get them again later. View **X Developer Platform’s** docs for more info about [authentication](https://developer.twitter.com/en/docs/authentication/overview). ## **Add X credentials to Kinde** 1. In Kinde, go to **Settings** > **Authentication**. 2. In the list of **Social connections**, select **Configure** on the **X** tile. 3. Paste the **Client ID** and **Client secret** from the X app into the relevant fields. 4. Select if you want to treat this connection as a trusted provider. A [trusted provider](/authenticate/about-auth/identity-and-verification/) is one that guarantees the email they issue is verified. We recommend leaving this off for maximum security. 5. Add any [upstream params](/authenticate/auth-guides/pass-params-idp/) that you want to pass to the IdP. 6. Select which applications will allow users to sign in with X. 7. Select **Save**. Users will now see X as an option to sign up and sign in to the selected applications. ## When an email is not provided X does not require an email for sign up, but Kinde does. So if a user signs up with X and an email is not detected, we will ask for one. The user only needs to provide their email once, then they can sign in via X without disruption. If the email they provide is already detected in Kinde, we will automatically link the accounts so as not to duplicate.

# Authenticate - Social sign in - Xero social sign in

> Step-by-step guide to setting up Xero social sign-in including Xero app creation, OAuth configuration, and Kinde integration.

Xero sign-in, Xero app, OAuth, client ID, client secret, callback URL
authenticate

You can enable users to sign up and sign in using their Xero credentials. To enable this, you’ll need a Xero app and some developer know-how. <Aside type="warning" title="Social sign in for production environments"> Before you make your production environment live, you must add your own social app's Client ID and Client secret in the Kinde connection (as per below). Do not use Kinde's app credentials by leaving the fields blank, as this poses a security and performance risk, and makes it difficult to change auth providers without service disruptions for your users. </Aside> ## **Get your Kinde callback URL** 1. In Kinde, go to **Settings** > **Authentication**. 2. In the **Social connections** section, select **Add connection.** 3. In the window that appears, select **Xero,** then select **Next**. 4. In the **Callback URL** section: 1. If you use Kinde’s domain as your default, copy the **Kinde domain** URL. 2. If you use custom domains, select the **Use custom domain instead** switch. 3. If you have only one custom domain, copy the **Custom domain** URL. If you have custom domains for multiple organizations, select each one from the list and copy the callbacks for each. You need to enter all custom domain callbacks in the Xero app. 5. Select **Save**. 6. Use the copied Callback URLs to set up the app, see below. ## **Create and configure a Xero app** 1. Create a Xero developer account. [https://developer.xero.com/](https://developer.xero.com/) 2. Verify your email when prompted. 3. Select New app. 4. Give the app a name and select Web app as the type. 5. Add your company URL. 6. Enter your Kinde callback URL in the **Redirect URI** field. Add additional entries for all your organization custom domain callbacks, e.g. `account.customdomainone.com/login/callback`, `account.customdomaintwo.com/login/callback`, etc. 7. Accept the terms and conditions and select **Create App**. 8. Go to **Configuration** and copy the **Client id** somewhere you can access it later. 9. Generate a **Client secret** and copy it immediately somewhere you can access it again. You will not get to copy it again. ## **Add Xero credentials to Kinde** 1. In Kinde, go to **Settings** > **Authentication**. 2. On the **Xero** tile, select **Configure**. 3. Paste the **Client ID** and **Client secret** from the Xero app into the relevant fields. 4. Select if you want to treat this connection as a trusted provider. A [trusted provider](/authenticate/about-auth/identity-and-verification/) is one that guarantees the email they issue is verified. We recommend leaving this off for maximum security. 5. Add any [upstream params](/authenticate/auth-guides/pass-params-idp/) that you want to pass to the IdP. 6. Select which applications will allow Xero social sign in. 7. Select **Save**. Users will now see Xero as an option to sign up and sign in to the selected applications.

# Billing - About billing - About billing

> Overview of Kinde billing capabilities including plan management, pricing tables, payment processing, and customer lifecycle management.

billing, plans, pricing, Stripe, customer lifecycle, revenue, subscriptions
billing

Kinde billing gives you the ability to charge customers for your services and collect revenue. As part of using this feature, you can: - Create and manage plans, and make them visible to your customers - Create and customize a pricing table for plan selection - Implement specific pricing models to suit your product - Use Stripe for secure handling of payments and invoicing - Link organizations (B2B) and individual customers (B2C) to a plan - Handle plan upgrade, downgrade, and cancellation - Enable self-serve account management for customers - Customize the pricing table to make the whole experience on-brand Billing makes the Kinde platform _the_ essential development infrastructure for managing the customer lifecycle across every part of your business. From registration to plan selection, authorization to provisioning, releases to upgrades. ## This is our first billing release Billing is a really complex area of app development, so while this release is tested and ready, we are actively working on improvements from day one. ### How to send feedback It would be amazing if you can send any feedback you have [support@kinde.com](mailto:support@kinde.com) so we can quickly collect and prioritize improvements. ## Known limitations These are current limitations that we are aware of and are working on adding. - Support for plan models with free trial periods - Annual and quarterly subscriptions. Only monthly is available right now. - Changes to the billing cycle (e.g. choose billing anniversaries, etc.) - Add-ons and discounts that can be applied to individual subscriptions

# Billing - About billing - Billing concepts & terms

> Comprehensive guide to billing concepts and terminology including plan groups, features, pricing models, and common billing terms.

billing concepts, plan groups, features, pricing models, metered usage, fixed charges, multi-currency
billing

'Billing' refers to the broad function of creating plans, setting pricing, collecting payments, etc. Here are some of the common concepts and terms you will come across. ## Billing identifiers - **Customer ID** - A `customer_id` uniquely identifies a user or org who has signed up to a plan. This is different to a `user_id` or `org_id` that identifies the user or org as an entity. - **Customer Agreement ID** - A `customer_agreement_id` identifies the contract or agreement created in Stripe when a plan is signed up to. The agreement ID is then associated with the `customer_id` in Kinde. ## Key concepts - **Plan groups** - Plan groups organize multiple plans under a common category, helping segment offerings by use case, customer size, or market. A group is scoped to either organizations (B2B) or individual customers (B2C). You can have multiple plan groups, but each plan must belong to a group. - **Plans** - Plans define the specific features, usage limits, and pricing tiers offered to customers in a SaaS product. - **Features** - Plan features are the specific capabilities or entitlements included in a plan. They can be chargeable (incurring additional fees) or non-chargeable (included at no extra cost). Features can be metered (usage-based) or unmetered (fixed access). - **Fixed charges**- Single chargeable items like the subscription base price and other stand alone recurring charges. - **Pricing models** - Pricing models are the different methods of charging customers, such as flat-rate, usage-based, tiered, per-seat pricing, etc. Your pricing model is determined by your product and customer needs. Consider scalability and longevity when deciding this. - **Payments processor** - A payments processor is a third-party service that securely processes customer payments via credit cards, ACH, or other methods - such as Stripe Billing. - **Pricing table** - A pricing table is a visual representation of your different subscription plans, showcasing features and prices to help users compare options. You can build one in Kinde and then show it to your customers in the auth flow or self-service portal. - **Self-serve account portal** - Kinde provides a self-serve portal. This allows customers to manage their subscriptions—such as upgrading plans, updating payment information, or cancelling. This reduces support overhead and improves user autonomy. In Kinde, you can decide what your customers can self-manage or remove the functionality completely. ## Common billing terms - **Agreement** - the term used in Stripe and the Kinde API to refer to a customer's subscription. Both terms are used throughout docs. - **Base price** – The starting cost of a subscription plan, typically the cost for a core set of features or a minimum level of usage. - **Chargeable / Non-chargeable feature** – - **Chargeable feature**: Incurs an additional fee when used. Might be metered or per unit price. - **Non-chargeable feature**: Add non-chargeable features for any included features which aren't independently chargeable, but need to be gated in your product. - **Feature** – A specific function or capability of your SaaS product that you provision for app users. In context with a plan, these are chargeable or non-chargeable features that are provisioned to customers. - **Fixed charge** – A recurring fee that does not change based on usage, often applied monthly or annually. Use this for a plan’s base price or other flat recurring fees. - **Metered and unmetered feature** – Metered features are provisioned in units, often with pricing per unit, e.g. MAU. An unmetered feature is like a boolean, and is a basic feature with no pricing attached. - **Multi-currency** – The ability to set plan prices in different currencies to support global customers. Kinde supports nearly all currencies, but you can currently only pick one as the default for all plans. - **Plan** – A packaged offering of features, prices, and terms available for subscription, typically tiered across a group (e.g., Basic, Pro, Enterprise). - **Plan group** – A collection of related plans, often grouped by customer type or usage level, allowing easier management and comparison. - **Pricing model** – The structure used to determine how features in a plan are priced. E.g. fixed charge, tiered, per-user, or usage-based pricing. Kinde lets you use multiple pricing models within one plan. - **Subscription** – The ongoing agreement where a customer pays for access to a SaaS product via a recurring plan. This is referred to as an agreement in Stripe. - **Tiered pricing** – This refers to unit pricing that has different unit costs based on the volume of units purchased. E.g. $10 per unit for 1–10 units, $8 per unit for 11–50 units, $5 per unit over 51 units. - **Unit price** – Where a price is set per unit of usage, e.g. a seat or license. Unit prices can also be applied to metered features, e.g. x per unit. Unit prices can also be tiered, e.g. x per unit up to 10 units, then y for 10+ units. - **Usage-based** **price** – A billing method where charges vary based on the metered consumption of resources or services (e.g., API calls, storage).

# Billing - About billing - Top questions about Kinde billing

> A collection of the top questions and answers about how to set up and configure Kinde billing for your Kinde business.

billing, plans, plan selector, entitlements, feature charges, pricing models, MAU, Stripe
billing, plans, plan selector, entitlements, feature charges, pricing models, MAU, Stripe

Here are short answers to the most common billing questions. Click any question to expand the answer. <Aside title="Ask the docs"> Type **@kindeAI** to access 24/7 global support in the **#ask-kinde-ai** channel in the Kinde [Slack](https://join.slack.com/t/thekindecommunity/shared_invite/zt-1vyq8qilj-jFH5V27jfFnHk~BuBSU0ZA) or [Discord](https://discord.gg/KdkCXRNTFn) communities. </Aside> ## Core billing functionality in Kinde <details> <summary><strong>How do I choose the right Kinde billing pricing model for my SaaS customers?</strong></summary> Think about how your customers actually use your product and what they value most. If you're selling a tool where usage varies dramatically - like API calls or storage - go with usage-based pricing so customers only pay for what they consume. For products where value comes from access to features rather than consumption, subscription pricing makes more sense. Kinde lets you mix these models within a single plan, so you could have a $20 base subscription plus $0.10 per extra API call. Start simple with one model and add complexity as you grow - your customers will thank you for not overwhelming them upfront. [Explore pricing models](/billing/pricing/pricing-models/) | [About billing concepts](/billing/about-billing/billing-concepts-terms/) </details> <details> <summary><strong>What's the difference between Kinde's metered and unmetered features in plans?</strong></summary> Metered features are the ones you can put a number on - monthly active users, API calls, storage gigabytes, support hours. These can be chargeable (customers pay per unit) or non-chargeable (included in their plan up to a limit). Unmetered features are more like switches - either customers have access to your advanced analytics dashboard or they don't. Think of metered features as "how much" and unmetered as "yes or no." Most SaaS businesses use a mix of both to create clear upgrade paths without making pricing too complicated. [About plans and features](/billing/manage-plans/about-plans/) | [Billing concepts guide](/billing/about-billing/billing-concepts-terms/) </details> <details> <summary><strong>How do Kinde plan groups help me organize billing for different customer types?</strong></summary> Plan groups are how you separate B2B and B2C offerings without creating a mess. Each group is tied to either individual users or organizations, never both. So you might have a "Professional" group with individual plans for freelancers and consultants, and a separate "Enterprise" group with team-based pricing for companies. You can create multiple pricing tables from one group, but each table can only show plans from a single group. This keeps your offerings clean and makes it easier for customers to find the right fit. [Plan groups management](/billing/manage-plans/about-plans/) | [Billing concepts](/billing/about-billing/billing-concepts-terms/) </details> <details> <summary><strong>Why should I use Kinde's billing features instead of building my own payment system?</strong></summary> Unless you're excited about spending months building subscription management, dunning logic, proration calculations, and tax compliance - spoiler alert: you're probably not - Kinde's billing saves you from that headache. We handle the messy bits like Stripe integration, plan upgrades, usage tracking, and invoice generation, so you can focus on building features your customers actually care about. Plus, you get a self-serve portal out of the box, which means fewer support tickets about billing issues. [About billing plans](/billing/manage-plans/about-plans/) | [Self-serve portal setup](/build/self-service-portal/self-serve-portal-for-orgs/) </details> <details> <summary><strong>How does Kinde handle the technical complexity of subscription billing?</strong></summary> We abstract away the most technical parts. Once you connect to Stripe (we create a new account for you automatically), everything syncs seamlessly. Plan changes, usage tracking, proration, invoice generation - it all happens behind the scenes. Your customers get a smooth experience upgrading or downgrading, and you can set up webhook notifications when important billing events happen. The only thing you need to worry about is building great features and deciding how to price them. [Stripe integration guide](/billing/get-started/connect-to-stripe/) | [About billing plans](/billing/manage-plans/about-plans/) </details> <details> <summary><strong>What happens when I publish a plan versus keeping it in draft, in Kinde?</strong></summary> Draft plans are your work in progress - you can tweak pricing, add features, change everything without affecting anyone. Once you publish a plan, it syncs to Stripe and becomes available for actual customers to subscribe to. Here's the catch: once someone subscribes to a published plan, you can't change it anymore, only version it (though plan versioning isn't available yet). This protects your existing customers from surprise pricing changes, but it means you need to think things through before hitting publish. [About plans lifecycle](/billing/manage-plans/about-plans/) | [Billing concepts](/billing/about-billing/billing-concepts-terms/) </details> ## Stripe integration <details> <summary><strong>Why does Kinde create a new Stripe account instead of connecting to my existing one?</strong></summary> This is actually a Stripe requirement for third-party integrations like ours, not something we chose. They want to ensure security and compliance by controlling how connected accounts are set up. The good news? You can transfer your existing business information during the Stripe onboarding process, so you're not starting from scratch. We're working on a migration strategy to make this smoother, but for now, the new account approach keeps everyone secure and compliant. [Stripe connection setup](/billing/get-started/connect-to-stripe/) | [Manage Stripe connection](/billing/payment-management/manage-stripe-connection/) </details> <details> <summary><strong>What should I tell customers when my Kinde–Stripe connection shows "In progress" status?</strong></summary> Don't worry - this just means Stripe needs a bit more information from you to complete the setup. Usually it's business details like contact information, tax info, or identity verification (they might ask for ID upload). The connection won't work for live payments until this is sorted, so customers won't be able to subscribe to paid plans yet. Jump into your Stripe dashboard through the "Update Stripe information" button in Kinde to see what's missing. Once everything's complete, the status should change to "Connected" and you're good to go. [Stripe connection troubleshooting](/billing/payment-management/manage-stripe-connection/) | [Connect to Stripe guide](/billing/get-started/connect-to-stripe/) </details> <details> <summary><strong>How do I test Kinde billing without charging real money?</strong></summary> Switch to your non-production environment in Kinde - this automatically creates a test Stripe account that won't process real payments. You can create plans, test the whole customer journey, even simulate failed payments, all without touching real credit cards. This is perfect for making sure your billing flow works before going live. Just remember to switch back to your production environment when you're ready to accept real payments. [Stripe integration setup](/billing/get-started/connect-to-stripe/) | [About billing plans](/billing/manage-plans/about-plans/) </details> ## Plan management <details> <summary><strong>How should I structure Kinde billing plans to make upgrading feel natural for customers?</strong></summary> Create a clear progression where each plan builds on the previous one. Start with a generous free plan that gives users real value, then add features and remove limits as they upgrade. Instead of completely different feature sets, use metered features to give everyone a "taste" - maybe 100 API calls on Free, 1,000 on Pro, unlimited on Enterprise. This way upgrades feel like growth, not switching to something completely different. Keep plan names simple and descriptive - "Starter," "Professional," "Enterprise" beats "Bronze," "Silver," "Gold" every time. [About pricing models](/billing/pricing/pricing-models/) | [Plan management guide](/billing/manage-plans/about-plans/) </details> <details> <summary><strong>What's the best way to handle Kinde plan features that some customers need but others don't?</strong></summary> This is where unmetered features shine. Instead of cramming every possible feature into every plan, gate advanced capabilities behind higher tiers. Use unmetered features as "gates" - advanced reporting might only be available on Business plans, while API access could be Professional and up. For features with variable usage, use metered features with different limits per plan. This way customers self-select into the right plan based on what they actually need, and you avoid feature bloat in your lower tiers. [Feature planning strategy](/billing/manage-plans/about-plans/) | [Billing concepts](/billing/about-billing/billing-concepts-terms/) </details> <details> <summary><strong>How do I explain Kinde's tiered pricing to customers who are confused about usage charges?</strong></summary> Be upfront about how the math works and give concrete examples. If you charge $0.50 for the first 10 API calls, then $0.30 for calls 11-50, show them: "If you make 25 API calls, you pay $5 for the first 10, then $4.50 for the next 15 = $9.50 total." Most customers appreciate transparency over surprises. Consider setting reasonable limits on lower plans instead of unlimited usage-based charging - it makes budgeting easier for them and upgrade paths clearer for you. Mke sure your pricing table is descriptive and clear about metered or package prices. This can be tricky. [Pricing models explained](m/billing/pricing/pricing-models/) | [Build a pricing table](/billing/billing-user-experience/plan-selection/) </details> <details> <summary><strong>What should I consider when setting Kinde plan upgrade and downgrade policies?</strong></summary> Think about what's fair for both you and your customers. By default, Kinde forgives unpaid usage when customers downgrade and doesn't refund unused subscription days - this is pretty industry standard and avoids messy proration calculations. But you can change these policies if needed. For example, if someone on your $100/month plan cancels mid-month, you might choose not to refund the remaining days but also not charge them for any metered usage that month. Find the balance that feels fair and stick with it consistently. [Plan policies configuration](/billing/manage-plans/upgrade-downgrade-plans/) | [Billing setup guide](/billing/get-started/connect-to-stripe/) </details> ## User experience <details> <summary><strong>How do I create Kinde pricing tables that actually convert visitors into customers?</strong></summary> Less is more when it comes to pricing tables. Stick to your 3-4 core plans (Free, Pro, Business works great), highlight which plan is most popular, and focus on benefits rather than features. Use the custom features section to highlight your best selling points for each plan, and don't just copy your technical feature list. Test different approaches, but remember - confused customers don't buy anything. If your product is complex or has a lot of features, you might want to create a custom designed table. [Build effective pricing tables](/billing/billing-user-experience/plan-selection/) | [Pricing table customization](/billing/billing-user-experience/plan-selection/) </details> <details> <summary><strong>Should I show Kinde pricing tables during the signup flow or after users experience my product?</strong></summary> Depends on your product and customer type. For simple tools where the value is obvious upfront, showing pricing during signup can work well - especially if you have a generous free tier. For complex products where users need to understand the value first, let them sign up and experience your product before presenting upgrade options. You can control this in Kinde by toggling the "Show pricing table when customers sign up" option. Test both approaches if you're unsure - the data will tell you what works for your audience. [Pricing table display options](/billing/billing-user-experience/pricing-table-display/) | [Billing integration guide](/billing/billing-user-experience/plan-selection/) </details> <details> <summary><strong>How do I handle customers who need custom pricing that doesn't fit Kinde's standard plans?</strong></summary> Start by trying to fit them into your existing plans with some creative metered feature limits - you'd be surprised how often this works. If they truly need something custom, you can manually adjust metered usage for specific customers through the Kinde API after they subscribe. For true enterprise deals with annual contracts or bank transfers, those arrangements are available but you'll need to work with Kinde's enterprise team. Most customers who think they need custom pricing actually just need a slightly modified version of your top tier. [API billing management](/billing/manage-plans/about-plans/) | [Enterprise billing options](/manage-your-account/profile-and-plan/change-kinde-plan/) </details> ## Self-serve portal <details> <summary><strong>How does Kinde's self-serve portal reduce my customer support workload?</strong></summary> Think of it as your billing support team that never sleeps. Customers can update their payment details, view billing history, upgrade plans, and manage organization settings without creating support tickets. You control exactly what they can self-manage - maybe you want them handling payment updates but prefer to manage plan changes yourself. The portal generates one-time secure links, so you can add "Manage Billing" buttons throughout your app that take users directly to the right section. Less support tickets means more time building features that matter. [Self-serve portal setup](/build/self-service-portal/self-serve-portal-for-orgs/) | [Portal configuration options](/build/self-service-portal/self-serve-portal-for-orgs/) </details> <details> <summary><strong>What permissions should I give organization members via Kinde's self-serve portal feature?</strong></summary> It's better to start with more restrictions and expand, than start with too many that you might have to remove. Most organizations want their admins to manage payment details and view billing history, but you might not want every team member changing subscription plans. Kinde provides some pre-defined roles with varying portal access - so that the right people can change the right things. The permissions map directly to Kinde's system permissions like `org:write:billing`, so you can be granular about who can do what. [Portal permissions setup](/build/self-service-portal/self-serve-portal-for-orgs/). </details> <details> <summary><strong>How do I generate Kinde self-serve portal links for use in my app?</strong></summary> You've got two options depending on your setup. If you're using Kinde for authentication, use the SDK to generate portal links on the fly - perfect for "Account Settings" buttons in your app. If you're handling auth yourself or need server-side generation, hit the Kinde Management API with an M2M token. You can specify which section of the portal to open (billing, profile, etc.) and where to redirect users when they're done. The links are one-time use for security, so generate them fresh each time. [Portal link generation](/build/self-service-portal/self-serve-portal-for-orgs/) | [Management API integration](/build/self-service-portal/self-serve-portal-for-orgs/) </details> ## Integration and development <details> <summary><strong>How do I sync Kinde billing data with my application's feature access controls?</strong></summary> Use the Account API to check what features and usage limits a signed-in user has access to. The API returns billing entitlements along with roles and permissions, so you can gate features based on their current plan. For organization-level billing data (which is more sensitive), use the Management API instead. Set up webhooks for billing events like plan changes or usage updates, so your app stays in sync automatically. Don't try to cache billing data for too long - things change, and you want accurate limits. [Account API for billing](/developer-tools/account-api/about-account-api/) | [Billing webhooks](/integrate/webhooks/about-webhooks/) </details> <details> <summary><strong>How should I handle Kinde billing webhook events in my application?</strong></summary> Set up dedicated API endpoints to receive billing webhooks and verify the JWT signatures - this is how you know the requests actually come from Kinde. Handle key events like subscription changes, payment failures, and usage updates to keep your app in sync. Always respond with a 200 status code when you successfully process a webhook, or Kinde will keep retrying with backoff logic. Use the webhook request ID as an idempotency key to avoid processing the same event twice if there are retries. [Webhook implementation](/integrate/webhooks/about-webhooks/) | [Webhook setup guide](/integrate/webhooks/add-manage-webhooks/) </details> <details> <summary><strong>How do I implement Kinde billing URLs and parameters for seamless user experiences?</strong></summary> Use URL parameters to direct customers to specific plans or pricing tables when they're ready to upgrade. For example, `?plan=pro_monthly` can take them straight to your Pro plan signup. This is super useful for email campaigns, in-app upgrade prompts, or landing pages. You can also override which pricing table displays using parameters, so different marketing campaigns can show different plan combinations. The SDK handles most of this automatically, but manual URL construction gives you more control. [Billing URL integration](/billing/billing-user-experience/plan-selection/) | [Pricing table configuration](/billing/billing-user-experience/pricing-table-display/) </details> ## Troubleshooting and support <details> <summary><strong>Why aren't the plan prices I set up in Kinde syncing with Stripe?</strong></summary> If you see "price not synced" status, it usually means the plan isn't published yet - only published plans sync to Stripe. Mixed sync status (some features synced, others not) typically happens when some features are already in a published plan while others are new additions. Try publishing or re-publishing the plan to trigger a sync. If it's still not working, check that your Stripe connection status shows "Connected" rather than "In progress" or "Connecting." [Plan publishing process](/billing/manage-plans/about-plans/) | [Stripe connection status](/billing/payment-management/manage-stripe-connection/) </details> <details> <summary><strong>What should I do when customers report billing discrepancies?</strong></summary> Start by checking the billing history in their organization's portal - this shows exactly what they were charged and when. Look for things like mid-month plan changes (which can cause proration), metered usage overages, or failed payment retries. Most "billing errors" are actually just confusing timing - customers might see charges for last month's usage appearing on this month's invoice. If you genuinely find an error, Kinde's support team can help resolve it, but having the billing details handy speeds things up. [Billing history access](/manage-your-account/profile-and-plan/view-kinde-plan/) | [Support resources](/build/self-service-portal/self-serve-portal-for-orgs/) </details> <details> <summary><strong>What are some of Kinde's billing limitations and when might these be fixed?</strong></summary> Currently, Kinde only supports monthly billing (no annual), doesn't have free trial periods built-in, and plan versioning isn't ready yet. For customers who need annual billing, you could manually create annual plans with different pricing. For free trials, you could start them on a free plan and set up automated emails to encourage upgrades. Give us feedback about your billing experience with Kinde by reporting bugs and making feature suggestions. We genuinely are listening. [Current billing limitations](/billing/manage-plans/about-plans/) | [Alternative approaches](/billing/pricing/pricing-models/) </details> ## Best practices <details> <summary><strong>What's the smartest way to launch Kinde billing for an existing SaaS product with users?</strong></summary> Start by setting up your billing plans and pricing tables in a non-production environment to get everything perfect. Create a grandfathering strategy for existing users - maybe they keep their current access levels for a certain period before needing to choose a plan. When you're ready to go live, communicate the changes clearly with plenty of notice. Consider starting with just new signups on the new billing system, then migrating existing users in batches. This gives you time to iron out any issues without affecting your entire user base at once. [Billing setup strategy](/billing/get-started/connect-to-stripe/) | [Plan management](/billing/manage-plans/about-plans/) </details> <details> <summary><strong>How should I price Kinde metered features to encourage growth while staying profitable?</strong></summary> Pricing decisions can be really hard. Start with generous free tiers that let customers experience real value, then use usage limits to create natural upgrade triggers. If your app gets more valuable with heavier usage, price metered features aggressively low or even free up to reasonable limits. The goal is to make customers successful enough that upgrading feels like a no-brainer rather than a burden. Watch your unit economics closely - some features cost you more to provide than others, so price accordingly. [Metered pricing strategies](/billing/pricing/pricing-models/) | [Feature management](/billing/manage-plans/about-plans/) </details> <details> <summary><strong>What's the most effective way to use Kinde billing data to reduce customer churn?</strong></summary> Set up webhooks for payment failures and usage pattern changes, then create automated workflows to reach out before customers hit walls. If someone's approaching their usage limits, send them upgrade prompts with specific benefits rather than just warnings. Use billing data to identify your best customers (high usage, consistent payments) and make sure they're getting white-glove treatment. Failed payments aren't always churn signals - sometimes cards expire or customers need payment method updates. [Billing webhooks setup](/integrate/webhooks/about-webhooks/) | [Usage tracking](/billing/manage-plans/about-plans/) </details> <details> <summary><strong>How do I structure Kinde plans to minimize customer confusion while maximizing revenue?</strong></summary> Keep it simple with clear value differences between tiers. Three to four plans usually hit the sweet spot - more than that and customers get paralyzed by choice. Use the "good, better, best" psychology: make your middle plan the obvious choice by giving it the best value ratio. Include some metered features as "freebies" in higher plans to justify the price jump. And please, test your pricing table with real humans before launching - what seems obvious to you might be confusing to customers who see it fresh. [Pricing table best practices](/billing/billing-user-experience/plan-selection/) | [Plan strategy guide](/billing/pricing/pricing-models/) </details>

# Billing - About billing - The Kinde billing model

> Detailed explanation of the Kinde billing model including Stripe integration, B2B/B2C support, multi-currency, and billing cycles.

Kinde billing model, Stripe integration, B2B, B2C, B2B2C, multi-currency, billing cycles, payment processing
billing

In the Kinde model, we handle everything except the payment processing part of billing. Kinde integrates with a third-party payment processor (Stripe) for secure payment processing. This involves a continuous sync between Kinde and Stripe, to ensure that products, prices, subscription information, invoices and payments, are accurate in both systems. Kinde does not store payment details, such as credit card information. This is exclusively managed by Stripe. ## Billing for B2B, B2C and B2B2C Kinde supports billing models for B2B, B2C and even B2B2C. Depending which you are setting up, you may need to do a few different tasks. Most of the setup is common, but we will call out tasks that are only relevant to one or the other. - B2B - customers are companies, organizations, or groups. - B2C - customers are individual users. - B2B2C - the platform model, where you have a customer who is an organization, and then users who are customers of that organization. ## Kinde and Stripe Kinde integrates a single payment processor (only Stripe Billing for now) to handle the financial and payment management side of things. Stripe uses the plan data and the customer info to create an agreement in Stripe. The customer is invoiced based on this agreement. Stripe securely stores your customer’s payment details and Kinde never sees credit card or other bank information. Here’s what the billing feature looks like as a workflow. ![Plan purchase workflow](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/b9a7bc9a-8f32-4a6d-fe4c-799db02c1600/public) Stripe is currently the only payment provider supported with Kinde. But we plan to expand to other providers in the near future. ## Multi-currency support Kinde has customers everywhere and almost every global currency is supported. ## Transaction data and Stripe region - When you connect your Stripe account to Kinde, you connect to our Stripe US account. We do this because Stripe US more widely supports global functionality. - Regardless of your own Stripe account region, you can still select any currency for your plans in Kinde, and Stripe will do the hard part of exchange rate conversion, tax calculations, etc. - Any fees you incur in Stripe for international transactions are your sole responsibility. ## Billing and invoice cycles By default, Kinde uses the following billing behavior, though some aspects can be customized depending on how you configure cancellations. - Billing cycles are monthly, based on the customer's original sign-up date. - Fixed charges (e.g. monthly subscription fees) are billed in advance, customers pay at the start of their billing period. - Metered (usage-based) charges are billed in arrears, usage is tracked throughout the billing period, and charges appear on the next invoice. You can also [set policies](/billing/get-started/setup-overview/) to control what happens when a customer cancels or changes their plan.

# Billing - Billing user experience - Update code and URLs for billing

> Guide to integrating billing into your application using URL parameters, React SDK components, and authentication flows.

billing integration, URL parameters, React SDK, plan selection, pricing table, org signup, B2B
billing

This topic explains how to customize billing flows with Kinde, including URL parameters, direct auth URLs, and SDK usage in React. Examples are given in React, but can be adapted for most frameworks. ## Edit the auth URL parameters directly Here’s a standard Kinde auth URL: ``` https://<your_kinde_subdomain>.kinde.com/oauth2/auth ?response_type=code &client_id=<your_kinde_client_id> &redirect_uri=<your_app_redirect_url> &scope=openid%20profile%20email &state=abc ``` Add these parameters as needed: | Parameter | Description | | --- | --- | | `plan_interest` | Pre-selects a plan (skips plan selection) | | `pricing_table_key` | Displays a specific pricing table | | `is_create_org` | Triggers org sign-up flow | ### Examples - Pre-select a plan: ``` ...&plan_interest=pro_monthly ``` - Show specific pricing: ``` ...&pricing_table_key=spring_promo ``` - Org sign-up: ``` ...&is_create_org=true ``` ## Integrate billing using the React SDK You can avoid manual URL construction by using our SDK components. Here's how. **User sign-up (default):** ```jsx <RegisterLink>Sign up</RegisterLink> ``` **Org sign-up (B2B):** ```jsx <RegisterLink isCreateOrg>Sign up your organization</RegisterLink> ``` **Pre-select a user plan:** ```jsx <RegisterLink planInterest="pro_monthly">Sign up with Pro plan</RegisterLink> ``` **Show a specific pricing table:** ```jsx <RegisterLink pricingTableKey="spring_promo">Spring Promo Sign up</RegisterLink> ``` **Combine for B2B + pricing table:** ```jsx <RegisterLink isCreateOrg pricingTableKey="enterprise_2024"> Sign up your company </RegisterLink> ```

# Billing - Billing user experience - Customize the plan sign-up experience

> Guide to customizing the plan sign-up experience including three different approaches and billing screen customization options.

plan sign-up, billing customization, plan selection, payment flow, billing screens, HTML CSS customization
billing

There are three ways you can allow customers to sign up to a plan. ## Option 1: Use your own plan selection screen Display a plan selection screen in your own app or website. Once the user selects a plan, redirect them to Kinde to complete the payment flow. To pre-select a plan, pass the `plan_interest` query parameter in the Kinde authentication URL. ## Option 2: Use Kinde’s built-in plan selection Let Kinde handle plan selection as part of the authentication flow. To enable this: - [Create a pricing table](/billing/billing-user-experience/plan-selection/) in Kinde - [Add and publish plans](/billing/manage-plans/create-plans/) - Set the table to **Live** Once this is done, use the relevant pricing table key in the authentcation URL and Kinde will display the plan selection screen during signup. ## Option 3: Assign a plan via the Kinde Management API Use the [Kinde Management API](https://docs.kinde.com/kinde-apis/management/#tag/billing-agreements/get/api/v1/billing/agreements) to assign a customer to a specific plan. The next time the customer signs in, Kinde will automatically prompt them for payment details. This is ideal for: - Migrating customers from another system - Assigning a plan without user input ## Customize billing screens in the authentication flow Depending on how you choose to onboard customers, users will see three different billing screens during the authentication flow. These screens can be customized: 1. **Plan selection** - Displayed when a user signs up for the first time and multiple plans are available. 2. **Payment details** - Shown after a user selects a plan—or if a plan was pre-selected before redirecting to Kinde. 3. **Success** - Shown when sign up and payment are successfully completed. By default, all screens will inherit branding and styling from the global Kinde [Design](/design/brand/global-brand-defaults/) settings. If you want more control, you can [fully customize these screens using your own **HTML, CSS, and JavaScript**](/design/customize-with-code/customize-with-css-html/).

# Billing - Billing user experience - Build a pricing table

> Comprehensive guide to building pricing tables in Kinde including plan selection, customization, multi-language support, and integration options.

pricing table, plan selection, plan groups, multi-language, plan highlighting, plan ordering, live pricing
billing

You can build pricing tables to enable your customers to select plans and go through a payment flow as part of signing up to your app or site. Kinde's pricing table builder can generate a pricing table from published plans, or you can start with a blank one. You can also add and edit information and content in your preferred languages. You can create as many pricing tables as you want. ![parts of a pricing table](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/c911b0af-5c1d-44f8-970b-47c0084ad500/public) ## Create a pricing table A pricing table can only have 4 plans. 1. Go to **Billing > Pricing tables**. 2. Select **Add pricing table**. 3. Choose an option: 1. **Generate** a pricing table from a [plan group](/billing/manage-plans/add-manage-plan-groups/) - this pre-populates the pricing table with basic details and the plans based on the plan group you select. Up to 4 plans can be included on a pricing table. If your plan group contains more, you may want to create a new pricing table. 2. **Create new** pricing table. Manually build the pricing table and add plans from a plan group. This gives you a blank slate to start in. 4. Select **Next**. 1. **Generated** - select the group and then **Save**. 2. **New** - complete the details in the window and **Save**. ## Edit the pricing table You can edit a pricing table, but they are not versioned. Whatever content you override, it cannot be reverted or recovered. You cannot edit a plan price. This is inherited from the plan itself. ## Change what plans show on a pricing table You can add and remove plans from the pricing table when it is being worked on. 1. Open the pricing table. 2. Scroll to the **Plans** section. 3. To remove a plan: 1. Select the three dots on the plan card and select **Remove from pricing table**. 2. Confirm you want to remove the plan. This removes all custom content you have added, in all languages you have added content in, on the pricing table. The plan is removed. 3. Select **Save**. 4. To add a plan, select **Add plan**. 1. In the window that opens, select an available plan. Only plans from the same plan group are shown. 2. Complete the details in the window for this plan. At minimum, you must enter a **Display name** and the **CTA button** content. This will be displayed in the pricing table. 3. Select **Save**. The plan is added to the pricing table. ## Change the order of plans on a pricing table 1. Open the pricing table. 2. Scroll to the **Plans** section. 3. Select the three dots menu on the plan you want to move. 4. Select **Move up** or **Move down**, depending on the plan position. 5. Select **Save**. This is the order plans will be displayed left to right on the pricing table. ## Add a features list to a plan on the pricing table To promote the top features in a plan, add them manually to the pricing table. These features don't need to correspond exactly to your plan configuration, this is an opportunity to sell the most appealing product features and make plan choices easy for customers. 1. Open the pricing table. 2. Scroll to the **Plans** section. 3. Select the three dots menu on the plan and select **Edit content**. 4. In the top of the window, select the language you want to add features in. 5. Add a **Features list heading**. This sits directly above the list. 6. Add a list of features in the large text **Features list** field. Features will appear in the order they are listed. 7. Select **Save**. ## Highlight a plan on a pricing table It’s common to want to call out or highlight something about a plan on the pricing table, for example, to highlight which plan is most popular. 1. Open the pricing table. 2. Scroll to the **Plans** section. 3. Select the three dots menu on the plan and select **Edit content.** 4. In the top of the window, select the language you want to add highlight content. 5. Add a **Highlight label** and select **Save**. ## Edit and translate pricing table content If you want to display pricing tables in multiple languages, you can change add content translations to the plans on the pricing table. 1. Open the pricing table. 2. Scroll to the **Plans** section. 3. Select the three dots menu on the plan and select **Edit content.** 4. In the top of the window, select the language you want to add or edit content for. ![image.png](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/58587ad1-0077-47d7-faca-ea3dd6345d00/public) 5. Enter or edit all the content you want in the chosen language. 6. Select **Save**. ## Make the pricing table live to customers We recommend only doing this after your plans are finalized and published. 1. Open the pricing table. 2. Select **Make live**. 3. Select **Save**. If a user passes the pricing table code in a URL, they will be able to sign up using it. Here's how to [add the pricing table params to URLs](/billing/billing-user-experience/add-billing-to-url-sdk/). ## Set pricing table to show as default in register flow You can set a pricing table to show by default, even if the code key is not passed in the URL during the normal sign up flow. 1. Open the pricing table. 2. Select **Show by default**. 3. Select **Save**. If a user goes through the registration flow without a pricing table code key in the URL, this is the pricing table they will see. ## Switch the pricing table off for the register flow You can configure Kinde to hide pricing tables in the sign up flow, but still show them in the self-serve portal. You'd do this if you have designed your own pricing pages and you only want to show Kinde's pricing table for the self-serve upgrade or downgrade experience. 1. Go to **Settings > Environment > Billing**. 2. Switch off the **Show the pricing table when customers sign up** option. 3. Select **Save**. ## Add plan selector to registration URL Use your SDK or manually change URL params to incorporate billing. See [Add billing to URl or SDK](/billing/billing-user-experience/add-billing-to-url-sdk/)

# Billing - Billing user experience - Pricing table display defaults

> Guide to understanding pricing table display defaults for B2C, B2B, and B2B2C models including when pricing tables are shown.

pricing table display, B2C, B2B, B2B2C, plan groups, default display, URL parameters
billing

The pricing table that is displayed in a particular flow depends on the the [default plan groups and pricing table order](/billing/manage-plans/add-manage-plan-groups/). ## B2C (User-based) A pricing table is shown when: - A new user registers - An existing user, marked as a billing customer, signs in but isn’t on a plan yet ## B2B (Org-based) A pricing table is shown when: - A new organization registers (`is_create_org` parameter) - An org member with `org:write:billing` permission signs in and the org is a billing customer but not on a plan yet ## B2B2C (Platforms - uses both) - Organization plan selection = B2B logic - User plan selection = B2C logic ## Here's a video showing the user experience for billing <YoutubeVideo videoId="xxVwZW8OxIA" videoTitle="Billing user experience"/> ## Override the default plan display You can override which plan or pricing table is shown using URL parameters. See: [Update code and URLs for billing](/billing/billing-user-experience/add-billing-to-url-sdk/). ## Summary of display for plan groups | Model | Plan group | Pricing table is shown when | | --- | --- | --- | | B2C | User plan group | New user registers / logs in | | B2B | Org plan group | New org registers / billing admin | | B2B2C | Both | Depends on flow context |

# Billing - Get started - Step 1 Add billing role (B2B)

> Guide to creating a billing role for B2B organizations including permissions setup and role assignment for billing management.

billing role, B2B, organization billing, billing admin, permissions, org:write:billing
billing

Skip this step if you sell your services to individuals (B2C). If you are a B2B business, your customers in Kinde are referred to as organizations. These can be created: * via API * manually in the Kinde admin area * via the auth flow if you have enabled the relevant settings and pass `is_create_org` as a query parameter in the authentication URL. In order to manage billing for the organization, create a default billing role (with relevant permissions) to assign to a user in the organization. 1. Go to **Settings > Roles** and select **Add role**. The **Add role** window opens. ![Roles screen for billing owner](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/96415552-a11b-4be3-e644-d9eaa2af6700/public) 2. Name the role, for example, `Billing Admin` , and enter a description and **Key**. 3. If you allow organizations to self-sign up, select the **Assign to the creator** option. 4. In the **System permissions** section, ensure the **org:write:billing** system permission is selected. 5. Select **Save**. ## Assigning the role If you have configured Kinde to allow organizations to self-sign up, and selected to apply this role to the "Creator", then this role will now be automatically assigned to users who create an organization as part of the authentication flow. Alternatively, you can assign the billing admin role to organization members via API or in the Kinde dashboard. You can add the permissions to any of your custom roles and mix and match the system permissions to work for your needs. **Next:** [Step 2 Connect to Stripe and set policies](/billing/get-started/connect-to-stripe/)

# Billing - Get started - Step 6 Create pricing table (optional)

> Guide to creating pricing tables in Kinde for plan selection during registration and self-serve portal plan changes.

pricing table, plan selection, registration flow, self-serve portal, plan upgrade, plan downgrade
billing

Kinde lets you create pricing tables based on your plans. The tables can be integrated into the auth flow so that plan selection becomes part of registration. It might look something like this. ![pricing table example](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/8514b968-262d-4aec-24bd-02070669e300/public) Pricing tables are also used in the plan upgrade and downgrade flows available in the self-serve portal. So when a customer changes their plan, the pricing table appears for them to select the new plan option. To create your own, go to [Build a pricing table](/billing/billing-user-experience/plan-selection/). If you have your own screen flows for plan display and selection, you do not have to use Kinde’s pricing tables. **Next:** [Step 7 Set up the self-serve portal (optional)](/billing/get-started/self-serve-portal-setup/)

# Billing - Get started - Step 4 Build plans

> Guide to developing a plan strategy and building plans in Kinde including B2B/B2C considerations, feature planning, and pricing models.

plan strategy, B2B, B2C, B2B2C, plan features, pricing models, plan limits, feature planning
billing

Whether you currently charge for services or are just starting out, building plans is the more complex part of the billing setup process. We recommend you define a strategy before adding plans in Kinde. - [Learn more about how plans work in Kinde](/billing/manage-plans/about-plans/) - [Skip to creating plans](/billing/manage-plans/create-plans) ## Develop a plan strategy If you have not created plans before, here’s a list of tasks to help you prepare. These will give you a strategy for creating the plans you need in Kinde. 1. Are you creating B2B or B2C or B2B2C plans? B2B plan types are for business customers (organizations), B2C plan types are for individual users, B2B2C is a platform model, where you have a customer who is an organization, and then users who are customers of that organization. 2. Decide how many plans you want and the name of each plan. E.g. `Free, Pro, Plus` or `Solo, Team, Enterprise`. 3. Make a list of each [plan’s features](/billing/manage-plans/create-plans). For each feature, decide on: - the [pricing model](/billing/pricing/pricing-models/) that applies - limits and inclusions for a feature Anything you ‘gate’ access to, or put limits on in your product, should be on this list. Tip: Create a spreadsheet to keep track of everything. ![example spreadsheet for plan planning](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/401ff633-c6c8-45ba-9502-1a29274b4400/public) 4. Identify which features are common across plans. You don’t need to add a new feature every time, you can [re-use features](/billing/manage-plans/about-plans/) across plans and change the details. **See [Create plans](/billing/manage-plans/create-plans)** for step-by-step instructions.

# Billing - Get started - Step 2 Connect to Stripe and set policies

> Step-by-step guide to connecting Kinde to Stripe for payment processing and setting up billing policies for cancellations and plan changes.

Stripe connection, payment processing, billing policies, cancellation policies, plan changes, onboarding
billing

Kinde’s billing feature comes with a dependency on [Stripe](https://stripe.com), which is a globally known and reliable payments processing platform. A new Stripe account is automatically created for you when you set up billing in Kinde. <Aside type="warning"> You can’t currently connect your existing Stripe account, but you will be able to copy across your business information from your existing account to the new account. This is a Stripe-imposed limitation for third party integrations. We’re working on a migration strategy. </Aside> ## Watch a quick video about how to connect to Stripe <YoutubeVideo videoId="-TgYfXe2qrs" /> ## Connect to Stripe 1. If you are testing billing, switch to your non-production environment. This will automatically trigger the use of a test Stripe account as well. 2. Go to **Settings > Environment > Billing**. 3. Select **Connect Stripe account**. Kinde initiates the connection and adds the connection card. ![Stripe card connection in Kinde](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/f3797997-6681-41c8-a297-4a962d5d0500/public) 4. Select **Update Stripe information**. This kicks off a Stripe onboarding flow. You will see a Stripe-generated screen to enter details. ![Kinde Stripe onboarding flow start screen](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/71b08393-f43d-4f91-3268-7501e08d3f00/public) <Aside> If the Stripe flow doesn’t appear and you remain in the Kinde dashboard, select **Update Stripe information.** </Aside> 5. Enter the email that will be associated with the Stripe account and select **Submit**. Here’s what happens next, depending if you have a Stripe account already associated with your email address. 1. **If you are in the test environment**, you’ll be prompted through a flow. You can continue or select **Return to Kinde**. 2. **If you are in a production environment,** you will be asked if you want to use details from an existing Stripe account or make a new one: 1. If you select existing, account details from the existing account will be used, but no other data will come across. 2. If you select to make a new one, you will be prompted to enter all your business details. This can take a while. 3. Follow the prompts as far as you want. Select **Return to Kinde**. <Aside> You can select **Return to Kinde** at any time. You do not have to set up the connection fully until you are ready to publish plans. Any time you want to complete the setup, select **Update Stripe information**. </Aside> 6. When you complete the Stripe onboarding, or opt out by selecting **Return to Kinde**, the connection card on the Kinde **Billing** page shows the connection status. ![Connection status on Kinde stripe card](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/f4eb395b-069e-42c3-ab4f-d78cc52e8800/public) - `Connecting` means Stripe is still sending information to Kinde about the account status. It should not take long to sync. - `In progress` indicates that Stripe has connected to Kinde, but still requires some additional details from you in order to fully set up the account. Select **Update Stripe information** to complete the Stripe onboarding. You need to do this before plans can be made available to your customers. - `Connected` means Stripe is successfully syncing data with Kinde and you’re ready to publish plans. ## Set billing policies for cancellation and plan changes After you have connected to Stripe, you can set policies to control what happens when a customer cancels or changes their plan. The policies are for deciding if you charge or forgive unpaid usage of metered features, or if you refund or retain unused, paid subscription days. 1. In the **Policies** section, choose the settings. 2. Select **Save**. **Next:** [Step 3 Set default billing currency](/billing/get-started/default-billing-currency/)

# Billing - Get started - Step 3 Set default billing currency

> Guide to setting the default billing currency for all Kinde plans including important considerations about currency selection.

default currency, billing currency, currency selection, multi-currency, Stripe transactions
billing

You need to set a default billing currency for all your Kinde plans, before you create them. This is the currency that purchase transactions will be processed in Stripe. The currency you select cannot be changed after your first plan is published. For now, the default billing currency will be used in all plans and plan groups you create. <Aside> If you have already created a plan and assigned a default currency that way, you may not need to change anything here. </Aside> 1. Go to **Settings > Environment > Billing**. 2. Select a default currency. 3. Select **Save**. Next: [Step 4 Build plans](/billing/get-started/build-plans/)

# Billing - Get started - Step 5 Publish plans

> Guide to publishing plans in Kinde including Stripe synchronization and best practices for testing before publication.

publish plans, Stripe sync, draft plans, published plans, plan testing
billing

When you publish a plan, all of the plan features and charges are synced to Stripe where they are transformed into products that users can buy. We recommend testing, reviewing, and making all changes before publishing plans. When you are ready, open the plan and select **Publish plan** in the top right of the plan window. Do this for each plan you want users to subscribe to. Learn more about [draft and published plans](/billing/manage-plans/about-plans/) **Next:** [Step 6 Create pricing tables](/billing/get-started/add-pricing-table/)

# Billing - Get started - Step 7 Set up self-serve portal (optional)

> Guide to setting up the self-serve portal for customers to manage their own plans, payment information, and account details.

self-serve portal, customer management, plan upgrades, plan downgrades, payment management, account management
billing

If you want your customers (organizations or individual users) to manage their own plans, including upgrades and downgrades, payment information, team members, etc., set up the self-service portal to allow this. Aside from account management, the self-serve portal is for orgs to self-manage teams and business information, and individuals to manage their user profile. - [Self-serve portal for orgs](/build/self-service-portal/self-serve-portal-for-orgs/) - [Self-serve portal for users](/build/self-service-portal/self-serve-portal-for-users/)

# Billing - Get started - Setup overview

> Step-by-step overview of the billing setup process including Stripe connection, plan creation, and self-serve portal configuration.

billing setup, Stripe connection, plan creation, self-serve portal, billing roles, pricing tables
billing

Billing is big step for a business, so it’s a good idea to review the process before you start. ## Overview of billing setup 1. [Set up billing roles and permissions (B2B)](/billing/get-started/add-billing-role/) 2. [Connect to Stripe and set billing policies](/billing/get-started/connect-to-stripe/) 3 [Set currency](/billing/get-started/default-billing-currency/) - you can’t change this once your first plan is published 4. [Build plans](/billing/manage-plans/create-plans/) 5. [Publish plans](/billing/get-started/publish-plans/) 6. Enable subscription self-serve (optional) 1. [Create a plan selector](/billing/billing-user-experience/plan-selection/) 2. [Enable self-serve portal](/build/self-service-portal/self-serve-portal-for-orgs/) 7. [Update your code and registration URLs](/billing/billing-user-experience/add-billing-to-url-sdk/) 8. Test the setup and get your first subscriber! ## ⚠️ Test in a non-production environment If you are using billing for the first time, make sure you use a Kinde non-production environment to test out the billing features. When you use a non-production environment, Stripe automatically creates a test Stripe environment. This test environment allows you to create customers and billing subscriptions without actually charging customers. You can also use Stripe’s test credit card details. When using a Kinde test environment and a test Stripe account, you will not incur any billing-related fees from Stripe or Kinde. ## Watch a video about creating and publishing plans, and building pricing tables <YoutubeVideo videoId="M3hX3JwhEY8" videoTitle="Manage plans, features, and pricing in Kinde"/> ## Tip: Before setting up billing - Make a list of all your app’s features - with names, descriptions, prices, metered rates, limits, inclusions, etc. You might consider doing this in a spreadsheet to make it easier and faster to add features in the Kinde plan builder. Include plan variations for prices, limits, etc. ![example of a spreadsheet of plans](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/401ff633-c6c8-45ba-9502-1a29274b4400/public) - (B2B) make sure your Kinde business is set up to [create an organization on sign up](https://docs.kinde.com/build/organizations/orgs-for-developers/#new-organization-self-sign-up). Follow the numbered steps in this section to set up billing in your business.

# Billing - Manage plans - About plans

> Comprehensive guide to understanding plans in Kinde including plan groups, features, pricing models, and plan lifecycle management.

plans, plan groups, features, pricing models, fixed charges, metered features, unmetered features, plan versioning
billing

Plans enable you to structure your app features and charge your customers for using your services. Kinde supports both basic and more advanced plans for SaaS services. Here’s some examples: - A simple subscription plan: $10 per month for x features - A more complex plan: $20 per month for x features, plus x amount per GB storage, plus MAU charges (up to x free per month). We recommend creating your basic or simplest plan first (e.g. your Free plan), then work through to more complex plans. ## Current limitations These are known limitations that we are actively working on to add. - Support for plan models with free trial periods. - Annual subscriptions. Only monthly is available right now. - No alterations to billing cycle or invoice methods. - Add-ons and discounts that can be applied to individual subscriptions. ## About plan groups Plan groups are a collection of related plans, tied to either users or organizations. - You can create as many plan groups as you need. - Each group can only contain plans for users OR plans for orgs. - You can create multiple pricing tables for one plan group (but only one is the default). - Only one plan group can be included in a pricing table. For more information see [add and manage plan groups](/billing/manage-plans/add-manage-plan-groups/) ## Parts of a plan There are a number of concepts and elements involved in building a plan. ### Plan profile This is the name of the plan, description, code key, etc. You need to enter these details and save them before you move on to adding charges and features. The plan name appears on the pricing table that you can generate to share with customers. We recommend keeping it short. Use the description fields to explain differences in plans for internal use. ### Plan feature pricing Depending how you manage plans and feature provisioning in your application, plan pricing might be simple or complex in your business. When you set up a plan, you can include a mixture of any of these options: - **Fixed charges** - a recurring charge that does not change and is invoiced in advance, e.g. a monthly subscription charge. - **Metered features** - usage-based entitlements that define what and how much users’ access, and what they pay to access it. These might be per unit, per tier, or non-chargeable. Such as included and additional MAU. - **Unmetered features** - things included in a plan that users don’t pay for separately. Unmetered features are generally used to gate feature access. E.g. X feature is not available on the Free plan, but is on a higher tier plan. ## Example plan features | Feature | Price | Pricing model | | ------------------- | ---------------------------- | ------------------------- | | Access to x feature | N/A | Unmetered | | Subscription | $ 20 / month for access | Fixed charge | | Interaction | $x per interaction | Metered / tiered | | Storage/Usage | $x per GB | Metered / units or tiered | | MAU | x included | Metered / non-chargeable | | MAU | Additional $x per MAU over n | Metered / tiered | A plan is complete when it includes all the features needed to provide the access and charge the right price. ## How to use and re-use features and charges Kinde structures plans so that they can share a pool of features and charges that you define at a high level. When you add the feature in a plan, you add the price, limits, and other differences uniquely in each plan. This makes building and managing plan features easier, because the feature shares the same key (e.g. `base_price`), making it easier to manage in your code and for gating. For example, you only need to define the item ‘Base price’ once, and then you define the price when you add it to each individual plan. Similarly, features that are inclusions, such as support hours included, just create one metered feature. Then set the limits of the feature differently for each plan level. E.g. Free plan one hour, Pro plan gets 2 hours, etc. ![Model of how you can use the same feature or charge across plans](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/190e7ba8-ba26-4fb6-57b4-a4d6b9fec700/public) ## Draft and published plans, and plan versioning Plans can be in two states: **Draft** - these plans are being developed and are not available for subscribers yet. **Published** - products and prices are synced to Stripe and the plan can be signed up to manually, or via API. - Once a plan has a subscriber, the plan cannot be changed, only versioned. - Published plans must be included in a pricing table for self-sign ups. Plan versioning is being worked on, but is not currently available. ## When a plan feature price syncs to Stripe Feature prices sync to Stripe when you are successfully connected to Strip and you publish the plan containing that feature. When you are creating a plan, you may notice that some features show `price synced` or `price not synced`. - Price synced - The price in Kinde and Stripe are the same. A plan with this feature is published. - Price not synced - The price in Kinde has not yet synced to Stripe. When you publish or re-publish the plan, this will change. If you see a mix of synced and not synced feature prices on a plan, this might be because the synced ones are in a plan that is published. Unmetered (non-chargeable) features do not have a price sync status badge.

# Billing - Manage plans - Add and manage plan groups

> Guide to creating and managing plan groups in Kinde including B2B/B2C organization, default groups, and plan ordering.

plan groups, B2B, B2C, B2B2C, default groups, plan organization, pricing tables
billing

Plan groups are a way of organizing sets of related plans together. A plan group can be defined as an 'organization' or 'user' type, depending who you are selling to. For (B2B) businesses, use the organization type. For (B2C) individual customers, use the 'user' type. If you are a B2B2C business, create one group of each type. How you set up plans in the group impacts how you present feature bundles on a pricing table. ## Default plan groups When you first add a plan in Kinde, you select the plan type and a plan group will be automatically created for you. You can later change the name of the group, or make a different group the default group. There can only be one default group for organizations and one for users. The default group is what is displayed by default on a pricing table. ## Add a plan group 1. Go to **Billing > Plans**. 2. Select **Add group**. 3. Enter a **Name** and select the type of plan the group contains. 4. Choose a colour. This only applies to how the group appears on the **Plans** page. 5. Select **Save**. 6. Repeat for all the groups you want to add. ## Organize plans within a group The order of plans within a group represents the order they are shown in the Kinde Admin. This does not impact the order they are shown on the pricing table. To move a plan up or down in a group, select the three dots menu and select a moving option: ![Plan card overflow menu](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/787e431f-c73c-44b4-b245-222f9a4cf200/public) ## Delete a plan group <Aside type="warning"> If you delete a plan group that is associated with a pricing table, the pricing table will also be deleted. These actions are not reversible. </Aside> 1. Go to **Billing > Plans**. 2. Select the three dots menu near the plan group name. ![Plan group overflow menu](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/1ba1256c-d3cf-4b80-e7b0-8422d3866100/public) 3. Select **Delete**. 4. In the confirmation window that appears, confirm you want to delete.

# Billing - Manage plans - Cancel a subscription

> Guide to canceling subscriptions including customer self-service cancellation and API-based cancellation methods.

cancel subscription, self-serve portal, API cancellation, agreement ID, billing role, cancellation workflow
billing

While we would rather customers didn't cancel their subscription to your services, they do need to be able to. There's two ways to do this. - The customer can cancel via the self-serve portal - You can cancel on behalf of a customer via API <Aside> There is not currently a way to cancel via the Kinde UI </Aside> ## How a customer can cancel their own plan Customers can only do this if you have enabled plan management in the [self-serve portal](/build/self-service-portal/self-serve-portal-for-orgs/) and the B2B customer has a [billing role](/billing/get-started/add-billing-role/) that allows them to make changes. 1. In your app or product, they open the self-serve portal for managing their account. Here's an example of where users (B2C) and organizations (B2B) can manage plans. ![Self-serve portal selector for managing plans](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/1f7c8192-418b-412e-1728-54affbfeed00/public) 2. On the **Plan** page, they can scroll to the bottom and select **Cancel plan**. 3. They follow the prompts to cancel. This information is synced to Stripe. Depending on the [billing policies](/billing/manage-plans/upgrade-downgrade-plans/) you have set, they might receive a bill for unpaid usage, or be credited for unused subscription days. ## Cancel a plan via API 1. Get the customer's Agreement ID. This is the unique ID associated with their subscription in Stripe. You can find it in their Kinde record under Billing. 2. Using a DELETE request, hit the delete/api/v1/billing/agreements endpoint and include the `agreement_id` value in the call. ![API cll to delete agreement](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/d136fd54-7474-486f-2768-8fcb1deaaa00/public) ## Receive an alert when a customer cancels their plan You can set up a workflow that enables you to check and approve cancellations. You might want to do this, for example, to be alerted when high value customers cancel. For details, refer to the [Plan cancellation request workflow](/workflows/example-workflows/plan-cancellation-request-workflow/).

# Billing - Manage plans - Create plans

> Step-by-step guide to creating plans in Kinde including plan groups, fixed charges, metered features, and tiered pricing configuration.

create plans, plan groups, fixed charges, metered features, tiered pricing, plan features, subscription fees
billing

Once you’ve got a plan strategy along with a plan feature list, prices, and details, you’re ready to create plans them in Kinde. All plans must belong to a plan group. When you create your first plan, it will be automatically added to the default group. A plan group can only contain either user plans or organization plans. When you create your first plan, we automatically create a group based on the plan type you select. <Aside> Remember you can create one charge or feature that can be used and redefined across all plans. E.g. You can have one ‘Base price’ charge that is defined as 0.00 in a free plan, 10.00 in a Plus plan, and 25.00 in a Pro plan. </Aside> ## Add a plan 1. Go to **Billing > Plans**. 2. If this is the first plan, select **Add plan** on the empty page. 3. If you already have plans, select **Add plan** in the top right. The **Add plan** window opens. ![Add plans window](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/a8a237d5-c242-45dc-453e-a7ad66e33a00/public) 4. Choose whether the plan is for **Organizations** or **Users**, or select the **Group** the plan belongs to. Only one of these options will appear. You cannot change these selections later. 5. Give the plan a **Name** (e.g. `Free`), a **Description**. This is the name that will also appear in the pricing table (if you use one). 6. Give your plan a **Key** for referencing in your code. This cannot be changed after a plan is published. 7. Select a **Default currency**. This field only appears if one has not been set. You can change this later in **Settings > Billing**, but only before any of your plans are published. 8. Select **Save**. ## Add a subscription fee or fixed charge to a plan A fixed charge is a recurring monthly charge such as base price or subscription fee. <Aside type="warning"> You need to create a $0.00 charge for Free plans. This ensures the plan is added to Stripe, and is included on the pricing table. </Aside> 1. Select **Add charge**. 1. If the charge exists, select **Use existing feature** then select it from the list. <Aside> You only need to create a new charge if the item is unique. For re-usable items such as ‘Base price’, select the existing charge but change the line item description and price for each plan. </Aside> 2. If this is a new charge, give it a name (e.g., `Base subscription fee`). If you’ll reuse this charge across plans, choose a generic name. This cannot be changed later. 2. Add a **Line item description**. This appears on the customer invoice, so might be more specific than the name, e.g. `Base subscription - Pro plan`. 3. Set the price. (You may be asked to set a default currency if you haven’t already). 4. Select **Save**. 5. Select **Save draft**. 6. Repeat from step 1 for each fixed charge you want to add, or start adding features. <Aside title="Feature price sync"> If you are successfully connected to Stripe and the charge is part of a published plan, it will show as `price synced`. Otherwise the charge will show as `price not synced`. </Aside> ## Add features (entitlements) to a plan Features describe the individual functions or entitlements that users get with their plan. These can be of the type metered (chargeable) or unmetered (included). <Aside type="warning"> You cannot change the Name, the Key or the Type of feature once you have created it. If you make an error, delete the feature and add a new one. </Aside> 1. Select **Add feature**. ![Add feature window](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/ceb95ba9-1c03-4ae7-89f9-275ab3185100/public) 2. To add a new feature, select **New unmetered** or **New metered**, then select **Next**. The **Add feature** window opens. 3. Enter a **Feature name**. Be sure to use something generic if you plan to use this feature again, e.g. `Included seats`. 4. Enter a **Description**. 5. Enter a **Key** for referencing the feature. 6. If you selected a unmetered feature, select **Save**. You’re done. Repeat from step 1 to add more features. 7. If you selected a metered feature, complete the rest of the details: ![Add feature window, select units](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/de016f2c-2477-4abd-9a2d-00e7c3e99300/public) 8. Enter the **Maximum units** allowed on the plan. Leave blank if there is no limit. 9. Enter the **Unit measurement** name, e.g. `license`, `MAU` 10. If the item is separately chargeable, select a **Pricing model**. ![Add feature window, tiered prices](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/80ea9a38-e6ac-479f-9697-f04e237d4d00/public) 11. Add a **Line item description**. This appears on the customer invoice, so might be more specific than the name, e.g. `Additional licenses for Pro (5)`. 12. For a flat unit price, enter the price and select **Save**. You’re finished. 13. For tiered pricing, select **Tiered - Graduated** and define each tier with unit numbers and add the price per unit. 14. Select **Add tier** to add a different price for higher unit tiers. For example, a unit might be $10 each if you use 1-10, but is $9 per unit if you use 11 or more. <Aside type="warning"> Ensure the tiered units amounts don’t overlap. E.g. make sure they follow a pattern like 1-10, 11-20, 21-30, etc. If you want to make it so an upper limit is limitless, E.g. 1-10, 11-(blank/limitless); use 1-10, 11-1,000,000 (or a very high number). Graduated unit fields can’t be left blank. </Aside> 15. Select **Save.** 16. In the **Plan** window, select **Save** to commit your changes. 17. Repeat for each feature you want to add to the plan. Then repeat this procedure for each plan. <Aside title="Feature price sync"> If you are successfully connected to Stripe and the feature is part of a published plan, it will show as `price synced`. Otherwise the feature will show as `price not synced`. </Aside> **Next:** [Step 5 Publish plans](/billing/get-started/publish-plans/)

# Billing - Manage plans - Plan upgrade and downgrade policies

> Guide to setting billing policies for plan upgrades, downgrades, and cancellations including usage billing and refund policies.

plan upgrade, plan downgrade, billing policies, usage billing, refund policies, cancellation policies
billing

If you offer different levels of paid plans, then you will need to facilitate plan upgrade or downgrade. Before you make plan changes, make sure you have set the policies. ## Set billing policies for cancellation and plan changes You can also set policies to control what happens when a customer cancels or changes their plan. The policies are for deciding if you charge or forgive unpaid usage of metered features, and if you refund or retain unused, paid subscription days. By default, unpaid usage is forgiven and you don't refund or credit for unused subscription days. 1. Go to **Settings > Environment > Billing** to set these policy defaults. 2. In the **Policies** section, choose the settings. ![Billing policies settings](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/1a4c3673-d972-4dd6-2c3a-d46b9eb70200/public) 3. Select **Save**.

# Billing - Manage subscribers - Add metered usage for a customer via API

> Guide to manually adding metered usage for customers via the Kinde API including agreement ID and feature code requirements.

metered usage, API, agreement ID, feature code, usage data, billing cycle
billing

From time to time, you may need to manually add metered usage for an individual customer. You can do this via the Kinde API. Adding usage values requires two key pieces of information: - your customer's agreement ID - the feature code you want to record usage against ## Get the agreement ID - [Via API](https://docs.kinde.com/kinde-apis/management/#tag/billing-agreements/get/api/v1/billing/agreements/). Include the `billing` expand parameter in your request to access the agreement ID. - Via the Kinde UI - Open the user or organization record in Kinde and select **Billing** in the menu. The customer agreement shows as part of the subscription details. ![Example of agreement ID in Kinde](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/6488a69d-a47d-413b-a3b3-47a39398b600/public) ## Get the feature ID 1. Open the plan the feature belongs to. 2. Edit the feature (to view it) in the plan. 3. Take note of the **Key**. ## Submit usage data POST the usage to the [meter usage record API](https://docs.kinde.com/kinde-apis/management/#tag/billing-meter-usage/post/api/v1/billing/meter_usage/) including the feature code and agreement ID to record a usage value. <Aside> Usage gets assigned to your customer's current billing cycle. Any usage submitted after a billing cycle ends will be recorded against the next billing cycle. </Aside>

# Billing - Manage subscribers - Respond to customer activity using webhooks

> Comprehensive guide to using Kinde billing webhooks to respond to customer activity including event triggers and automation examples.

billing webhooks, customer activity, JWT, event triggers, automation, subscription events, payment events
billing

Kinde's billing webhooks are outbound calls Kinde makes to your specified endpoint when particular billing events occur. You can use them to keep your application synchronized with Kinde's billing events, trigger automated actions to provide a seamless experience for your customers, and reduce the load on your support team. ## How Kinde webhooks work Kinde webhooks use HTTPS REST to send information about events to a verified external URL that you provide. When an event is triggered, Kinde dispatches a JSON Web Token (JWT) containing relevant data to your registered endpoint. It's essential to verify the authenticity of this JWT to confirm the request originated from Kinde and then decode it to access the event data. If your endpoint doesn't return a 200 OK response, Kinde will retry the webhook call using a back-off policy. More about webhooks: Manage [Kinde webhooks](/integrate/webhooks/about-webhooks/) via the Kinde interface, or via the [Kinde Management API](https://docs.kinde.com/kinde-apis/management/#tag/webhooks). ## Billing webhook triggers and examples ### A customer cancels their subscription * **Trigger**:`customer.agreement_cancelled` * **Description**: Triggered when a customer subscription is cancelled, this might be by the customer or by an admin * **Example**: Automatically deactivate premium features for a user in your application, initiate an offboarding sequence, or update their status in your CRM to "cancelled. ### A new agreement is created for a customer - **Trigger:** `customer.agreement_created` - **Description**: Triggered when a customer signs up to a plan or changes plans, and an agreement is created for the customer. - **Example**: Provision new services for the customer, send a welcome email confirming their subscription, or grant access to exclusive content. ### A customer's invoice becomes overdue * **Trigger:** `customer.invoice_overdue` * **Description**: Triggered when a customer's invoice becomes overdue. Usually only triggered in cases where payment is not automated. * **Example**: Send automated reminders to the customer about their outstanding payment, trigger a temporary suspension of services, or notify your accounts receivable team for follow-up. ### Metered usaage is recorded against a plan feature * **Trigger:** `customer.meter_usage_updated` * **Description**: Triggered when a customer's metered usage data is updated. * **Example**: Ideal for displaying real-time usage statistics to the customer within your app, calculating potential overage charges, or sending notifications if their usage approaches a predefined limit. ### A payment from a customer fails * **Trigger:** `customer.payment_failed` * **Description**: Triggered when a customer's payment attempt fails, for example due to insufficient funds or incorrect credit card details. * **Example**: Initiate a dunning process, prompt the customer to update their payment method, or temporarily restrict access to features until payment is resolved. ### A payment from a customer succeeds * **Trigger:** `customer.payment_succeeded` * **Description**: Triggered when a customer's payment is successfully processed. * **Example**: Confirm a payment receipt to the customer, unlock paid features, or record the successful transaction in your accounting system. ### A plan is associated with a customer in Kinde * **Trigger:** `customer.plan_assigned` * **Description**: Triggered when a customer is associated with a plan in Kinde. * **Example**: Activate the features associated with the newly assigned plan in your application, send a plan activation email, or update the customer's profile with their new plan details. ### A customer's plan changes (upgrade or downgrade) * **Trigger:** `customer.plan_changed` * **Description**: Triggered when a customer's billing plan is changed (e.g., upgraded or downgraded). * **Example**: Adjust the customer's feature access based on the new plan, update their billing cycle information, or notify relevant internal teams about the plan changes.

# Billing - Manage subscribers - Subscription upgrade and downgrade methods

> Guide to upgrading and downgrading customer subscriptions including self-serve portal, manual changes, and API methods.

subscription upgrade, subscription downgrade, plan changes, self-serve portal, API, billing policies
billing

Customers will eventually want to change the plan they are on and you need a way to alter their subscription. ## How to upgrade or downgrade a plan subscription - Set up the self-serve portal and allow customers to manage their own subscriptions. See [self-serve portal for orgs](/build/self-service-portal/self-serve-portal-for-orgs/) and [self-serve portal for users](/build/self-service-portal/self-serve-portal-for-users/). In this scenario, the user will select the new plan from the pricing table. - Manually upgrade or downgrade via the Kinde UI (see below) - Overwrite the current agreement (subscription) by [creating a new one via API](/kinde-apis/management/#tag/billing-agreements/post/api/v1/billing/agreements/) ## Change a plan subscription for an organization (B2B) or user (B2C) 1. Open the organization or user record in Kinde. - Go to **Organizations** and locate the org. - Go to **Users** and locate the user. 2. Select **Billing** in the side menu. Details of the org's or user's plan are shown. 3. Select **Change plan**. 4. In the dialog that appears, select the new plan. 5. Select **Save**. The customer's plan is now updated. Depending on the [billing policies](/billing/manage-plans/upgrade-downgrade-plans/) you have set, this information will be synced to Stripe and an invoice credit or bill will be issued.

# Billing - Payment management - Manage Stripe connection

> Guide to managing the Stripe connection in Kinde including connection status monitoring, troubleshooting, and disconnection procedures.

Stripe connection, connection status, troubleshooting, business information, identity verification, disconnect
billing

When you connect to Stripe as part of Kinde's billing feature, a new Stripe account is created for you. You cannot connect an existing Stripe account. When you first connect Stripe as part of the setup flow, you need to set up the new Stripe account with all your business and other details to make the connection active. To connect, follow [this process](/billing/get-started/connect-to-stripe/). You can then manage the connection in **Settings > Billing**. ![Stripe connection card in Kinde](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/859d5538-db3c-4244-3dbe-7a2ff2c04b00/public) ## Manage the Stripe connection The Stripe connection status (see below) lets you know if Stripe is connected or if you need to take action. Statuses include: - `Connecting` means Stripe is still sending information to Kinde about the account status. It should not take long to sync. - `In progress` indicates that Stripe has connected to Kinde, but still requires some additional details from you in order to fully set up the account. Select **Update Stripe information** to complete the Stripe onboarding. You need to do this before plans can be made available to your customers. - `Connected` means Stripe is successfully syncing data with Kinde and you’re ready to publish plans. You may also see an error and message, letting you know what action is needed. To add and edit Stripe business information, select **Update Stripe information**. ## Disconnect Stripe This action is not reversible. 1. Go to **Settings > Environment > Billing**. 2. On the Stripe connection card, select the three dots, then select **Disconnect**. 3. In the confirmation window, select **Disconnect billing connection**. ## Troubleshoot Stripe issues Stripe requires that your account is set up properly before connecting successfully. Here's some common reasons why the Stripe connection status remains **In progress**. - Incomplete business information - contact, tax, or other business details - Identity verification - where you need to upload a copy of your ID To add details in Stripe, select the **Update Stripe information** option.

# Billing - Payment management - Connect payment processor (Stripe)

> Step-by-step guide to connecting Stripe payment gateway to Kinde including onboarding flow and connection status management.

payment gateway, Stripe connection, onboarding flow, business information, connection status, test environment
billing

Kinde’s billing feature comes with a dependency on third party payment processor, specifically [Stripe Billing](https://stripe.com/au/billing). A payment processor holds credit card details, processes payments, applies tax, and generally handles all the financial side of billing. For now, only [Stripe](https://stripe.com), a known and reliable payments processing platform, is supported. A new Stripe account is automatically created for you when you set up billing in Kinde. <Aside type="warning"> You can’t currently connect your existing Stripe account, but you will be able to copy across your business information from your existing account to the new account. This is a Stripe-imposed limitation for third party integrations. We’re working on a migration strategy. </Aside> 1. If you are testing billing, switch to your non-production environment. 2. Go to **Settings > Environment > Billing**. 3. Select **Connect Stripe account**. Kinde initiates the connection and adds the connection card. ![Stripe card connection in Kinde](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/f3797997-6681-41c8-a297-4a962d5d0500/public) 4. Select **Update Stripe information**. This kicks off a Stripe onboarding flow. You will see a Stripe-generated screen to enter details. ![Kinde Stripe onboarding flow start screen](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/71b08393-f43d-4f91-3268-7501e08d3f00/public) <Aside> If the Stripe flow doesn’t appear and you remain in the Kinde dashboard, select **Update Stripe information.** </Aside> 5. Enter the email that will be associated with the Stripe account and select **Submit**. The next step depends if you have a Stripe account already associated with your email address. 1. **If you are in the test environment**, you’ll be prompted through a flow. You can continue or select **Return to Kinde**. 2. **If you are in a production environment,** you will be asked if you want to use details from an existing Stripe account or make a new one: 1. If you select existing, account details from the existing account will be used, but no other data will come across. 2. If you select to make a new one, you will be prompted to enter all your business details. This can take a while. 3. Follow the prompts as far as you want. Select **Return to Kinde**. <Aside> You can select **Return to Kinde** at any time. You do not have to set up the connection fully until you are ready to publish plans. Any time you want to complete the setup, select **Update Stripe information**. </Aside> 6. When you complete the Stripe onboarding, or opt out by selecting **Return to Kinde**, the connection card on the Kinde **Billing** page shows the connection status. ![Connection status on Kinde stripe card](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/f4eb395b-069e-42c3-ab4f-d78cc52e8800/public) - `Connecting` means Stripe is still sending information to Kinde about the account status. It should not take long to sync. - `In progress` indicates that Stripe has connected to Kinde, but still requires some additional details from you in order to fully set up the account. Select **Update Stripe information** to complete the Stripe onboarding. You need to do this before plans can be made available to your customers. - `Connected` means Stripe is successfully syncing data with Kinde and you’re ready to publish plans.

# Billing - Pricing - Pricing models

> Comprehensive guide to pricing models in Kinde including flat rate, usage-based, tiered, and per-feature pricing strategies.

pricing models, flat rate pricing, usage-based pricing, tiered pricing, per-feature pricing, SaaS pricing strategy
billing

A pricing model refers to the structured approach businesses use to charge customers for products and services, often based on factors like usage, feature access, or licensing. In Kinde, each feature you include in a plan has a pricing model attached. This topic describes some examples of pricing models you can apply in Kinde, when you might want to use them, and how to [set them up in your Kinde plans](/billing/manage-plans/create-plans/). ## Pricing decisions There's a lot of information available about SaaS pricing strategy, and many things to consider. Research the market and map out an approach that works for your business now and as you grow, before setting up plans for the first time. We will also add more flexibility and variation for pricing models in Kinde, as our billing feature develops. ## Flat rate pricing (e.g. subscription pricing) Where you want to charge a periodic (e.g. monthly) flat fee for access to your product or services. Higher plans may include access to more features, or have higher access limits. In Kinde, create a **Fixed charge** and call it something like `Subscription fee`. Re-use this charge in each plan, and change the price and line item description. - Example - Basic plan 5.00, Team plan 20.00, Business plan 75.00. ## Usage-based (metered or tiered) pricing Where you charge customers for what they use. For example, monthly active users, data storage, transactions, etc. For each individual plan you can treat this as fully pay-as-you-go, or charge volume prices so the price goes down the more units are used. You can set limits for usage based pricing or leave as limitless. Limits can make plan upgrade more attractive. <Aside> If you need to, you can [add metered amounts to individual customer plans via the Kinde API](/billing/manage-subscribers/add-metered-usage/). </Aside> ### Usage pricing - per unit In Kinde, add a **New metered feature**, e.g. `Data storage`. Leave **Maximum units** blank for limitless, or set a limit. Select a **per unit** pricing model. Set a price for each unit. E.g. - Example - Basic plan is 00.30 per unit, Team plan is 00.20 per unit, Business plan is 00.10 per unit. ### Usage pricing - volume pricing In Kinde, add a **New metered feature**, e.g. `Token generation`. Leave **Maximum units** blank for limitless (you might do this for the highest plan only), or set a limit per plan. Select the **Tiered graduated** pricing model. Set the price for each unit tier for each plan. E.g. - Basic plan (100 unit limit) 0-10 tokens / 0.50 per token, 11-20 tokens / 0.35 per token, 21-100 tokens / 0.20 per token. - Team plan (250 unit limit) 0-10 tokens / 0.40 per token, 11-20 tokens / 0.30 per token, 21-100 tokens / 0.15 per token. - Business plan (No unit limit) 0-100 tokens / 0.15 per token, 101-250 tokens / 0.10 per token, 251-1,000,000,000 tokens / 0.05 per token. (Note you need to include an upper tier limit even if you offer limitless, just use a really high number.) ## Per feature pricing Where you charge per feature or module in your SaaS model. This approach can make plan pricing transparent and make it easy for customers to choose the right plan. It can also help you group "expensive" or more "enterprise" features for inclusion in higher plans. However, it can also be challenging to decide what features should be in or out of specific plans, and to provision and gate each feature in-product. If you want to charge based on features, we recommend using a subscription model, and then including/excluding features for your plan levels. - Example - Basic plan 10.00 for features A-E. Team plan 20.00 for features A-N. Business plan 75.00 for features A-Z. Another way to approach this is to included limited metered features per plan, so that all customers get a "taste" of features, but to get more of one you need to upgrade. - Example - Basic plan 10.00 for features A-E (plus one each of F & G). Team plan 20.00 for features A-N (Plus two of U & V). Business plan 75.00 for features A-Z. ## Support and feedback Email support@kinde.com if you need a different pricing model than those listed above, or if you need help setting up your plan pricing.

# Build - Applications - Applications in Kinde

> Comprehensive overview of Kinde applications including backend, frontend, and machine-to-machine applications with OAuth 2.0 flows and security considerations.

applications, OAuth 2.0, authorization flows, backend apps, frontend apps, M2M apps, client credentials
applications, oauth, authentication

Applications in Kinde facilitate the receipt of access tokens in your application’s code. Kinde applications use OAuth 2.0 flows to securely pass tokens. See [Section 4 of the OAuth 2.0 Authorization Framework](https://datatracker.ietf.org/doc/html/rfc6749#section-4) for details on Authorization flows. We support the following applications and flows. ## Back-end / server-side apps Use for server-rendered web applications. Suitable for confidential applications (such as Regular Web Applications) because the application's authentication methods are included in the exchange and must be kept secure. ### Secured with Authorization Code Flow This application uses the Authorization Code Flow to exchange an authorization code for a token. For security, a client secret is required to request an access token. The client secret is known only to the application and the authorization server. So when the application makes a request for an access token, it includes the client secret as a form of authentication. This ensures that the authorization server can verify the identity of the client application. The use of client secrets protects sensitive data from being accessed by unauthorized users and systems. <Aside> If the Client secret field is empty in your Kinde app it’s because client secrets are only available for back-end/server-side apps. You may have created a front-end/client-server app (that has no client secret) by mistake. </Aside> ### SDKs and compatible frameworks Apollo GraphQL, Elixir, ExpressJS, Express GraphQL, Java, .NET, Next.js, NodeJS, Nuxt, PHP, Python, Ruby, TypeScript. [View Kinde SDKs](/developer-tools/about/our-sdks/) ## Front-end / client-side apps Use for client-side web applications, single page web applications, and mobile applications. Authentication methods are different for these apps because they run in unsecured systems, such as web browsers. ### Secured with Authorization Code Flow and PKCE This application uses the Authorization Code Flow with Proof Key for Code Exchange (PKCE). Client-side applications, such as single-page web apps, are typically unable to securely store a client secret due to the inherent exposure of client-side code. That’s why OAuth 2.0 recommends the Implicit Flow or PKCE (Proof Key for Code Exchange) to provide security without relying on a client secret. <Aside> **Kinde does not support the Implicit Flow** method for front-end apps as it has some security vulnerabilities. We support Authorization Code Flow with PKCE instead. </Aside> ### SDKs and compatible frameworks JavaScript, React, TypeScript, Android, iOS, React Native, Expo, Flutter, Node/Apollo GraphQL, Node/Express GraphQL. [View Kinde SDKs](/developer-tools/about/our-sdks/) ## Machine to machine (M2M) apps Use for your backend services that require access to an API. This includes accessing the Kinde management API. Other use cases include CLIs, daemons and IoT devices. You can create as many M2M apps as you require. See [Add a machine to machine application for API access](/developer-tools/kinde-api/connect-to-kinde-api/). ### Secured with Client Credentials M2M applications are secured through an initial exchange of each application’s Client ID and Client Secret. This identifies each application as authorized for token exchange. Each access token request must include the `Client Credentials` grant type. Typically, a request includes scopes, which define the type of information that can be requested in the exchange. ### Access to Kinde's Management API is managed via scopes When you set up an M2M application that you will use with Kinde's Management API, you need to select the scopes that your application will need to access. For example, you'll select `read`, `create`, `update`, and `delete` actions. ### Add properties to M2M tokens If you want, you can [add custom properties to an M2M application](/properties/work-with-properties/manage-properties/) and then [include these properties in M2M tokens](/properties/work-with-properties/properties-in-tokens/). This is helpful if you want to include special information when you pass M2M tokens between systems.

# Build - Applications - Add and manage applications

> Step-by-step guide for adding and managing applications in Kinde including configuration tasks, application deletion, and integration setup requirements.

add applications, manage applications, application configuration, delete applications, application keys, callback URLs
applications, configuration

Applications are how you make your product or service available to your users, such as through a mobile app, a web app, or a website. If you plan to manage authentication for each of your applications using Kinde, you will need to add and configure each application. [Kinde provides several application types](/build/applications/about-applications/), including a regular web app (for execution on a server), single page web app (for browsers and mobile), and machine to machine applications (for backend services that require access to an API, including the [Kinde management API](/developer-tools/kinde-api/connect-to-kinde-api/)). ## Add an application 1. Go to **Settings > Environment >** **Applications**. 2. Select **Add application**. 3. Enter a name and select the type of application. 4. Select **Save**. A tile appears for the application. 5. Configure the application by selecting **View details** on the application tile. Some of the main tasks are listed below. ## Application configuration tasks - [Get application keys](/get-started/connect/getting-app-keys/) to connect your apps - Set callback URLs using the [relevant SDK](/developer-tools/about/our-sdks/) - [Set up authentication](/authenticate/authentication-methods/set-up-user-authentication/) - [Configure tokens](/build/tokens/configure-tokens/) ## Delete an application You can now delete applications in Kinde. You need to be an owner or an admin to do this. <Aside type="danger"> Deleting an application is a destructive action which cannot be reversed. We recommend backing up all relevant data and checking for application dependencies. </Aside> When an application is deleted, all application-related authentication settings, token settings, session information, and API links are also deleted. 1. Go to **Settings > Environment >** **Applications**. 2. Select the three dots next to the application you want to delete and select **Delete application**. A confirmation window appears. 3. Follow the prompts in the window and select **Delete application**.

# Build - Applications - Authenticating single-page apps (SPAs) with Kinde

> Comprehensive guide for authenticating single-page applications with Kinde including client-side and server-side authentication approaches with React and Node.js examples.

SPA authentication, single-page apps, client-side auth, server-side auth, PKCE, JWT validation, API routes
applications, authentication, spa

A very common architecture is to use a decoupled front-end / back-end with a standalone front-end and separate REST API for the back end. This topic runs through a scenario for authenticating a SPA. In our scenario, you have a React front-end and a NodeJS based API. This is a pretty common set up we see at Kinde, however, the guiding principles are the same regardless of the technologies you use. There are a couple of ways you can use Kinde to authenticate this style of application. ## Option 1: Client side authentication This authentication option takes place in the browser and when you want to call your API, you send the access token you received from Kinde to your API in the **Bearer header**. ### Front end setup 1. In Kinde, go to **Settings > Applications > Add application** and choose **Front-end and mobile** application. <Aside> This application type does not have a client secret as authentication takes place in the browser and there is no place to securely store secrets. Instead it uses the Authorization Code Flow with Proof Key for Code Exchange (PKCE) extension which you can read more about [here](/build/tokens/oath-scopes/#oauth-flows). </Aside> 2. Follow the **Quick Start** guide for your chosen technology to get set up. This can be found in the menu when you view details of the application in Kinde. 3. Once you are up and running, call your API with code similar to the below - replacing `<your_api_endpoint>` with the API you are trying to call. 4. This sample is from a React application, but it will be very similar for any frontend technology. ```jsx const { getAccessToken } = useKindeAuth(); const fetchData = async () => { try { const accessToken = await getAccessToken(); const res = await fetch(`<your_api_endpoint>`, { headers: { Authorization: `Bearer ${accessToken}` } }); const {data} = await res.json(); console.log({data}); } catch (err) { console.error(err); } }; ``` ### Back end setup You do not need to set up a back-end application in Kinde. The request sent to your API will include the access token, which gets validated when you receive it on your back end. Validation checks the token has not expired and that the token has originated from Kinde, as well as various other checks. While it is possible to write code to check this yourself, it can be easy to miss something and accidentally introduce serious security vulnerabilities. Here's our recommendations: - Use the Kinde JWT verifier for your chosen technology (if available). Our Node package is available [here](https://www.npmjs.com/package/@kinde/jwt-validator). OR - Use any existing middleware for your web framework OR - Choose a third-party library, for example the OpenID Foundation has [a list of libraries for working with JWT tokens](https://openid.net/developers/jwt/). #### Audience To further protect your project, we recommend you [register your API](/developer-tools/your-apis/register-manage-apis/) in Kinde and make sure it is enabled for your front end application. You will then need to [request the audience](/developer-tools/your-apis/register-manage-apis/#request-an-audience-be-added-to-a-token) from your front end to make sure it is included in the `access_token` when your user authenticates with Kinde. This is an additional check in the JWT validation above, which should be handled by the verifier you are using. ## Option 2 - Server side authentication with API routes In this approach your API deals with the authentication side and shares a session cookie with your front end. It is important to note that in order for this to work securely, both your API and front-end need to be hosted on the same domain. 1. In Kinde, go to **Settings > Applications > Add application** and choose **Back-end web** application. 2. Follow the **Quick start** guide for your respective technology to initiate the Kinde client. This can be found in the menu when you view details of the application in Kinde. 3. Implement `/login` and `/register` and `/callback` routes on your API. For example in Express this might look something like: ```typescript const app = express(); app.get("/login", async (req, res) => { const loginUrl = await kindeClient.login(sessionManager); return res.redirect(loginUrl.toString()); }); app.get("/register", async (req, res) => { const registerUrl = await kindeClient.register(sessionManager); return res.redirect(registerUrl.toString()); }); ``` 4. In your front-end SPA, your login and register buttons will point to the API endpoints you set up above - e.g `[api.myapp.com/login](<http://api.myapp.com/login>)` ```jsx <a href="https://<api.myapp.com>/login">Sign in</a> ``` This will handle the redirect to Kinde where your user will authenticate. 5. You will also need an API route to handle the callback - again using Express as an example: ```jsx app.get("/callback", async (req, res) => { const url = new URL(`${req.protocol}://${req.get("host")}${req.url}`); await kindeClient.handleRedirectToApp(sessionManager, url); // Code to creates a stateful session goes here return res.redirect("/"); }); ``` Your API should create a stateful session which is shared with your front end via a `secure`, `same-site`, `httpOnly` cookie. As previously mentioned, for this to be secure it should be on the same domain. In this architecture the user is only authenticated with your API which means your frontend SPA doesn't know their identity. For this reason it is a good idea to create a `/profile` route on your API to fetch the identity of the user after authentication.

# Build - Applications - Set a default login route for an application

> Guide for setting default login routes to handle session issues and provide fallback authentication endpoints for applications with expired or problematic sessions.

default login route, login URI, session management, authentication loop, callback URLs, safety net redirect
applications, authentication, routing

A default login route provides a kind of ‘safety net’ redirect for users who encounter issues with authenticated sessions in your application. This route provides the login endpoint for the application, so users can navigate back to the sign in screen to restart an authentication session. There are a number of reasons that default login routes are useful. - A bookmarked link to an application tries to access an expired session - A user hits ‘back’ in their browser while authenticating and the session cannot resume - A user has cookies disabled and the redirect URI sends them into an authentication loop - A link in an invitation or verification email fails when a past session has not closed properly ## To set default login routes We recommend setting a default login route for all your front-and back-end applications. 1. In Kinde, go to **Setting > Applications**. 2. Select **Configure** on the relevant application. 3. In the left menu, select **Authentication**. 4. Scroll to the **Callback URLs** section. 5. Add the **Application login URI.** This is the default login route for resolving session issues. Hits the /auth endpoint to redirect back to your application sign in page. E.g. `https://app.yourapp.com/api/auth/login` 6. Select **Save**. 7. Repeat for each relevant application.

# Build - Applications - Rotate client secret

> Security guide for rotating client secrets in backend and machine-to-machine applications including step-by-step rotation process and dependency management.

client secret rotation, security, backend apps, M2M apps, secret management
applications, security

To ensure your applications remain secure, you can periodically rotate the Client secret stored in the Kinde-side application. You can only do this for back-end and machine-to-machine applications. Note that you can only rotate a client secret by completely deactivating the old one. So you must update any dependent apps, connections, and services with the new secret ASAP. ## Rotate client secret in Kinde 1. In Kinde, go to **Settings > Applications**. 2. Select **View details** on the relevant application. 3. Scroll to the **Admin actions** section. 4. If you have previously retained a Client secret you’ll need to delete the previous secret first: 1. Take a copy of the previous secret if you want to. 2. Select **Delete previous client secret.** 5. Select **Rotate**. A confirmation window opens. 6. If you want, opt in to rotate the client secret and retain the old secret. You may need to [upgrade plans](https://kinde.com/pricing/) to do this. 7. If you don’t want to retain the previous secret, or you don’t want to upgrade, leave the switch off. 8. Select **Rotate client secret**. 9. Update any dependent apps, connections, and services with the new secret.

# Build - Domains - Add a custom domain for an organization

> Comprehensive guide for adding custom domains to organizations including DNS configuration, SSL certificate provisioning, verification monitoring, and troubleshooting steps.

custom domain, organization domain, DNS records, SSL certificate, subdomain, domain verification, social auth callback
domains, organizations, ssl

<Aside type="upgrade"> This is an advanced org feature that is only available on the [Kinde Scale plan](https://kinde.com/pricing/). Charges apply for each organization that uses [advanced org features](/authenticate/custom-configurations/advanced-organization/). </Aside> When you add a custom domain to an organization, it sets the domain URL for authentication to the custom domain, instead of a Kinde domain address. For example `account.domain.com` instead of `domain.kinde.com`. It's important to include a subdomain for this procedure to work. Common subdomain names include `account` , `id` , or `auth`, e.g. `account.domain.com`. Kinde currently supports a single custom domain per organization. ## Step 1: Add the custom domain to the organization 1. In Kinde, go to **Organizations**. 2. Browse or search for the organization. 3. In the list, select the organization to open the **Details** page. 4. Select **Custom domain** in the menu. 5. Select **Add custom domain** and enter the custom domain you want. Be sure to include the subdomain, e.g. `account.domain.com`. 6. Select **Save**. The DNS details are generated. Use them to add DNS records to your domain provider site. ## Step 2: Add DNS records to your domain provider site Instructions will vary depending on your domain provider. Here’s the general process. 1. Sign in to your domain provider admin portal. 2. Navigate to the page where you can add DNS records. 3. Use the details provided by Kinde to add CNAME DNS records. ## Step 3: Monitor for verification and SSL certificate provisioning 1. Open the individual organization record. 2. Select **Custom domains**. 3. The custom domain panel DNS records shows the current verification status. The verification process can take anywhere from a few minutes to a couple of hours. When it completes, the verification statuses will change. Here are the possible statuses you will see: - Unverified - Verification in progress - Verified - Verification failed (check that DNS records are correct on your domain provider site and try again). - Unprovisioned - Provisioning in progress - Provisioned (SSL certificate issued) - Provisioning failed Once successfully provisioned, your custom domain will then be used for this organization. You will also receive email confirmation. <Aside type="warning"> The challenge DNS record needs to remain in place after verification in order for us to renew your SSL certificate on an ongoing basis. </Aside> ## Step 4: Update provider social auth apps and codebase If the organization's users will use social authentication to sign in, update the provider apps such as Google or GitHub to include the custom domain callback (e.g. `account.example.com/login/callback`) as an authorized redirect URI. How you do this will be different for each provider you use. Remember to also update your application's codebase to reference the custom domain. ## Troubleshoot custom domain issues If you encounter any errors, such as the verification taking too long, re-check the DNS records you created on your provider site, to ensure the details are correct. ### No subdomain It's important to include a subdomain for the procedure to work, e.g. `account.domain.com`. If you left out the subdomain, delete the custom domain in Kinde, re-add it using the subdomain, and add the newly generated DNS details to your provider records. ### Tips for the DNS set up When you create the DNS records be sure to match the format and details provided in Kinde. For example, if your custom domain is `account.example.com`, then: Host = `account` Record type = `CNAME` Value = `account.example.com` TTL = Leave as default Routing policy = Leave as default ### Using multi-level subdomains If you are using a multi-level subdomain, like `multi.subdomain.example.com`, how you set up DNS records will depend on how your zones are set up. The details provided in the admin console assumes the domain entered is adding a single level to your DNS zone, but if you are adding more than one level you’ll need to create others. So if your business is `multi.subdomain.example.com` and your zone is `example.com`, you need to create a DNS entry for `multi.subdomain`, as well as for `_acme-challenge.multi.subdomain`. ## Remove a custom domain for an organization <Aside type="warning"> If your users are already signing in through a custom domain, removing it can break their authentication experience. </Aside> 1. Open the **Organization** record in Kinde. 2. Select **Custom domain** in the menu. 3. In the custom domain details area, select the three dots menu and then select **Remove custom domain**. Respond to the confirmation message.

# Build - Domains - Use your own custom domain

> Complete guide for setting up custom domains in Kinde including DNS configuration, verification process, SSL certificate provisioning, and integration with social authentication providers.

custom domain, DNS records, CNAME, SSL certificate, subdomain, social auth, domain verification, multi-level subdomains
domains, custom-domain, dns

By default, Kinde issues a Kinde subdomain when you first register. But for your production environment you can use your own custom domain instead of Kinde’s as your URL. For example, `account.example.com` instead of `mydomain.kinde.com`. There are a few reasons you may wish to do this. - It will give your users the impression they have never left your application to authenticate, creating a seamless user experience. - For Single Page Applications (SPAs) it means we can securely set a first party cookie meaning authentication state persists for full-page refreshes and new tabs. - If you also register the domain in the configuration for any social providers you are using, the social providers auth screen will be customized with your app details. <Aside title="When to still use the Kinde domain"> Even if you use custom domains, you need to use your Kinde domain for Kinde Management API access and machine-to-machine applications. </Aside> ## Before you begin - Name your custom domain. It needs to include a subdomain for this procedure to work. Common subdomain names include `account` , `id` , or `auth`, e.g. `account.example.com`. - Make sure your application is configured to use the exact custom domain. This includes updating the environment variables and any relevant configuration files. For example, the KINDE_ISSUER_URL needs to be updated to the custom domain. - Ensure that the callback and logout redirect URLs in your Kinde settings are updated with the custom domain. This can be done in the Kinde dashboard under Settings > Applications > [your app] > View details. ## Set up in Kinde Note that the verification process can take anywhere from 5 minutes to a few hours, depending on who your domain provider is. See [tips for the DNS set up](/build/domains/pointing-your-domain/#tips-for-the-dns-set-up) below. 1. Go to **Settings > Environment > Custom domain**. 2. Select **Add custom domain** 3. In the dialog, enter your custom domain. Be sure to include the subdomain, for example `account.example.com`. 4. Select **Save**. DNS details appear. You need to add these to your domain provider site. ## Add CNAME DNS records 1. Go to your domain provider website. 2. Create CNAME DNS records using the DNS details generated above. Apologies that we can’t offer instructions for all situations, as this will be different depending on your provider. But here are the setup steps for [Godaddy](https://au.godaddy.com/help/add-a-cname-record-19236), [Cloudflare](https://community.cloudflare.com/t/adding-dns-records/52718), and [NameCheap](https://www.namecheap.com/support/knowledgebase/article.aspx/9646/2237/how-to-create-a-cname-record-for-your-domain/). <Aside type="warning"> Cloudflare users: DNS entries must be DNS-only, not proxied. </Aside> ## Check verification status in Kinde Once you have created the DNS entries, Kinde will start the verification process. This can take anywhere from a few minutes to a couple of hours. When it completes, the verification status will change to 'Provisioned' and an SSL certificate will be provisioned. Your domain will then be used instead of Kinde’s. You will also receive an email notification when the process is complete. If you encounter any errors, such as the verification taking too long, re-check the DNS records you created on your provider site, to ensure the details are correct. <Aside type="warning"> The challenge DNS record needs to remain in place after verification in order for us to renew your SSL certificate on an ongoing basis. </Aside> ## Update your code - Update your code to use the custom domain. ## Add the custom domain to social sign in When you use social connections to authenticate users, you need to add the callback URL to the provider app so that the custom domain shows on the sign in form, instead of kinde.com. <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/9247cb87-9e7a-4977-b3f5-6c8b52f64200/public" alt="" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" /> If you haven't set this up, follow these instructions for the [relevant social provider](/authenticate/social-sign-in/add-social-sign-in/). If you already have social auth set up, make sure you add the custom domain callback (e.g. `account.example.com/login/callback` as an authorized redirect URI in the provider app. ## Domains and auth end points Auth endpoints are available for both custom domains and your Kinde subdomain. You can get tokens from either end point, but they are not interchangeable. For example, if you get an ID and access token from `account.example.com`, it cannot be used with `mydomain.kinde.com`. ## Local domain Currently, Kinde only supports `*.localhost` for non-https traffic. ## Tips for the DNS set up When you create the DNS records for linking your own domain to Kinde, be sure to match the format you have used above. For example, if your custom domain is `account.example.com`, then: Host = `account` Record type = `CNAME` Value = `account.example.com` TTL = Leave as default Routing policy = Leave as default ## Using multi-level subdomains If you are using a multi-level subdomain, like `multi.subdomain.example.com`, how you set up DNS records will depend on how your zones are set up. The details provided in the admin console assumes the domain entered is adding a single level to your DNS zone, but if you are adding more than one level you’ll need to create others. So if your business is `multi.subdomain.example.com` and your zone is `example.com`, you need to create a DNS entry for `multi.subdomain`, as well as for `_acme-challenge.multi.subdomain`. <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/ee01b968-bea8-4082-7680-cde0522fbf00/public" alt="" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" /> There are many different ways people manage multi-level domains and zones, and unfortunately we can’t cover all variations in these instructions.

# Build - Domains - Org handles and dynamic callbacks for subdomains

> Guide for implementing organization handles and dynamic callbacks to route users to correct subdomains in multi-tenant applications with authentication flow examples.

organization handles, dynamic callbacks, subdomains, multi-tenant, callback URLs, organization routing
domains, organizations, callbacks

If you use [organizations in Kinde](/build/organizations/multi-tenancy-using-organizations/), you probably build and maintain multi-tenant software. And if you manage multiple subdomains for those tenants, you'll need to make sure they are redirected to the right subdomain when they authenticate. The most effective way to do this is via ‘organization handles’ supported by a dynamic callback URL. ## How it works For every organization that has its own subdomain, you will add an organization handle. The handle and the subdomain need to match exactly. Here's an example. | Organization | Handle | Subdomain | | --- | --- | --- | | Red | red | red.everycolor.com | | Green | green | green.everycolor.com | | Blue | blue | blue.everycolor.com | Then you add one dynamic callback URL to your application that routes all the users to the correct subdomain via the organization handle: `{organization.handle}.everycolor.com`. The result is that users of the **Red** org will be automatically redirected to `red.everycolor.com` when they authenticate, and so on. ## Example authentication flow ![showing how handles and a dynamic callback route users during authentcation](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/e4e8e1ca-564f-4e25-602f-5f7cc51b1700/public) ## Requirements - This feature works for top level subdomains only - Handles must exactly match subdomain names - Handles must be unique for each organization ## Add the dynamic callback URL to your application 1. In Kinde, go to **Settings > Applications > [your application] > Details.** 2. Scroll to the **Callback URLs** section and in the **Allowed callback URLs** field, add `https://{organization.handle}.<yourdomain>.com.`, and replace `<yourdomain>` with your primary domain. For example, `https://{organization.handle}.everycolor.com` 3. Select **Save**. 4. Repeat from step 1 for each app you want to enable this for. ## Add handles to your organizations You can do this [via API](/kinde-apis/management#tag/organizations/patch/api/v1/organization/{org_code}) using the `handle` parameter, or manually in Kinde (see below). 1. In Kinde, go to **Organizations > [your organization] > Details.** 2. Enter the subdomain name for this organization in the **Handle** field, without the added URL information. For example, enter `blue` for the subdomain `https://blue.everycolor.com`. Ensure the subdomain name and the handle match exactly. The handle must also be unique within your Kinde business. 3. Select **Save**.

# Build - Env variables - Add and update environment variables

> Step-by-step guide for adding, updating, and deleting environment variables in Kinde including naming conventions and sensitive variable management.

add environment variables, update environment variables, delete environment variables, sensitive variables, variable naming, environment configuration
env-variables, configuration

Environment variables are key-value pairs configured outside your source code so that each value can change depending on the [Environment](/build/environments/environments/). Common use cases are for API keys, and URLs or IDs which change per environment, as they can be more easily updated wherever the key is referenced. You can store as many environment variables in Kinde as you want. ## Recommendations for variables - Choose a key name that helps you easily recognize what the variable is for. - Use descriptive, purpose-indicating names (e.g., `DATABASE_URL`, `API_KEY_STRIPE`). - Use a consistent case, such as CamelCase, snake_case, kebab-case, etc. We recommend using UPPER_SNAKE_CASE for environment variables as this is a widely adopted convention. - Mark a variable as sensitive if the value should be kept secret. For example an API key or password. - Consider adding a prefix for different environments (e.g., `PROD_`, `DEV_`). - Document the purpose and format of each variable for team reference. ## Add an environment variable 1. Go to **Settings > Data management > Env variables**. 2. Select **Add environment variable**. 3. In the dialog that opens, enter the **Key** and the **Value**. 4. Select if the key is **Sensitive**. 5. Select **Save**. ## Update an environment variable value You can only update the value of non-sensitive variables. If you need to update a sensitive variable value, you’ll need to delete and then create a new variable. 1. Go to **Settings > Data management > Env variables**. A list of all your variables is shown. 2. Select **Edit variable** in the … three dots menu next to the relevant non-sensitive variable. The **Edit variable** dialog opens. 3. Change the **Value**. You cannot change the `key`. 4. Select **Save**. ## Delete an environment variable 1. Go to **Settings > Data management > Env variables**. A list of all your variables is shown. 2. Select **Delete variable** in the … three dots menu next to the relevant variable. A confirmation window appears. 3. Confirm the variable deletion.

# Build - Env variables - Store environment variables in Kinde

> Guide for storing environment variables in Kinde including sensitive and non-sensitive variable types, environment-specific configuration, and security best practices.

environment variables, sensitive variables, secret management, key-value pairs, workflow variables
env-variables, security, workflows

Environment variables are key-value pairs that enable access to applications across different environments and systems. Once you can bring your code into Kinde via workflows, it’s important to be able to reference environment variables using a key, instead of hardcoding these values into your code. Kinde allows you to create and store sensitive (secret) and non-sensitive key-value pairs. ## Store variables for each environment You need to set environment variables separately, in each of your Kinde environments. You can’t share keys across development, testing, staging, and production, etc. ## Sensitive and non-sensitive environment variables The environment variables you store in Kinde can be sensitive or non-sensitive. - **Sensitive environment variables** contain confidential data (e.g., passwords, API keys, credentials) that must be handled with care to avoid security risks and data breaches. When you mark an existing environment variable as sensitive, Kinde converts it to a non-readable format and the value can no longer be read by you or your team. It can only be read by Kinde workflows at runtime. The value will also be redacted in any logs. - **Non-sensitive environment variables** handle non-confidential settings (e.g., language, application name, etc.) that don’t pose a risk if exposed. ## Examples of environment variables | Variable Name | Type | Description | Example Value | | --- | --- | --- | --- | | API_KEY | Sensitive | Authentication key for external services | `********` | | CLIENT_SECRET | Sensitive | OAuth client secret | `********` | | APP_NAME | Non-sensitive | Application identifier | `my-kinde-app` | | LOG_LEVEL | Non-sensitive | Application logging configuration | `debug` |

# Build - Environments - About environments

> Overview of Kinde environments including production and non-production environments, environment management, rate limiting considerations, and development workflow best practices.

environments, production environment, non-production, staging, testing, environment management, rate limiting
environments, development, production

Kinde allows you to run multiple environments to support your software development cycle. All plans come with one production environment and one non-production environment. Higher plans come with additional non-production environments, so you can add staging, testing, beta, etc. to meet your team’s needs. <Aside> You must use the default production environment (the one you got when you first signed up to Kinde) as your production environment. This is important for when you are [ready to go live](/build/environments/production-to-live/). You cannot delete the production environment or add additional production environments. </Aside> You can see the environment you are working in at the top left of the home page when signed in. ## Take care using multiple environments Unless you are a developer, we recommend you stay in the production environment for viewing and working with your Kinde account. For developers who want to test new user configurations or make other changes, do this in a non-production (testing or staging) environment first, before replicating in the production environment. ## Rate limiting for live production environments Before you make your production environment live, [follow ](/build/environments/production-to-live/)[this checklist](/build/environments/production-to-live/). It is critical that all [third-party authentication](/authenticate/authentication-methods/set-up-user-authentication/) connections (such as social connections or enterprise connections) are set up with the third-party’s Client ID and Client secret. If you leave these fields blank during setup, Kinde’s credentials will be used as a proxy, and rate limits will apply. Note that you can leave these fields blank in your non-production environments. Non-production environments cannot be made live. ## View and manage environments Select the environment drop-down in the top left of the home screen. From here you can: - Switch to another environment - View all your environments (and create additional ones) - View environment settings ## Add an environment You can only add non-production environments. 1. Select the environment drop-down in the top left of the home screen, and select **All environments**. 2. On the **Environments** page, select **Add environment**. 3. Enter a name and code for the environment, then select **Save**. ## Switch between environments Select the environment drop-down in the top left of the home screen, and select the environment you want to switch to. ## Change the name of an environment 1. Switch to the environment you want. 2. Select the environment drop-down in the top left of the home screen and choose **Environment settings**. 3. Change the environment name and select **Save**. ## Delete a non-production environment You cannot delete the production environment. 1. Select the environment drop-down in the top left of the home screen, and select **All environments**. 2. On the environment you want to delete select the three dots, then select **Delete environment**. 3. Confirm you want to delete the environment. This action is irreversible. ## Move data between environments There is currently no way to shift data or configuration settings between environments. For now, you need to replicate settings manually, and export/import data or use the [Kinde Management API](https://docs.kinde.com/kinde-apis/management/). It's on our roadmap to make this easier someday.

# Build - Environments - Prepare your production environment to go live

> Comprehensive checklist for preparing production environment to go live including authentication setup, domain configuration, security measures, and analytics integration.

production environment, go live, live checklist, third-party authentication, custom domain, multi-factor authentication, Google analytics
environments, production, go-live

As you build your business on Kinde and configure connections and features, you will eventually want to set your production environment to be ‘live’. This indicates the status of the environment to anyone making changes. Follow the checklist below before you switch your environment to show as 'Live'. <Aside title="The live button is not actually live"> The 'Live' switch is for indicating the environment is live. It does not actually change or do anything in relation to your app. Your app can be live on Kinde without the switch being on. </Aside> ## Go-live checklist Before you go live, make sure you’ve done the following: - (Required) Enter a `Client ID` and `Client secret` in all your [third-party authentication](/authenticate/authentication-methods/set-up-user-authentication/) connections (such as social connections or enterprise connections). If you left these fields blank at setup, Kinde’s credentials are used and rate limits will apply. - (Required) Add Twilio details if you have [phone or SMS authentication](/authenticate/authentication-methods/phone-authentication/) switched on. - Add a [development environment](/build/environments/environments/) to continue building your product on Kinde without affecting the live production instance. - Add [policies and terms](/manage-your-account/business-information/policies-terms/) so that users can access and agree to these on sign up. - Configure [custom email details](/get-started/connect/customize-email-sender/) so that authentication emails sent to your users come from your business, and not Kinde. - Connect [your own domain](/build/domains/pointing-your-domain/) and customize the [sign in screens](/design/brand/global-brand-defaults/) to provide a seamless and branded experience for users. - Set up [multi-factor authentication](/authenticate/multi-factor-auth/enable-multi-factor-authentication/) to add extra layers of security for user sign in. - Connect [Google analytics](/manage-users/view-activity/track-user-sign-in-with-google-analytics/) to track sign ups through Kinde. - Set up [default roles](/manage-users/roles-and-permissions/default-user-roles/) for assigning to new users when they sign up. ## Switch an environment to appear live When you are ready, turn the 'Live' indicator switch on. 1. Open your production environment. 2. Go to **Settings > Environment > Details.** 3. Scroll to the **Environment status** section and toggle the switch to **Live**. 4. Select **Save**. If there are any issues, an error message will appear. Where there are no errors, your Kinde environment should now show as 'Live. ![Status of production environment in Kinde](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/ac1aa617-bcb6-4a7f-02d3-b51aa7bcc600/public)

# Build - Organizations - Add and manage organizations

> Step-by-step guide for adding and managing organizations in Kinde, including creating new organizations, modifying the default organization, and understanding organization codes.

add organizations, manage organizations, default organization, organization code, external organization ID
organizations, multi-tenancy

All Kinde businesses come with one default organization. Some businesses will create more organizations to support a multi-tenancy business model. [Learn more about organizations](/build/organizations/multi-tenancy-using-organizations/). - To add organizations manually, follow the procedure below. - To add multiple organizations, we recommend importing them. See [Import organizations](/build/organizations/import-organizations/). ## Add an organization 1. In the main menu, select **Organizations.** The **Organizations** page opens. 2. Select **Add organization**. 3. Enter the name of the organization. 4. If you want, add an **External organization ID**. This is the ID you use to identify the organization, and enables you to import users and assign them to organizations by matching to this ID. 5. Select **Save**. The organization now appears on the **Organization** page, and is assigned a unique code. Developers need this code for using the Kinde API and SDKs. 6. To view the details or get the code again, select the three dots and then select **View details**. ## Change the name of the default organization When you first sign up to Kinde, you have one organization already created for you. This is the default organization that all users will be added to, until you create other organizations. You can change the name of this organization, but not the unique code. 1. In the main menu, select **Organizations.** The **Organizations** page opens. 2. Select the three dots next to the default organization, and select **View details**. 3. Edit the organization name and select **Save**.

# Build - Organizations - Allow organization creation on sign up

> Guide for controlling organization creation during user signup, including how to disable automatic organization creation for new registrations.

organization creation, signup, self-signup, is_create_org
organizations, signup

By default, Kinde allows organizations to be created when a user signs up if the `is_create_org` param is passed. This is helpful if your customers are organizations and you want them to be able to self-sign up. If you want to, you can disable organization creation for new sign ups. ## Switch off organization creation on sign up You can switch this option off at any time. 1. Go to **Settings > Environment > Policies**. 2. Switch off the **Allow organization creation on sign up** option. 3. Select **Save**.

# Build - Organizations - Manage user sign up to organizations

> Comprehensive guide for managing user signup to organizations, including allowing specific organization registrations, default organization settings, and disabling self-signup with security considerations.

user signup, organization registration, default organization, user policies, registration management
organizations, user-management, signup

Kinde lets you easily manage which organizations users can sign up to. For example, you can: - allow or disable users from signing up to specific organizations (if you manage multiple organizations) - allow or disable automatic sign up to the default organization (all Kinde businesses have a default) - disable signups completely, and add users manually, via API, or by import. - disable organizations from being created when a user signs up - this is usually only needed by businesses who’s customers are also businesses (B2B). Follow the relevant procedure below to set up your preferences. ## Allow users to register to a specific organization Each organization you set up in Kinde will have a unique `org_code`. If you want users to sign up to a specific organization, the `org_code` must be passed with their registration request. You need to switch this functionality on per organization. <Aside type="warning" title="Caution"> The `org_code` in the http request is vulnerable to manipulation, so only allow registrations to organizations that you would allow anyone to sign up to. If this is not the case, we suggest you leave this switched off and add the user to the right organization later via the Kinde management API. </Aside> 1. Go to **Organizations** and select the organization. 2. On the **Policies** page, switch on the option to **Allow registrations**. 3. Select **Save**. Anyone can now register onto this organization if the `org_code` is passed with the registration request. ## Sign users up to the default organization If the organization being signed up to is not known when a user signs up, the default organization is used. This applies to users created via API and by import as well. If you want, you can switch this off to prevent sign-ups to the default org. <Aside type="warning"> Users must belong to an organization to be assigned roles and permissions </Aside> 1. Go to **Organizations** and open the default organization. 2. Go to **Policies**, then switch off the **Sign users up to the default organization if one can’t be detected** option. 3. Select **Save**. ## Disable user self-sign up You can disable user self-sign up altogether. You might do this if you want to add and manage users manually, by API, or by import only. 1. Go to **Settings > Environment > Policies**. 2. Switch off the **Allow users to sign up** option. 3. Select **Save**. This setting applies to all apps in your business. <Aside type="warning"> Leave this on if you plan to use [JIT provisioning for enterprise connections](/authenticate/enterprise-connections/provision-users-enterprise/). </Aside> ## Sign in experience for users in multiple organizations If a user belongs to multiple organizations, they will be prompted to select an organization when they sign in unless they pass a specific `org_code`. If you use enterprise authentication, users will be recognized by their email domain and will be forwarded to the correct identity provider.

# Build - Organizations - Delete an organization

> Guide for safely deleting organizations including data cleanup considerations, user reassignment, and irreversible deletion process with safety precautions.

delete organization, organization removal, data cleanup, user reassignment
organizations, data-management

You can delete organizations in Kinde, but doing so removes all users from the organization, and deletes organization settings, feature flags, and data. Users who belong to other organizations remain assigned to those organizations. Users who only belong to the organization you are deleting will be removed, but not deleted from Kinde. ## Caution: Before you delete Deleting an organization cannot be reversed, so we recommend you: - [Reassign users to other organizations](/manage-users/about/manage-users-across-organizations/) (if you need to) - Review [feature flags](/releases/feature-flags/manage-feature-flags/) that might only apply to this organization - [Export any data](/manage-your-account/your-data/exporting-data/) that you want ## Deleting an organization 1. In Kinde, go to **Organizations**. 2. In the list, find the organization you want to delete. 3. Select the three dots menu at the far right and then select **Delete organization**. 4. In the confirmation window that appears, select **Yes, I definitely want to delete**, and then select **Delete organization**.

# Build - Organizations - Customize email sender for an organization

> Guide for customizing email sender settings for organizations including sender name and email address configuration with SMTP requirements.

email sender, organization branding, custom email, SMTP, email customization
organizations, email, branding

<Aside type="upgrade"> This is an advanced feature that is only available on the [Kinde Scale plan](https://kinde.com/pricing/) </Aside> If you want, you can set a unique email address and sender name for each organization you have. Users in the organization will receive emails from the email address and sender name you set, for example one-time passcode emails. You can change the customer sender name any time, but you must have a [custom email sender](/get-started/connect/customize-email-sender/) set up to change the email sender address. ## Change the email sender name for an organization 1. In Kinde, go to **Organizations**, then view an organization. 2. Select **Email**. 3. Add or change the **Sender name**. 4. Select **Save**. 5. To change the sender email, see below. ## Change the email sender address for an organization You must have a [custom SMTP email provider](/get-started/connect/customize-email-sender/) set up in Kinde, and your provider details configured with the address you are sending from. 1. In Kinde, go to **Organizations**, then view an organization. 2. Select **Email**. 3. Add or change the **Sender email**. 4. Select **Save**. 5. If you want, select **Send test email**. This lets you check the changes you made. ## Send a test email 1. In Kinde, go to **Organizations**, then view an organization. 2. Select **Email**. 3. Select **Send test email**. This lets you check the email details that your customer sees.

# Build - Organizations - Import organizations

> Guide for importing multiple organizations via CSV including file format requirements, import process, and integration with user bulk import workflows.

import organizations, bulk import, CSV import, external organization ID, B2B setup
organizations, bulk-import, csv

All Kinde businesses come with one default organization. For B2B business models, multiple organizations are usually required. [Learn more about organizations](/build/organizations/multi-tenancy-using-organizations/). Use this procedure to import multiple organizations into Kinde via CSV, before you [import users](/manage-users/add-and-edit/import-users-in-bulk/) into those organizations. You can also [add and manage organizations](/build/organizations/add-and-manage-organizations/) manually. ## Set up your CSV file Before importing, you need to set up the CSV file with the organization details: - Organization name - External organization ID The CSV should be set up like this: ```text name, id alpha, a001 beta, b002 charlie, c003 ``` ## Import organizations You can use this procedure to add new organizations or update the details of your existing organizations. 1. In Kinde, go to **Organizations** and then select **Import organizations**. 2. In the window that opens, select **Choose file** and select the CSV file. 3. Select **Import**. The **Organizations** window now shows the imported organizations or changes. Next: [Import users in bulk](/manage-users/add-and-edit/import-users-in-bulk/) and include the **external organization id** to assign users to the imported organizations.

# Build - Organizations - About organizations

> Overview of multi-tenancy using Kinde organizations including business models, tenant isolation, and user management across multiple organizational structures.

multi-tenancy, organizations, B2B, B2B2B, B2B2C, tenant isolation, business structure
organizations, multi-tenancy, business-models

Kinde is designed to support most business models and structures, from single entities to large enterprises. You can [run multiple businesses](/build/set-up-options/run-multiple-businesses/) on the Kinde platform, and you can also use organizations to separately manage sub-entities and user groups - known as multi-tenanting. ## What is multi-tenancy? Multi-tenancy is where a single instance of software (e.g. a business on Kinde), and its supporting infrastructure, can serve multiple customers. There are a number of ways that multi-tenancy can be done: - A single database with a tenant ID per tenant - A single database with a schema per tenant (how Kinde does it) - A database per tenant At Kinde we use a single database with a schema per tenant, which means each customer shares the application and a single database, but each tenant’s data is isolated and remains invisible to other tenants. ## Who needs to use organizations? If your business services businesses, who in turn service businesses or customers in a B2B2B or B2B2C model, you’ll need to set up organizations. For example, you might be: - a parent company running multiple stores, branches or membership groups. - a service or SaaS company managing access to a platform for different businesses and their customers. - a consultancy managing projects for different clients. ## Sample organization structure The diagram below shows an example of an organization structure. <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/84dfbf3e-75bd-4f4a-d513-94088fc10100/public" alt="" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" /> An organizational structure outlines how certain activities are managed, including [user roles and permissions](/manage-users/roles-and-permissions/apply-roles-and-permissions-to-users/). ## User management in organizations Organizations function to separate user groups or members, so you can separately control and manage access for them. Users can also belong to multiple organizations. For example, you may want freelancers or contractors to access all organizations. User management at the organization level, lets you: - Control who can access the organization - Set roles and permissions for each user in the organization

# Build - Organizations - Set access policies for an organization

> Advanced guide for setting organization-specific access policies including domain restrictions, auto-addition rules, and default role assignments for new members.

organization policies, access control, domain restrictions, default roles, organization security
organizations, access-policies, security

<Aside type="upgrade"> This is an advanced feature that is only available on the [Kinde Scale plan](https://kinde.com/pricing/). You can apply policies for 5 orgs, and then charges apply. </Aside> You can set policies for an organization to control access to the organization. When you set policies for an organization, this overrides any [policies set at the environment level](/build/set-up-options/access-policies/). This topic provides instructions for the following tasks: - Allow anyone to join the organization - Only allow users from specific domains to sign in to the organization (i.e. apply domain restrictions for an organization) - When users from specific domains sign up, add them as members to this organization - Assign specific roles to new members of an organization You may need to activate some features as you go. ## Go to the Policies section in your organization 1. In Kinde, go to **Organizations**. 2. Browse or search for the organization. 3. In the list, select the organization to open the details page. 4. Select **Policies** in the menu. 5. Configure policies using the following procedures. ### Configure access 1. If you want users to be able to join this organization if they pass the correct `org_code`, select **Allow org members to be auto-added**. 2. (Only in the default organization) Choose if you want to **Add users to this organization if no organization is specified** on sign up. ### Configure domain restrictions 1. Select **Allow org members to be auto-added** (if not already selected). 2. Select **Auto-add users from allowed domains**. 3. Enter the domains in the **Allowed domains** list. Use the format `domain.com` and not `https://www.domain.com`. This restricts users from joining the organization unless they belong to an allowed domain. If you leave this empty, users from any domain can sign up. 4. Select **Save**. ### Configure default roles for new members 1. In the **Default roles** section, select which roles will be assigned to new members when they sign up. ![Select default roles](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/6fc3e960-8bfe-427e-1e34-051b515aa600/public) 2. Select **Save**. ## Policy setting quick reference Note that your selections for each organization override the [global policy settings](/build/set-up-options/access-policies/). | To… | Do this… | | --------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------- | | Allow anyone to join this organization. | Select **Allow org members to be auto-added**. | | Sign up users who are not already associated with an organization, to the default organization. | Select **Add users to this organization if no organization is specified**. | | Allow only people from `specificdomain.com` to sign up to this organization. | Select **Allow self sign-up** and enter the `specificdomain.com` into the **Allowed domains** list. | | Allow only people from `specificdomain.com` to sign up to this organization and auto-add them seamlessly. | Select **Allow self sign-up** and enter the `specificdomain.com` into the **Allowed domains** list and select Auto-add users from allowed domains. | | Assign new members specific roles when they sign up | Select the **Default roles** you want assigned

# Build - Organizations - Give API access to an organization using M2M

> Guide for creating organization-scoped machine-to-machine applications to provide secure API access for automated systems and backend services within specific organizations.

organization m2m, api access, machine to machine, organization scoped, backend services
organizations, m2m, api-access

If you want to give automated systems, AI agents, or backend services access to data in a specific organization, you can do this securely using an **organization-scoped machine-to-machine (M2M) application**. This type of app is tied to a single organization and can only be used to access resources for that org. To create an org-scoped M2M app: 1. In Kinde, go to **Organizations**, then select the organization. 2. Select **Machine-to-machine apps**. 3. Follow the steps to create the app and assign the appropriate scopes. For full details, see [M2M access scoped to organizations](/machine-to-machine-applications/organization-scoped-m2m-apps/m2m-applications-for-organizations/).

# Build - Organizations - Kinde organizations for developers

> Comprehensive developer guide for working with Kinde organizations including creation, user assignment, self-signup flows, and organization management with code examples.

organizations, multi-tenancy, organization creation, user assignment, organization management, org_code
organizations, multi-tenancy, user-management

Organizations allow you to group your users into buckets. An organization in Kinde could represent a club, a company, a practice, a department - however you model your business. We’ll refer to them collectively as **organizations** in this topic. ## Important things to know about Kinde organizations - A user can belong to [multiple organizations](/manage-users/about/manage-users-across-organizations/) - The same user can have different [roles and permissions](/manage-users/roles-and-permissions/apply-roles-and-permissions-to-users/) in different organizations - By default they inherit global styles - but you can [brand them individually](/design/brand/apply-branding-for-an-organization/) - There is a **default organization** where new users are placed if we don’t know which organization they belong to. Auto assigning to this organization can be [turned off](/build/organizations/allow-user-signup-org/#sign-users-up-to-the-default-organization). - You can also [turn off](/build/organizations/allow-user-signup-org/#allow-users-to-register-to-a-specific-organization) the ability for users to sign up to specific organizations. ## Creating an organization There are three ways of creating an organization. 1. [Add](/build/organizations/add-and-manage-organizations/) or [import](/build/organizations/import-organizations/) through the Kinde application. 2. Add through the [Kinde management API](/kinde-apis/management#tag/organizations/post/api/v1/organization). 3. Allow organizations to sign themselves up (see below). ## New organization self-sign up By default Kinde allows organizations to self-sign up to your project. You can [turn this off](/build/organizations/allow-org-create-on-signup/) in Kinde if you prefer to handle registration another way. ### Basic implementation To initiate the organization self-sign up flow pass the `is_create_org` parameter in the auth url when redirecting to Kinde. This will prompt the user to register an account and upon successful registration create an organization in the background on Kinde. Our SDKs contain helpers to achieve this. The below example is from the Kinde React SDK, which ships with a `createOrg` method. ```jsx import {useKindeAuth} from "@kinde-oss/kinde-auth-react"; export const RegisterOrgButton = () => { const {createOrg} = useKindeAuth(); return ( <button onClick={createOrg} type="button"> Create Organization </button> ); }; ``` See the [relevant SDK doc](/developer-tools/about/our-sdks/) for your stack, for examples on how to do this. ### Providing an organization name If you want to pass an organization name to Kinde, you can pass it in the auth url with the `org_name` parameter. A common pattern is to provide an input field in your project for the user to type their preferred name. Here’s another example using React. ```jsx import {useKindeAuth} from "@kinde-oss/kinde-auth-react"; import {useState} from "react"; const RegisterOrgForm = () => { const {createOrg} = useKindeAuth(); const [orgName, setOrgName] = useState(""); const handleSubmit = (e) => { e.preventDefault(); // 1. store whatever you need to in your project // 2. redirect to Kinde createOrg({org_name: orgName}); }; return ( <form> <label for="id_org_name">Org name</label> <input id="id_org_name" onChange={(e) => setOrgName(e.target.value)} type="text" /> <button onSubmit={handleSubmit}>Register</button> </form> ); }; ``` See the [relevant SDK doc](/developer-tools/about/our-sdks/) for your stack, for examples on how to do this. ## Assigning a user to an existing organization There are a few ways of doing this. 1. Go into Kinde and [add](/manage-users/add-and-edit/add-and-edit-users/) or [import](/manage-users/add-and-edit/import-users-in-bulk/) users manually. 2. Add users via the [Kinde management API](/kinde-apis/management#tag/organizations/post/api/v1/organizations/{org_code}/users). 3. Provide a sign up link from your product (see below). ### Signing up new users into an existing organization As noted earlier, Kinde has the notion of a **default organization** where new users are placed if we don’t know which organization they belong to. This can be [switched off](/build/organizations/allow-user-signup-org/#sign-users-up-to-the-default-organization), or you can pass an `org_code` parameter in the auth URL to specify which organization you would like users to sign up to. <Aside type="warning" title="Caution"> Caution: the `org_code` in the http request is vulnerable to manipulation, so only allow registrations to organizations that you would allow anyone to sign up to. If this is not the case, we suggest you leave this switched off and add the user to the right organization later via the [Kinde management API](/kinde-apis/management/). </Aside> Our SDKs provide specific helper methods for passing the `org_code` parameter. For example, in React, this can be achieved as follows: ```jsx import {useKindeAuth} from "@kinde-oss/kinde-auth-react"; export const RegisterOrgButton = (orgCode) => { const {register} = useKindeAuth(); return ( <button onClick={() => register({org_code: orgCode})} type="button"> Register for this org </button> ); }; ``` See the [relevant SDK doc](/developer-tools/about/our-sdks/) for your stack, for examples on how to do this. ### Signing users into an existing organization The flows are slightly different depending on whether you supply an organization code to us in the auth url as `org_code` parameter. **No org code provided** If Kinde is not provided with an `org_code`, there are three possible outcomes: 1. If a user only belongs to a single organization they will be automatically signed into this organization. 2. If the user belongs to multiple organizations, after they have authenticated we present them with an organization selector that shows all the organizations they have access to. They can then choose one to continue. 3. If the user belongs to no organizations, they will be signed in without an organization, meaning the `org_code` claim will be omitted from the access token. Code wise there is nothing different to do from a standard sign in. Again, a React example: ```jsx import {useKindeAuth} from "@kinde-oss/kinde-auth-react"; export const LoginButton = () => { const {login} = useKindeAuth(); return ( <button onClick={login} type="button"> Log in </button> ); }; ``` See the [relevant SDK doc](/developer-tools/about/our-sdks/) for your stack, for examples on how to do this. **Org code provided** If Kinde receives the `org_code` parameter in the auth url it means two things: 1. If you have set up [branding for the organization](/design/brand/apply-branding-for-an-organization/) we display this to the end user providing a much more customized experience 2. If the user is a member of multiple organizations we can skip the organization switcher step mentioned above and sign them straight into the requested organization. Our SDKs describe how to provide the `org code` in the auth url. Here’s an example from React. ```jsx import {useKindeAuth} from "@kinde-oss/kinde-auth-react"; export const LoginOrgButton = (orgCode) => { const {login} = useKindeAuth(); return ( <button onClick={() => login({org_code: orgCode})} type="button"> Log in to org </button> ); }; ``` See the [relevant SDK doc](/developer-tools/about/our-sdks/) for your stack, for examples on how to do this. ## Getting the organization ID We refer to the organization’s ID as an `org_code` which is unique for each organization. Once a user has authenticated and is returned to your project we expose the `org_code` in their access token. Each SDK has a way of accessing this. For example in React: ```jsx const {getOrganization} = useKindeAuth(); console.log(getOrganization()); //returns {orgCode: "org_xxxxxxxxxx"} ``` See the [relevant SDK doc](/developer-tools/about/our-sdks/) for your stack, for examples on how to do this. ## Getting the list of all organization IDs a user belongs to If a user belongs to multiple organizations, you might find it useful to get a list of them. You could do this in a couple of ways: 1. Via the [Kinde management API](/kinde-apis/management#tag/organizations) 2. Reading the `id_token` (see below). ### Using the id_token to get a list of organization IDs We provide an array of organization codes in the `org_codes` claim of the `id_token`. You can either use a JWT parser to extract these, or use our SDKs provide helper methods. In React you can use the following helper: ```jsx const {getUserOrganizations} = useKindeAuth(); console.log(getUserOrganizations()); //returns {orgCodes: ["org_1234", "org_5678"]} ``` ## Roles and Permissions A user can have different roles and permissions per organization. This means they can have an `admin` role in Organization ABC but a `member` role in Organization XYZ. You can manage these roles and permissions: 1. In the [Kinde admin area](/manage-users/roles-and-permissions/user-permissions/) 2. Via the [Kinde Management API](/kinde-apis/management#tag/permissions) 3. Read them from the `access_token` (see below). Note that only permissions specific to the organization the user is signed into will be returned. ### Using the access_token to get a list of permissions We provide an array of permissions in the `permissions` claim of the `access_token`. You can either use a JWT parser to extract these, or using our SDK helper methods. In React you can use the following helper: ```jsx const {getUserOrganizations} = useKindeAuth(); console.log(getUserOrganizations()); //returns {orgCodes: ["org_1234", "org_5678"]} ``` ### Using an SDK for permission-based access control Our SDKs also ship with helpers for handling permission checks. For example in React you could use: ```jsx const {getPermission} = useKindeAuth(); getPermission("create:todos"); // {orgCode: "org_1234", isGranted: true} ``` Then you could gate the feature as follows: ```jsx { getPermission("create:todos").isGranted ? <button>Create todo</button> : null; } ``` See the [relevant SDK doc](/developer-tools/about/our-sdks/) for your stack, for examples on how to do this. ## Release management You can use feature flags to provide different features to different organizations. This is especially helpful if you want to beta test a new feature for your project and only release it to selected organizations. You can manage these feature flags: 1. In the [Kinde admin area](/releases/feature-flags/add-feature-flag/) 2. Via the [Kinde Management API](/kinde-apis/management#tag/feature-flags) 3. Read them from the `access_token` (see below). ### Using the access_token to get a list of feature flags We provide an array of flags in the `feature_flags` claim of the `access_token`. You can use a JWT parser extract these, or use an [appropriate SDK](/developer-tools/about/our-sdks/) for handler examples. Here’s an example from the React SDK. ```jsx feature_flags: { theme: { "t": "s", "v": "pink" }, is_dark_mode: { "t": "b", "v": true }, competitions_limit: { "t": "i", "v": 5 } } ```

# Build - Organizations - Customize the self-serve portal for an organization

> Use advanced organizations to override the self-serve portal setting for individual organizations. For example, make a function available in one organization that is not suitable for another org.

self-serve, plan, bill, payment method, SSO
self-serve portal, manage organizations, self-manage, SSO, plan management, payment details

<Aside type="upgrade"> This is an advanced feature that is only available on the [Kinde Scale plan](https://kinde.com/pricing/) </Aside> If an organization requires a unique setup for the self-service portal, you can do this using an advanced organization function. If you set this up, the authorized members of the organization will be able to perform the selected functions. 1. In Kinde, open the organization you want to customize. 2. In the side menu, select **Self-serve portal**. 3. If you don't have Advanced organizations switched on, enable this now. 4. Switch on the **Override environment settings** option. ![Switch to override](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/9461ff2f-0c8e-4f2a-0dbb-f6db420bb400/public) 5. Select the options you want to be available in the self-serve portal for this org. 6. Select any additional changes you want to make for members of the org (users) to access. Note that individual access is still controlled via system roles. 7. Select **Save**. Learn more about [setting up the self-serve portal for an organization](/build/self-service-portal/self-serve-portal-for-orgs/).

# Build - Set up options - Customer self-serve portal

> Intro to concept of self-serve portals in Kinde, including what functions they include, how to use them, and when to set them up.

organization portal, self-serve portal, user portal, billing portal, portal permissions
self-serve-portal, organizations, users, billing

Customer support is one of the higher overheads for a SaaS business. For paying customers, the expectation is that they get help when needed, for example, to manage their account or get assistance with your app. Kinde lets you configure a self-serve portal so authorized customers can self-manage functions provided by Kinde. A self-serve portal means your customers can make account changes without contacting you for support, saving everyone time and money. There's two types of portal: one for end users (B2C), and one for organizations (B2B). ## Watch Dave's portal demo in 90 seconds <YoutubeVideo videoId="Q3HW6Mgj6wA" videoTitle="Customer portal in 90 seconds"/> ## Self-serve portal for organizations In the organization portal, you can allow org members to manage: - Account details - Payment details (if you have billing set up) - API Keys (Paid plans) - Members and roles (Coming soon - Paid plans only) - SSO enterprise connections (Coming soon - Kinde Scale plan only) You can enable all functions or limit them to what you offer. [Set up a self-serve portal for an org](/build/self-service-portal/self-serve-portal-for-orgs/) <Aside> If you are on the Kinde Scale plan, you can configure the [portal per organization](/build/organizations/self-serve-portal-per-org/). E.g. allow some functions for some customers and not others. </Aside> ## Self-serve portal for users In the user portal, you can allow users to manage: - Account details - Payment details (if you have billing set up) - Multi-factor auth settings (coming soon) - API Keys [Set up a self-serve portal for users](/build/self-service-portal/self-serve-portal-for-users/) ## Self-serve portal settings These are the self-serve portal settings you can enable. ![Self-serve portal settings in Kinde](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/1fd3505c-883b-4b01-8dff-e028e25b6300/public) ## Current limitations Currently, we don't support any customer design for the portal appearance. However, you can build your own portal and use the [Kinde API](https://docs.kinde.com/kinde-apis/management/) endpoints to provide the functions.

# Build - Set up options - Set global access policies

> Guide for setting global access policies including self-signup controls, domain restrictions, organization creation, and social profile synchronization settings.

access policies, domain restrictions, self signup, organization creation, social profile sync, global policies
access-policies, security, user-management

This topic is about setting user access policies at the environment level. If you want to apply user access policies per organization, see [Set access policies for an organization](/build/organizations/organization-access-policies/) This topic covers the following tasks: - Allow anyone to sign-up for an account - Create an organization when someone signs up (for B2B businesses usually) - Allow only users from specific domains to sign up (i.e. restrict sign up based on email domain) - Enable profiles from social providers to sync with Kinde profiles (recommended if you allow social sign in) ## Set policies for all organizations 1. In Kinde, go to **Settings > Environment > Policies**. 2. If you want users to be able to sign up or register to your application, select **Allow self sign-up**. 3. If you want to restrict which domains can sign up to your applications, enter domains in the **Allowed domains** list. Use the format `domain.com` and not `https://www.domain.com`. If you leave this empty, users from any domain can sign up. 4. Choose if you want to **Allow organization creation on sign up**. This is common for B2B businesses. 5. Select **Sync user profiles on sign in** if you want to keep basic user profile data provided by third-party sources (like Google, GitHub, etc.) in sync with Kinde profiles. You only need to select this if you allow sign-up and sign-in using social providers. 6. Select **Save**. ## Policy setting quick reference Note that global access policies can be overriden at the individual organization level if you are on a [Kinde Scale plan](https://kinde.com/pricing/) and activate the Advanced organization feature. | To… | Do this… | | ----------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------- | | Allow anyone to sign up to your applications. | Select **Allow self sign-up**. | | Allow only people from `specificdomain.com` to sign up to your applications. | Select **Allow self sign-up** and enter the specificdomain.com into the **Allowed domains** list. | | Allow anyone to sign up to your applications and create an organization if they are a business. | Select **Allow self sign-up** and **Allow organization creation on sign up**. |

# Build - Set up options - Configure attack protection

> Guide for configuring attack protection including brute force protection settings, credential enumeration protection, and security best practices for account lockouts.

attack protection, brute force protection, credential enumeration, account lockout, security settings, failed sign-in attempts
security, attack-protection, brute-force

Attack protection is always on, and Kinde ships with sensible defaults to keep your product protected without you lifting a finger. There are some things you can configure. ## Set brute force protection 1. In Kinde, go to **Settings > Attack protection**. 2. Select **Brute force protection**. 3. Set how many sign-in attempts users get before being locked out of their account. You can choose the Kinde default of 5 or set a custom amount. 4. Set how long the account lockout lasts before users can sign in again. You can accept the Kinde default of 5 minutes or set a custom time, up to 60 minutes. 5. Select **Save**. ### What counts as a failed sign-in attempt - incorrect password entered - incorrect OTP code entered - incorrect recovery code entered - incorrect MFA response entered ## Enable credential enumeration protection Enumeration attacks are where an attacker tries to verify if an account exists using your credentials. One of the ways an attacker knows you have an account or not, is if they enter credenitals (e.g. email or phone number) and the screen either progresses to a password/code entry screen, or shows a message that the account does not exist. Once an attacker knows an account exists, they can go about breaking in. To prevent them ever knowing, you can ensure that the sign in experience does not give the answer away. 1. In Kinde, go to **Settings > Attack protection**. 2. Select **Enumeration protection**. 3. Switch on the toggle for **Credential enumeration protection**. 4. Select **Save**. For general information about Kinde security, practices, and policies, see the [Trust Center](/trust-center/security/security-at-kinde/).

# Build - Set up options - Kinde for different business models

> Comprehensive guide to different business models supported by Kinde including B2C, B2B, B2B2C, marketplace, agency, and membership organizations with configuration recommendations.

business models, B2C, B2B, B2B2C, marketplace, agency, membership, multi-tenancy
business-models, multi-tenancy, organizations

Kinde is built to support many types of SaaS models, for apps, sites, and projects. From straightforward models where you provide services directly to individuals, to multi-tenant setups for managing other business’s auth and user needs. This topic explains how to use organizations in Kinde to support your business model. ## You provide services directly to customers (B2C) Users sign up directly to your business and you manage them in one large user group. <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/3c8e194f-db16-44e9-691e-8cb6e3d7b300/public" alt="" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" /> For this business setup, configure everything at the Business and Environment level in Kinde, including: - [Authentication](/authenticate/about-auth/about-authentication/) (including signing up and in with third party providers like Google) - [Global brand and page design](/design/brand/global-brand-defaults/) - [Defining roles and permissions](/manage-users/roles-and-permissions/user-roles/) Kinde comes with a default organization, so if you only have one user group, they all belong to that default organization. ## You provide services to companies (B2B) Each company your business services has their own organization in Kinde. Each organization can also have it’s own group of users. If you want, you can [allow organizations to be created when a new business signs up](/build/organizations/allow-org-create-on-signup/) to your service. <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/0b98bd9f-ad8c-498d-e194-d04ee99bf600/public" alt="" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" /> Configure these settings at the Business and Environment level for organizations to inherit: - [Authentication](/authenticate/about-auth/about-authentication/) (including enterprise auth such as [Entra ID](/authenticate/enterprise-connections/azure/) or [SAML](/authenticate/enterprise-connections/custom-saml/)) - [Global brand and page design](/design/brand/global-brand-defaults/) - [Define roles and permissions](/manage-users/roles-and-permissions/user-roles/) Then you’ll set up organizations for each business you service, and in each organization: - [Manage how users sign up to organizations](/build/organizations/allow-user-signup-org/) - (optional) Set up individual [organization brand, including the sign up and sign in experience](/design/brand/apply-branding-for-an-organization/) - Define what [roles and permissions](/manage-users/roles-and-permissions/apply-roles-and-permissions-to-users/) apply for users of each organization - Enable special [feature access](/releases/about/about-feature-flags/#overriding-feature-flags) for individual organizations ## You provide services to companies, and their customers (B2B2C) Each company your business services has their own organization in Kinde. And for each organization, there is a group of users who are managed separate to each other. In tech-speak, this is multi-tenanting. You will want to carefully manage [how users sign up to organizations](/build/organizations/allow-user-signup-org/) for this business model. <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/adc65381-19f9-44bb-6db5-dbec7e5b0e00/public" alt="" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" /> You will configure most settings at the Business and Environment level, and then you can decide if you customize some settings per organization. You might set up the following for your business and in your applications: - Supported [Authentication](/authenticate/about-auth/about-authentication/) types, including custom auth for [SAML](/authenticate/enterprise-connections/custom-saml/), and [social sign in](/authenticate/social-sign-in/add-social-sign-in/) - [Global brand and page design](/design/brand/global-brand-defaults/) - Define the [roles and permissions](/manage-users/roles-and-permissions/user-roles/) that can be applied to users in each organization For each organization, you will want to: - Assign [user roles and permissions](/manage-users/roles-and-permissions/apply-roles-and-permissions-to-users/), including [default roles](/manage-users/roles-and-permissions/default-user-roles/) that apply when a user signs up - Enable special [feature access](/releases/about/about-feature-flags/#overriding-feature-flags) for individual organizations - (optional) Set up individual [organization brand, including the sign up and sign in experience](/design/brand/apply-branding-for-an-organization/) In this set up, you will likely need to [manage users across organizations](/manage-users/about/manage-users-across-organizations/) as well. ## You’re a membership-type organization You’re a central organization, and you service related businesses, branches, locations, or clubs, who have members. This works a bit like a B2B2C, but the structure is usually more simple. <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/5267537f-80e7-4208-464c-f0ee4d66da00/public" alt="" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" /> Membership organizations are typically branded at the org level, and authentication is kept fairly simple. You will configure most settings at the Business and Environment level, such as: - [Authentication](/authenticate/about-auth/about-authentication/) (including [passwordless](/authenticate/authentication-methods/passwordless-authentication/) and [social sign up](/authenticate/social-sign-in/add-social-sign-in/) to make things easy) - A base [global brand and page design](/design/brand/global-brand-defaults/) - [Defining simple sets of roles and permissions](/manage-users/roles-and-permissions/user-roles/) For each organization, you will want to: - Spend time setting up [brand and design](/design/brand/apply-branding-for-an-organization/) - Align [roles](/manage-users/roles-and-permissions/user-roles/) and [feature access](/releases/feature-flags/edit-feature-flag/#override-feature-flag-value-for-an-organization) within each organization to ensure different users see the right part of your application - Decide [how user’s are able to sign up to an org](/build/organizations/allow-user-signup-org/) ## You’re a marketplace A marketplace usually combines a bit of B2C and B2B. This kind of business connects buyers with sellers, creators and audiences, businesses and consumers - you get the idea. <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/0ed1e797-10a0-4b18-f57e-b1184b4a0e00/public" alt="" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" /> A marketplace usually separates the different market participants, which can be done through organizations. This enables independent control of the parts of your app each organization can access, and how. Configure most settings at the Business and Environment level, such as: - A base [global brand and page design](/design/brand/global-brand-defaults/) - [Defining simple sets of roles and permissions](/manage-users/roles-and-permissions/user-roles/) For each organization, you will want to: - Set up [Authentication](/authenticate/about-auth/about-authentication/) per organization to enable different sign up and sign in methods, depending on user segment. For example, set password authentication with [multi-factor authentication](/authenticate/multi-factor-auth/enable-multi-factor-authentication/) for your supplier side users, and [easy social sign up](/authenticate/social-sign-in/add-social-sign-in/) for your consumer side users. - Align [roles](/manage-users/roles-and-permissions/user-roles/) and [feature access](/releases/feature-flags/edit-feature-flag/#override-feature-flag-value-for-an-organization) within each organization to ensure different users see the right part of your application - Decide [how user’s are able to sign up to an org](/build/organizations/allow-user-signup-org/) - (optional) Set up individual [organization brand, including the sign up and sign in experience](/design/brand/apply-branding-for-an-organization/) ## You’re an agency This model is for enterprise-sized customers who really love Kinde. For example, an agency who sets up and runs multiple businesses and applications, on behalf of clients, using the Kinde platform. You’ll set up each of your client’s businesses according to what type of business model they are. See above for business structure recommendations. <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/52f6adce-cd5e-4a2c-7639-9b7e32cdee00/public" alt="" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" /> Tip: You could adapt this model if you’re a large multi-location, multi-department, or multi-service enterprise.

# Build - Set up options - Set up and manage user access requests

> Guide for setting up and managing user access requests including page configuration, contact conversion to users, and access request lifecycle management.

access requests, user conversion, request access page, contact management, user onboarding
access-requests, user-management, onboarding

In Kinde, you can collect user information before you give people access to your application. This is managed through the **Access requests** user list. You might use this function if you’re not ready to give people product access, but you want them to register their interest. You can also use this if you want to select and control who or how many people can access your application. It’s a good idea to maintain a separate contact list for general communication to customers, and you can do this by [building your subscriber list](/manage-users/add-and-edit/manage-subscribers/). ## Set up the request access page Kinde allows you to design the page where customers can go to register their interest. See [set up your request access page](/design/pages/set-up-the-request-access-page/). ## View access requests list 1. In Kinde, go to **Users > Access requests**. A list of customer contacts is shown. 2. To see when a contact requested access, find them in the list, select the three dots menu and select **View details**. A panel slides out showing added information. ## Convert an access requests contact to a user When you’re ready to give application access to someone on your access requests list, you can convert them to a user and (if applicable) allocate them to an organization. 1. Go to **Users > Access Requests** and find the contact you want to convert to a user. 2. Select the three dots menu and select **Convert to user**. A window appears, prompting you to select the organization the user will belong to. You can only select one. 3. Select **Convert**. The contact will now appear on the **All users** list, but will also remain an **Access requests** contact. See [Manage users across organizations](/manage-users/about/manage-users-across-organizations/) if you want to assign the user to other organizations. ## Delete access request contact 1. Go to **Users > Access Requests** and find the contact you want to delete. 2. Select the three dots menu and select **Delete** **access request**. A confirmation message appears. 3. Select **Delete**. The contact is permanently removed from this list.

# Build - Set up options - Run multiple businesses

> Guide for managing multiple businesses on Kinde including adding new businesses, switching between them, and safely deleting businesses with data export considerations.

multiple businesses, business management, switch business, delete business, data export
business-management, multi-tenancy

You can run multiple businesses on Kinde. This is helpful if you want to create different businesses with different user groups. For instance if you are a founder working on multiple applications, or you also run a business in a different region. Organizations, users, branding, and activity are all managed separately. ## **Add a new business** 1. Select your business profile in the bottom left of the Kinde home screen. 2. From the menu, select **Switch business**. A screen showing all your businesses opens. 3. Select **Add business**. 4. Complete the form, including your preferred Kinde domain and data storage region. These details cannot be changed later. 5. Select **Save**. 6. To complete the setup, select the business to switch to it. Follow the quickstart prompts. ## **Switch between businesses** 1. Select your business profile in the bottom left of the Kinde home screen. 2. From the menu, select **Switch business*. A screen showing all your businesses opens. 3. Select the one you want to work in. The business loads. ## Delete a business You can only [delete a business](/manage-your-account/your-data/delete-business/) that is on the Kinde free plan. If you have a paid subscription, you need to email [support@kinde.com](mailto:support@kinde.com) to downgrade from a paid account before deleting. Include the Kinde domain and business name in the email, and send it from the owner account email. Deleting a business is a nuclear and irreversible action, so make sure you [export](/manage-your-account/your-data/exporting-data/) all your important data before doing this.

# Build - Set up options - Enable self-serve portal for orgs

> Guide for enabling self-serve portals for organizations including business details management, billing access, permission controls, and portal link generation methods.

organization portal, self-serve portal, org management, billing portal, portal permissions, organization alias
self-serve-portal, organizations, billing

You can configure a self-serve portal to enable authorized organization members to be able to self-manage functions provided by Kinde. Authorized org members can update: - [Business details](/manage-your-account/business-information/update-your-details/) - [Payment details](/manage-your-account/profile-and-plan/update-kinde-payment/) (if you have billing set up) - [API Keys](/manage-your-apis/add-manage-api-keys/self-serve-api-keys/) - [Members and roles](/get-started/team-and-account/add-team-members/) - Multi-factor auth settings (coming soon) - SSO enterprise connections (almost here) A self-serve portal means your customers can make account changes without contacting you for support. This can save you both time. If you are on the Kinde Scale plan, you can configure the [portal per organization](/build/organizations/self-serve-portal-per-org/). E.g. allow some functions for some customers and not others. ## Configure the organization self-serve portal 1. Go to **Settings > Environment > Self-serve portal**. ![Settings for self-serve portal for orgs](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/81169031-611b-402a-20f7-47c84f53b600/public) 2. Enter the **Return URL** that you want users to land on when they exit the portal, e.g. your app dashboard. 3. Add an **Organization alias** to represent how your customers are referred to in your business, e.g. Account, Partner, Workspace, etc. This will be visible in the interface in the portal. 4. In the **Organization profile** section, select the functions you want organization admins to be able to manage. ![Options for showing hiding settings for org members](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/13cf1ec6-bbe1-4059-4c78-b97d94b2b200/public) 5. Select **Save**. ## Portal access control with system permissions Each core function within the self-serve portal is governed by a corresponding system permission. For example, the `org:write:billing` permission allows users to update billing details. These permissions can be included in your custom roles and assigned to organization members. We recommend creating custom roles with varying levels of portal access, which you can then assign as needed. For instance, you might create a role that allows members to view billing details but not update them. You can select these permissions within your existing roles, or when you create them. ![Roles with system permissions for self-serve portal](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/1e90e72e-00d5-4063-8d34-79d1a9b8f000/public) When [configuring org roles](/billing/get-started/add-billing-role/), you can specify whether it should be: - Automatically assigned to all new organization members. - Automatically assigned to the organization creator. ## Generate the self-serve portal link Access to the portal is granted via a one-time link. You then use the link on an 'account' or 'profile' button in your app to open the Kinde portal screens. There are two main ways to generate this link: - **Using the user's access token** (recommended) - **Using the Kinde Management API** ### Include the self-serve portal link in the user's access token This method is ideal when you want to generate the portal link on the fly—for example, when a user clicks an "Account" button in your app. ### Generate a self-serve portal link with a Kinde SDK If you're using the Kinde React SDK, you can use the `<PortalLink />` component, which both generates the link and redirects the user: ```jsx import {PortalLink} from "@kinde-oss/kinde-auth-react"; <PortalLink>Account</PortalLink>; ``` ### Generate a self-serve portal link without a Kinde SDK If you're not using a Kinde SDK, you can manually call the Account API: ```js const response = await fetch("/account_api/v1/portal_link", { headers: { Authorization: `Bearer ${userAccessToken}` } }); const data = await response.json(); window.location = data.url; ``` Optional parameters: - `return_url` – where to redirect the user after exiting the portal. - `sub_nav` – specify the portal section to open (e.g., `organization_billing`, `profile`). ### Manage the self-serve portal link using the Kinde Management API This option is useful for server-side applications or if you're using Kinde billing features without Kinde Authentication. Make a request to the `POST /api/v1/portal/generate_url` endpoint using an M2M token. **Request body** ```js { "user_id": "kp_1234567890", // The ID of the user for whom you want to generate the portal link "organization_code": "org_123456789", // Optional: the organization code for which the portal link is generated "return_url": "https://yourapp.com/dashboard", // Optional: where to redirect the user after exiting the portal "sub_nav": "profile" // Optional: specify the portal section to open (e.g., `organization_billing`, `profile`) } ``` This will return a one-time portal link for the specified user. ## How the self-serve portal looks When the user clicks the link you've added to your app, the portal opens. The default design is shown below, and we are working on allowing you to style this yourself. The options a member sees depends on their role and what you have chosen to display. ![Self-serve portal in Kinde](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/fb38548b-e530-4dfa-68b3-29ef2f287700/public)

# Build - Set up options - Enable self-serve portal for users

> Guide for enabling and configuring self-serve portals for users including profile management, billing access, and multiple methods for generating portal links with SDK and API examples.

self-serve portal, user portal, account management, billing portal, portal link, account API
self-serve-portal, user-management, billing

You can configure a self-serve portal to enable users to be able to self-manage functions provided by Kinde. For example, you can allow users to update their profile, as well as their billing subscription and payment details (if you have billing set up). If you have a B2C business, you might want to set this up. A self-serve portal means your customers can make basic account changes without contacting you for support. This can save time and money. ## Configure the user self-serve portal 1. Go to **Settings > Environment > Self-serve portal**. ![Settings for self-serve portal set up in Kinde](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/81169031-611b-402a-20f7-47c84f53b600/public) 2. Enter the **Return URL** that you want users to land on when they exit the portal, e.g. your app dashboard. This can also be used as a fallback URL if you decide to use the SDK method of dynamically generting the URL (see below). 3. In the **User profile** section, select the functions you want the user to be able to manage. If you select **Billing**, they can manage their plan as well as payment methods. ![Self-serve portal settings for users](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/f821e9c5-497d-41f0-b373-2755320d1c00/public) 4. Select **Save**. ## Generate the self-serve portal link Access to the portal is granted via a one-time link. There are two main ways to generate this link: - **Using the user's access token** (recommended) - **Using the Kinde Management API** Both methods are able to generate the portal link on the fly. For example, when a user clicks an "Account" button in your app. ### Generate a self-serve portal link with a Kinde SDK If you're using the Kinde React SDK, you can use the `<PortalLink />` component, which both generates the link and redirects the user: ```jsx import {PortalLink} from "@kinde-oss/kinde-auth-react"; <PortalLink>Account</PortalLink>; ``` ### Generate a self-serve portal link without a Kinde SDK If you're not using a Kinde SDK, you can manually call the Account API: ```js const response = await fetch("/account_api/v1/portal_link", { headers: { Authorization: `Bearer ${userAccessToken}` } }); const data = await response.json(); window.location = data.url; ``` Optional parameters: - `return_url` – where to redirect the user after exiting the portal. - `sub_nav` – specify the portal section to open (e.g., `organization_billing`, `profile`). ### Manage the self-serve portal link using the Kinde Management API This option is useful for server-side applications or if you're using Kinde billing features without Kinde Authentication. Make a request to the `POST /api/v1/portal/generate_url` endpoint using an M2M token. **Request body** ```js { "user_id": "kp_1234567890", // The ID of the user for whom you want to generate the portal link "organization_code": "org_123456789", // Optional: the organization code for which the portal link is generated "return_url": "https://yourapp.com/dashboard", // Optional: where to redirect the user after exiting the portal "sub_nav": "profile" // Optional: specify the portal section to open (e.g., `organization_billing`, `profile`) } ``` This will return a one-time portal link for the specified user. ## How the self-serve portal looks When the user clicks the link you've added to your app, the portal opens. The default design is shown below, and we are working on allowing you to style this yourself. The options a member sees depends on their role and what you have chosen to display. ![Self-serve portal in Kinde](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/4b3574c5-a499-4da5-e8d0-467d56255e00/public) You can also watch this short video showing how the portal works when a customer signs up for a plan using Kinde billing. <YoutubeVideo videoId="xxVwZW8OxIA" videoTitle="The customer billing experience with Kinde"/>

# Build - Set up options - Manage your code in Kinde

> Guide for managing git code in Kinde including repository connection, branch selection, code preview functionality, and workflow deployment management.

git sync, GitHub, code preview, workflow code, BYO code, repository management
git, workflows, code-management

To use workflows and other BYO code features, you need to sync your git-stored code to Kinde. Currently, Kinde only syncs with Github, but other providers will be added as the feature progresses. ## Change the git repo If you are connecting your repo to Kinde for the first time, see [Connect your workflows repo and branch](/workflows/getting-started/connect-repo-for-workflows/) 1. Go to **Settings > Git repo**. 2. Select **Change repo** 3. Follow the steps to add your repo, select the branch, etc. 4. If you are on an eligible plan, switch on the code preview option in **Advanced settings**. This lets you preview newly deployed code before making it live. 5. Select **Save**. ## Preview workflow code If you are on an eligible plan, we recommend enabling code preview for your workflow. This lets you [test deployed code](/workflows/testing/preview-workflows/) before you make it live for customers. 1. Go to **Settings > Git repo**. 2. Select the **Enable preview mode** option. 5. Select **Save**. <Aside type="warning"> If the preview mode option is switched off, your code will be pushed live automatcially each time you sync. </Aside>

# Build - Tokens - Access tokens

> Comprehensive guide to Kinde access tokens including standard JWT claims, Kinde-specific claims like organization codes and feature flags, and token behavior during refresh operations.

access tokens, JWT, OAuth 2.0, token claims, feature flags, permissions, organization claims
tokens, authentication, oauth

Access tokens are a secure way of authenticating users, and passing information about a user to to a system. ## Access token standard claims - **Token Type** - indicates the type of access token being used. For example, `Bearer` is a common token type used in OAuth 2.0. - **Expiration Time** - `exp` **-** Access tokens come with an expiration time (also known as expiry or lifetime) after which it is no longer valid. The timestamp is usually represented in **seconds** and can be calculated using the [Epoch](https://www.epochconverter.com/) timestamp (UNIX) or other methods. More about [setting token expiry in Kinde](/build/tokens/configure-tokens/). - **Scopes** - `scp` - information about the scopes granted to the token holder. These scopes define what actions or resources the token can access. There can be multiple scope values, so the type of this claim is an `array`. - **Issuer -** the entity that issued the access token. This is often represented as the token's `iss` claim in JWT. Typically your kinde domain e.g. `https://<your_subdomain>.kinde.com` - **Subject** - subject of the token, i.e., the user or entity for which the token was issued. Represented as the token's `sub` claim in JWT. If this is an access token for a Kinde user this will be their ID e.g. `kp_xxxx` - **Audience** - intended recipient of the access token. Represented as the token's `aud` claim in JWT. There can be multiple audience values, so the type of this claim is an `array`. - **Issued At** - timestamp of when the access token was issued. Represented as the token's `iat` claim in JWT. The timestamp is usually represented in **seconds** and can be calculated using the [Epoch](https://www.epochconverter.com/) timestamp (UNIX) or other methods. - **Token ID** - `jti` - identifier for the access token, useful for tracking and validation purposes. See [this definition](https://www.rfc-editor.org/rfc/rfc7519#section-4.1.7). - **Custom Claims** - Available using the [Kinde Properties feature](/properties/work-with-properties/properties-in-tokens/). ## Kinde additional claims - **Organization** - `org_code` claim for the organization they are accessing. Format is `org_xxxx`. - **Feature flags** - `feature_flags` claim. Access controls for what features the user can see and access. Format is: ```json "feature_flags": { "analytics": { "t": "b", "v": true }, "theme": { "t": "s", "v": "pink" } } ``` We use short codes for the various keys in the feature flags claim such as `t` and `v` to keep the token size down. `t` = `type` `v` = `value` `b` = `boolean` `i`= `integer` `s` = `strong` - **Permissions** - `permissions` claim controls for what the user can do in an app. This is an array. For example: ```json "permissions": [ "create:competitions", "delete:competitions", "view:stats", "invite:users", "view:profile ] ``` - **External provider ID** - The ID you use to identify the organization the user is authorized against - (MS Entra ID authentication only) Claims starting with `ext_` indicate that user details have come from a third party enterprise auth provider like Microsoft. For example: ```jsx "ext_groups": [ "group1", "group2 ], "ext_attributes": { "jobTitle": "engineer", "mail": "engineer@kinde.com", "preferredLanguage": "en", } ``` ## Example access token ```jsx { "aud": [ "myapp:prod-api ], "azp": "dee7f3c57b3c47e8b96edde2c7ecab7d", "exp": 1693371599, "feature_flags": { "analytics": { "t": "b", "v": true }, "theme": { "t": "s", "v": "pink" } }, "iat": 1693285199, "iss": "https://<your_subdomain>.kinde.com", "jti": "fbb6bc62-x64e-4256-8ea4-8fb9a645b123", "org_code": "org_xxxxxxxxx", "permissions": [ "create:competitions", "delete:competitions", "view:stats", "invite:users", "view:profile ], "scp": [ "openid", "profile", "email", "offline ], "sub": "kp:_xxxxxxxxx" // your user id } ``` ## Behaviour of Access Tokens on refresh When you use the `refresh_token` grant to refresh an access token, Kinde will return an existing access token if that existing access token is not expired. You will get a completely new access token if one (or more) of the following conditions are met: - You revoke your existing access token - Your user has signed out of their session, and your application has called the logout function in Kinde - Your existing access token has expired.

# Build - Tokens - ID tokens

> Complete guide to Kinde ID tokens including standard OpenID Connect claims, Kinde-specific claims, and troubleshooting missing claims with scope configuration.

ID tokens, OpenID Connect, user identity, token claims, authentication, user profile
tokens, authentication, oidc

During authentication, ID tokens carry information about authenticated users securely to your application. ## ID token standard claims - **At hash** - `at_hash` ensures the integrity of the claim made in the access token. - **Audience** - intended recipient of the token. Represented as the token's `aud` claim. This could be your kinde domain or app URI, e.g. `https://<your_subdomain>.kinde.com` - **Authentication time** - `auth_time` indicates the time when the user was authenticated. It's useful for scenarios where certain actions are allowed only if the user has recently authenticated. - **Authorized party** - an `azp` claim specifies the client ID of the party to which the ID Token was originally issued. - **Email** - the `email` associated with the user’s profile - **Expiration Time** - The `exp` claim specifies the timestamp when the ID token expires and should no longer be considered valid. It helps prevent the token from being used indefinitely. More about [setting token expiry in Kinde](/build/tokens/configure-tokens/). - **Issued At** - The `iat` claim indicates the timestamp when the ID token was issued. It can be used to determine the token's age and to mitigate replay attacks. - **Issuer** - The `iss` claim specifies the issuer of the ID token, usually the URL of the authorization server or identity provider. It's used to verify the token's authenticity. - **Picture URL** - the `picture` claim contains the location reference of the avatar picture of the user, if there is one. - **Subject -** The `sub` claim is a unique identifier for the authenticated user within the context of the issuing authentication server. In Kinde, this is the user’s ID. - **Token ID** - the `jti` claim is the unique identifier of the ID token - **Updated at** - the `updated_at` claim specifies the issuer of the ID token, usually the URL of the authorization server or identity provider. It's used to verify the token's authenticity. - **User last name** - the `family_name` claim contains the user’s last name - **User first name** - the `given_name` claim contains the user’s first name - **User full name** - `name` contains the first name and last name of the user ## Kinde additional claims - **Social identity** - Details from the user’s third-party profile, such as handle, username, and ID. - **Organizations** - The `org_codes` claim contains an array of IDs for the Kinde organizations that the user belongs to. ## Example ID token ```jsx { "at_hash": "VZ6cU0Ay0RKB5EosbWuTCQ", "aud": [ "https://<your_subdomain>.kinde.com ], "auth_time": 1692361334, "azp": "dee7f3c57b3c47e8b96edde2c7ecab7d", "email": "jane.smith@gmail.com", "exp": 1693288799, "family_name": "Smith", "given_name": "Jane", "iat": 1693285199, "iss": "https://<your_subdomain>.kinde.com", "jti": "fcxf6xd3-8c75-402x-a4cb-1659fb8c555d", "name": "Jane Smith", "org_codes": [ "org_xxxxxxxxxxx ], "picture": "https://lh3.googleusercontent.com/a/google-url", "provided_id": "<user_id_in_your_system>", "sub": "kp_xxxxxxxxxxxxxxxxxxxx", "updated_at": 1692009540 } ``` ## Can't find a claim in the token? Missing token claims are usually caused by missing scope requests in your app. If you are not using an SDK, you need to manually add scopes (such as `profile`, `email`, `openid`) so that the token you receive from Kinde includes the right claims. Review this document if you are [not using an SDK](/developer-tools/about/using-kinde-without-an-sdk/).

# Build - Tokens - Configure token and session expiry

> Comprehensive guide for configuring token and session expiry times including security best practices, token lifetime management, and risk mitigation strategies for different token types.

token expiry, session timeout, token lifetime, security, refresh tokens, access tokens, ID tokens
tokens, security, configuration

Tokens are an essential part of keeping your application secure. They enable the continued verification of users and applications (including APIs), and are a mechanism for detecting unauthorized intruders. Tokens need to be updated and refreshed to remain secure, which is why you need to set how long a token lasts, for each token type. ## Defining token lifetimes You can define the lifetime (expiry time) of ID tokens, access tokens, refresh tokens, and SSO session expiry tokens. Expiry and timeouts are usually defined in seconds - where 3,600 seconds is one hour and 86,400 seconds is one day. Tokens and sessions need to be configured per application. - **ID Tokens**: Contain identity information about a user. These do not need to last long as identity info is only needed at the moment of authentication, and is unrelated to session lifetimes. - **Access tokens**: Contain access permissions for a user during authentication. These are the most vulnerable token for attacks, and we do not recommend extending the access token lifetime beyond 1 day. - **Refresh tokens**: Are issued at the same time as an access token, and extend a user's session without them having to reauthenticate. If you want a user to stay authenticated without having to sign in daily or more frequently - set a high lifetime for refresh tokens. - **Session inactivity timeout**: A user can be requested to re-authenticate if they do not sustain activity in the current session. We recommend setting a fairly short limit for inactivity - e.g. up to one day. If you extend the session inactivity timeout, a user's data may become vulnerable, for example if they sign in on a public device and forget to sign out. Token and session expiry should be approached with priority for system and user security. The aim is to reduce risks such as: - Token theft through man-in-the-middle attacks - Unauthorized access through compromised refresh tokens - Session hijacking on shared or public devices - Data exposure through prolonged inactive sessions ## **Set token lifetimes** 1. Go to **Settings** **> Environment > Applications.** 2. Select **View details** on the application tile. 3. Select **Tokens** in the side menu. 4. For each token type, set the expiry time in seconds. 3,600 seconds is one hour; 86,400 seconds is one day. 5. Select **Save**. ## Token security Tokens can be vulnerable to security breaches. Access tokens in particular contain sensitive information, and these tokens can be used to access systems. Refresh tokens can be used to reduce some of this risk as they can be used to get new access tokens. However, refresh tokens are also a security risk for the same reason they are useful. To mitigate risk, we recommend using Automatic Reuse Detection and Refresh Token Rotation. You can revoke access tokens and refresh tokens via the Kinde Management API. [Search the Kinde API docs](/kinde-apis/management/).

# Build - Tokens - Using OAuth scopes

> Guide to using OAuth 2.0 scopes in Kinde including supported scopes, authorization flows, and implementation guidance for different application types.

OAuth scopes, authorization, openid, email, profile, offline, PKCE
tokens, oauth, scopes

In Kinde, OAuth 2.0 scopes are used to request access to the protected information we store on behalf of your users. The OAuth protocol helps ensure only authorized access to this information. ## Kinde-supported OAuth scopes The following scopes can be requested from Kinde. `openid` - requests an ID token which contains information about the user `email` - requests a user's email `profile` - requests profile details as part of ID token, e.g. name, family name, given name, picture (avatar) `offline` - request to act on behalf of the user if they're offline ## OAuth flows How you request scopes depends on your tech framework and the OAuth 2.0 flow you’re using for your application type. You can use the following flows to request scopes in Kinde. ### Authorization Code flow `authorization_code` Recommended for regular web applications rendered on the server. ### Authorization Code flow with Proof Key for Code Exchange (PKCE) `authorization_code_flow_pkce` Kinde supports the PKCE extension, in which case the `code_challenge` and `code_challenge_method` parameters are also required. This is recommended for mobile apps and single page applications (SPAs). ### Implicit flow (not supported) Before PKCE (see above) this was the method used by applications that were unable to store secrets securely. This flow has security implications and Kinde does not support it for this reason. ## Guidance on requesting scopes Our SDK documents contain guidance on how to connect and make requests in your chosen framework or language. See [all our SDKs](/developer-tools/about/our-sdks/). You can also access our [starter kits on GitHub](https://github.com/kinde-starter-kits) and our [Kinde Management API library](/kinde-apis/management/).

# Build - Tokens - Refresh tokens

> Understand how refresh tokens work, including token rotation, offline scope implementation, security best practices, and SDK integration for maintaining user sessions.

refresh tokens, token rotation, offline scope, session management, token security, auto-update
tokens, authentication, oauth

Refresh tokens are used to request new access tokens. Access tokens are issued when a user makes an authentication request or a call is made to an API. An access token gives permission to enter and interact with a system. ## How refresh tokens work Access tokens usually have an intentionally short lifetime. However, rather than having a user need to re-authenticate frequently, a refresh token can be used to request a new access token. Refresh tokens operate without user intervention, extending session access without the same security risk as requesting a new access token. Refresh tokens can be used a finite amount of times before re-authentication is required. ## How to get a refresh token To get a refresh token, you need to include the `offline` scope when you initiate an authentication request through the `https://<your_subdomain>.kinde.com/oauth2/auth` endpoint. You also need to initiate Offline Access in your API. Details on how to do this is provided in [our SDKs](/developer-tools/about/our-sdks/), but here’s how to do it yourself. Below is an example using the Authorization Code grant, with the `offline` scope being one of the scopes passed to the authentication request. ```jsx curl -X POST -H "Content-Type: application/x-www-form-urlencoded" \ -d "response_type=code&client_id=your_client_id&redirect_uri=your_redirect_uri&scope=offline%20email%20openid%20profile&grant_type=authorization_code" \ https://<yoursubdomain>.kinde.com/oauth2/auth ``` Refresh tokens are stored in sessions. When a session needs to be refreshed (for example, a pre-defined time has passed), the app uses the refresh token on the backend to obtain a new access token, using the `https://<your_subdomain>.kinde.com/oauth2/token` endpoint with `grantType=refresh_token`. **Example of a refresh token response** ```jsx { "access_token": "hju76F...P8rTh63Ute", "refresh_token": "VOe264go...oLp2dC6", "token_type": "Bearer" } ``` ## Refresh token rotation Kinde always rotates refresh tokens. When you use an existing refresh token to request a new access token, a new refresh token is also generated and provided with your new access token. The old refresh token becomes immediately invalid. ## Auto-update of refresh tokens Kinde allows a small overlap period when both a previous and new refresh token is valid. This is to account for retries and bad network connections. You can [set the lifetime of a refresh token](/build/tokens/configure-tokens/) in Kinde. It needs to be longer than the life of an access token. ## Refresh tokens when you are not using an SDK You should store the refresh token you get with your initial `/token` request. Otherwise, your user will need to go through the sign in process again, to get a new access token. ## Refresh tokens when you are using a front-end SDK If you’re using a front-end SDK like [JavaScript](/developer-tools/sdks/frontend/javascript-sdk/) or [React](/developer-tools/sdks/frontend/react-sdk/), the `getToken` function stores an in-memory cache of the access token, which it returns by default. If the token is about to expire it will use a refresh token to get a new access token from Kinde silently in the background so additional network requests to Kinde are only made when absolutely necessary. ## Token security recommendations Token security can be approached in a number of ways. We recommend at least covering the basics of: - keeping the number of refresh tokens within a manageable limit to keep credentials safe and secure. - storing refresh tokens securely in the back-end of your application because they essentially allow a user to remain authenticated forever. - employing refresh token rotation and automatic reuse detection for added security.

# Build - Tokens - Token customization

> Learn how to customize Kinde tokens by adding custom claims, properties, and third-party integrations like Hasura for enhanced token functionality.

token customization, custom claims, properties, additional claims, third-party integration, Hasura
tokens, customization, properties

If you want to include additional information in tokens, you can customize access tokens, M2M tokens, and ID tokens using preset custom claims and [properties](/properties/about-properties/). If you need Kinde token formats to be third-party friendly, you can also enable mapping for those services, e.g. Hasura. Token customization is a step toward enabling custom claims, but it is not the same thing. ## Add claims to a token 1. In Kinde, go to **Settings > Applications** and select **Details** on your application. 2. Select **Tokens**, then scroll to the **Token customization** section. 3. On the relevant token type card, select **Customize**. A window appears where you can select scopes and properties. ![Customize access token window with selection of scopes and properties](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/8b20408b-5494-4da9-c59c-01be32accf00/public) 4. Select the available **Additional claims** and **Properties** you want to include in the token. 5. Select **Save**. ## Additional claims for tokens Apart from your own [custom properties](/properties/work-with-properties/properties-in-tokens/), you can add some out of the box additional claims to tokens. ### Add claims to access tokens You can: - add an organization name to an access token (`org_name`) - add roles to an access token (`roles`) - add an email to an access token (`email`) - add an external organization ID to an access token (`external_organization_id`) ### Add claims to ID tokens You can: - Add a user's social identity to an ID token - Add a user's organizations to an ID token ### Add claims to M2M tokens You can [add feature flags to an M2M token](/machine-to-machine-applications/m2m-application-setup/add-feature-flags-to-m2m-applications/). ## Add properties to tokens To further customize tokens you can add information using [properties](/properties/about-properties/). Properties are custom fields and information that you can attach to your users, organizations, and applications in order to collect the data you want. For example, if you ask your customers to complete a form, you can map the answers to their user record. Another example could be you want to collect a delivery address for an organization, or include unique identifiers for M2M apps. To make a property available in a token, you need to [make the property public](/properties/work-with-properties/manage-properties/), and then customize the token following the procedure above, to add a property. The value will appear in the token under a `application_properties` claim: ```json { "application_properties": { "region": { "v": "eu" }, "tier": { "v": "pro" } } } ``` The `v` is a shortcode for the value of the property. Only the properties you explicitly toggle on will be included. ## Token integration for third parties Currently, we only support formatting for Hasura. 1. In Kinde, go to **Settings > Applications** and select **Details** on your application. 2. Select **Tokens.** 3. Scroll to the **Token integrations** section and switch the toggle on for the platform you use. 4. Select **Save**.

# Build - Tokens - OAuth 2.0 access token validation and error codes

> Reference guide for OAuth 2.0 access token validation including successful response formats and common error codes with troubleshooting information.

OAuth 2.0, token validation, error codes, invalid_request, invalid_client, invalid_grant, unauthorized_client
tokens, oauth, error-handling

OAuth 2.0 authentication involves a request for an access token, and a response to the request. Here’s some typical successful and unsuccessful (error) responses. ## Successful responses - `access_token` (required) – The access token string as issued by the authorization server. - `token_type` (required) – The type of token this is, typically just the string “Bearer”. - `expires_in` (recommended) – If the access token expires, the server should reply with the duration of time the access token is granted for. - `refresh_token` (optional) – If the access token will expire, then it is useful to return a refresh token which applications can use to obtain another access token. - `scope` (optional) – If the scope the user granted is identical to the scope the app requested, this parameter is optional. If the granted scope is different from the requested scope, such as if the user modified the scope, then this parameter is required. ## Unsuccessful responses - `invalid_request` – The request is missing a parameter so the server can’t proceed with the request. This may also be returned if the request includes an unsupported parameter or repeats a parameter. - `invalid_client` – Client authentication failed, such as if the request contains an invalid client ID or secret. Send an HTTP 401 response in this case. - `invalid_grant` – The authorization code (or user’s password for the password grant type) is invalid or expired. This is also the error you would return if the redirect URL given in the authorization grant does not match the URL provided in this access token request. - `invalid_scope` – For access token requests that include a scope (password or client_credentials grants), this error indicates an invalid scope value in the request. - `unauthorized_client` – The client is not authorized to use the requested grant type. For example, if you restrict which applications can use the Implicit grant, you would return this error for the other apps. - `unsupported_grant_type` – If a grant type is requested that the authorization server doesn’t recognize, use this code. Note that unknown grant types also use this specific error code rather than using the `invalid_request` above.

# Build - Tokens - Verifying JSON Web Tokens

> Learn how to verify JSON Web Tokens (JWTs) for secure authentication, including signing algorithms, validation methods, and security best practices for protecting your backend APIs.

JWT verification, token validation, RSA signing, JSON Web Key, issuer claims, audience claims, state verification
tokens, security, jwt

Kinde uses JSON Web Tokens (JWT) for secure data transmission, authentication, and authorization. JWT verification ensures that only authorized users and apps can access your regular web, native, or single-page applications, by checking that tokens are valid, and have not been tampered with, misused, or are expired. The validation process checks the structure, claims, and signature of the JWT. If you are [setting up with Kinde without an SDK](/developer-tools/about/using-kinde-without-an-sdk/), or if you are using a mobile or front-end SDK and want to protect your back-end APIs, this topic is relevant for you. ## **How the JWTs work** ### **Signing algorithm** The JWT signature is generated using a ’signing algorithm’. Kinde supports: - RSA with 2048-bit key - SHA-256 hashing algorithm - RSA signature with SHA-256 ### **Hash values** When validating a JWT, generally, the current hash value and the original hash value are parsed, or decoded, then compared to verify the token signature is authentic. This is part of token encryption. ## **Methods to verify JWTs** If you are not using one of our SDKs, you can parse and validate a JWT by: - Using any existing middleware for your web framework. - Choosing a third-party library, for example the OpenID Foundation has [a list of libraries for working with JWT tokens](https://openid.net/developers/jwt/) See also [Kinde’s supported languages and frameworks](/developer-tools/about/our-sdks/). ## **Asymmetric signing algorithm (RSA)** Verify that the token is signed with `RS256` algorithm (see the `alg` header in the token response). Kinde only supports signing tokens with the asymmetric signing algorithm (RSA). We don’t support `HMAC` signing by design. ## **JSON Web Key** It’s likely you will be using a library to validate your JWTs and they will require the url for your public JSON Web Key (also known as a `jwks` file). The file can be found here: `https://<your_subdomain>.kinde.com/.well-known/jwks` ## **Included in the Kinde access token** ### **Issuer (iss) claim** Verify the `iss` claim, that the token was issued by your Kinde environment. Each environment has a unique `iss` claim. ### **Audience (aud) claims** If you are authenticating an API, verify `aud` claims in the token. We support multiple `aud` claims which are passed in the token as a JSON array. ### **State versus stateless** For increased security in a back-end application, verify the `state` that you provided in the callback. Deny all requests with a `state` that your application does not recognize. You can use `state` for front-end applications, but it does not increase security. ## The getToken function The `getToken` function stores an in-memory cache of the access token, which it returns by default. If the token is about to expire it will use a refresh token to get a new access token from Kinde silently in the background so additional network requests to Kinde are only made when absolutely necessary. To keep tokens secure, they should only be stored in the back end of your application. Tokens become unsecured if stored in a browser’s local storage, indexed database, or session storage.

# Contribute - Index.mdx - Contribution guide

> Comprehensive contribution guide for Kinde documentation including writing guidelines, MDX syntax, component usage, GitHub workflow, and community contribution standards.

contribution guide, documentation, GitHub, pull request, frontmatter, MDX syntax, code samples, components
contribute, documentation, community

We love that you want to help us with our docs in GitHub, so here’s our guidelines to help make this easier for you. The first thing to know is that Kinde has editorial discretion over all docs and we will review and edit community contributions to keep content in line with our styles and standards. Don’t let this stop you from raising issues or making suggestions - we need your expertise. We just don’t expect writing perfection, so we’ve got you covered. ## What to contribute Our docs describe what Kinde does, how our platform works, the core functions, configurations, features, settings, etc. We’re not trying to cover every use case, just the most common. Please raise an issue or suggestion if: - Something is incorrect and needs to be fixed - Something is under-explained and needs improvement - You find a gap in the docs or missing information What we are not looking for: - Product suggestions or feature requests - please log these [here](https://kinde-21631392.hs-sites.com/en-au/feature-request/) - Workarounds or solutions from third-parties - Non-specific feedback such as ‘bad doc, please improve’. ## Ways to contribute ### Raise an issue Let us know if a document is wrong or needs fixing. Be as specific as you can so we can address it quickly. An example is where a code snippet is incorrect, or a procedure is no longer working. For issues, provide: - Clear descriptive titles - Links to relevant pages/files - Explanations as to why (or *for whom*) this is a problem - Optional: proposed solutions ### Suggest a single page edit Suggest an improvement or change to a document by selecting **Edit this page** in your browser on the document. This will take you to GitHub where you can edit the content of the file and then create a pull request. As part of creating the pull request, make sure you explain why the changes are needed, who they help, and how. ### Raise a PR for bigger contributions We prefer to write the big stuff ourselves, so we encourage people to raise issues about gaps in our content and provide suggestions that way. However, if you want to create a new topic or edit multiple files, go to GitHub to create a branch or fork and raise a PR. There’s no guarantee your pages will be approved and merged, but we will review and get in touch to discuss and definitely consider new content for inclusion. ## Contributing to SDK documentation Our SDK docs are always evolving and we welcome suggestions and contributions to make them better. SDK docs are stored with our other docs (see the file structure below). The SDKs themselves are stored in separate [Kinde repos](https://github.com/kinde-oss/). ## General document structure Most Kinde docs follow a similar structure: - What is the topic about and who is it for (1-2 sentences) - Conceptual explanations with appropriate headings - Before you begin section for prerequisites - Procedure with steps - How to do x. - Supplementary or adjacent information - Related topics ## How we write Our documents are used by developers of varying experience, people from different language backgrounds, and users who are in a hurry to get the answer they need. Our guiding principle is to always use clear, simple language. Our docs are not translated currently, but they will be soon. Plain English makes translation easier. ### Writing principles - Use direct, clear sentences and short paragraphs - Use simple, plain vocabulary and phrases - Minimize jargon, idioms, and internet shorthand - Don’t make assumptions about what readers already know - Explain abbreviations and acronyms in full ### Content principles - Use short, descriptive headings that include keywords, so people can scan to find what they need. E.g. ‘Update redirect URLs’, instead of ‘Edit the .env file’. - Provide clear, step-by-step instructions that any level of user could follow easily. - Include conceptual explanations and use cases for complex topics. - Create tidy code snippets or examples that will help users get it right. ### Tone and voice - Take a friendly but casual tone, like you are explaining things to a peer or colleague. - Don’t waffle on too much with preamble, get to the point. - Speak with clarity and confidence. You know what you’re talking about. ## How to contribute to the Kinde docs ### Edit an existing article 1. Navigate to the doc in your browser and select **Edit page** at the bottom. GitHub opens. 2. Make the required changes and then **Commit**. 3. Provide clear and direct notes about your changes. 4. Submit a PR. [See below](/contribute/#raise-a-pr). ### Create a new document 1. Navigate to the folder of the section and subsection the topic will go. 2. Select **New file**. 3. Type the name of the file in the blank field and add .mdx. 4. Add the required frontmatter of the topic (`title` and `page_id`). See the [Docs syntax](/contribute/#docs-syntax) topic below. 5. Add content and commit. Explain the reason for the topic as part of the PR. ### File structure in GitHub Our documentation articles are written in `mdx` and are structured as follows: <FileTree> - src - content - docs - topic group - subtopic group - article-1.mdx - article-2.mdx </FileTree> ### Raise a PR When you're ready to raise a PR, use the following naming conventions: `feat:[description]` for new topics or substantial changes `fix:[description]` for corrections and minor changes This helps us recognize and prioritize requests. ## Docs syntax This section describes some of our styles, elements, and conventions for docs content. ### Frontmatter The header/metadata part of the content helps the article appearing correctly in docs. It is also important for external AI tools and search optimization. Copy the whole example below into the top of any new topic. And complete the required sections. Complete optional sections if you want. ```md title="src/content/docs/developer-tools/about/our-sdks.mdx --- page_id: title: description: "description" sidebar: order: relatedArticles: - - app_context: - m: s: topics: - - - sdk: [] languages: [] audience: complexity: keywords: - - - - - updated: yyyy-mm-dd featured: deprecated: ai_summary: --- ``` #### Required Fields **`title`** (string) - You must provide a title for every page. This will be displayed at the top of the page, in browser tabs, and in page metadata. **`page_id`** (uuid) - This is the internal unique `id` for the article. This will be used when referencing other articles within the `relatedArticles` frontmatter. You can use our [online UUID generator tool](https://kinde.com/tools/online-uuid-generator/) to use as the `page_id`. **`description`** (string) - A brief description of the article content, used for SEO and metadata. **`keywords`** (array) - Array of keywords for search optimization. #### Optional Fields **`order`** (number) - Control the order of this article when sorting an autogenerated group of links under a specific topic or subtopic. Lower numbers are displayed higher up in the link group. Providing the `order` frontmatter is completely optional and will be treated as a hint for us to where to place the file. We may update the article's `order` upon further review. **`topics`** (array) - Array of topic tags that help categorize the content. **`sdk`** (array) - Array of SDKs that are relevant to this article. Use `[]` for no SDKs or `null` for not applicable. **`languages`** (array) - Array of programming languages covered in the article. **`ai-summary`** (string) - A summary of the article content for AI processing and search. Can be same as description. **`relatedArticles`** (array) - Array of page IDs for related articles that should be displayed at the bottom of the page. ### Code samples The code snippets in our docs are powered by [astro-expressive-code](https://github.com/expressive-code/). Here are some examples in how you can use them: #### Regular syntax highlighting For code highlighting, you will need a language identifier. (See full list of [supported languages](https://github.com/shikijs/textmate-grammars-themes/blob/main/packages/tm-grammars/README.md) on GitHub) e.g. `js` for JavaScript: ````md title="example.mdx" ins=/^([^a-z]{3}.*)/ ```js console.log("This code is syntax highlighted!"); ``` ```` Will render: ```js console.log("This code is syntax highlighted!"); ``` #### Frames If you use a language identifier that is typically used for terminal sessions or shell scripts, a terminal frame will be added to the rendered output. ```` ```bash nano script.sh ``` ```` Will render: ```bash nano script.sh ``` If you add a value for `title`, then you get a title bar: ```` ```powershell title="PowerShell terminal example Write-Output "This one has a title! ``` ```` Result: ```powershell title="PowerShell terminal example Write-Output "This one has a title! ``` If the language identifier is not a terminal session or shell script one, providing the `title` attribute will render the frame with the file name, for example. ```` ```tsx title="src/app/page.tsx import { RegisterLink, LoginLink } from "@kinde-oss/kinde-auth-nextjs/components"; ``` ```` Output: ```tsx title="src/app/page.tsx import {RegisterLink, LoginLink} from "@kinde-oss/kinde-auth-nextjs/components"; ``` This can also been achieved by adding a comment with the file name at the top of your file. ````text frame="none" ```tsx // src/app/page.tsx import { RegisterLink, LoginLink } from "@kinde-oss/kinde-auth-nextjs/components ``` ```` Output: ```tsx // src/app/page.tsx import {RegisterLink, LoginLink} from "@kinde-oss/kinde-auth-nextjs/components"; ``` <Divider /> ### Images Use images sparingly, to support complex or detailed procedures. For accessibility, do not use images instead of text. Always include alt-text. If you need an image or screen shot in your article, you’ll have to: - Create a folder within `src/assets/images` with the same slug as your article (the article’s `.mdx` file name) - The image must be at least `1440px` wide - Include `alt text` in the markdown. Images are optimized before publishing, and have styles and zoom functionality added. For example, this article lives under `src/docs/contribute/index.mdx` - In this case, we would create a `contribute` folder under `src/assets/images` and save the image there. <FileTree> - src - assets - images - contribute - penguin.jpg </FileTree> To add an image to an article, just simply use the `markdown` syntax like so: ```md title="src/docs/contribute/index.mdx ![An image of a penguin](@assets/images/contribute/penguin.jpg) ``` The image will be rendered with some padding and will have the **click to zoom** functionality added to it. ![An image of a penguin](@assets/images/contribute/penguin.jpg) ## Components <Aside> We are slowly building a library of components to be used in our articles. You can see below a list of the ones ready to use — this list is constantly being updated. </Aside> ### `PackageManagers` This component combines multiple useful commands from different package managers in the `node` ecosystem. It generates commands for `npm`, `pnpm` and `yarn`. #### <span class="text-lg font-bold">`pkg` (required)</span> `string` — The package to be installed. For example: `@kinde-oss/kinde-auth-nextjs` #### <span class="text-lg font-bold">`type` (optional)</span> `add` `create` `exec` `run` `remove` default: `add` #### Example ```mdx <PackageManagers pkg="@kinde-oss/kinde-auth-nextjs" /> ``` #### Result <PackageManagers pkg="@kinde-oss/kinde-auth-nextjs" /> <Divider /> ### `Aside` This component is useful for displaying secondary information alongside a page’s main content. #### <span class="text-lg font-bold">`type` (optional)</span> `info` `warning` `danger` `upgrade` default: `info` #### <span class="text-lg font-bold">`title` (optional)</span> `string` default: `null` #### Example with title ```mdx <Aside type="warning" title="Attention"> This is the message </Aside> ``` #### Result <Aside type="warning" title="Attention"> This is the message </Aside> #### Example without a title and a type (defaults to the `info` variant) ```mdx <Aside> This is the message </Aside> ``` #### Result <Aside> This is the message </Aside> <Divider /> ### `FileTree` Use the `<FileTree>` component to display the structure of a directory with file icons and collapsible sub-directories. #### Example ```mdx <FileTree> - .env.local - src - app - page.tsx </FileTree> ``` #### Result <FileTree> - src - app - layout.tsx - page.tsx - dashboard - page.tsx - next.config.ts - .env.local </FileTree> <Divider /> ### `YoutubeVideo` This will embed a YouTube video using [`lite-youtube`](https://github.com/justinribeiro/lite-youtube) behind the scenes. #### <span class="text-lg font-bold">`videoId` (required)</span> The YouTube video `id`. `string` #### <span class="text-lg font-bold">`videoTitle` (optional)</span> The video title. `string` default: `"Video"` #### Example ```mdx <YoutubeVideo videoId="ybmHcAVBnec" /> ``` #### Result <YoutubeVideo videoId="ybmHcAVBnec" /> <Divider /> ### `Tabs` To create a tabbed interface use the `<Tabs>` and `<TabItem>` components. Tabs are useful for grouping equivalent information where a user only needs to see one of several options. #### <span class="text-lg font-bold">`<Tabs>: syncKey` (optional)</span> A key used to keep multiple tab groups synchronized across multiple pages. `string` #### <span class="text-lg font-bold">`<TabItem>: label` (required)</span> A tab item must include a label attribute set to the text that will be displayed in the tab. `string` #### Example ```text frame="none" <Tabs> <TabItem label="Stars">Sirius, Vega, Betelgeuse</TabItem> <TabItem label="Moons">Io, Europa, Ganymede</TabItem> </Tabs> ``` #### Result <Tabs> <TabItem label="Stars">Sirius, Vega, Betelgeuse</TabItem> <TabItem label="Moons">Io, Europa, Ganymede</TabItem> </Tabs> #### Example with code <Aside type="warning"> Depending on your `mdx` formatter, you may need to add extra space between jsx tags and the `TabItem` content. </Aside> ````text frame="none" <Tabs> <TabItem label="JavaScript"> ```text console.log("hello world!"); ``` </TabItem> <TabItem label="PHP"> ```php echo "hello world"; ``` </TabItem> </Tabs> ```` #### Result <Tabs> <TabItem label="JavaScript"> ```js console.log("hello world!"); ``` </TabItem> <TabItem label="PHP"> ```php echo "hello world"; ``` </TabItem> </Tabs>

# Design - Brand - Apply unique branding for an organization

> Comprehensive guide for applying unique branding to organizations including logo, favicon, theme, and color customization with API integration and reset functionality.

organization branding, multi-tenancy, logo, favicon, brand colors, theme, API, reset branding
design, brand, organizations

If your business model supports multi-tenancy or multiple user groups and you use [organizations](/build/organizations/multi-tenancy-using-organizations/) in Kinde, you can apply brand overrides to modify the pages in each organization. This means that when a user signs up or signs in to an organization, they have the brand experience associated with that organization, through page logo and colours. You can change the background, button, and text colours, as well as the favicon and logo for: - Sign up and sign in pages - Request access and subscription pages - Emails <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/c5a7fcf3-205b-4cf1-f199-d9da7aa11000/public" alt="Custom sign in screens in Kinde" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" /> ## To add or change a logo for an organization Logos must be under 1MB, and they are resized to have a maximum width or height of 120 pixels based on the aspect ratio. SVG works best as it displays well on any screen, but PNG and other formats are accepted. 1. In Kinde, go to **Organizations**. 2. In the list, select the organization you want to view. The organization **Details** page opens. 3. Select **Brand** in the left menu. The **Brand** page for the organization opens. 4. Scroll to the **Logo** section: 1. To remove an existing logo, select the trashcan icon. 2. To add a new or replace the logo, select **Upload image**. 5. Select **Preview** to see what your changes look like. 6. Select **Back** to exit the preview. 7. Select **Save** to apply the changes. 8. Test the change in your test or production environments. <Aside title="Logo fallback behavior"> If an organization logo is not available, you can set fallback behavior to show the org name or the global business logo instead. See [set global brand](/design/brand/global-brand-defaults/). </Aside> ## To add a logo via the Kinde Management API Use this endpoint `POST {{domain}}/api/v1/organizations/{org_code}/logos/light` For different logo variations, adjust the type path parameter (e.g., `light`, `dark`). In the Header, set a boundary value, e.g. `content-type: multipart/form-data; boundary="value"` Use `form-data` in the body to upload a valid PNG, JPEG, GIF, SVG, AVIF or WEBP image smaller than 1MB. You can also delete logos via the API. [See the API docs](https://docs.kinde.com/kinde-apis/management/#tag/organizations/post/api/v1/organizations/{org_code}/logos/{type}). ## To add or change a favicon for an organization Favicons are the tiny image shown on the tab of a browser. Image files must be a multiple of 48px square (e.g. 48x48, 96x96). <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/310d10e2-ab73-4aec-9872-7352aca57200/public" alt="" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" /> 1. In Kinde, go to **Organizations**. 2. In the list, select the organization you want to view. The organization **Details** page opens. 3. Select **Brand** in the left menu. The **Brand** page for the organization opens. 4. In the **Favicon** section, select **Upload image** to add or replace a favicon. 1. Upload an **SVG** that will work in most browsers. 2. Add a **Fallback** image in PNG for other browsers. 5. To preview a favicon, you’ll need to save it and check in your test or live environment. 6. To remove a favicon, select the trashcan icon near the image. 7. Select **Save** to apply the changes. ## Add an avatar for an organization If your organizations manage their own profile or payment details via a [Kinde self-serve portal](/build/self-service-portal/self-serve-portal-for-orgs/), you can upload an avatar to personalize the experience for organization members. An avatar is usually a simple logo. Avatars must be in SVG format, and be smaller than 5kb. They appears as a 36px square in the interface. 1. In Kinde, open the organization details and go to **Brand** in the menu. 2. In the **Avatar** section, select **Upload image**. 3. Select **Save**. ## Set a light or dark theme 1. In Kinde, go to **Organizations**. 2. In the list, select the organization you want to view. The organization **Details** page opens. 3. Select **Brand** in the left menu. 4. Set the **Theme**: **Light**, **Dark**, or **User preference**. If you select user preference, make sure you choose a brand color scheme for both experiences. See below. 5. Select **Save**. ## Set brand colors for an organization 1. In Kinde, go to **Organizations**. 2. In the list, select the organization you want to view. The organization **Details** page opens. 3. Select **Brand** in the left menu. The **Brand** page for the organization opens. 4. Change the following elements to appear how you want: background, buttons, text color, link color, and button border radius. 5. Select **Preview** to see what your changes look like. 6. Select **Save** to apply the changes. ## Reset organization brand to match global styles If you want to revert to global styles for an organization, it is easy to reset. 1. In Kinde, go to **Organizations**. 2. In the list, select the organization you want to view. The organization **Details** page opens. 3. Select **Brand** in the left menu. The **Brand** page for the organization opens. 4. In the bottom section called **Admin actions**, select **Reset to default**. 5. Select **Save**. This removes logo, color schemes, etc.

# Design - Brand - Set global brand defaults

> Guide for setting global brand defaults including logo upload, favicon configuration, theme selection, and brand color customization for authentication pages.

global brand, logo, favicon, theme, brand colors, light theme, dark theme, user preference
design, brand, customization

When users sign up or sign in to your product, they land on pages generated by Kinde. You can update the look of these pages to match your brand. You also have the option to bring your own page design to the authentication experience. See - [Custom design with code](/design/customize-with-code/customize-with-css-html/) - [Custom sign-up and sign-in pages](/authenticate/custom-configurations/custom-authentication-pages/). ## Setting global brand elements You can choose to set a global theme for all pages, or else use global settings as a fallback for custom page designs. Use the following procedures to make design changes to suit your brand. ## Add your company logo Logos must be under 1MB, and they are resized to have a maximum width or height of 120 pixels based on the aspect ratio. SVG works best as it displays well on any screen, but PNG and other formats are accepted. 1. In Kinde, go to **Design > Global > Brand**. 2. In the **Logo** section, upload your company logo. Make sure images are less than 1MB, are PNG, JPEG, or GIF. 3. Scroll down to the bottom of the page and select the global logo fallback behavior. - Enable to use the global logo as a fallback default for organizations where the logo is not available. This means the end customer will see the organization logo, if not the global level logo, and failing that, the name of the organization. - Disable if you want the default behavior to be show the organization logo, then the organization name, and as a last option show the global logo. 4. Select **Save**. <Aside> The logo will be automatically linked to the [Redirect URL](/get-started/connect/callback-urls/) set for your business, or the [application homepage URL](/design/brand/link-to-homepage/) set up for each application. If you are using tracking, the URL will also reflect that the user clicked out of the sign up/sign in screen, so you can distinguish this action from successful sign ins. </Aside> ## Add favicons for web browsers Favicons are small icons that appear on browser tabs. To add them to Kinde, they must measure 48x48px (or multiples of, such as 96x96). ![image of browser favicons](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/f4cc6e0f-3f87-46af-f99d-7c4910602600/public) 1. In Kinde, go to **Design > Global > Brand**. 2. In the **Favicon** section: 1. Add one as SVG format (so it works in most browsers). 2. Add one as a **Fallback** PNG for other browsers, such as Safari. 3. Select **Save**. To change the favicon of an organization, see [Apply unique branding for an organization](/design/brand/apply-branding-for-an-organization/). ## Add an avatar for your business To personalize you Kinde experience, add an avatar for your business to display your logo or preferred image in the Kinde user interface. For example, an avatar appears on the home page in the bottom left where you can access business and profile controls. Avatars must be in SVG format, and be smaller than 5kb. They appears as a 36px square in the Kinde interface. 1. In Kinde, go to **Design > Global > Brand**. 2. In the **Avatar** section, select **Upload image**. 3. Select **Save**. ## Set a light or dark theme 1. In Kinde, go to **Design > Global > Brand**. 2. Set the **Theme**: **Light**, **Dark**, or **User preference**. If you select user preference, make sure you choose a brand color scheme for both experiences. See below. 3. Select **Save**. You can [change the light and dark theme settings for your organizations](/design/brand/apply-branding-for-an-organization/) as well. ## Set brand colors for page elements Your selections will be inherited across all pages and for all organizations, unless you set overrides. 1. In Kinde, go to **Design > Global > Brand**. 2. Select settings and colors for **Pages (backgrounds)**, **Cards**, **Buttons,** **Input fields**, and **Links**. Be sure to set a light and dark version of each if you want your brand colours to appear in both modes. 3. Select **Save**. 4. To preview pages, open the page using the side menu and select **Preview** in the top right. To set the brand color scheme of an organization, see [Apply unique branding for an organization](/design/brand/apply-branding-for-an-organization/).

# Design - Brand - Add homepage URL to the sign-in page

> Guide for adding homepage URL to sign-in pages so business logos link to application homepages and provide error recovery navigation.

homepage URL, sign-in page, application homepage, logo link, callback URLs, error handling
design, brand, applications

To link to your application’s homepage from your sign in page, you need to add a homepage URL to each of your applications. Once you do this: - Your business logo on the sign-in page will link to your application homepage - If a browser or other error occurs, we can provide a link to your user, to get them back to your application homepage ## Set the homepage URL for your applications 1. In Kinde, go to **Setting > Applications**. 2. Select **Configure** on the relevant application. 3. In the left menu, select **Authentication**. 4. Scroll to the **Callback URLs** section. 5. Add the **Application homepage URI**, e.g. `https://app.yourapp.com` 6. Select **Save**. 7. Repeat for each relevant application.

# Design - Brand - Remove Kinde branding from sign in pages

> Simple guide for removing Kinde branding from sign-in pages for paid plan users through business settings configuration.

remove branding, Kinde branding, sign in pages, paid plans, business details
design, brand, customization

<Aside type="upgrade"> Available on [paid Kinde plans](https://kinde.com/pricing/) </Aside> If you have a paid Kinde account, you can remove the Kinde branding from sign in pages. 1. In Kinde, go to **Settings > Business > Details.** 2. Switch off the **Show Kinde branding** switch. 3. Select **Save**.

# Design - Content customization - Customize email content

> Guide for customizing email content including sender details, logo configuration, OTP email customization, and multi-language support for authentication emails.

email customization, email sender, email logo, OTP email, passwordless auth, SMTP, business name
design, email, content-customization

If emails are part of your authentication processes for users - for example, users receive sign-in codes via email in a passwordless process - you can customize email details, with some limitations. ## **Change the email sender** **name** You can add your business or brand name so it appears as the sender of emails. 1. Go to **Settings > Email**. 2. Enter your business or brand name in the **Sender** name field. 3. Select **Save**. ## Change the email sender address If you want to change the email sender address, you add your own email provider’s SMTP details. See [Customize email sender](/get-started/connect/customize-email-sender/). ## **Change email logo** Emails inherit the logo you set as part of your [global brand](/design/brand/global-brand-defaults/). But you can also set a unique logo [for each organization](/design/brand/apply-branding-for-an-organization/) in your business. ## Change who verification emails are sent from _Only applies if you choose not to send emails from your own provider_ When Kinde sends an email on your behalf, it is sent from the ‘Business name’ listed in your Kinde business by default. For example: <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/aad2b06f-1a1d-4da0-8643-ef3709cb9c00/public" alt="" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" /> If you want emails to come from your app name instead (if it is different), then you can edit the business name in **Settings > Business > Details**, without it affecting your Kinde domain or other environment settings. ## Change the content of the one-time passcode (OTP) email (passwordless auth) You can change the content of the OTP email if you use a [custom email sender](/get-started/connect/customize-email-sender/) for sending OTP emails. Once this is set up, you can make content changes as follows. 1. In Kinde, go to **Design > Emails > Email content.** 2. Select the language you want to edit. Only [languages you have selected](/design/content-customization/set-language-for-pages/) in your business are available. 3. You can edit the subject line, body content, and disclaimer footer. Use the placeholders to personalize and define where the code appears. 4. When you have made your changes, select **Save**. The new email content will now be sent. ## Add sign-in code to the email subject line (passwordless auth) You can include the sign-in code in the subject line of OTP emails to make it visible for users in notifications. Note that it is less secure to do this, as the code can be seen by anyone when notifications are displayed openly on devices. 1. In Kinde, go to **Design > Emails > Email content.** 2. Select the language you want to edit. Only [languages you have selected](/design/content-customization/set-language-for-pages/) in your business are available. 3. In the subject line field, include the `${code}` placeholder. This is where the code will appear. E.g. Enter `${code}` for access. 4. Select **Save**.

# Design - Content customization - How content is managed in Kinde

> Overview of content management in Kinde including editable page elements, multi-language support, and available authentication pages for customization.

content management, page content, multi-language, authentication pages, sign up, sign in, error messages
design, content-customization, multi-language

You can change the content for the main pages that your users see as part of authentication. You’re also able to manage the content in [all the languages you have selected](/design/content-customization/set-language-for-pages/) in Kinde. Currently, you can edit content for the following pages: - Sign up - Sign-up confirmation - Sign in - Sign-in confirmation - Request access form - Verify password Additional screens will be added, including error screens, in the coming months. ## What can be edited? You can edit the following page content: - Sign-up page: General page elements, consent, disclaimer, privacy, T&C acceptance, some error messages - Sign-in page: General page elements plus 'Account not found' error message - Verify password page: General page elements, error messages, helper text For the confirmation and request access form pages, you can edit the general page elements. Go to Design > Page content.

# Design - Content customization - Manage languages on user facing pages

> Comprehensive guide for managing languages on user-facing pages including language selection, default language configuration, language detection, and widget translation support.

language management, multi-language, internationalization, RTL languages, language detection, default language, Kinde widget
design, content-customization, multi-language

By default, all Kinde user-facing screens (for example the sign up and sign in screens) are in US English. However, you can make your end-user experience more international by selecting multiple languages for these screens as well. ## What gets translated? Only the user facing pages are translated. This includes, sign up, sign in, verification code, confirmations, one-time code emails. It is not yet possible to select a different language for the whole Kinde platform. To change the language displayed on sign up and request access pages, you need to [customize the relevant page](/design/brand/global-brand-defaults/). ## Supported languages Kinde’s language support offering is growing all the time. Here’s just a sample of what we have so far: English (en / en-US / en-AU / en-GB), Dutch, German, Polish, Hebrew, Italian, French, Malay, Spanish, Russian, Portuguese (Brazilian), Norwegian, Swedish. We aim to eventually support [all these languages](https://github.com/kinde-oss/kinde-translations#language-codes). Feel free to submit a pull request via [GitHub](https://github.com/kinde-oss/kinde-translations) to request or contribute a specific language translation. ## Choose languages Kinde will display the relevant language on authentication screens, when the user’s regional settings are detected. 1. Go to **Settings > Languages**. 2. In the **Supported languages** section, select the checkboxes of all the languages you want to support. Includes support for right to left (RTL) languages. ## Change the default language The default language is the fallback language if a user’s region is not detected, or if the detected language is not selected as supported in Kinde. 1. Go to **Settings > Languages**. 2. In the **Default language** dropdown, choose the language you would like to display as standard. ## How Kinde displays languages For user-facing authentication screens, Kinde gives display priority using language detection, as follows: 1. The language supplied in the auth url ^ 2. The preferred language selected in the user’s browser ^ 3. The default language you have selected in Kinde 4. US English as a last resort, if a translation is not available ^ If you have chosen not to support a language, we will try the next available option. Through language matching, Kinde automatically works out the closest base language to the requested language and will use this if supported by your app. ## Translation of content in the Kinde widget Translations inside of the Kinde widget are taken care of by Kinde. We will grab the copy from the relevant route and language from your [page content settings](/design/content-customization/update-auth-page-content/) and apply them to the widget. ## Customize text on authentication pages You can customize the text on various pages in the auth flow. See [Update page content for the auth flow](/design/content-customization/update-auth-page-content/) for more information. Kinde provides relevant localized content within the `context` object that is passed into the Page default function as mentioned above. Localizations and placeholder replacements are handled for you at run time. For example: ```jsx const {content} = event.context.widget; <img src={<img_url>} alt={content.logoAlt} /> <title>{content.pageTitle}</title> <h1>{content.heading}</h1> <p>{content.description}</p> ```

# Design - Content customization - Update page content

> Guide for updating authentication page content including multi-language support, text variables, and escape route URL configuration for error handling.

page content, content customization, text variables, multi-language, auth pages, escape route URL, preview
design, content-customization, multi-language

For maximum extensibility, page content has been decoupled from the page itself. This lets you update the copy on most screens, which you can do via the **Page content** section of the admin area (see below) or via API (coming soon). ### Update page content If your application is built for [multiple languages](https://docs.kinde.com/design/pages/set-language-for-pages/), select these first in Kinde. <Aside type="warning"> Make sure you hit save each time you finish updating a language or page. If you switch between without saving, you may lose changes. </Aside> 1. In Kinde, go to **Design > Page content**. 2. Select the language you want (only applicable if multiple languages are configured). 3. Select the page you want to edit. The list of content shown corresponds with page elements such as headings, field labels, helper text, error messages, etc. 4. Make the changes to the content. If you want, you can use text variables, explained below. 5. When you’ve finished, select **Save**. The save only applies to the current language and page selected. You need to select **Save** again if you edit in different languages. 6. Check changes by selecting **Preview**. You'll only see an accurate preview if the environment is fully connected, otherwise you may see errors. 7. Repeat from step 2 for each language and page you want to edit. ### Text variables for page content Variables are used to stand in for actual values that you want to appear on pages. They are a way of automating content. For example, if you use the `${email_address}` variable, the user’s email address will be shown. Variables can be used on pages as follows. **Sign in confirm code page** `${email_address}` - shows the full email address of the user `${email_address_obfuscated}` - shows only a part of the user's email **Sign up confirm code page** `${email_address}` ### Include ‘escape route’ URL in auth errors When auth errors appear, you want to give users a way to navigate out of them. To provide an ‘escape route’ URL in these situations: 1. In Kinde, go to **Settings > Applications** and select **View details** on your application. 2. Enter your website URL into the **Application homepage URI** and **Application login URI** fields. 3. Select **Save**.

# Design - Customize with code - Connect your repo for custom pages

> Guide for connecting GitHub repositories for custom page design including directory structure setup, code preview options, and status monitoring.

connect repo, custom pages, GitHub, custom domain, code preview, directory structure, code status
design, customize-with-code, git

To enable your custom code to override Kinde page design, you need to set up and connect a git repo for the design files. You must also be using a [custom domain](/build/domains/pointing-your-domain/) to run your custom code with Kinde. ## Connect your repo 1. Go to **Design > Custom code**. 2. Select the option to **Connect repo**. This will take you to the **Settings > Git Repo** page where you can manage your repo connection for design and workflows. 3. If you don’t already have a repo set up for workflows, select **Connect GitHub**. 4. Follow the prompts to connect a repo and branch. ## Option to enable code preview If you are on the Kinde Plus or Scale plan, you can enable a code preview before you deploy new code to be live. This is helpful for checking the design before making it public in your production environment. If you have a free or Pro plan, we recommend you preview designs in a non-production environment before syncing in production. ## Set up the Git directory structure Your directory structure should follow the following structure. ```jsx myApp/ ├── kindeSrc/ │ └── environment/ │ └── pages/ │ └── (kinde)/ │ └── <route>/ │ └── page.tsx ├── package.json └── kinde.json ``` In the above example, `<route>` is used to map your code to a rendered page in Kinde. For example `kindeSrc/environment/pages/(kinde)/(register)/page.tsx` will map to the register / sign up page in the authentication flow. ## Code status alerts The home page of your Kinde dashboard shows a code alert status. You can see immediately if there are any concerns with your code. Select **View code status** to see if the issue is: - a code sync problem - a workflow code problem - a design custom code issue

# Design - Customize with code - Review custom code logs

> Guide for reviewing custom code logs including sync, build, and runtime logs for debugging deployment issues and troubleshooting code problems.

custom code logs, sync log, build log, runtime log, debugging, deployment errors, troubleshooting
design, customize-with-code, logs, debugging

There are several logs that can be checked when something goes wrong. ## Sync log Check to see if your code is syncing to Kinde and is able to be deployed. Issues with sync logs are most commonly associated with missing files or other directory issues. Go to **Settings > Git repo > Sync log**. ## Build log A build log is generated for each deployment. It provides details on the deployment checks, showing a success or fail message. 1. Go to **Design > Custom code**. 2. Select **Deployments** in the menu. 3. Select the specific deployment you want to view. 4. Scroll to the **Build log** section. For each page included in the deployment, open the dropdown to view the build details. We recommend fixing all the errors detected during this process and syncing your code again. This generates a new deployment and new code check. ## Runtime log Runtime logs record events that occur when your code is running. When something goes wrong, you can check runtime logs to see what happened. 1. Go to **Design > Custom code**. 2. Select **Runtime logs** in the menu. 3. Select the runtime ID to open a details page. 4. Scan the logs for errors.

# Design - Customize with code - Apply custom styling per application

> How to apply custom styling per application using the Client ID attribute and conditional rendering.

custom CSS, custom HTML, conditional rendering, custom domain
design, customize-with-code, css, styling

You can apply unique HTML and CSS styling to each Kinde application within the same business account. Although you can only connect one Git repository for your custom pages, you can use conditional rendering to serve different designs based on which application is being accessed. This guide will walk you through how to use the application's **Client ID** to render unique styles and layouts. This doc is based on the tests and implementation we ran and provides example code, folder layout, and implemention checklist. The **clientID** is a unique identifier assigned to each application in Kinde. This value distinguishes one app from another, allowing your template code to detect which application is active and render the appropriate HTML and CSS for each app accordingly. ## Solution: Conditional rendering The key to this solution is the `clientId`, a unique identifier assigned to every application you create in Kinde. This ID is passed in the `request` object to your custom pages. By checking the value of the `clientId`, your code can determine which application is active and render the corresponding HTML and CSS. This process happens server-side, so there's no performance loss for your users. ## Before you begin - Set up a [custom domain](/build/domains/pointing-your-domain/) for your Kinde business. - Connect a [Git repository](/design/customize-with-code/connect-repo/) to manage your custom pages. - Make sure your custom design files are already working. Follow [this guide](/design/customize-with-code/customize-with-css-html/) for more details. ## Step 1: Set up file structure Your repository needs to follow a specific structure for Kinde to recognize the files. For this example, we are using the simplest structure with the `(default)` folder to act as a fallback and a `page.tsx` file within it. This file will contain your conditional logic. ``` myApp/ ├── kindeSrc/ │ └── environment/ │ └── pages/ │ └── (kinde)/ │ └── (default)/ │ └── page.tsx │ └── layout.tsx ├── package.json └── kinde.json ``` For this specific example, we focus on the default design, but you can use this for your sign up and sign pages as well. ## Step 2: Find the Client ID In your `page.tsx` file, you can access the `clientId` from the `request` object that is passed to your page component. ```js const DefaultPage: React.FC<KindePageEvent> = async ({ context, request }) => { let clientId = request.authUrlParams?.clientId || null; // ... rest of your code };` ``` ## Step 3: Implement the conditional logic Now you can use the `clientId` variable to build your conditional logic. For example, you can use an `if/else` statement, a `switch` statement, or a ternary operator to render different JSX for each application. The following example shows how to render different content for three separate applications (Next.js, Python, and Nuxt.js), with a default fallback. ### `kindeSrc/environment/pages/(kinde)/(default)/page.tsx` ```js 'use server'; import { getKindeWidget, fetch, type KindePageEvent, } from '@kinde/infrastructure'; import React from 'react'; import { renderToString } from 'react-dom/server.browser'; import Layout from '../../layout'; const DefaultPage: React.FC<KindePageEvent> = async ({ context, request }) => { // 1. Access the client ID from the request object let clientId = request.authUrlParams?.clientId || null; // Environment variables const BUILDER_API_KEY = process.env.BUILDER_API_KEY; const CLIENT_ID_NEXT_APP = process.env.CLIENT_ID_NEXT_APP; const CLIENT_ID_PYTHON_APP = process.env.CLIENT_ID_PYTHON_APP; // Example: Fetching dynamic content (optional) const res = await fetch( `https://cdn.builder.io/api/v3/content/login-page-data?apiKey=${BUILDER_API_KEY}&sort.createdDate=-1`, { headers: {}, method: 'GET', } ); const { loginPageImage, signInFormTextTop, signupFormTextTop, signInFormTextBottom, signupFormTextBottom, } = res?.data?.results?.[0]?.data || {}; const isUserOnLoginOrRegisterPage = request?.route?.flow; return ( <Layout context={context} request={request} props={res?.data?.results?.[0]?.data} > {/* 2. Use conditional rendering based on the client ID */} {clientId == CLIENT_ID_NEXT_APP ? ( <div className='container'> {/* Content for the Next.js App */} <h1>Styling for the First App - Next.js</h1> <h2>Client ID: {clientId}</h2> <div className='login-form-wrapper'> {getKindeWidget()} </div> </div> ) : clientId == CLIENT_ID_PYTHON_APP? ( <div className='container-2'> {/* Content for the Python App */} <h1>Styling for the Second App - Python</h1> <h2>Client ID: {clientId}</h2> <table> <tr> <th>Company</th> <th>Contact</th> <th>Country</th> </tr> <tr> <td>Alfreds Futterkiste</td> <td>Maria Anders</td> <td>Germany</td> </tr> </table> <div className='login-form-wrapper'> {getKindeWidget()} </div> </div> ) : ( <div className='container-default'> {/* Fallback content for any other app (e.g., Nuxt app) */} <h1>Default Kinde Authentication Page</h1> <h2>Client ID: {clientId || 'Not available'}</h2> <div className='login-form-wrapper'> {getKindeWidget()} </div> </div> )} </Layout> ); }; // Page Component export default async function Page(event: KindePageEvent): Promise<string> { const page = await DefaultPage(event); return renderToString(page); } ``` The custom CSS for classes like `.container` and `.container-2` would typically be defined in your `layout.tsx` file or in a separate CSS file. ## Expected output for custom designs per application When a user authenticates through each of your applications, they will see a different page design based on your conditional logic. The examples below are not over-designed, but you could make them as distinct as you want. - **Next.js App (`clientId`: `ca3c184xxxxxxd842777bc***xxxx`)** - The user will see the content inside the first block, with the heading "Styling for the First App - Next.js". ![An image of how the page for the Next.js app looks after the conditional rendering is applied](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/b78f5a38-8c84-4b2c-5759-9df24aa61700/public) - **Python App (`clientId`: `c41376xxxxxx244b3122dd***xxxx`)** - The user will see the second block, with the heading "Styling for the Second App - Python" and a custom HTML table. ![An image of how the page for the Python app looks after the conditional rendering is applied](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/b161fbec-4144-4975-8561-a4fb6b1d8500/public) - **Nuxt.js App or any other app (`clientId`: `730c34be0xxxxxxe206ec07***xxxx`)** - Since this ID doesn't match the first two conditions, the user will see the final fallback block with the heading "Default Kinde Authentication Page". ![An image of how the page for any other app (default) would look after the conditional rendering is applied](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/9aacda1b-2583-4226-48c7-3dcd09981100/public)

# Design - Customize with code - Custom UI examples

> Collection of custom UI examples and starter templates including SplitScape, Evolve.ai, Orbit, and Bark & Bite for different design themes and use cases.

custom UI examples, starter templates, React Server Components, SplitScape, Evolve.ai, Orbit, Bark & Bite
design, customize-with-code, examples

View examples to help you get started with Kinde custom UI. ## Example repos Fully customizable UI starter templates built with React Server Components: - [SplitScape](https://github.com/kinde-starter-kits/custom-ui-splitscape) - Professional and friendly, with room to grow. **Theme:** Clean, flexible, balanced **Description**: A well-balanced, two-column layout that suits a broad range of industries—from SaaS to marketplaces. Social login options are prominent, and the welcome message is clear and reassuring. Great default for teams who want flexibility without committing to a niche tone. - [Evolve.ai](https://github.com/kinde-starter-kits/custom-ui-evolve-ai) - Simple, focused, and designed to convert. **Theme:** Futuristic, minimalist, product-led **Description:** A no-frills, gradient-backed sign-in screen with clear CTA flow. Designed for AI products, productivity tools, or platforms that want a polished, tech-forward look while keeping the user’s focus on getting started fast. - [Orbit](https://github.com/kinde-starter-kits/custom-ui-orbit) - Built for launch-ready teams with a bold aesthetic. **Theme:** Dark mode, sci-fi, and startup energy **Description:** A sleek, dark-themed template with interstellar vibes. Perfect for tech startups, crypto products, and developer tools that want to signal modernity and momentum. - [Bark & Bite](https://github.com/kinde-starter-kits/custom-ui-barknbite) - Warm, approachable, and built to delight. **Theme:** Friendly, natural, lifestyle **Description:** Soft colors and charming personality make this template ideal for lifestyle brands, pet-related businesses, or companies targeting families and individuals.

# Design - Customize with code - Customize designs with code

> Overview of customizing Kinde designs with HTML, CSS, and JavaScript including widget customization, page design, and content management layers.

custom design, CSS, HTML, JavaScript, custom domain, Kinde widget, page customization, code management
design, customize-with-code, css, html

Kinde gives you the ability to bring your own HTML / CSS and JavaScript to our hosted pages. For security, your custom code will only be run on a custom domain. These are free to use in Kinde - [set up a custom domain](/build/domains/pointing-your-domain/). There are three layers which make up design customization in Kinde: - **The Kinde widget** - This is the ‘form’ that shows on each screen where end users interact, such as where they input and confirm their auth credentials, enter OTPs, etc. You can change the layout and design of widget elements. - **The page** - the page on which the widget appears, includes background colour, images, footer, location of the widget on the page, etc. - **Copy / translations** - the content that appears in and around Kinde widgets, including field labels, headings, button text, etc. You can update content for all the languages you have selected in Kinde. ![Image of sign in page as an example of page parts](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/361adeeb-53f5-46d4-1223-b66eabf96e00/public) It's important to understand how to work with each of these elements, before getting too far along the custom code path. Learn more about: - [The widget](/design/customize-with-code/kinde-widget/) - [Working with pages](/design/customize-with-code/understand-page-design/) - [Content control](/design/content-customization/how-content-is-managed/) ### Code management Your code for your pages will live in a GitHub repository (other git providers to be supported later). For details see [Connect your repo](/design/customize-with-code/connect-repo/).

# Design - Customize with code - Design inspection with DevTools

> Guide for inspecting Kinde widget components using browser DevTools including style hooks, CSS settings, and debugging techniques across different browsers.

DevTools, design inspection, style hooks, CSS settings, browser debugging, element inspection, Safari, Chrome, Firefox
design, customize-with-code, devtools, debugging

It's helpful to be able to inspect the Kinde widget components and layouts, using DevTools. This lets you: - view [settings](/design/customize-with-code/styling-with-css/) applied to a component or layout, especially when they aren’t defined under `:root`. - get the [style hook](/design/customize-with-code/style-with-style-hooks/) of an element. You can learn more about DevTools in browser documentation. Here's a few common examples: - [Apple Safari](https://developer.apple.com/documentation/safari-developer-tools) - [Google Chrome](https://developer.chrome.com/docs/devtools?hl=en) - [Microsoft Edge](https://learn.microsoft.com/en-us/microsoft-edge/devtools-guide-chromium/landing/) - [Mozilla Firefox](https://firefox-source-docs.mozilla.org/devtools-user/) ## Step 1: Open DevTools Most browsers follow a similar approach for opening DevTools. Here’s a quick guide. **Right-click method:** 1. Right-click anywhere on the page. 2. From the context menu, select **"Inspect"** or **"Inspect Element"**. **Keyboard shortcut:** - `Ctrl + Shift + I` (Windows/Linux). - `Cmd + Option + I` (macOS). **Menu navigation:** 1. Open your browser’s menu (three dots or lines in the top-right corner). 2. Select **More tools** **>** **Developer Tools/Web Developer Tools**. In Safari, go to the top menu bar and select **Develop > Show Web Inspector**. If you don’t see the **Develop** menu item, you’ll need to enable it: 1. In the top menu bar, go to **Safari > Settings**. 2. Open the **Advanced** tab. 3. Check **Show features for web developers**. ## Step 2: Locate in HTML Once DevTools is open: 1. On the page, right-click the element you want to inspect. 2. From the context menu, select **Inspect** or **Inspect Element**. 3. The element will be highlighted and focused to in the **Elements** (or **Inspector**) tab. 4. All widget components and layouts have style hooks on them: `data-kinde-[…]`. 5. Click the arrow (▸) icon next to the element to expand its child elements. ## Step 3: View settings Once a component or layout is located in the HTML: 1. On the page, right-click the element you want to inspect. 2. From the context menu, select **Inspect** or **Inspect Element**. 3. In the **Styles** (or **Rules**) panel, the element’s CSS rules will be displayed, revealing the settings applied to it. 4. Look for `--kinde-[…]` instances to identify the settings specific to the component or layout. If a `--kinde-[…]` setting is explicitly defined, clicking on it will navigate to its definition at the document root, where its value is set. Most browsers also display the setting’s value in a tooltip when hovered. If the setting is not defined and relies on a fallback, it will appear inactive and cannot be clicked. 5. To view state-specific settings: 1. In the **Elements** (or **Inspector**) tab, right-click the element (some browsers may include a menu button next to the element for this action). 2. From the context menu, select **"Force state"** (or **“Change Pseudo-class”** or **“Forced Pseudo-Classes,”** depending on the browser). 3. Choose the desired state from the list.

# Design - Customize with code - Working with the Kinde widget

> Guide for working with the Kinde widget including customization options, authentication flow settings, MFA configuration, and error handling for form components.

Kinde widget, form components, CSS customization, authentication flow, MFA, error handling, branding
design, customize-with-code, widget

The Kinde widget is a core element in Kinde page design. The components that make up the widget have been specifically designed to be easily overridden by your own CSS so you can give it the look and feel of your brand whilst keeping best in class security. The widget refers to a specific form component that lives on the page, that consists of fields, labels, cards, buttons, text strings with URLs, and the 'Built with Kinde' logo. Most styles can be switched out using our suite of [CSS custom properties](/design/customize-with-code/styling-with-css/) but for more complex customizations, we have provided [style hooks](/design/customize-with-code/style-with-style-hooks/) that you can use to completely replace everything. Before designing the elements of the widget and page, fully set up authentication and user access flow, as these impact what is shown in the widget. ## Change what appears in the widget ### Settings for all widgets - [Remove Kinde branding](/design/brand/remove-kinde-branding/) - available only on paid plans ### Settings for the sign in flow - [Auth options](/authenticate/authentication-methods/set-up-user-authentication/) (org or application level configuration) - Create account link - hidden if registrations are disabled ### Settings for the register flow - [Auth options](/authenticate/authentication-methods/set-up-user-authentication/) (org or application level configuration) - [Ask first name / last name](/authenticate/custom-configurations/authentication-experience/) - [Show marketing widget](/authenticate/custom-configurations/authentication-experience/) - [Show “already have account” link](/authenticate/custom-configurations/authentication-experience/) - [Privacy / terms of use links](/manage-users/access-control/accept-policies-signup/) ### Settings for the MFA method - [MFA options](/authenticate/multi-factor-auth/enable-multi-factor-authentication/) (org or application level configuration) ### Settings for errors Follow [this procedure](/design/brand/link-to-homepage/) to include ‘escape hatch’ URLs for errors during the auth flow.

# Design - Customize with code - Manage custom code deployments

> Guide for managing custom code deployments including code preview, syncing, making deployments live, and rollback functionality for Plus and Scale plan users.

custom code deployment, code preview, sync code, rollback, Plus plan, Scale plan, GitHub integration
design, customize-with-code, deployment

Each time your code is synced to Kinde, a new deployment is created. A deployment is a unique point-in-time process that checks the code, which can then be made live. ## Enable code preview Kinde Plus and Scale plan customers are able to preview the design before setting the code live in the production environment. In **Settings > Git repo**, switch on the **Enable preview mode** option. If this setting is not available to you as a Free or Pro plan user, we suggest you use non-production environments to check your designs before deploying to production. ## Sync code Every time you change your code in GitHub, you must sync those changes back to Kinde so you can make them live. 1. Go to **Design > Custom code**. 2. Select **Sync code**. A new deployment is generated on click. If the deployment is successful, you will be able to make it live. ## Make a deployment live 1. Go to **Design > Custom code**. The **Summary** page shows which deployment is live and which is ready to go. 2. If you want, select **Sync code** to get the latest deployment. 3. Select **Deployments** in the menu. A list of current and previous deployments is shown. 4. Find the deployment you want to make live and select **Make live** in the three dots menu. ## Roll back a deployment To roll back a deployment, you just need to make a previous deployment live. 1. Go to **Design > Custom code**. The **Summary** page shows which deployment is live and which is ready to go. 2. Select **Deployments** in the menu. A list of current and previous deployments is shown. 3. Find the previous deployment you want to roll back to and select **Make live** in the three dots menu. This will override the current live deployment.

# Design - Customize with code - Manage assets

> Guide for managing design assets including Kinde-hosted favicons and logos, external assets, and Content Security Policy compliance for custom domains.

design assets, favicons, logos, external assets, CSP, Content Security Policy, organization logos
design, customize-with-code, assets

It is likely that your logos and favicons are managed in Kinde, but you may also manage externally hosted assets like stylesheets, fonts, and images. ## Kinde hosted assets Within your custom code you can reference assets which have been uploaded within the Kinde admin area. The Kinde infrastructure package ships with helper methods for accessing these: ### Favicons ```jsx import {getFallbackFaviconUrl, getSVGFaviconUrl} from "@kinde/infrastructure"; ``` #### Usage ```jsx <link rel="icon" href={getFallbackFaviconUrl()} sizes="48x48"> <link rel="icon" href={getSVGFaviconUrl()} type="image/svg+xml" /> ``` ### Logos ```jsx import {getLogoUrl, getDarkModeLogoUrl} from "@kinde/infrastructure"; ``` #### Usage ```jsx // Always use light logo <img src={getLogoUrl()} alt={event.context.widget.content.logoAlt} /> // Always use dark logo <img src={getDarkModeLogoUrl()} alt={event.context.widget.content.logoAlt} /> // User preference <picture> <source media="(prefers-color-scheme: dark) srcset={getDarkModeLogoUrl()} > <img src={getLogoUrl()} alt={event.context.widget.content.logoAlt} /> </picture> ``` ### Org logos Both logo functions accept the org code as an argument to return the relevant organization logo url: ```jsx // Pass org code in const {orgCode} = event.request.authUrlParams <img src={getLogoUrl(orgCode)} alt={event.context.widget.content.logoAlt} /> ``` ## External CSS files, fonts and images We know you will want to use assets like stylesheets, fonts and images. Kinde does not currently offer hosting for these static assets and you will need to host them yourself. Your root domain as well as any subdomains of that domain are added to our Content-Security-Policy (CSP) by default so to use your own assets and comply with Kinde’s CSP, the assets should be stored on servers that share the same domain as your custom domain. For example, if you are using the custom domain `auth.myapp.com` you could host your external fonts, images and CSS files at `assets.myapp.com` and they would be accessible in your code.

# Design - Customize with code - Page rendering

> Guide for understanding Kinde page rendering including SPA behavior, DOM replacement, and optimizing performance with data-kinde-root attribute.

page rendering, SPA, DOM replacement, data-kinde-root, server rendering, performance
design, customize-with-code, page-rendering

Part of page rendering is understanding how Kinde treats the code you add. By default Kinde will swap out the content of the `<body>` tag in a single DOM replacement when navigating between pages. This provides single-page-application (SPA) behavior, with all the performance and security benefits of a server-rendered page. We use the `<body>` element as we don't know the structure of your code. This does mean there is a risk of collisions with scripts that do something with the `body` (e.g. Google Font Loader or third-party browser extensions) which can produce very weird and hard to debug errors in production. We recommend that you designate a specific entry point for Kinde by placing the `data-kinde-root` attribute on a wrapper element. This has the added advantage of minimizing the amount of the UI being swapped out, which means less network requests and a better end user experience. Here's an example: ```jsx <header> <Logo> </header> // our header and logo won't change so exclude from re-rendering <main data-kinde-root="true"> <h1>{heading}</h1> <p>{description}</p> {getKindeWidget()} </main> // our footer won't change so exclude from re-rendering <footer> // some content here </footer> ``` This means that only critical page items are being re-rendered.

# Design - Customize with code - Pages and the Kinde Management API

> Guide for integrating Kinde Management API with custom pages including M2M setup, environment variables, and common API calls for B2B applications.

Kinde Management API, M2M application, API calls, server rendering, environment variables, organization API, bindings
design, customize-with-code, api

Pages are rendered on the server which means it is possible to make API calls before the page is delivered to the browser. The most common use case for this is calling the Kinde Management API to get additional information for the page. <Aside type="warning"> Just because you can do something doesn’t mean you should. Every API call adds latency to page render times slowing down the experience for your end users. Where possible, we have provided the data you require either via functions in the npm package, or via the event object. The main reason for using the API is for B2B businesses who require more data for the current org to display. Let us know if you find other use cases or you think other data would be useful to include. </Aside> ## Before using the Kinde Mangement API for pages 1. [Create an M2M application](/developer-tools/kinde-api/connect-to-kinde-api/) within Kinde and grant it access to the Kinde Management API with the desired scopes. 2. Setup environment variables in Kinde to provide the client ID and secret. By default the `createKindeAPI` method initially looks up the following environment variables setup in Kinde settings to determine the application to use. - `KINDE_WF_M2M_CLIENT_ID` - `KINDE_WF_M2M_CLIENT_SECRET` - Ensure this is setup with sensitive flag enabled to prevent accidental sharing `createKindeAPI` can also accept an additional parameter which can contain `clientID/clientSecret` or `clientIDKey/clientSecretKey` which can define the environment variables to look up. ## Calling the Kinde Management API for pages The example below calls the `environment` API and adds the logo to the page. **Required bindings** ```js export const pageSettings = { bindings: { "kinde.env": {}, "kinde.fetch": {}, url: {} } }; ``` Example usage calling Organization API: ```jsx export default async Page(event: onPageRequestEvent) { const orgCode = event.request.authUrlParams.orgCode; const kindeAPI = await createKindeAPI(event); const { data: res } = await kindeAPI.get({ endpoint: `organization?code=${orgCode}`, }); const {org} = res; return `<html lang={event.request.locale.lang} > <head> <title>Hello world</title> </head> <body> <p>{org.name}</p> </body> </html> `; } ``` ## Common API calls for custom page design - `GET /environment` - includes brand settings for the environment including logos / background images. Required M2M scope: `read:environments` - `GET /organizations?org_code=${request.authUrlParams.orgCode}` brand settings for the requested org including logo. Required M2M scope: `read:organizations` - `GET /business` - business details like the business name. Required M2M scope: `read:businesses` - `GET /applications/${request.authUrlParams.clientId}`. Required M2M scope: `read:applications`

# Design - Customize with code - Libraries and packages for pages

> Guide for using npm packages and libraries in Kinde page designs including supported packages, React templates, and development dependencies.

npm packages, libraries, React, Liquid, dev dependencies, runtime environment
design, customize-with-code, packages

As part of bringing your own code to page designs, you'll likely need to work with some `npm` libraries in addition to the `@kinde/infrastructure` package. Kinde supports a handful of carefully selected libraries from `npm`. These include: `@kinde/infrastructure` This is Kinde’s package that supplies helpers and methods to give you the best possible authoring experience of Kinde pages and workflows. For server side React templates: `react` and `react-dom/server.browser` For Liquid templates: `liquidjs` Attempting to import unsupported packages into your runtime code will result in your deployment failing. Dev dependencies (e.g packages used for linting, tests and build steps) can be used, as they do not affect the Kinde runtime environment. Any code dependent on these packages should be prebuilt before deploying to Kinde.

# Design - Customize with code - Preview custom code

> Guide for previewing custom code designs using preview credentials and auth flow testing for Plus and Scale plan users.

preview custom code, pages_mode, preview password, Plus plan, Scale plan, auth flow
design, customize-with-code, preview

<Aside type="upgrade"> You can only preview custom code if you are on a Kinde Plus or Scale plan. </Aside> Unlike changes you make in the Kinde UI that impact page layouts and content, your custom designs can’t be viewed in a Kinde-generated preview. Instead, you can test designs using your real auth flow, using preview credentials. ## Preview custom code 1. In your application code, pass the additional auth url parameter `pages_mode=preview`. When the auth flow is initiated a password screen will appear which is required to view the preview. 2. Enter your preview password. Go to **Design > Custom code > Preview**. 3. Copy the **Password** and use it in the authentication request. The preview will show the latest code deployment version.

# Design - Customize with code - Quick start guide

> Quickly set up and run your first Kinde workflow in minutes.

quick start, custom UI, GitHub template, React Server Components, custom domain, workflow setup
design, customize-with-code, quick-start

The quickest way to see an end-to-end example of custom HTML/CSS and JS running on Kinde hosted pages is to follow this guide. ## What you need - A Kinde account with an application set up on a [custom domain](/build/domains/pointing-your-domain/). - A GitHub account to host your code. ## Step 1: Clone a Kinde example template 1. Sign in to your GitHub account and go to [Kinde example Splitscape Custom UI template](https://github.com/kinde-starter-kits/custom-ui-splitscape). 2. Select the green **Use this template button**. 3. Select **Create a new repository**. This will create a new repository in your GitHub account with a copy of the example code. It contains a a fully customizable UI starter template built with React Server Components. ## Step 2: Connect your GitHub repository to Kinde 1. Sign in to your Kinde account and go to **Settings > Git repo**. 2. Select **Connect GitHub** and follow the instructions to connect your GitHub account to Kinde. When you select the repository you just created, Kinde will automatically sync the code for you. ## You're done! Assuming you have an application set up, you can see your custom UI by navigating to your sign in screen. You can now modify the custom UI code to look however you like. ## Next steps - Explore the [Kinde custom UI documentation](/design/customize-with-code/customize-with-css-html/) to learn more about how custom UI works. - Take a look at some other example templates

# Design - Customize with code - Style with style hooks

> Comprehensive guide for styling Kinde widgets using style hooks including CSS selectors, theme support, dark mode, and HTML data attributes for custom styling.

style hooks, CSS styling, data attributes, widget styling, dark mode, theme styles, HTML selectors
design, customize-with-code, styling

Style hooks are [HTML data attributes](https://developer.mozilla.org/en-US/docs/Learn_web_development/Howto/Solve_HTML_problems/Use_data_attributes) that can be targeted using the [CSS attribute selector](https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors), allowing you to apply styles directly to the Kinde widget in your custom CSS. <Aside> Style hooks only apply to styles in the Kinde widget, and not the full page design. </Aside> They give you full control over styling widget components and layouts. Unlike CSS classes, which are used internally, style hooks are dedicated to external (custom) styling. This separation ensures your custom styles remain stable, even if internal styles change. Style hooks are useful when a setting doesn’t exist for a specific style, such as adding a shadow effect to the **Button** component. For example: ```css [data-kinde-button] { box-shadow: 0 1px 3px rgba(12, 12, 12, 0.09); } ``` ## Define style hooks in your CSS Style hooks allow you to apply styles directly in your custom CSS. For example, add a shadow effect to the **Button** component when hovered: ```css [data-kinde-button]:hover { box-shadow: 0 1px 3px rgba(12, 12, 12, 0.09); } ``` <Aside> For your custom styles to apply correctly, make sure they load **after** the Kinde-required CSS. See [Including the Kinde required CSS](/design/customize-with-code/styling-with-css/). </Aside> ## Available style hooks Nearly all elements in the widget have a style hook applied, allowing you to style it as needed. The best way to see which hooks are available is by using [DevTools](/design/customize-with-code/inspect-design-devtools/). Here’s an example of a form field with its style hooks: ```html <div class="kinde-form-field kinde-form-field-variant-select-text data-kinde-form-field="true data-kinde-form-field-variant="select-text > <label class="kinde-control-label" data-kinde-control-label="true" for="credentials_email"> Email </label> <input class="kinde-control-select-text data-kinde-control-select-text="true data-kinde-control-select-text-variant="text id="credentials_email name="p_email required=" kui-input-persist="true autocapitalize="off autocomplete="email spellcheck="false type="email inputmode="email /> </div> ``` And here’s the HTML showing only the style hooks: ```html <div data-kinde-form-field="true" data-kinde-form-field-variant="select-text"> <label data-kinde-control-label="true"> Email </label> <input data-kinde-control-select-text="true" data-kinde-control-select-text-variant="text" /> </div> ``` ## When style hooks aren’t available In rare cases, an element may not have a style hook. This doesn’t mean it can’t be styled—just that a hook isn’t needed. In these cases, it's safe to use an attribute selector or an element (type) selector, but never a class selector, because these attributes and elements are standardized in HTML and won't change. For example, if you wanted to style a specific text input type, like “email”, “url”, “password”, etc, which belongs to the **Control select text** component, you can safely do that by targeting the “type” attribute: ```css [data-kinde-control-select-text][type="email"] { /* Your styles */ } ``` Or if you wanted to target a select list’s `<option>` element, you can safely do that via a type selector: ```css [data-kinde-control-select-text] option { /* Your styles */ } ``` ## Apply theme styles <Aside> Light and dark themes are managed in Kinde. See [Design brand experience defaults](/design/brand/global-brand-defaults/) for more details. </Aside> Theme styles can be applied using the theme hook (`data-kinde-theme`), an HTML data attribute assigned to the `<html>` element. To include it, use the `getKindeThemeCode()` helper from the `@kinde/infrastructure` package: ```js import {getKindeThemeCode} from "@kinde/infrastructure"; ``` Then, apply it inside the `<html>` tag: ```html <html data-kinde-theme="{getKindeThemeCode()}"></html> ``` The theme hook has three possible values based on the applied theme in Kinde: - “light” (default) - “dark” - “user-preference” Since “light” is the default theme, no extra setup is required—styles can be assigned to style hooks as usual. ### Apply dark mode styles To apply dark mode styles to a component or layout, use the `[data-kinde-theme='dark']` selector. Example: Dark mode styles for the **Card** component ```css [data-kinde-theme="dark"] [data-kinde-card] { /* Your styles */ } ``` ### Apply user preference styles The **user-preference** theme allows users to inherit their system theme settings. To apply styles only when the system is set to dark mode, use the [`prefers-color-scheme: dark`](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/prefers-color-scheme) media query inside the theme selector. Example: User preference styles for the **Card** component ```css [data-kinde-theme="user-preference"] [data-kinde-card] { @media screen and (prefers-color-scheme: dark) { /* Your styles */ } } ``` ### Combine dark mode and user preference When supporting both dark mode and user preference, repeat the dark mode styles inside the `@media` query: ```css [data-kinde-theme="dark"] [data-kinde-card] { /* Your styles */ } [data-kinde-theme="user-preference"] [data-kinde-card] { @media screen and (prefers-color-scheme: dark) { /* Your styles */ } } ``` ## Style hook naming structure Style hooks, like settings, follow a consistent naming structure to make them easy to identify and understand. ### Root element A component or layout’s root element follows this structure, as shown in the **Text link** component: ``` data-kinde-text-link | | | | | └── Component/layout name (text link) | └── Prefix (kinde) └── HTML-defined prefix (data) ``` Example HTML: ```html <a class="kinde-text-link" data-kinde-text-link="true" href="[url]"> Sign in </a> ``` Since components are the default unit of styling, layouts include a `layout` identifier in their style hook to distinguish them from components: ``` data-kinde-layout-button-group | | | | | | | └── Component/layout name (button group) | | └── Layout identifier | └── Prefix (kinde) └── HTML-defined prefix (data) ``` ### Variant Component or layout variants follow this structure, as shown in the **Button** component: ``` data-kinde-button-variant="primary | | | | | | | └── Variant (primary) | | └── Component/layout name (button) | └── Prefix (kinde) └── HTML-defined prefix (data) ``` Example HTML: ```html <button class="kinde-button kinde-button-variant-primary data-kinde-button="true data-kinde-button-variant="primary type="submit > <span class="kinde-button-text" data-kinde-button-text="true"> Save </span> </button> ``` ### Modifier Component or layout modifiers follow this structure, as shown in the **Text link** component: ``` data-kinde-text-link-is-external | | | | | | | └── Modifier (is-external) | | └── Component/layout name (text link) | └── Prefix (kinde) └── HTML-defined prefix (data) ``` Example HTML: ```html <a class="kinde-text-link data-kinde-text-link="true data-kinde-text-link-is-external="true href="[url] target="_blank rel="noopener noreferrer > Terms of use </a> ``` A component or layout can have multiple modifiers: ```html <a class="kinde-text-link kinde-text-link-is-inline data-kinde-text-link="true data-kinde-text-link-is-external="true data-kinde-text-link-is-inline="true href="[url] target="_blank rel="noopener noreferrer > Terms of use </a> ``` ### Child elements Child elements of components or layouts follow this structure, as shown in the **Recovery codes** component: ``` data-kinde-recovery-codes-code | | | | | | | └── Element name (code) | | └── Component/layout name (recovery codes) | └── Prefix (kinde) └── HTML-defined prefix (data) ``` Example HTML: ```html <ul class="kinde-recovery-codes" data-kinde-recovery-codes="true"> <li data-kinde-recovery-codes-item="true"> <code data-kinde-recovery-codes-code="true">4EA4356E3</code> </li> <li data-kinde-recovery-codes-item="true"> <code data-kinde-recovery-codes-code="true">954602631</code> </li> <li data-kinde-recovery-codes-item="true"> <code data-kinde-recovery-codes-code="true">A2C3C6D43</code> </li> <!-- [More codes…] --> </ul> ``` List structures (e.g., `<li>` elements) use the generic `item` identifier for consistency.

# Design - Customize with code - Styling with CSS

> Comprehensive guide for styling Kinde pages and widgets using CSS custom properties, settings, fallback values, and integration with the Kinde designer.

CSS styling, custom properties, settings, widget styling, CSS variables, fallback values, Kinde designer
design, customize-with-code, css, styling

Kinde pages and the widget are styled using standard CSS custom properties, collectively managed in 'settings'. Settings provide a simple way for you to customize the end-user experience, as you can override the [CSS custom properties](https://developer.mozilla.org/en-US/docs/Web/CSS/Using_CSS_custom_properties) using your own CSS code. For example, you can: - Set the page’s base text color with `--kinde-base-color`. - Set the primary button’s background color with `--kinde-button-primary-background-color`. - Set the color of a form field’s invalid message with `--kinde-control-associated-text-invalid-message-color` (or use `--kinde-shared-color-invalid` for a more global approach). ## Hosting your CSS and other asset files We know you will want to use assets like stylesheets, fonts and images. Kinde does not currently offer hosting for these static assets and you will need to host them yourself. We recommend hosting them on servers that share the same domain as your custom domain. For example, if you are using the custom domain `auth.myapp.com` you could host your external fonts, images and CSS files at `assets.myapp.com` and they would be accessible in your code. ## Define settings in your CSS Kinde settings are standard CSS custom properties, making them easy to integrate into your custom CSS. You can also map your own design tokens or custom properties to Kinde settings for added consistency. To define settings in your CSS, scope them to the [`:root` pseudo-class](https://developer.mozilla.org/en-US/docs/Web/CSS/:root): ```css :root { --kinde-base-background-color: hsl(0 100% 50% / 50%); --kinde-base-color: hsl(50 80% 40%); --kinde-base-font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; --kinde-base-font-weight: 700; --kinde-button-primary-background-color: var(--kinde-base-color); --kinde-button-primary-color: hsl(0, 0%, 100%); --kinde-alert-banner-error-background-color: hsl(0, 100%, 27%); --kinde-alert-banner-error-color: hsl(0, 0%, 100%); } ``` ### Apply your styles To apply custom styles, you need to load your custom CSS **after** the Kinde required CSS in the HTML `<head>`. This ensures your styles will apply on top of the default styles. ### Include the Kinde required CSS Kinde’s required CSS provides the default styles for the widget and defines all Kinde settings. Without it, the widget will not function correctly. You can include it using the `getKindeRequiredCSS()` helper method from the `@kinde/infrastructure` package: ```js import {getKindeRequiredCSS} from "@kinde/infrastructure"; ``` Once imported, call this function inside the HTML `<head>` of your page to load the necessary styles. For example, to load your custom CSS after the Kinde required CSS using an external stylesheet: ```html <html> <head> {getKindeRequiredCSS()} <link rel="stylesheet" href="/custom_styles.css" /> </head> </html> ``` ## Available settings Most styles (individual CSS properties) have a corresponding setting that can be defined or overridden in your custom CSS. For a full list of available settings, see [Types of settings](#types-of-settings). For example, here’s the CSS for the **Alert banner** component: ```css .kinde-alert-banner { background-color: var(--kinde-alert-banner-error-background-color); border: var(--kinde-alert-banner-border-width, 0.0625rem) var(--kinde-alert-banner-border-style, solid) var(--kinde-alert-banner-error-border-color); border-radius: var(--kinde-alert-banner-border-radius, 0.5rem); color: var(--kinde-alert-banner-error-color); display: var(--kinde-alert-banner-display, flex); gap: var(--kinde-alert-banner-gap, 1rem); padding: var(--kinde-alert-banner-padding, 1.5rem); } ``` ### Non-customizable styles Not all styles can be overridden using settings. Some styles are intentionally hardcoded in Kinde to ensure functionality, usability, and accessibility. There are two main categories of non-customizable styles: **Functional styles** - Styles that are necessary for proper functionality and accessibility. These prevent the UI from breaking and ensure a smooth user experience. Examples include: - Preventing interactions using [`pointer-events`](https://developer.mozilla.org/en-US/docs/Web/CSS/pointer-events), such as disabling an element with `pointer-events: none;`. - Enforcing correct mouse cursors with [`cursor`](https://developer.mozilla.org/en-US/docs/Web/CSS/cursor), such as `cursor: not-allowed;` for disabled elements. - Managing visibility with [`display`](https://developer.mozilla.org/en-US/docs/Web/CSS/display) to correctly show or hide elements. - Applying accessibility-related styles, such as visually hiding elements while keeping them screen-reader accessible or ensuring compliance with user preferences like "reduced motion.” **Expected styles** – Styles that are widely expected and do not typically require customization. Examples include: - The **Card** component’s “is-content-center-aligned” modifier applies `text-align: center;` because the modifier specifically exists for centering the content. Allowing other alignments like "left" or "right" would contradict its purpose. - The **Button** component removes underlines from links (`<a>`) using `text-decoration-line: none;`. This follows best practices, as underlined text generally indicates a standard hyperlink, not a button. ## Settings fallback values We explicitly define settings in the following cases: - **Color-related settings** - For managing light and dark mode with dynamic values. - **Reusability** - When a setting is referenced in multiple places. For settings that aren’t explicitly defined, styles are applied using [CSS custom property fallback values](https://developer.mozilla.org/en-US/docs/Web/CSS/Using_CSS_custom_properties#custom_property_fallback_values). For example, the **Button** component’s font size appears as: ```css font-size: var(--kinde-button-font-size, 1rem); ``` This means: - If `--kinde-button-font-size` is undefined, the fallback value (`1rem`) will be used. - If you define `--kinde-button-font-size`, your value will override the fallback. <Aside> Settings that use fallback values won’t appear in the document root (`:root`) when inspecting in DevTools. If a setting isn’t visible under `:root`, [inspect the specific element instead](/design/customize-with-code/inspect-design-devtools/). </Aside> ## Styling via the Kinde designer You can control page elements and content (including elements of the widget) directly within Kinde, in the Kinde designer. See [Design brand experience defaults](/design/brand/global-brand-defaults/) for more details. Styles set this way act as fallbacks where something is undefined in your code. You can take a hybrid approach and define styles in Kinde as well as in code-defined settings. In fact, we recommend setting defaults via the Kinde designer, so that fallbacks exist for core elements. For example, in the widget’s CSS, the page background color is defined like this: ```css background-color: var(--kinde-base-background-color, var(--kinde-designer-base-background-color)); ``` This means: - `--kinde-base-background-color` is not defined by default. Instead, Kinde uses the fallback: `--kinde-designer-base-background-color`, which comes from the Kinde designer. - To override this style, you can either update it in Kinde designer or define `--kinde-base-background-color` in your custom CSS. <Aside type="warning"> Do not assign values to Kinde designer settings (`--kinde-designer-[...]`) in your custom CSS. These act as non-consumable fallbacks. Instead, control the style either in Kinde Designer or by using the associated default setting. </Aside> ## Types of settings Settings are categorized into distinct types based on their purpose and scope. Here’s an overview of the available types. ### Shared settings: `--kinde-shared-[…]` These settings are shared across the widget CSS to minimize redundancy. They serve as global fallbacks, applied only when a locally scoped setting is not defined. | Setting | Description | Applies to | | ------------------------------------------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------ | | `--kinde-shared-color-disabled-background` / `--kinde-shared-color-disabled-background-dark` | Sets the background color for disabled elements | Button component, Control checkable component, Control select text component | | `--kinde-shared-color-disabled-text` / `--kinde-shared-color-disabled-text` | Sets the text color for disabled elements | Button component, Text button component | | `--kinde-shared-color-invalid` / `--kinde-shared-color-invalid-dark` | Sets the color for invalid elements. Applied to borders or text for elements failing form validation (via `:user-invalid` or `[aria-invalid='true']`). | Composite field component, Control associated text component, Control checkable component, Control select text component | | `--kinde-shared-color-text-caption` / `--kinde-shared-color-text-caption-dark` | Sets the text color for captioned elements, using a lighter shade of body copy | Choice separator component, Control associated text component | | `--kinde-shared-color-text-label` / `--kinde-shared-color-text-label-dark` | Sets the text color for labeled text elements (e.g., `<label>` or `<dt>`), using a darker shade of body copy | Control label component, Key value pair component | | `--kinde-shared-font-small-size` / `--kinde-shared-font-small-letter-spacing` / `--kinde-shared-font-small-line-height` / `--kinde-shared-font-small-weight` | Sets the font styles for text smaller than the body copy | Base `small` element, Disclaimer component, Control associated text component | ### Base settings: `--kinde-base-[…]` These settings define foundational styles, such as fonts and colors, that apply globally to the page. They are typically scoped to the `body` element and a few other key global elements. | Setting | Description | Default | Applies to | | ---------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------- | ----------------------------------------- | | `--kinde-base-scroll-behavior` | Sets the page’s scroll behavior using the CSS [`scroll-behavior`](https://developer.mozilla.org/en-US/docs/Web/CSS/scroll-behavior) property. | “smooth” | `html` element | | `--kinde-base-block-size` | Sets the page’s width or height using the CSS [`block-size`](https://developer.mozilla.org/en-US/docs/Web/CSS/block-size) property, depending on the page’s [writing mode](https://developer.mozilla.org/en-US/docs/Web/CSS/writing-mode). | `100%` | `html` and `body` elements | | `--kinde-base-accent-color` / `--kinde-base-accent-color-dark` | Sets the accent color for specific form controls using the CSS [`accent-color`](https://developer.mozilla.org/en-US/docs/Web/CSS/accent-color) property. **Note:** Matches the “checked” background color of the Control checkable component | Light: `#0f0f0f` | | Dark: `#0054f0` | `body` element | | `--kinde-base-background-color` / `--kinde-base-background-color-dark` | Sets the page’s background color using the CSS [`background-color`](https://developer.mozilla.org/en-US/docs/Web/CSS/background-color) property. **Note:** Falls back to [Kinde's admin brand settings](https://docs.kinde.com/design/pages/design-your-welcome-pages/#set-brand-colors-for-page-elements) if not defined. | Light: `#ffffff` | | Dark: `#0f0f0f` | `body` element | | `--kinde-base-color` / `--kinde-base-color-dark` | Sets the page’s text color using the CSS [`color`](https://developer.mozilla.org/en-US/docs/Web/CSS/color) property | Light: `#2b2b2b` | | Dark: `#dbdbdb` | `body` element | | `--kinde-base-font-family` | Sets the page’s font family using the CSS [`font-family`](https://developer.mozilla.org/en-US/docs/Web/CSS/font-family) property | “Inter, 'CustomSystemFontStack’” | `body` element | | `--kinde-base-font-kerning` | Sets the page’s font kerning using the CSS [`font-kerning`](https://developer.mozilla.org/en-US/docs/Web/CSS/font-kerning) property | “normal” | `body` element | | `--kinde-base-font-size` | Sets the page’s font size using the CSS [`font-size`](https://developer.mozilla.org/en-US/docs/Web/CSS/font-size) property. Note: All other rem-based settings are derived from this value. | `1rem` | `body` element | | `--kinde-base-moz-osx-font-smoothing` | Sets the page’s font smooth using the non-standard Firefox CSS [`-moz-osx-font-smoothing`](https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth) property | “grayscale” | `body` element | | `--kinde-base-webkit-font-smoothing` | Sets the page’s font smooth using the non-standard WebKit CSS [`-webkit-font-smoothing`](https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth) property | “antialiased” | `body` element | | `--kinde-base-font-synthesis` | Sets the page’s font synthesis using the CSS [`font-synthesis`](https://developer.mozilla.org/en-US/docs/Web/CSS/font-synthesis) property | “none” | `body` element | | `--kinde-base-font-variant-ligatures` | Sets the page’s font ligatures and contextual forms using the CSS [`font-variant-ligatures`](https://developer.mozilla.org/en-US/docs/Web/CSS/font-variant-ligatures) property | “common-ligatures contextual” | `body` element | | `--kinde-base-font-variant-numeric` | Sets the page’s font glyphs for numbers, fractions, and ordinal markers using the CSS [`font-variant-numeric`](https://developer.mozilla.org/en-US/docs/Web/CSS/font-variant-numeric) property | “oldstyle-nums proportional-nums” | `body` element | | `--kinde-base-font-weight` | Sets the page’s font weight using the CSS [`font-weight`](https://developer.mozilla.org/en-US/docs/Web/CSS/font-weight) property | `400` | `body` element | | `--kinde-base-letter-spacing` | Sets the page’s letter spacing using the CSS [`letter-spacing`](https://developer.mozilla.org/en-US/docs/Web/CSS/letter-spacing) property | `-.005em` | `body` element | | `--kinde-base-line-height` | Sets the page’s line height using the CSS [`line-height`](https://developer.mozilla.org/en-US/docs/Web/CSS/line-height) property | `1.5` | `body` element | | `--kinde-base-overflow-wrap` | Sets the page’s text overflow using the CSS [`overflow-wrap`](https://developer.mozilla.org/en-US/docs/Web/CSS/overflow-wrap) property | “break-word” | `body` element | | `--kinde-base-tab-size` | Sets the page’s tab character width using the CSS [`tab-size`](https://developer.mozilla.org/en-US/docs/Web/CSS/tab-size) property | `4` | `body` element | | `--kinde-base-focus-border-radius` | Sets the border radius of the page’s focus indicator using the CSS [`border-radius`](https://developer.mozilla.org/en-US/docs/Web/CSS/border-radius) property. Note: If the focused element has a custom radius, the focus indicator will match it. | `.125rem` | `:focus-visible` | | `--kinde-base-focus-outline-width` | Sets the outline width of the page’s focus indicator using the CSS [`outline-width`](https://developer.mozilla.org/en-US/docs/Web/CSS/outline-width) property | `.125rem` | `:focus-visible` | | `--kinde-base-focus-outline-style` | Sets the outline style of the page’s focus indicator using the CSS [`outline-style`](https://developer.mozilla.org/en-US/docs/Web/CSS/outline-style) property | “solid” | `:focus-visible` | | `--kinde-base-focus-outline-color` | Sets the outline color of the page’s focus indicator using the CSS [`outline-color`](https://developer.mozilla.org/en-US/docs/Web/CSS/outline-color) property | Light: `#0054f0` | | Dark: `#94b9ff` | `:focus-visible` | | `--kinde-base-focus-outline-offset` | Sets the outline offset of the page’s focus indicator using the CSS [`outline-offset`](https://developer.mozilla.org/en-US/docs/Web/CSS/outline-offset) property | `.125rem` | `:focus-visible` | | `--kinde-base-focus-transition` | Sets the transition of the page’s focus indicator using the CSS [`transition`](https://developer.mozilla.org/en-US/docs/Web/CSS/transition) property. | “outline-offset 150ms cubic-bezier(.25, 0, .1, 1)” | `:focus-visible` | | `--kinde-base-font-family-mono` | Sets the font family for code-related elements using the CSS [`font-family`](https://developer.mozilla.org/en-US/docs/Web/CSS/font-family) property | “ui-monospace, SFMono-Regular, ‘SF Mono’, Consolas, ‘Liberation Mono’, Menlo, monospace” | `code`, `kbd`, `samp`, and `pre` elements | | `--kinde-base-font-kerning-mono` | Sets the font kerning for code-related elements using the CSS [`font-kerning`](https://developer.mozilla.org/en-US/docs/Web/CSS/font-kerning) property | “none” | `code`, `kbd`, `samp`, and `pre` elements | | `--kinde-base-font-size-mono` | Sets the font size for code-related elements using the CSS [`font-size`](https://developer.mozilla.org/en-US/docs/Web/CSS/font-size) property | `--kinde-base-font-size` | `code`, `kbd`, `samp`, and `pre` elements | | `--kinde-base-font-variant-ligatures-mono` | Sets the font ligatures and contextual forms for code-related elements using the CSS [`font-variant-ligatures`](https://developer.mozilla.org/en-US/docs/Web/CSS/font-variant-ligatures) property | “contextual” | `code`, `kbd`, `samp`, and `pre` elements | | `--kinde-base-font-variant-numeric-mono` | Sets the font glyphs for numbers, fractions, and ordinal markers for code-related elements using the CSS [`font-variant-numeric`](https://developer.mozilla.org/en-US/docs/Web/CSS/font-variant-numeric) property | “lining-nums tabular-nums slashed-zero” | `code`, `kbd`, `samp`, and `pre` elements | | `--kinde-base-font-weight-mono` | Sets the font weight for code-related elements using the CSS [`font-weight`](https://developer.mozilla.org/en-US/docs/Web/CSS/font-weight) property | `500` | `code`, `kbd`, `samp`, and `pre` elements | | `--kinde-base-letter-spacing-mono` | Sets the letter spacing for code-related elements using the CSS [`letter-spacing`](https://developer.mozilla.org/en-US/docs/Web/CSS/letter-spacing) property | “normal” | `code`, `kbd`, `samp`, and `pre` elements | | `--kinde-base-line-height-mono` | Sets the line height for code-related elements using the CSS [`line-height`](https://developer.mozilla.org/en-US/docs/Web/CSS/line-height) property | `1.5` | `code`, `kbd`, `samp`, and `pre` elements | | `--kinde-base-pre-overflow-x` | Sets the `pre` element’s horizontal overflow using the CSS [`overflow-x`](https://developer.mozilla.org/en-US/docs/Web/CSS/overflow-x) property | “auto” | `pre` element | | `--kinde-base-strong-font-weight` | Sets the font weight for emphasized text elements using the CSS [`font-weight`](https://developer.mozilla.org/en-US/docs/Web/CSS/font-weight) property | `500` | `b` and `strong` elements | ### Component settings: `--kinde-[component_name]-[…]` These settings are specific to self-contained UI patterns within the widget, such as buttons, cards, and form controls. Components are the default unit of styling, so they do not require an explicit `component` type indicator. Component settings are numerous, as they represent the primary method for styling the widget. To explore them, use DevTools. See [Inspect using DevTools](/design/customize-with-code/inspect-design-devtools/) for instructions. ### Layout settings: `--kinde-layout-[…]` These settings are specific to layouts within the widget. Unlike components, which define specific UI patterns, layouts determine the arrangement of components—such as spacing between them—to ensure a consistent structure across the widget. Like component settings, layout settings are numerous. To explore them, use DevTools. See [Inspect using DevTools](/design/customize-with-code/inspect-design-devtools/) for instructions. ## Naming structures Settings follow a consistent naming structure to make them easy to identify and understand. Most settings are structured as follows. This sets the background color of the page using the CSS `background-color` property: ``` --kinde-base-background-color | | | | | └── Property (background-color) | └── Type (base) └── Prefix (kinde) ``` Here’s a more complex setting. This sets the background color in dark mode for the page using the CSS `background-color` property. ``` --kinde-base-background-color-dark | | | | | | | └── Dark mode suffix | | └── Property (background-color) | └── Type (base) └── Prefix (kinde) ``` This sets the border width for the “primary” variant of the **Button** component using the CSS `border-width` property. ``` --kinde-button-primary-border-width | | | | | | | └── Property (border-width) | | └── Variant (primary) | └── Type (component) └── Prefix (kinde) ``` This sets the text-decoration-line style (underline, overline, etc.) of the **Text link** component when hovered using the CSS `text-decoration-line` property. ``` --kinde-text-link-text-decoration-line-is-inline-hover | | | | | | | | | └── State (hover) | | | └── Modifier (is-inline) | | └── Property (text-decoration-line) | └── Type (component) └── Prefix (kinde) ``` ### Prefixes All settings start with the `--kinde` prefix to ensure uniqueness and prevent conflicts with custom-defined CSS. ### Type The second part indicates the [type of setting](#types-of-settings). ### [Variant/Element] / Property / Modifier / State Each setting includes a combination of **[variant/element]**, **property**, **modifier**, and **state**, depending on the level of specificity required. Every setting always includes a **property**. #### [Variant/Element] **Variant** - Certain components, such as the **Button** component, have predefined variants. Variants define distinct styles or versions of a component. For example, the background colors for the **Button** component’s variants are defined as: - **Primary variant:** `--kinde-button-primary-background-color` - **Secondary variant:** `--kinde-button-secondary-background-color` - **Uncontained variant:** `--kinde-button-uncontained-background-color` **Element** - For components with child elements, element-specific identifiers are used to distinguish settings that apply to the component's root element versus its child elements. For example, here are some settings for the **Key value pair** component’s "key" element (the child `<dt>` element): - `--kinde-key-value-pair-key-color` - `--kinde-key-value-pair-key-font-weight` Some identifiers can be more generic. For example, list structures (e.g., `<li>` elements) use the generic **"item"** identifier: - `--kinde-key-value-pair-item-margin-block-end` Another common generic identifier is **"child"**, representing unnamed child elements typically targeted with the [universal selector (`*`) CSS selector](https://developer.mozilla.org/en-US/docs/Web/CSS/Universal_selectors): - `--kinde-fallback-action-child-display` <Aside> "Variant" and "Element" can coexist when a component has settings for a child element that are scoped to a specific variant. The variant identifier always comes before the element identifier. For example, the setting that controls the size of the **Composite field** component’s nested select element when in the "phone-number" variant is defined as: `--kinde-composite-field-phone-number-control-select-inline-size` </Aside> #### Property Each setting corresponds to a standard CSS property. For example, settings related to text color, such as `--kinde-base-color`, match the associated `color` property. This makes the settings intuitive and easy to understand. <Aside> An exception to this applies to settings related to element spacing. Instead of using specific CSS properties (like `margin-block-end`), a generic “spacing” term is used. This helps identify the common concept of spacing across multiple properties (e.g., `margin`, `gap`). Spacing refers to the whitespace **external** to an element, while **internal** spacing is defined with the `padding` property. For example: - `--kinde-control-label-spacing` defines spacing after the **Control label** component. More specific variants are: - **“spacing-content”** – Defines spacing between child elements, or the “content” (e.g., `--kinde-card-spacing-content`). - **“spacing-[element_name]”** - Defines spacing for a specific child element (e.g., `--kinde-layout-widget-spacing-footer`). </Aside> #### Modifier Sometimes, styles include modifiers, which are small adjustments to the default style. For example, the **Button** component includes the “is-content-width” modifier: `--kinde-button-inline-size-is-content-width`, which adjusts the button's width to match its content, as opposed to using the default width based on its container. #### State For components with interactive elements, such as buttons, links, and form controls, state-specific settings apply when the element is in a particular state. For example, the states for the **Text link** component’s text color are defined as: - **Active state:** `-kinde-text-link-color-active` - **Focus state:** `-kinde-text-link-color-focus` - **Hover state:** `-kinde-text-link-color-hover` - **Visited state:** `-kinde-text-link-color-visited` States are defined using [CSS pseudo-classes](https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-classes). Common states include: - [**Active** (`:active`)](https://developer.mozilla.org/en-US/docs/Web/CSS/:active) – Styles applied when the element is being activated, such as when a user clicks, taps, or presses a key that triggers the element. - [**Focus** (`:focus-visible`)](https://developer.mozilla.org/en-US/docs/Web/CSS/:focus-visible) – Styles applied when the element receives keyboard or programmatic focus. <Aside> **Kinde uses `:focus-visible` exclusively instead of `:focus` to provide a better user experience.** `:focus-visible` ensures that focus indicators appear only when necessary—typically during keyboard or other non-mouse interactions. In contrast, `:focus` applies whenever an element gains focus, including mouse clicks and taps, which can lead to visual confusion and make the UI harder to interpret. </Aside> - [**Hover** (`:hover`)](https://developer.mozilla.org/en-US/docs/Web/CSS/:hover) – Styles applied when the element is hovered by a mouse pointer. ### Dark mode suffix Settings for defining the widget’s dark mode colors include the “dark” term appended to the end of the setting. For example, the **Alert banner** component’s dark mode settings are defined as: - **Background color:** `--kinde-alert-banner-error-background-color-dark` - **Border color:** `--kinde-alert-banner-error-border-color-dark` - **Text color:** `-kinde-alert-banner-error-color-dark` <Aside> Light and dark themes are managed in Kinde. See [Design brand experience defaults](/design/brand/global-brand-defaults/) for more details. For theme styling to work in your repo, see HTML data attributes [(Style hooks) > Apply theme styles](/design/customize-with-code/style-with-style-hooks/). </Aside> ### Shared settings Shared settings use a unique naming structure because they apply to broader styling aspects rather than specific components or elements. Unlike other settings, they do not follow the **[Variant/Element] / Property / Modifier / State** structure. Instead, these settings are categorized by general UI styling aspects. Currently, the main categories are: - **“Color”:** `--kinde-shared-color-[…]` - **“Font”:** `--kinde-shared-font-[…]` After the category, the remaining structure varies depending on the styling need. For example, state-based color settings follow this format: - `--kinde-shared-color-[state]-[element_part]` **Examples:** - `--kinde-shared-color-disabled-background` – Sets the background color for disabled elements. - `--kinde-shared-color-disabled-text` – Sets the text color for disabled elements. - `--kinde-shared-color-invalid` – Sets the color of all parts of an element affected by an “invalid” state, such as background, border, or text.

# Design - Customize with code - Understand Kinde page customization

> Comprehensive guide for understanding Kinde page customization including React templating, directory structure, route mapping, and server-rendered JavaScript implementation.

page customization, Kinde widget, React templating, directory structure, kinde.json, route mapping, server rendering
design, customize-with-code, page-design

The 'page' is the whole user interface rendered by the browser, including everything that surrounds the Kinde widget. You can provide your own markup to influence the page design. There's also a handy placeholder so you can tell us where you want the widget rendered. You define a page by default exporting a function from a `page.[ts/tsx/js/jsx]` file. ```jsx "use server"; import React from "react"; import { renderToString } from "react-dom/server.browser"; import { getKindeRequiredCSS, getKindeRequiredJS, getKindeNonce, getKindeWidget, getKindeCSRF, getLogoUrl, getSVGFaviconUrl, setKindeDesignerCustomProperties, getKindeRegisterUrl } from "@kinde/infrastructure"; const Layout = async ({request, context}) => { return ( <html lang={request.locale.lang} dir={request.locale.isRtl ? "rtl" : "ltr"}> <head> <meta charset="utf-8" /> <meta name="viewport" content="width=device-width, initial-scale=1" /> <meta name="robots" content="noindex" /> <meta name="csrf-token" content={getKindeCSRF()} /> <title>{context.widget.content.page_title}</title> <link rel="icon" href={getSVGFaviconUrl()} type="image/svg+xml" /> {getKindeRequiredCSS()} {getKindeRequiredJS()} <style nonce={getKindeNonce()}> {`:root { ${setKindeDesignerCustomProperties({ baseBackgroundColor: "#fff", baseLinkColor: "#230078", buttonBorderRadius: "0.5rem", primaryButtonBackgroundColor: "#230078", primaryButtonColor: "#fff", inputBorderRadius: "0.5rem" })}} `} </style> <style nonce={getKindeNonce()}> {` :root { --kinde-base-color: rgb(12, 0, 32); --kinde-base-font-family: -apple-system, system-ui, BlinkMacSystemFont, Helvetica, Arial, Segoe UI, Roboto, sans-serif; } [data-kinde-control-select-text]{ background-color: rgb(250, 250, 251); } .c-container { padding: 1.5rem; display: grid; gap: 230px; } .c-widget { max-width: 400px; width: 100%; margin: 0px auto; } .c-footer { border-top: 1px solid rgba(12, 0, 32, 0.08); padding-block: 1.5rem; display: flex; justify-content: space-between; } .c-footer-links { display: flex; gap: 1.5rem; } `} </style> </head> <body> <div data-kinde-root="/admin" class="c-container"> <header class="c-header"> <img src={getLogoUrl()} alt={context.widget.content.logo_alt} /> </header> <main> <div class="c-widget"> <h1>{context.widget.content.heading}</h1> <p>{context.widget.content.description}</p> <div>{getKindeWidget()}</div> </div> </main> <footer class="c-footer"> <p class="c-no-account-link"> No account? <a href={getKindeRegisterUrl()}>Sign up for free</a> </p> <ul class="c-footer-links"> <li> <a href="">Privacy</a> </li> <li> <a href="">Terms</a> </li> <li> <a href="">Get help</a> </li> </ul> </footer> </div> </body> </html> ); }; export default async function Page(event) { const page = await Layout({...event}); return renderToString(page); } ``` ### Supported templating languages Kinde uses server-rendered JavaScript to compose custom pages and has a range of templating options available: - React - Liquid - JavaScript - TypeScript <Aside> If you are using React for templating, note this code is rendered on the server. This means client side functions for example, `useEffect`, will not be available. </Aside> ## Page structure in the Git directory The code for your pages must live in a GitHub repository (other git providers to be supported later). Your directory structure in the repo is critical to Kinde being able to run your design code. The directory structure for a Kinde custom code repo should be as follows: ``` myApp/ ├── kindeSrc/ │ └── environment/ │ └── pages/ │ └── (kinde)/ │ └── (default)/ │ └── page.tsx ├── package.json └── kinde.json ``` ## Kinde.json The `kinde.json` file defines the config for all custom code in Kinde, including workflows and custom pages. A typical config file will look as follows: ```json { "rootDir": "kindeSrc", -- the directory where Kinde should look for your code "version": "2024-12-09" -- the last breaking change } ``` `rootDir` - the directory where Kinde will look for your custom code. Defaults to `kindeSrc` so that you can include Kinde code alongside existing projects. Change this if you wish the code to live in another directory. `version` - based on the date when the API version was released. Any breaking changes will be released in a new API version. ## Which pages can I customize? All Kinde hosted pages can be customized and use url route mapping to determine which template to use. If a specific mapped route does not exist, a special route called `(default)` will be rendered. Set up the `(default)` page to ensure all your pages follow this design unless you have overridden them with custom code. <Aside type="warning"> Once you start customizing pages, it's on you not to break them. We recommend always applying custom code to pages in a non-prod environment first. </Aside> ### Common pages These are the most frequently used or fallback pages. - `(default)` – Fallback template used when a specific page is not found. - `(register)` – The sign-up page. - `(login)` – The sign-in page. - `(index)` – Landing page when visiting the root domain (e.g. `https://<yourdomain>.kinde.com`). ### Authentication Pages involved in initiating authentication flows. - `(register)` – The sign-up page. - `(login)` – The sign-in page. - `(sso_home_realm)` – Displayed when a user selects “Continue with SSO” to choose their identity provider. - `(provide_email)` – Shown when using a social login provider that does not return an email address. - `(clickwrap)` – Displays terms and conditions or agreements that must be accepted. ### Password flows Used in password-based authentication and recovery. - `(verify_password)` – Shown during sign-in when using a password-based method. - `(set_password)` – Shown during a password-based sign-up flow. - `(reset_password_verify_email_otp)` – First step of the reset flow where the user verifies identity using an email OTP. - `(reset_password)` – Password entry screen shown after verification during the reset flow. ### One-Time Passcode (OTP) verification Used in sign-in and sign-up flows with OTP (email or phone). - `(sign_in_use_email_otp)` – Sign in with a one-time email code. - `(sign_up_use_email_otp)` – Sign up with a one-time email code. - `(sign_in_sign_up_use_phone_otp)` – Sign in or sign up with a one-time phone code. ### Multi-Factor Authentication (MFA) Shown after primary authentication when MFA is required or being set up. - `(mfa_method_selection)` – User selects their preferred MFA method. - `(mfa_authenticator_app)` – Setup screen for using an authenticator app. - `(mfa_setup_email)` – Setup screen for email-based MFA. - `(mfa_setup_phone)` – Setup screen for phone-based MFA. - `(mfa_use_email_otp)` – Enter a one-time email code for MFA. - `(mfa_use_phone_otp)` – Enter a one-time phone code for MFA. - `(mfa_use_recovery_code)` – Enter a recovery code if unable to use other MFA methods. - `(mfa_view_recovery_codes)` – View and save MFA recovery codes. ### Billing Pages related to choosing a plan and making a payment. - `(choose_plan)` – User selects a subscription plan. - `(collect_payment_details)` – User enters billing information. - `(subscription_success)` – Confirmation page shown after successful subscription. ### Early access Pages for gated access to your product before full launch. - `(request_access)` – Request early access to your product. - `(request_access_success)` – Confirmation page after a request is submitted. ### Error pages Shown when a user encounters an error state. - `(account_locked)` – The user’s account has been locked. - `(account_not_found)` – No account was found for the entered credentials. - `(invalid_redirect_url)` – The redirect URL is invalid or not on the allowed list. - `(error)` – Generic error screen. If you want specific customization for a page not listed here, reach out and let us know. ## Set the page default export function Your `page.[ext]` file should contain a default export. It doesn’t matter what this is called, but the general convention is to call it `Page`. This is provided a single `event` argument which is an object containing 2 keys `context` and `request`. The `request` key contains information about the request to the page and includes the following sub-objects: - `authUrlParams` contains useful info from authorization request url - `orgCode` - the requested organization code e.g `org_12345` - `state` - the state parameter in the auth url - `clientId` - the `client_id` query param from the auth url - this is the application ID - `redirectUri` - the `redirect_uri` query param from the auth url - `locale` - localization data - `isRtl` - if the requested language should be rendered right to left - `lang` - the code for the requested language - `route` - `context`- the requested widget `CX_m` e.g `register` | `choose_organization` - `flow` - whether the flow is a sign in or sign up flow e.g `register` | `login` - `path` - the path of the request `auth` | `account`| `\` The top level `context` key object contains information about the page itself, like the page state and content. - `domains` contains relevant domain info - `kindeDomain` your domain on Kinde e.g https://example.kinde.com - `widget` contains data generated from the widget - `content` an object containing page content - translated and with placeholders replace - `pageTitle` the title of the page commonly displayed in the `<title>` tag for showing in the browser tab - `heading` the main heading for the page - `description` the page description - `logoAlt` the alt text for your company logo ## Page settings Sometimes additional information needs to be passed to Kinde from your page. You can use the page settings object for this. ```js export const pageSettings = {}; ``` The main use case for this is when you want to make bindings available to your page, for example access to your Kinde environment variables. ```js export const pageSettings = { bindings: { "kinde.env": {} } }; ``` This allows you to have fine grained control over what your pages can access.

# Design - Pages - User consent for marketing on sign up

> Guide for adding marketing consent checkboxes to sign-up pages including feature configuration, label customization, and user consent status management.

marketing consent, user consent, sign up, checkbox, properties, opt-in, marketing communications
design, pages, marketing

If you want users to opt-in for marketing communications when they sign up to your app, you can add a consent box to the sign up screen. The checkbox option is a Kinde property that shows in the user’s profile if they consent or not. How you manage sending marketing material to the user, and how you allow them to opt out is up to you as a business, and is not part of this feature. ## Add the checkbox to the sign up page You need to switch this on for each application you want it to appear for. **Switch on the feature** 1. In Kinde, go to **Settings > Applications > [Your application]**. 2. On the **Details** page, scroll to the **Authentication experience** section. 3. Switch on the **Add marketing consent checkbox** option. **Update the checkbox label** 1. Go to **Design > Page content**. 2. Select the **Sign up page** from the dropdown. 3. Scroll to the **Label for requesting marketing consent** field and make the required changes. 4. Select Select **Save**. 5. To preview, select **Sign up page** in the menu and select **Preview**. ## View or change the consent status for a user 1. In Kinde, go to **Users** and find the user who’s profile you want to view. 2. Open their profile. 3. In the left menu, select **Properties**. 4. Find the **Yes to marketing** or `kp_marketing_consent` property. It will either say True = They agreed; False = They did not agree. 5. If you want to change the property value: a. select the edit (pencil) icon. b. In the window that appears, change the value by selecting or deselecting the checkbox. c. Select **Save**. 6. Select **Save**.

# Design - Pages - Manage page layouts

> Guide for managing page layouts including authentication pages, background customization, widget positioning, and additional auth element configuration.

page layout, auth pages, sign in page, sign up page, passwordless, background, widget positioning, custom domain
design, pages, layout

If you are not using [custom code for your page designs](/design/customize-with-code/customize-with-css-html/), you can still change the layout of pages (including auth pages), to control elements such as the background, alignment and position of page elements and widget. After you’ve set the global brand, view how it looks on individual pages, and make additional changes. You can further customize: - sign in page - what a user sees each time they sign in to their account - sign up page - what a user sees when they first sign up to your business - confirm sign in page (if using [passwordless](/authenticate/authentication-methods/passwordless-authentication/) authentication) - where a user enters the passwordless email code each time they sign in. - Confirm sign up page (if using [passwordless](/authenticate/authentication-methods/passwordless-authentication/) authentication) - where a user enters the passwordless email code the first time they sign up. - Emails - for when you send email from the company. - Subscription page - the sign up page for new subscribers (if you use this) - Request access page - when you're collecting a waiting list <Aside> To manage page design using your own CSS code, see [page design with code](/design/customize-with-code/understand-page-design/). </Aside> ### To customize pages 1. Select the page you want to view or edit from the left menu. 2. Depending on the type of page you are viewing, you can edit, the background image, page layout, content, and more. 3. Select **Save** to apply changes. 4. Select **Preview** in the top right to view changes. ## Other cusomizations you might want to apply - [Use your own domain instead of Kinde’s](/build/domains/pointing-your-domain/) - [Manage the authentication experience for users](/authenticate/custom-configurations/authentication-experience/) - [Add a marketing consent checkbox to the sign up page](/design/pages/marketing-consent/) - [CSS page design for the auth experience](/design/customize-with-code/customize-with-css-html/) ### Enable/disable additional auth elements 1. In Kinde, go to **Settings > Applications** and select **View details** on your application. 2. Scroll down to the **Authentication experience** section and make any changes you want. 3. Select **Save**.

# Design - Pages - Set up the request access page

> Guide for setting up request access pages including design configuration, success URL setup, content customization, and contact management for lead generation.

request access page, lead generation, success link URL, page design, access requests, contact management, custom domain
design, pages, lead-generation

When you are a brand new company and still building your application, you might want new users to request access to your product. People who customize pages also like to [use their own domain instead of Kinde’s](/build/domains/pointing-your-domain/). ## **Design and activate the request access page** 1. Go to **Design > Lead generation > Request access**. 2. Make your design and layout selections. For tips on how to change things, see [Design your welcome pages](/design/brand/global-brand-defaults/). 3. Enter the **Success link URL**. 4. Select **Preview** to view how the page will look. 5. Once you like it, switch the **Page details** button to **Live** and then select **Save**. 6. To change the content on the page, go to **Page content** in the menu, and select the **Request access** page. 7. Make the changes you want in all the relevant languages and **Save**. 8. You'll need to separately set up the **Request Access URL** on your website. ## Manage request access contacts As you collect contacts who want access to your product, you can manage them in the [Access requests list](/build/set-up-options/manage-access-requests/) in Kinde. You can also easily convert these contacts to users.

# Design - Pages - Set up a subscription form

> Guide for setting up subscription forms including form customization, embed code generation, and subscriber management for lead generation campaigns.

subscription form, lead generation, embed code, HTML, CSS, JavaScript, subscribers, form customization
design, pages, lead-generation

If you want to collect details from site visitors and subscribe to them to receive communications from your business, you can set up a form using Kinde. ## Customize the subscription form 1. Go to **Design > Lead generation > Subscribe**. 2. In the panel on the right, make any content changes you want. 3. Enter the URL for the site where the form will appear. Note that you only need to include the root part of the URL, not the specific pages (e.g. `https://kinde.com`). 4. Select **Save and generate code**. 5. Use this code to add the subscription page to your website. - `HTML` - Add this to your site page to embed the form. - `CSS` - Copy into your page header. To apply your own style, add a style block and use custom class names to apply your designs. - `JS` - Copy and paste this somewhere in the page markup. Putting it after the provided HTML markup (above) is ideal. ## **View and manage subscribers** Once the form is activated, in the main menu of Kinde, go to **Users** and select **Subscribers** to view a list of people who have signed up. You can [add, delete and convert subscribers into users](/manage-users/add-and-edit/manage-subscribers/).

# Developer tools - About - Kinde SDKs

> Comprehensive overview of Kinde SDKs including frontend, backend, and native SDKs with version compatibility considerations and community SDK information.

Kinde SDKs, frontend SDKs, backend SDKs, native SDKs, community SDKs, version compatibility, tech stack
developer-tools, sdks, frontend, backend, native

Kinde provides Software Development Kits (SDKs) help you connect your app more easily to Kinde. Generally, you only need one SDK per application or service. But you might use multiple SDKs if your product is comprised of applications or services written in multiple languages. You can also use different SDKs to support front end and back end behavior, if this suits your setup. <Aside type="warning" title="Check version compatibility"> Make sure that your tech stack’s versions are compatible with the SDK you want to use. </Aside> ## **Front end** - [JavaScript SDK](/developer-tools/sdks/frontend/javascript-sdk/) - [React SDK](/developer-tools/sdks/frontend/react-sdk/) - [TypeScript SDK](/developer-tools/sdks/backend/typescript-sdk/) ## **Back end** - [Elixir SDK](/developer-tools/sdks/backend/elixir-sdk/) - [Express.js SDK](/developer-tools/sdks/backend/express-sdk/) - [.NET SDK](/developer-tools/sdks/backend/dotnet-sdk/) - [Java SDK](/developer-tools/sdks/backend/java-sdk/) - [Next.js App Router SDK](/developer-tools/sdks/backend/nextjs-sdk/) - [Next.js Pages Router SDK](/developer-tools/sdks/backend/nextjs-prev-sdk/) - [Nuxt module](/developer-tools/sdks/backend/nuxt-module/) - [Node.js SDK](/developer-tools/sdks/backend/nodejs-sdk/) - [PHP SDK](/developer-tools/sdks/backend/php-sdk/) - [Python SDK](/developer-tools/sdks/backend/python-sdk/) - [Remix SDK](/developer-tools/sdks/backend/remix-sdk/) - [Ruby SDK](/developer-tools/sdks/backend/ruby-sdk/) - [SvelteKit SDK](/developer-tools/sdks/backend/sveltekit-sdk/) - [TypeScript SDK](/developer-tools/sdks/backend/typescript-sdk/) ## **Native** - [Android SDK](/developer-tools/sdks/native/android-sdk/) - [iOS SDK](/developer-tools/sdks/native/ios-sdk/) - [React Native SDK](/developer-tools/sdks/native/react-native-sdk/) - [Expo and React Native SDK](/developer-tools/sdks/native/expo/) - [Flutter SDK ](/developer-tools/sdks/native/flutter-sdk/) ## **Other** - [Node/Apollo GraphQL](/developer-tools/sdks/backend/apollo-graphql/) - [Node/Express GraphQL](/developer-tools/sdks/backend/node-express-graphql/) ## Community SDKs Community SDKs are developed independently by members of the Kinde developer community. While we review community SDKs before we link to them, Kinde is not responsible for directly supporting or updating community SDKs. Please contact the author through GitHub. - [Angular SDK](https://github.com/luukhaijes/kinde-angular) Contact us via [Slack](https://join.slack.com/t/thekindecommunity/shared_invite/zt-2k5i0aeet-d6Z_2qYphcNCpj0bFa4oCg) or [Discord](https://discord.gg/KdkCXRNTFn) support channels if you want to contribute a community SDK.

# Developer tools - About - Using Kinde without an SDK

> Comprehensive guide for integrating with Kinde without SDKs using OAuth 2.0 and OpenID Connect standards including authorization flows, token exchange, and request parameters.

OAuth 2.0, OpenID Connect, callback URLs, authorization code, PKCE, access tokens, scopes, request parameters
developer-tools, oauth, openid-connect

Kinde is designed to help founders and developers build SaaS products by providing software infrastructure like authentication, feature flags, user management, and more. We support connecting to Kinde through [our SDKs](/developer-tools/about/our-sdks/), but everything we build is also OAuth 2 standard, so you can integrate into any language framework with Kinde without an SDK. ## **Get started** [Start for free](https://kinde.com/) on Kinde. ## **OpenID Connect** To connect to Kinde you need to know where the endpoints are for things like authorization, tokens, and user profiles. You’ll also need to know the response types, scopes, and claims that are supported. All this data and more can be found in your OpenID configuration file which is located at: `https://<your_kinde_subdomain>.kinde.com/.well-known/openid-configuration` ## **Set** **callback URLs in Kinde** During the auth process your user will authenticate on Kinde and once authenticated will be redirected back to an endpoint in your code. To define this callback url: 1. In Kinde, go to **Settings > Applications > [Your app] > View details**. 2. Add your callback URLs in the relevant fields. For example: - Allowed callback URLs (also known as redirect URIs) - for example [`http://localhost:3000/api/auth/kinde_callback`](http://localhost:3000/api/auth/kinde_callback) - Allowed logout redirect URLs - for example `http://localhost:3000` 3. Select **Save**. You will need to use this redirect URL in the following step. ## **Signing up and signing in** Your users must be redirected from your product to Kinde to sign up or sign in securely. The redirect URL on your product side would look like the following: ```markdown https://<your_kinde_subdomain>.kinde.com/oauth2/auth ?response_type=code &client_id=<your_kinde_client_id> &redirect_uri=<your_app_redirect_url> &scope=openid%20profile%20email &state=abc ``` Note: Never include the client secret in the URL as this is publicly viewable. Kinde supports all the standard OAuth 2 request parameters as well as a few additional Kinde-specific parameters to improve the end user experience. Full details can be found in the **Request parameters** table below. Kinde also supports the PKCE extension, in which case the `code_challenge` and `code_challenge_method` parameters are also required. This is recommended for mobile apps and single page applications (SPAs). ## Handling successful auth for desktop and mobile apps If you offer mobile and desktop apps, as well as access through a browser, you'll need to handle the post-authentication browser state. Rather than leaving a hanging screen, you can show users a success page. To do this, add the `is_use_auth_success_page` parameter to the authorization URL. See the [Request prameters](/developer-tools/about/using-kinde-without-an-sdk/#request-parameters) section below. ## Handling the callback As mentioned before when a user authenticates through Kinde, we will redirect them to the endpoint you defined in the previous step. As part of this redirect, Kinde provides an authorization `code` as a query parameter in the URL. Using the localhost example from before the URL would look something like: ```jsx http://localhost:3000/api/auth/kinde_callback ``` You need to extract this authorization `code` parameter from the URL and exchange it for an access token by making a POST request to the Kinde token endpoint `https://<your_kinde_subdomain>.kinde.com/oauth2/token`. As well as the `code` you have received, this request should also include parameters such as the `client_id`, `client_secret` \*\*, `redirect_uri`, and `grant_type` (which should be set to `authorization_code`). Make a POST request with the following payload: ```markdown client_id=<your_kinde_client_id> &client_secret=<your_kinde_client_secret> &grant_type=authorization_code &redirect_uri=<your_app_redirect_url> &code=<CALLBACK_AUTHORIZATION_CODE> ``` Make sure you replace the `<values>` with your own credentials. This url can now be used to return the access token which can be stored and later used to make authenticated requests on behalf of the user. Note that the `code_verifier` is also required in PKCE flow. The response body will then contain a token that you can decode. Do not include the client secret in frontend / single page applications as this is publicly viewable - instead, use the PKCE extension. ## **Supported grant types for getting access tokens** ### **Authorization Code Flow** Recommended for regular web applications rendered on the server. ### **Authorization Code Flow with Proof Key for Code Exchange (PKCE)** Kinde supports the PKCE extension, in which case the `code_challenge` and `code_challenge_method` parameters are also required. This is recommended for mobile apps and single page applications (SPAs). ### **Implicit flow (not supported)** Before PKCE (see above) this was the method used by applications that were unable to store secrets securely. This flow has security implications and Kinde does not support it for this reason. ## OAuth 2.0 scopes The following scopes can be requested from Kinde. `openid` - requests an ID token which contains information about the user `email` - requests a user's email `profile` - requests profile details as part of ID token, e.g. name, family name, given name, picture (avatar) `offline` - request to act on behalf of the user even if they're offline ## **Request parameters** There are a few useful additional parameters that Kinde supports in the authorization URL. ### `audience` The `audience` claim for the JWT. This can be used to protect your APIs and resource servers. Type: `string` Required: No ### `client_id` The unique ID of your application in Kinde. Type: `string` Required: Yes ### `code_challenge` A base64 encoded string of a SHA256 hash of a code verifier. Type: `string` Required: For PKCE ### `code_challenge_method` Should always be `S256` tells Kinde the method used to hash the code challenge above Type: `string` Required: For PKCE ### `connection_id` Connection ID for authentication method when using [Custom sign-up and sign-in pages](/developer-tools/about/using-kinde-without-an-sdk/) Type: `string` Required: When using custom sign up and sign in pages ### `is_create_org` If an organization should be created along with the user. Type: `boolean` Required: No ### `is_use_auth_success_page` Displays a sign-in success page following authentication. Recommended for browser authentication. Type: `boolean` Required: No ### `has_success_page` Show a success page at the end of the auth flow, this is useful when the callback URL is not a web page Type: `boolean` Required: No ### `lang` For selecting the UI language. Type: `string` Required: No ### `login_hint` When your project knows which user it is trying to authenticate, it can provide their email in this parameter as a hint to Kinde. Passing this hint pre-fills the email box on the sign up and sign-in screens. Type: `string` Required: No ### `org_code` For multi-tenant or platform apps, tell Kinde which organization a user is trying to sign in or sign up to. Type: `string` Required: No ### `org_name` If `is_create_org` is passed then you can optionally include the name of the organization you would like to create. Type: `string` Required: No ### `start_page` (deprecated) Accepts `login` or `registration`, but we recommend using `prompt` as per below instead. Type: `string` Required: No ### `prompt` Accepts `login` or `create` so you can determine if your user should land on the sign up or sign in page. By default, users will land on the sign in page. You can also use `none`. If you use `none` Kinde will not show authentication screens to the user. - If the user has an active SSO session, this will redirect them to the callback URL where the token exchange can occur. - If the user does NOT have an active SSO session, this will redirect them to the callback URL with the following error: ```jsx 302 https://YOUR_CALLBACK_URL? error=login_required& error_description=User+authentication+is+required& state=YOUR_STATE ``` Type: `string` Required: No ### `redirect_uri` The URL that the user will be returned to after authentication. Type: `string` Required: Yes ### `response_type` Should always be `code`. Kinde does not support the implicit flow as it has shown to be unsecure. Type: `string` Required: Yes ### `scope` The scopes to be requested from Kinde. Scopes include `openid`, `profile`, `email`, `offline`. Type: `string` Required: No ### `state` Kinde will return this to your app so you can validate it came from us and prevent CSRF attacks. Type: `string` Required: No (but recommended) ### nonce Single use code to prevent replay attacks, this will be included in the signed id token Type: `string` Required: No (but recommended) ### workflow_deployment_id workflow deployment to test, password will be requested on login Type: string Required: No ### supports_reauth When this is set to true, users state will be stored encrypted and returned back to application when accessing an expired link. Type: boolean Required: false ### reauth_state The `supports_reauth` is true, state will be returned with error, pass this back to the auth flow to restart flow. Type: string Required: No ### plan_interest Indicates which plan the user has expressed interest in to be signed up to. Type: String Required: No ### pricing_table_key Defines which pricing table to show in billing flow Type: String Required: No ## **Verifying the Kinde access token** It’s likely you will be using a library to validate your JWTs and they will require the URL for your public JSON Web Key (also known as a jwks file). The file can be found here: `https://<your_kinde_subdomain>.kinde.com/.well-known/jwks` ## **Signing out your users** When users sign out, you will want to clear any session or locally stored data in your app and redirect them to your preferred logout URL with the `redirect` parameter. Such as: ```markdown https://<your_kinde_subdomain>.kinde.com/logout?redirect=<your_logout_url> ``` This will end their session on Kinde. A new access token or refresh token needs to be issued for them to sign in again. To add a logout URL in Kinde, go to **Settings > Applications > View Details**, then add the URLs to the **Allowed logout redirect URLs** field. Users will be redirected back to this URL when they sign out.

# Developer tools - Account api - About Kinde's Account API

> Overview of Kinde's Account API for accessing user data like roles, permissions, profile, and billing entitlements using browser-scoped access tokens

account api, user access token, roles, permissions, profile, billing entitlements, feature flags, properties
developer-tools, account-api

Kinde's [Account API](https://docs.kinde.com/kinde-apis/frontend/) uses a users access token to grab data like roles, permissions, profile, billing entitlements, etc. These details can be called from a browser as the call is scoped to the user who the token is for. <Aside> Some data is intentially not available via the Accounts API. For example, plan entitlements information for organizations. This is because Accounts API data is surfaced via a browser token and passing data this way is less secure. Access the Kinde Management API to access secure data. Or contact support for guidance. </Aside> ## When to use the Kinde Account API - `properties` - show a specific promotion for users in certain regions or industries - `feature flags` - roll out beta features for a subset of users - `permissions` - only give access to certtain parts of your app based on permissions - `roles` - restrict access to functions by role, e.g. admins. - `entitlements` - to enable individual users to see plan entitlements ## Access the Account API 1. Get a user access token. This can be obtained when a user signs in via the methods you've setup in Kinde (e.g. Google, passwordless, etc). 2. Call one of the Account API endpoints using the user access token in the Authorization header as a Bearer token. Typically, you can use the getToken command in the relevant SDK. If you want an endpoint added to the [Account API library](https://docs.kinde.com/kinde-apis/frontend/), contact us via support@kinde.com.

# Developer tools - Guides - Troubleshoot code sync errors

> Troubleshooting guide for common code sync errors including deployment failures, missing exports, workflow configuration issues, and runtime error resolution.

code sync errors, troubleshooting, deployment failed, workflow triggers, default function, workflow ID, runtime errors, imports
developer-tools, guides, troubleshooting

If you’ve synced your repository to pass code to Kinde for custom pages or workflows, you may encounter errors from time to time. Here are some common issues and how to resolve them. ## Deployment failed: More than one workflow assigned to this trigger Each trigger can be mapped to only one workflow. Make sure you don’t already have a workflow using the same trigger. ## No default function exported Kinde expects a default function to be exported. Make sure the format is correct. ```jsx // Pages export default async function Page(event) { return "<div>Page content</div>"; } // Workflows export default async function Workflow(event) { // Workflow code here } ``` ## Workflow ID is required Workflows require a unique ID to be set in the `workflowSettings` object. If an ID is present in your code, this usually means the page failed to compile and the settings could not be read. ## Sync log showing no pages and no workflows Technically the sync was successful but Kinde was unable to find any pages or workflows in your repo. Check your `kindeSrc` file and default exports. ## No matching export in `"kindeKnownPackage:https://cdn.jsdelivr.net/npm/@kinde/infrastructure@latest/+esm" for import <xxxxx>` Occurs if you are trying to use a method from the Kinde infrastructure package that doesn’t exist. Check your imports. ## Runtime error: `x` is not defined at `y` Check your code for undefined variable usage.

# Developer tools - Guides - Deploy an app on Vercel

> Step-by-step guide for deploying Kinde applications on Vercel including environment variable configuration, callback URL setup, and starter kit integration.

Vercel deployment, environment variables, callback URLs, starter kits, GitHub integration, cloud deployment
developer-tools, guides, deployment, vercel

Vercel is a cloud platform which enables seamless deployment directly from a GitHub repository, offering scalability, performance, and security. You can use it to streamline the development and deployment process of applications. If you want to test what your app will look like with Kinde auth, follow this guide. Let’s deploy an app on Vercel! ## What you need - A [Vercel](https://vercel.com/) account - You can sign up free using GitHub or your email. - A [GitHub](https://github.com/) account - You can use third-party Git sources, but this tutorial will focus on GitHub. - A deployed application that uses Kinde OR a starter kit such as the [Next.js starter kit](https://github.com/kinde-starter-kits/kinde-nextjs-app-router-starter-kit). ## (Optional) Set up a project using a Kinde starter kit If you don’t have an existing project, create a project with a starter kit from Kinde. 1. Go to the [Kinde Starter Kits Github repository](https://github.com/kinde-starter-kits/) and find the starter kit you want to use. 2. Copy the starter kit by selecting **Use this template**, then select **Create a new repository**. This copies the kit content to your Github account. (You can also clone the repo to your GitHub account if you want.) 3. Enter a name for the new repository, then select **Create repository.** 4. Open the directory of the new repo and find the file called **`.env.local.sample`**. You will need this later. ## Step 1: Add a project in Vercel 1. Sign in to the Vercel [Dashboard](https://vercel.com/dashboard). You’ll see a list of all your projects if you have them. 2. In the top right, select **Add New**, then select **Project**. ![Shows new project screen in Vercel](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/6714b3d9-5725-454a-2dde-e06e6a832200/public) 3. Pick the repository you want to deploy to Vercel (e.g. the one you created above if you used the starter kit). This tutorial uses the project cloned from the previous step `vercel-nextjs-kinde`. 4. Select **Import** next to the project you want to deploy. 5. On the **Configure Project** page, expand the **Environment Variables** section: ![Environment variables in Vercel](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/b95cb15a-4f2a-4aa7-9362-51561ea1c100/public) 6. Open the local `.env` file from your project and copy all the contents. 7. Paste the details into the **Environment Variables** section in Vercel. Vercel will autofill your keys and values for you. ![Paste environment variables in Vercel](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/faa5d8a5-7d00-4db8-d477-ba6607ad6e00/public) 8. Once you are done, select **Deploy**. Your project will deploy to Vercel. This may take a minute or two. When the process is finished, you will see the **Congratulations!** page. 9. Vercel generates a public URL for accessing your site. E.g. `https://vercel-nextjs-kinde.vercel.app/`. Copy the URL to use in a later step, where we will update the Kinde callback URLs. ## Step 2: Set up your application in Kinde 1. Sign in to your [Kinde](kinde.com) business and go to **Settings.** 2. Select **Applications.** 3. If you do not have any applications yet, create one. [Follow this guide](https://docs.kinde.com/build/applications/add-and-manage-applications/). 4. If you have already created your app, select **View details** on the application tile. 5. Scroll to the **App keys** section and copy the **Domain, Client ID, and Client secret** somewhere you can access it again. ![App keys section in your Kinde app](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/f6b6879b-2e12-4255-6b7d-864b57c3a400/public) 6. Scroll to the **Callback URLs** section and enter the URL you copied when you deployed on Vercel. The URL will be something like `<NAME_OF_YOUR_PROJECT>.vercel.app`, for example `https://vercel-nextjs-kinde.vercel.app`. 7. Enter the URL in the **Application homepage URI** field, the **Application login URI** field, and the **Allowed logout redirect URLs** field. 8. If you were using `https://localhost:3000`, replace it with your new domain in the **Allowed callback URLs** field. If you're using a starter kit, this might be: `https://vercel-nextjs-kinde.vercel.app/dashboard`. ![Updating Kinde callbacks](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/e4351ab5-a0cc-446c-f124-8f941c855900/public) 9. Select **Save.** ## Step 3: Update Vercel environment variables 1. Open your [Vercel project dashboard](https://vercel.com/dashboard) and navigate to your project. Select the three dots … menu, then **Settings**. 2. Select **Environment Variables**. 3. Edit the values of each environment variable by selecting three dots menu, then selecting **Edit**. ![Update Vercel variables again](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/339ec567-e386-4393-b4bd-da0f5b34fe00/public) 4. In the window that opens, enter the new value for the variable, then select **Save**. 5. Change the variables as follows, using Kinde values: - KINDE_CLIENT_ID - KINDE_CLIENT_SECRET - KINDE_ISSUER_URL (Domain in Kinde) 6. Change the variables as follows, using Vercel values (e.g. `https://vercel-nextjs-kinde.vercel.app`): - KINDE_SITE_URL - KINDE_POST_LOGOUT_REDIRECT_URL - KINDE_POST_LOGIN_REDIRECT_URL You need to deploy your Vercel instance to apply the updated variables. 7. Go to the **Deployments** section. 8. Select the three dots … menu and select **Re-deploy**. <Aside> Do not select **Use existing Build Cache** as that will preserve the old environment variables </Aside> Your website will now be fully functional and you can authenticate with Kinde! ![Shows Kinde verification page for auth](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/d7ecbc5a-08ee-407c-f2a6-60e753198200/public) Remember, if you need any assistance with getting Kinde connected reach out to [support@kinde.com](mailto:support@kinde.com). You can also join the [Kinde community on Slack](https://join.slack.com/t/thekindecommunity/shared_invite/zt-26hdaavyc-CfOa06vP23guSwK~~OpFMQ) or the [Kinde community on Discord](https://discord.com/invite/tw5ng5tK6V) for support and advice from the team and others working with Kinde. Congratulations 🎉 on deploying your Kinde project to Vercel!

# Developer tools - Guides - Integrate Kinde with ASP.NET using Open ID Connect

> Comprehensive guide for integrating Kinde with ASP.NET using OpenID Connect including authentication setup, authorization policies, and secure route protection for MVC and Razor pages.

ASP.NET, OpenID Connect, OIDC, authentication, authorization, policies, permissions, roles, MVC, Razor pages
developer-tools, guides, dotnet, openid-connect

Kinde supports the OpenID Connect (OIDC) protocol, which allows integration with the authentication services built into ASP.NET, without the need for a separate SDK. This guide walks through the steps of integrating Kinde auth into an ASP.NET web application using OpenID Connect. A complete sample project can be found in the .NET [starter kit](https://github.com/kinde-starter-kits/dotnet-starter-kit/). ## Configure your project 1. Install the OpenID connect package: ```bash dotnet add package Microsoft.AspNetCore.Authentication.OpenIdConnect ``` 2. Add authentication services (typically in `program.cs`): ```bash builder.Services.AddAuthentication(options => { options.DefaultScheme = CookieAuthenticationDefaults.AuthenticationScheme; options.DefaultChallengeScheme = OpenIdConnectDefaults.AuthenticationScheme; }) .AddCookie() .AddOpenIdConnect(); ``` 3. Add the authentication and authorization middleware: ```bash app.UseAuthentication(); app.UseAuthorization(); ``` 4. Configure authentication in `appsettings.json`, replacing the placeholders `<your_kinde_domain>`, `<your_client_id>` and `<your_client_secret>`, with your [application keys](/get-started/connect/getting-app-keys/) found in Kinde. ```bash "Authentication": { "Schemes": { "OpenIdConnect": { "Authority": "<your_kinde_domain>", "ClientId": "<your_client_id>", "ClientSecret": "<your_client_secret>", "MapInboundClaims": false, "ResponseType": "code" } } } ``` 5. In Kinde, add an [allowed callback](/get-started/connect/callback-urls/#set-callback-urls) to your application. For local development this callback will look like the following, where `<local_port>` should be replaced with the port generated for your project: ```bash https://localhost:<local_port>/signin-oidc ``` Similarly, add an allowed logout: ```bash https://localhost:<local_port>/signout-callback-oidc ``` The OpenID Connect middleware will automatically handle requests to these routes. ## Manage authorization with policies Access tokens contain information (claims) about what a user is authorized to do when they sign in. In Kinde, you can create policies to manage authorization. ### Via permission claims (recommended) Create a policy that allows only users with certain permission claims, e.g. `read:weather` . ```csharp builder.Services .AddAuthorization(options => { options.AddPolicy("ReadWeatherPermission", policy => policy.RequireAssertion( context => context.User.Claims.Any(c => c.Type == "permissions" && c.Value == "read:weather") )); }); ``` [Set up permissions](/manage-users/roles-and-permissions/user-permissions/) in Kinde. ### Via role claims 1. [Set up Roles](/manage-users/roles-and-permissions/user-permissions/) in Kinde. 2. Add roles to the access token via custom claims, see the [token customization](/build/tokens/token-customization/) procedure. 3. Create a policy for a particular role, for example: ```csharp builder.Services .AddAuthorization(options => { options.AddPolicy("AdminRole", policy => policy.RequireAssertion( context => context.User.Claims.Any(c => c.Type == "roles" && c.Value == "admin") )); }); ``` Note roles defined in Kinde do not map to roles as defined in ASP.NET, so the related functionality, such as `RequireRole()`, cannot be used. ## Secure MVC pages To protect routes, add the `[Authorize]` attribute (from the `Microsoft.AspNetCore.Authorization` package) to any controllers or actions required. For example, allow access only to users that satisfy the policy defined in the previous section: ```csharp [Authorize(Policy = "ReadWeatherPermission")] public ActionResult Weather() ``` See the [ASP.NET Core documentation](http://ASP.NET) for more details on [authorization](https://learn.microsoft.com/en-us/aspnet/core/security/authorization/simple?view=aspnetcore-8.0#use-the-authorize-attribute). ## Secure Razor pages Razor pages can be secured by specifying the routes in service configuration, for example: ```csharp builder.Services.AddRazorPages(options => { options.Conventions.AuthorizePage("/Protected"); options.Conventions.AuthorizePage("/Weather", "ReadWeatherPermission"); }); ``` See Microsoft documentation for more details about [authorizing Razor pages](https://learn.microsoft.com/en-us/aspnet/core/security/authorization/razor-pages-authorization?view=aspnetcore-8.0). ## Log out You’ll want to log a user out of your application as well as Kinde, for example: ```csharp public async Task Logout() { await HttpContext.SignOutAsync(CookieAuthenticationDefaults.AuthenticationScheme); await HttpContext.SignOutAsync(OpenIdConnectDefaults.AuthenticationScheme); } ``` ## Additional options Kinde has some [additional options](/developer-tools/about/using-kinde-without-an-sdk/#request-parameters) such as specifying the organization to log into. These parameters can be specified in the `OnRedirectToIdentityProvider` event in the OpenID connect options. For example: ```csharp .AddOpenIdConnect(options => { options.Events.OnRedirectToIdentityProvider = context => { context.ProtocolMessage.SetParameter("org_code", "<your_org_code>"); return Task.CompletedTask; }; }); ```

# Developer tools - Kinde api - About scopes and Kinde API access

> Comprehensive guide to M2M scopes for Kinde API access, including scope examples and management procedures

scopes, jwt, api access, permissions, read:users, write:users, read:roles, write:roles
developer-tools, kinde-api

The Kinde management API uses JSON Web Tokens (JWTs) to authenticate requests. The token’s scopes claim indicates which endpoints can be accessed when calling the API. ## Example scopes - `read:users` for fetching user details. - `write:users` for modifying user details. - `read:roles` or `write:roles` for managing roles. You can select scopes when you authorize a new application or you can add scopes to an existing application. We recommend adding as few scopes as you need, to maintain API security. ## Request scopes in the body of an access token request By default token requests for an authorized application will return all the scopes enabled below. You can also optionally ask for a subset of enabled scopes to be returned by including them in the body of the access token request. You might do this to add more security to access requests, or because you want your users to be very specific about scopes in their requests. Example request ``` curl --request POST \ --url 'https://<your_subdomain>.kinde.com/oauth2/token' \ --header 'content-type: application/x-www-form-urlencoded' \ --data grant_type=client_credentials \ --data 'client_id=<your_m2m_client_id>' \ --data 'client_secret=<your_m2m_client_secret>' \ --data 'audience=https://<your_subdomain>.kinde.com/api'\ --data 'scope=read:users update:users' ``` ## Add or modify scopes for accessing the Kinde Management API Follow this procedure if you already have an application and you experience a scope error, if you want to add scopes for an application, or remove scopes to tighten security. 1. Go to **Settings > Applications** and select the relevant M2M application. 2. On the left, select **APIs**. 3. Select the three dots next to the Kinde management API, then choose **Manage scopes**. 4. Select the scopes you want to include in the token. For maximum security only enable the minimum scopes you require. 5. Select **Save**.

# Developer tools - Kinde api - Call the Kinde Management API

management api, access token, m2m application, client credentials, oauth2, api authentication
developer-tools, kinde-api

Before you can get an access token and call the Kinde Management API, follow the steps to [create and authorize a machine-to-machine (M2M) application, with scopes](/developer-tools/kinde-api/connect-to-kinde-api/). ## Get access token There are two main methods for getting an access token for the Kinde Management API. ### Method 1: Get a test access token in the Kinde Admin 1. Open the M2M application you created for API access. 2. Go to **Test**. 3. Select **Get token**. 4. Select **Use test token**. You'll be taken to the API docs with the access token prepopulated. You can now test any endpoint. For full details, see [generate a test access token for the Kinde Management API](/developer-tools/kinde-api/kinde-api-test-token/). ### Method 2: Perform a POST request to get an access token To ask Kinde for an access token for calling the management API, perform a POST request to the `https://<your_subdomain>.kinde.com/oauth2/token` endpoint, using the credentials of the M2M application you created in the prerequisite step. The payload should look as follows: <Tabs> <TabItem label="cURL"> ```shellscript curl --request POST \ --url 'https://<your_subdomain>.kinde.com/oauth2/token' \ --header 'content-type: application/x-www-form-urlencoded' \ --data grant_type=client_credentials \ --data 'client_id=<your_m2m_client_id>' \ --data 'client_secret=<your_m2m_client_secret>' \ --data 'audience=https://<your_subdomain>.kinde.com/api' ``` </TabItem> <TabItem label="C#"> ```c# var client = new RestClient("https://<your_subdomain>.kinde.com/oauth2/token"); var request = new RestRequest(Method.POST); request.AddHeader("content-type", "application/x-www-form-urlencoded"); request.AddParameter("application/x-www-form-urlencoded", "grant_type=client_credentials&client_id=<your_m2m_client_id>&client_secret=<your_m2m_client_secret>&audience=https%3A%2F%2F<your_subdomain>.kinde.com%2Fapi", ParameterType.RequestBody); IRestResponse response = client.Execute(request); ``` </TabItem> <TabItem label="Go"> ```go package main import ( "fmt "strings "net/http "io/ioutil ) func main() { url := "https://<your_subdomain>.kinde.com/oauth2/token payload := strings.NewReader("grant_type=client_credentials&client_id=<your_m2m_client_id>&client_secret=<your_m2m_client_secret>&audience=https%3A%2F%2F<your_subdomain>.kinde.com%2Fapi") req, _ := http.NewRequest("POST", url, payload) req.Header.Add("content-type", "application/x-www-form-urlencoded") res, _ := http.DefaultClient.Do(req) defer res.Body.Close() body, _ := ioutil.ReadAll(res.Body) fmt.Println(res) fmt.Println(string(body)) } ``` </TabItem> <TabItem label="Java"> ```java HttpResponse<String> response = Unirest.post("https://<your_subdomain>.kinde.com/oauth2/token") .header("content-type", "application/x-www-form-urlencoded") .body("grant_type=client_credentials&client_id=<your_m2m_client_id>&client_secret=<your_m2m_client_secret>&audience=https%3A%2F%2F<your_subdomain>.kinde.com%2Fapi") .asString(); ``` </TabItem> <TabItem label="Node.js"> ```js async function getToken() { try { const response = await fetch(`https://<your_subdomain>.kinde.com/oauth2/token`, { method: "POST", headers: { "content-type": "application/x-www-form-urlencoded" }, body: new URLSearchParams({ audience: "https://<your_subdomain>.kinde.com/api", grant_type: "client_credentials", client_id: "<your_m2m_client_id>", client_secret: "<your_m2m_client_secret>" }) }); if (!response.ok) { throw new Error(`Response status: ${response.status}`); } const json = await response.json(); console.log(json); } catch (error) { console.error(error.message); } } getToken(); ``` </TabItem> <TabItem label="Obj-C"> ```objc #import <Foundation/Foundation.h> NSDictionary *headers = @{ @"content-type": @"application/x-www-form-urlencoded" }; NSMutableData *postData = [[NSMutableData alloc] initWithData:[@"grant_type=client_credentials" dataUsingEncoding:NSUTF8StringEncoding]]; [postData appendData:[@"&client_id=<your_m2m_client_id>" dataUsingEncoding:NSUTF8StringEncoding]]; [postData appendData:[@"&client_secret=<your_m2m_client_secret>" dataUsingEncoding:NSUTF8StringEncoding]]; [postData appendData:[@"&audience=https://<your_subdomain>.kinde.com/api" dataUsingEncoding:NSUTF8StringEncoding]]; NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://<your_subdomain>.kinde.com/oauth2/token"] cachePolicy:NSURLRequestUseProtocolCachePolicy timeoutInterval:10.0]; [request setHTTPMethod:@"POST"]; [request setAllHTTPHeaderFields:headers]; [request setHTTPBody:postData]; NSURLSession *session = [NSURLSession sharedSession]; NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) { if (error) { NSLog(@"%@", error); } else { NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response; NSLog(@"%@", httpResponse); } }]; [dataTask resume]; ``` </TabItem> <TabItem label="PHP"> ```php $curl = curl_init(); curl_setopt_array($curl, [ CURLOPT_URL => "https://<your_subdomain>.kinde.com/oauth2/token", CURLOPT_RETURNTRANSFER => true, CURLOPT_ENCODING => "", CURLOPT_MAXREDIRS => 10, CURLOPT_TIMEOUT => 30, CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1, CURLOPT_CUSTOMREQUEST => "POST", CURLOPT_POSTFIELDS => "grant_type=client_credentials&client_id=<your_m2m_client_id>&client_secret=<your_m2m_client_secret>&audience=https%3A%2F%2F<your_subdomain>.kinde.com%2Fapi", CURLOPT_HTTPHEADER => [ "content-type: application/x-www-form-urlencoded ], ]); $response = curl_exec($curl); $err = curl_error($curl); curl_close($curl); if ($err) { echo "cURL Error #:" . $err; } else { echo $response; } ``` </TabItem> <TabItem label="Python"> ```python import http.client conn = http.client.HTTPSConnection("") payload = "grant_type=client_credentials&client_id=<your_m2m_client_id>&client_secret=<your_m2m_client_secret>&audience=https%3A%2F%2F<your_subdomain>.kinde.com%2Fapi headers = { 'content-type': "application/x-www-form-urlencoded" } conn.request("POST", "https://<your_subdomain>.kinde.com/oauth2/token", payload, headers) res = conn.getresponse() data = res.read() print(data.decode("utf-8")) ``` </TabItem> <TabItem label="Ruby"> ```ruby require 'uri' require 'net/http' require 'openssl' url = URI("https://<your_subdomain>.kinde.com/oauth2/token") http = Net::HTTP.new(url.host, url.port) http.use_ssl = true http.verify_mode = OpenSSL::SSL::VERIFY_NONE request = Net::HTTP::Post.new(url) request["content-type"] = 'application/x-www-form-urlencoded' request.body = "grant_type=client_credentials&client_id=<your_m2m_client_id>&client_secret=<your_m2m_client_secret>&audience=https%3A%2F%2F<your_subdomain>.kinde.com%2Fapi response = http.request(request) puts response.read_body ``` </TabItem> <TabItem label="Swift"> ```swift import Foundation let headers = ["content-type": "application/x-www-form-urlencoded"] let postData = NSMutableData(data: "grant_type=client_credentials".data(using: String.Encoding.utf8)!) postData.append("&client_id=<your_m2m_client_id>".data(using: String.Encoding.utf8)!) postData.append("&client_secret=<your_m2m_client_secret>".data(using: String.Encoding.utf8)!) postData.append("&audience=https://<your_subdomain>.kinde.com/api".data(using: String.Encoding.utf8)!) let request = NSMutableURLRequest(url: NSURL(string: "https://<your_subdomain>.kinde.com/oauth2/token")! as URL, cachePolicy: .useProtocolCachePolicy, timeoutInterval: 10.0) request.httpMethod = "POST request.allHTTPHeaderFields = headers request.httpBody = postData as Data let session = URLSession.shared let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in if (error != nil) { print(error) } else { let httpResponse = response as? HTTPURLResponse print(httpResponse) } }) dataTask.resume() ``` </TabItem> </Tabs> Make sure to replace `<your_subdomain>`, `<your_m2m_client_id>` and `<your_m2m_client_secret>` with your own details. The response will contain a signed JWT containing claims including the scopes the token is allowed to access and the expiry time. Here is an example token: ```json { "aud": [ "https://example.kinde.com/api ], "azp": "bd69bb9fe5db44a38b6b2dacd1f4b451", "exp": 1729812040, "gty": [ "client_credentials ], "iat": 1729725640, "iss": "https://example.kinde.com", "jti": "6f091ebe-44ba-4afc-bd2f-05fcccafc89e", "scope": "read:users update:users" } ``` ## Use the access token To use this token, include it in the Authorization header of your request. For example to get all users you would call: <Tabs> <TabItem label="cURL"> ```shellscript curl --request GET \ --url 'https://<your_subdomain>.kinde.com/api/v1/users' \ --header 'authorization: Bearer <m2m_access_token>' \ --header 'content-type: application/json' ``` </TabItem> <TabItem label="C#"> ```c# var client = new RestClient("https://<your_subdomain>.kinde.com/api/v1/users"); var request = new RestRequest(Method.GET); request.AddHeader("content-type", "application/json"); request.AddHeader("authorization", "Bearer <m2m_access_token>"); IRestResponse response = client.Execute(request); ``` </TabItem> <TabItem label="Go"> ```go package main import ( "fmt "net/http "io/ioutil ) func main() { url := "https://<your_subdomain>.kinde.com/api/v1/users req, _ := http.NewRequest("GET", url, nil) req.Header.Add("content-type", "application/json") req.Header.Add("authorization", "Bearer <m2m_access_token>") res, _ := http.DefaultClient.Do(req) defer res.Body.Close() body, _ := ioutil.ReadAll(res.Body) fmt.Println(res) fmt.Println(string(body)) } ``` </TabItem> <TabItem label="Java"> ```java HttpResponse<String> response = Unirest.get("https://<your_subdomain>.kinde.com/api/v1/users") .header("content-type", "application/json") .header("authorization", "Bearer <m2m_access_token>") .asString(); ``` </TabItem> <TabItem label="Node.js"> ```js async function getUsers() { try { const response = await fetch(`https://<your_subdomain>.kinde.com/api/v1/users`, { method: "GET", headers: { "content-type": "application/json", authorization: "Bearer <m2m_access_token>" } }); if (!response.ok) { throw new Error(`Response status: ${response.status}`); } const json = await response.json(); console.log(json); } catch (error) { console.error(error.message); } } getUsers(); ``` </TabItem> <TabItem label="Obj-C"> ```objc #import <Foundation/Foundation.h> NSDictionary *headers = @{ @"content-type": @"application/json", @"authorization": @"Bearer <m2m_access_token>" }; NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://<your_subdomain>.kinde.com/api/v1/users"] cachePolicy:NSURLRequestUseProtocolCachePolicy timeoutInterval:10.0]; [request setHTTPMethod:@"GET"]; [request setAllHTTPHeaderFields:headers]; NSURLSession *session = [NSURLSession sharedSession]; NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) { if (error) { NSLog(@"%@", error); } else { NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response; NSLog(@"%@", httpResponse); } }]; [dataTask resume]; ``` </TabItem> <TabItem label="PHP"> ```php $curl = curl_init(); curl_setopt_array($curl, [ CURLOPT_URL => "https://<your_subdomain>.kinde.com/api/v1/users", CURLOPT_RETURNTRANSFER => true, CURLOPT_ENCODING => "", CURLOPT_MAXREDIRS => 10, CURLOPT_TIMEOUT => 30, CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1, CURLOPT_CUSTOMREQUEST => "GET", CURLOPT_HTTPHEADER => [ "authorization: Bearer <m2m_access_token>", "content-type: application/json ], ]); $response = curl_exec($curl); $err = curl_error($curl); curl_close($curl); if ($err) { echo "cURL Error #:" . $err; } else { echo $response; } ``` </TabItem> <TabItem label="Python"> ```python import http.client conn = http.client.HTTPSConnection("") headers = { 'content-type': "application/json", 'authorization': "Bearer <m2m_access_token>" } conn.request("GET", "https://<your_subdomain>.kinde.com/api/v1/users", headers=headers) res = conn.getresponse() data = res.read() print(data.decode("utf-8")) ``` </TabItem> <TabItem label="Ruby"> ```ruby require 'uri' require 'net/http' require 'openssl' url = URI("https://<your_subdomain>.kinde.com/api/v1/users") http = Net::HTTP.new(url.host, url.port) http.use_ssl = true http.verify_mode = OpenSSL::SSL::VERIFY_NONE request = Net::HTTP::Get.new(url) request["content-type"] = 'application/json' request["authorization"] = 'Bearer <m2m_access_token>' response = http.request(request) puts response.read_body ``` </TabItem> <TabItem label="Swift"> ```swift import Foundation let headers = [ "content-type": "application/json", "authorization": "Bearer <m2m_access_token>" ] let request = NSMutableURLRequest(url: NSURL(string: "https://<your_subdomain>.kinde.com/api/v1/users")! as URL, cachePolicy: .useProtocolCachePolicy, timeoutInterval: 10.0) request.httpMethod = "GET request.allHTTPHeaderFields = headers let session = URLSession.shared let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in if (error != nil) { print(error) } else { let httpResponse = response as? HTTPURLResponse print(httpResponse) } }) dataTask.resume() ``` </TabItem> </Tabs> Make sure to replace `<your_subdomain>` with your Kinde subdomain and `<m2m_access_token>` with the token received in the previous step. ## Use the Kinde Management API JS SDK As an alternative to making HTTP calls, you can also use the [Kinde Management API JS](https://github.com/kinde-oss/management-api-js/) SDK. You can use it to automatically obtain tokens for, and interact with the Kinde management API. ## Alternative - using Postman guide ### Set up Postman environment We recommend you do this in a non-production environment first. If you decide to use Postman, we recommend that you set up a Postman environment. Here's some [troubleshooting solutions](/developer-tools/kinde-api/troubleshoot-kinde-api/) in case you need them. 1. Add your Kinde machine to machine application keys as environment variables. <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/69800dc4-2d22-468c-4300-71e4b4ee8b00/public" alt="Adding environment variables in Postman" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" /> 2. Make sure you select `Save` or the variables will not persist. ### Get the access token 1. Go to **Collections**. Create a new collection called **Kinde**. 2. In the three dots menu next to the new **Kinde** folder, select **Add request**. <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/ececdf0a-452f-49bc-6a96-f5343d8a8d00/public" alt="Adding a request in Postman" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" /> 3. Go to the **Authorization** section and set the **Type** to **OAuth 2.0** and set the **Header Prefix** to **Bearer**. 4. In the **Configure New Token > Configuration options** section, set the **Grant Type** to **Client Credentials**. 5. Enter the **Access Token URL** using the domain variable you created above. For example, `{{business_domain}}/oauth2/token`. Note that even if you use a custom domain, the access token URL should still use your `https://<your_subdomain>.kinde.com` domain. <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/8149baf6-e3b7-406d-7447-390fe4bc2100/public" alt="Entering the access token URL" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" /> 6. Enter the **Client ID** and **Client Secret** using the environment variables you created earlier or by copying them from the Kinde application. 7. Set the **audience** to `{{business_domain}}/api`. To do this: - Scroll down click **Advanced**. In the **Token request** section, select the `audience` key and enter the above URL in the **Value** field. Ensure it is being sent in the `body` of the request <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/f2c9f0dc-ef24-40e4-dae9-2d1fd6731b00/public" alt="" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" /> 8. Go to the **Headers** tab. <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/92102061-66fb-48f8-f94a-f048b80a3f00/public" alt="Setting the Content-Type value in Postman" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" /> 9. Select **Accept** and ensure the value is `application/json`. 10. In the **Authorization** section, select **Get New Access Token**. You should see a confirmation message. 11. Select **Proceed**. <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/b736bc91-3f30-4d48-62c6-37f131e88300/public" alt="Access Token in Postman" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" /> 12. Select **Use Token**. You should now have the access token for making requests to the Kinde management API. See the [Kinde API documentation](/kinde-apis/management/) for all the available end points. ### Test the API endpoints You can test your API access in Postman by sending a `GET` request to any Kinde API endpoint. See the [Kinde Management API library](/kinde-apis/management/) for options. Here’s an example using the `Get users` endpoint. 1. Create a new `GET` request. 2. Enter a URL that contains the `/users` endpoint, e.g. `https://<your_subdomain>.kinde.com/api/v1/users` . <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/44dd0ac2-b96e-4a91-79dd-4a9f9dda2000/public" alt="Entering a Request URL in Postman" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" /> 3. Send the request. It should return your users in the body section. If it does, the connection is successful. <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/8f4aae17-6f38-43e4-9bf7-55ac0bf2d300/public" alt="Response body in Postman" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" /> 4. Repeat from step 1 for any other [Kinde API endpoints](/kinde-apis/management/) you want to test.

# Developer tools - Kinde api - Call the Kinde API - NodeJS example

nodejs, management api, access token, m2m application, api example, fetch
developer-tools, kinde-api

If you don’t use Postman or other similar tools to test your connections, here’s an example of how to call the [Kinde Management API](/kinde-apis/management/) in NodeJS. 1. [Add a machine to machine application](/developer-tools/kinde-api/connect-to-kinde-api/) for API access, and copy the **App keys - Domain, Client ID** and **Client secret** from the application. 2. Call the Kinde token endpoint using the app key details you copied at step 1. Here’s a code sample in NodeJS. This should return an access token. ```jsx const getAccessToken = async () => { try { const searchParams = { grant_type: "client_credentials", client_id: "<your_client_id>", client_secret: "<your_secret_id>", audience: "https://<your_subdomain>.kinde.com/api" }; const res = await fetch("https://<your_subdomain>.kinde.com/oauth2/token", { method: "POST", headers: { "Content-Type": "application/x-www-form-urlencoded" }, body: new URLSearchParams(searchParams) }); const token = await res.json(); console.log({token}); } catch (err) { console.error(err); } }; ``` 3. Use the access token to call the Kinde management API. Here’s an example of calling the `users` endpoint in NodeJS: ```jsx const getUsers = async () => { const accessToken = await getAccessToken(); const headers = { Accept: "application/json", Authorization: `Bearer ${accessToken}` }; try { const res = await fetch("https://<your_subdomain>.kinde.com/api/v1/users", { method: "GET", headers: headers }); const data = await res.json(); console.log({data}); } catch (err) { console.error(err); } }; ``` 4. Dive into our [API docs](/kinde-apis/management/) and starting connecting your product to ours.

# Developer tools - Kinde api - API rate limits

> Documentation on Kinde API rate limits, including rate and concurrency limiters, common causes, and graceful handling strategies

rate limits, api limits, 429 error, rate limiting, concurrency limiter, exponential backoff, token bucket
developer-tools, kinde-api

Kinde may rate limit incoming traffic to help maximise API stability and prevent bursts of requests from destabilizing API functions. If you send a lot of requests in quick succession, you might see error responses with **code `429`**. For advice on handling these errors, see [Handle limiting gracefully](#handle-limiting-gracefully), below. If you suddenly see a rising number of rate-limited requests, contact Kinde support. ## API limiters Kinde has several limiters in the API, including a rate limiter and a concurrency limiter. ### Rate limiter The basic rate limiter restricts the number of API requests per minute as follows: - maximum page size of 500 per request to API GET endpoints that use the `page_size` parameter, additional results can be requested using the `page_size` and `next_token` parameters (e.g. GET `/api/v1/subscribers`) - maximum 100 objects can be updated in a single request when sending `POST/PATCH` requests to bulk endpoints (e.g. PATCH `/api/v1/organizations/{org_code}/users`) If this affects your integrations and you require an extended period with a higher limit please get in touch. ## Common causes Rate limiting can occur under a variety of conditions, but it’s most common in these scenarios: - Running a large volume of closely-spaced requests can lead to rate limiting. Often this is part of an analytical or migration operation. When engaging in these activities, you should try to control the request rate on the client-side. - Issuing many long-lived requests can trigger limiting. Requests vary in the amount of Kinde’s server resources they use, and more resource-intensive requests tend to take longer and run the risk of causing new requests to be shed by the concurrency limiter. - Resource requirements vary, but list requests and requests that include expansions generally use more resources and take longer to run. We suggest profiling the duration of Kinde API requests, and watch for timeouts to try and spot those that are unexpectedly slow. - A sudden increase in volume like the bulk addition of new users can result in rate limiting. We try to set our rates high enough that legitimate user traffic never exceeds the limits, but if you suspect that an upcoming event might push you over the limits listed above, contact us to increase limits for you. ## Handle limiting gracefully Graceful handling involves monitoring for `429` status codes and triggering a retry method. The header `RateLimit-Reset` will return the number of seconds until the rate limit is reset. Your method should follow an exponential back-off schedule to reduce request volume as needed. We also recommend building randomness into the back-off schedule to avoid a ‘thundering herd’ effect. Another method is to manage traffic at a global level, and throttle it back if you detect substantial rate limiting. A common technique for controlling rate is to implement something like a token bucket rate limiting algorithm on the client-side. Ready-made and mature implementations for token bucket can be found in most programming languages.

# Developer tools - Kinde api - Set up Kinde Management API access

> Step-by-step guide to setting up M2M applications and authorizing them for Kinde Management API access with proper scopes

management api, m2m application, api access, scopes, authorization, access token, machine to machine
developer-tools, kinde-api

In order to call the Kinde Management API, you will need a Kinde management API access token. These tokens are generated by using an authorized M2M application to call the Kinde token endpoint. This guide shows you how to set up a new machine to machine (M2M) application, and authorize it for Kinde Management API access. ## Step 1: Add a machine to machine application 1. Go to **Settings > Applications**. 2. Select **Add Application**. The **Add application** dialog opens. 3. Give the application a name, and select **Machine to Machine** as the **Application type**. 4. Select **Save**. App keys - including Domain details, Client ID and Client Secret - are issued for the application. 5. Select **View details** on the new application and copy the app keys. You need these details to test or initiate access requests from your application or service to Kinde's API. See Step 4 below. ## Step 2: Authorize the M2M application Only authorized M2M applications are allowed to access the Kinde management API. Without this step you will receive an error when calling the Kinde management API. 1. Select **View details** on the M2M application you just created. 2. On the left, select **APIs**. 3. Select the three dots next to the Kinde Management API, then choose **Authorize application**. ## Step 3: Select scopes Each Kinde endpoint requires specific permissions to be present in the token, to grant access to it. These are known as scopes. If a scope is not in the access token, the API will return an error indicating which scope is required. 1. Select the three dots next to the relevant Kinde management API, then choose **Manage scopes**. 2. Select the scopes you want to include in the token. For maximum security only enable the minimum scopes you require. 3. Select **Save**. ## Step 4: Get an access token and call the Kinde Management API - Fast method: Generate a [test access token](/developer-tools/kinde-api/kinde-api-test-token/) in Kinde. - Other methods: Follow [this guide](/developer-tools/kinde-api/access-token-for-api/) that includes several different options for getting an access token, including via Postman. ## How M2M tokens are calculated in Kinde An M2M token is generated each time you call the `/oauth2/token` Kinde API endpoint to retrieve an M2M access token. Where an access token is re-used - say where the same token is used to make another API request, this does not count as a new token. Similarly, where a token is re-used to make calls to other Kinde-registered APIs, this is also not counted as another token. Kinde’s free and Pro plans have a generous amount of M2M tokens included, before we start charging for them. For details, see our [pricing page](https://kinde.com/pricing/). ## Video demo: Get a test token for accessing the Kinde Management API Watch a video about how easy it is to test the Kinde Management API on our YouTube channel [here](https://www.youtube.com/watch?v=iqO7CL3QyY8).

# Developer tools - Kinde api - Get token to test the Kinde Management API

> Guide to generating test tokens for the Kinde Management API using the Kinde admin interface for quick testing

test token, management api, m2m application, api testing, token generation
developer-tools, kinde-api

Kinde lets you quickly generate a test token for testing the Kinde Management API with your M2M application. This can save you time generating a token via Postman or other service. This process assumes you have [set up access to the Kinde Management API](/developer-tools/kinde-api/connect-to-kinde-api/). 1. In Kinde, go to **Settings > APIs**. 2. Select **View details** on the Kinde Management API. 3. Select **Test** in the menu. 4. Select the authorized M2M application, then select **Get token**. Token details are generated. ![shows the generated token for copying and using](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/321a49c0-f629-4c7a-9ef2-349ad0f31f00/public) 5. Copy the code and use it to test. 6. Or, select **Use test token.** The Kinde Management API docs opens with the test token pre-populated. ![Shows Kinde Management API page showing test token in use](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/72840d32-1f90-4fc3-30e9-40074f163f00/public) - Search for the endpoint you want to test. - Select **Test request** in the code snippet. ![Shows API code snippet and test request button](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/833a2c93-61ad-4fa7-8999-4b9ac4a44f00/public) - The test will complete using the test token you generated.

# Developer tools - Kinde api - Search users via the Kinde API

> Guide to searching and filtering users via the Kinde Management API using query parameters and property filters

search users, api search, user filtering, properties filter, wildcard search, management api
developer-tools, kinde-api

You can search users and filter results via the Kinde Management API. You might need to do this to isolate users with specific properties defined, for example, to find users in a particular city. ## Make an API search request Search with `GET` request: `/api/v1/search/users?query=searchterm` Add additional filters to the request: `&filterA=X&filterB=Y` Search and filter: GET `/api/v1/search/users?query=searchterm&filterA=X&filterB=Y` The query= part is for searching by user name or email, additional filters can be applied separately. For example, use /api/v1/search/users?query=*&properties[kp_user_city]=Sydney to find all users from Sydney based on the kp_user_city property. Here's some examples of search requests with different filter types. - Filter for users with multiple properties using AND(&) statements. ```/api/v1/search/users?query=properties[kp_usr_last_name]=Swan&properties[kp_usr_industry]=Construction``` - Filter for users with any property filter using OR(comma) statements. ```/api/v1/search/users?query=properties[kp_usr_last_name]=Hornet,Swan``` - Use a combination of filters. ```/api/v1/search/users?query=properties[kp_usr_last_name]=Hornet,Swan&properties[kp_usr_industry]=Construction&expand=identities,properties``` - Wildcards can also be used. ```/api/v1/search/users?query=*&properties[kp_usr_middle_name]=Hornet,Swan&properties[kp_usr_industry]=Construction&expand=identities,properties``` ## Example response ```jsx { "results": [ { "id": "kp_8ef060c544584c51b255e83416818c12", "email": "big.turtle42350@site.com", "phone": null, "picture": null, "username": null, "full_name": null, "last_name": null, "created_on": "2025-02-05T11:23:22.634233+00:00", "first_name": null, "identities": [ { "type": "email", "identity": "big.turtle42350@site.com" } ], "properties": { "kp_usr_industry": "Construction", "kp_usr_middle_name": "Hornet" }, "provided_id": null, "is_suspended": false, "organizations": [ "org_d36a3f3f3c7 ], "last_signed_in": null, "total_sign_ins": 0, "failed_sign_ins": 0 } ] "code": "OK", "message": "Success" ```

# Developer tools - Kinde api - Troubleshooting Kinde API access

> Troubleshooting guide for common Kinde API issues including null responses and scope errors

troubleshooting, api errors, null response, scope errors, token customization, custom claims
developer-tools, kinde-api

There's a lot of configurations and events that support API connections. Sometimes things go wrong. Here's a few common errors people come across. ## When a request returns `null` When you request to receive data back via the API and get an unexpected or `null` response, you may need to add custom claims to the token. 1. In Kinde, go to **Settings > Applications** and open the relevant application. 2. Select **Tokens** in the menu. 3. Scroll to the **Token customization** section. 4. Select **Customize** on the Access or ID token type and switch on / select any claims or properties you want to include in the token. 5. Select **Save**. For more detailed information, see [Token customization](/build/tokens/token-customization/) ## Kinde Management API scope errors Access to Kinde's Management API is limited by scopes. When you create or update a M2M application, you need to review and select scopes. If you find that some information is not included in a returned token, check the scopes. 1. In Kinde, go to **Settings > Applications** and select **View details** on the relevant M2M application. 2. Select **APIs** in the menu. 3. In the **Kinde Management API** entry, select the three dots menu and select **Manage scopes**. 4. Select and deselect scopes as required. 5. Select **Save**.

# Developer tools - Sdks - Node/Apollo GraphQL

> Guide to securing Node.js Apollo GraphQL endpoints with Kinde authentication, including backend and React client integration.

apollo graphql, nodejs, authentication, bearer token, authorization, react, context
developer-tools, sdks, apollo, graphql, backend

These instructions assume you already have a Kinde account. You can [register for free here](https://app.kinde.com/register) (no credit card required). This guide details how to protect your GraphQL endpoints, when running on Node.js. It assumes you already have a front end connected to Kinde which is sending a Kinde issued bearer token to your API for verification. If you don’t yet have a front end setup, please set this up first following the relevant guide: [React](/developer-tools/sdks/frontend/react-sdk/) [Next.js](/developer-tools/sdks/backend/nextjs-sdk/) [VanillaJS](/developer-tools/sdks/frontend/javascript-sdk/) ## **Apollo Server** You can use our Node.js SDK to secure your endpoints and check that the user is authorized to access them. ## **Configure Apollo** ### **Add Kinde Node as a dependency** <PackageManagers pkg="@kinde-oss/kinde-node" /> ### **Environments** If you would like to use our Environments feature as part of your development process. You will need to create them first within your Kinde account, see the guide here. In this case you would use the Environment subdomain in the code block above. ### **Integrate with your app** Import the library as you would any other Node package - we recommend you do this in you `app.js` or `index.js` file depending on your structure. ```jsx const kindeNode = require("kinde-node"); ``` ### **Initialize** In the same file after any other imports initialize the library by entering your Kinde domain. This grabs the verification keys for your app. ```jsx let authorize; (async () => { authorize = await kindeNode(YOUR_KINDE_DOMAIN); })(); ``` ### **Protect!** The Apollo docs provide a few ways [for securing your APIs](https://www.apollographql.com/docs/apollo-server/security/authentication/). We will use the approach of adding the user object to the context. ```jsx const server = new ApolloServer({ typeDefs, resolvers, context: ({req}) => { // auth check on every request const user = new Promise((resolve, reject) => { authorize(req, (err, user) => { if (err) { return reject(err); } resolve(user); }); }); return { user }; } }); ``` It’s pretty common that a Graph will have a mix of public and private fields. Because we’ve added the user to context we can access this in the individual field resolvers and decide what to return. As an example, this resolver is only accessible with a valid user: ```jsx users: (parent, args, context) => { // In this case, we'll pretend there is no data when // we're not logged in. Another option would be to // throw an error if (!context.user) return null; return ["bob", "jake"]; }; ``` If a user is not authorized you can make use of the built in Apollo helper `AuthenticationError` to return a suitable response. ### **Apollo client - with React** Once you have [integrated Kinde with your React application](/developer-tools/sdks/frontend/react-sdk/) using the Kinde React SDK you can enhance it to support the Apollo client. ### **Integrate with your app** We recommend creating a specific component in your app to handle the Apollo / Kinde integration: ```jsx import React from "react"; import {ApolloClient, InMemoryCache, ApolloProvider, createHttpLink} from "@apollo/client"; import {setContext} from "@apollo/client/link/context"; import {useKindeAuth} from "@kinde-oss/kinde-auth-react"; const KindeApolloProvider = ({children}) => { const {getToken} = useKindeAuth(); const httpLink = createHttpLink({ uri: [YOUR_GRAPHQL_URI_HERE] }); const authLink = setContext((_, {headers}) => { // get the authentication token from local storage if it exists const token = localStorage.getItem("kinde_token"); const parsedToken = token ? JSON.parse(token) : {}; // return the headers to the context so httpLink can read them return { headers: { ...headers, authorization: token ? `Bearer ${parsedToken.access_token}` : "" } }; }); const client = new ApolloClient({ link: authLink.concat(httpLink), cache: new InMemoryCache() }); return <ApolloProvider client={client}>{children}</ApolloProvider>; }; export default KindeApolloProvider; ``` Then you can use it in your app as follows. ```jsx import {KindeProvider} from "@kinde-oss/kinde-auth-react"; const App = () => ( <KindeProvider domain="[YOUR_KINDE_DOMAIN]" redirectUri={window.location.origin}> <KindeApolloProvider> <Routes /> </KindeApolloProvider> </KindeProvider> ); ``` This will ensure every API call to your Apollo server contains the Bearer token provided by Kinde. If you need any assistance with getting Kinde connected reach out to us at [support@kinde.com](mailto:support@kinde.com).

# Developer tools - Sdks - .NET SDK

> Guide to using the Kinde .NET SDK for integrating with the Management API, including installation, configuration, and API calls for user and organization management.

dotnet sdk, csharp, nuget, management api, asp.net, openid connect, machine to machine, kinde client
developer-tools, sdks, backend

{/* @case-police-ignore Api */} {/* @case-police-ignore Mvc */} {/* @case-police-ignore Html */} Kinde auth can be integrated into your application without the need for an SDK. Follow the appropriate guide to secure your API or use OpenID Connect to secure your web application: - [Integrate with ASP.NET based APIs](/developer-tools/your-apis/dotnet-based-apis/) - [Integrate with ASP.NET using Open ID Connect](/developer-tools/guides/dotnet-open-id-connect/) The Kinde .NET SDK allows developers to quickly and securely call the Kinde Management API. The Kinde SDK is available from the Nuget package repository at [https://www.nuget.org/packages/Kinde.SDK](https://www.nuget.org/packages/Kinde.SDK) ## Before you begin - Kinde .NET SDK supports .NET 6.0+ - If you haven’t already got a Kinde account, [register for free here](https://app.kinde.com/register) (no credit card required). Registering gives you a Kinde domain, which you need to get started, e.g. `yourapp.kinde.com`. - Create a [machine to machine application for Kinde Management API access](/developer-tools/kinde-api/connect-to-kinde-api/). ## Add packages to your application Use `Dotnet CLI` or `NuGet CLI` to add packages in your project. Dotnet CLI: ```bash dotnet add package Kinde.SDK ``` NuGet: ```bash NuGet\Install-Package Kinde.SDK ``` This command is intended to be used within the Package Manager Console in Visual Studio, as it uses the NuGet module's version of Install-Package. ## Configure API client Create and authorize a new client: ```csharp var client = new KindeClient(new ApplicationConfiguration("<your-kinde-domain>", "", ""), new KindeHttpClient()); await client.Authorize(new ClientCredentialsConfiguration("<your-client-id>", "", "<your-client-secret>", "https://<your-kinde-domain>/api")); ``` Replacing `<your-kinde-domain>` with your Kinde domain, `<your-client-id>` and `<your-client-secret>` with your machine to machine app keys. ## Call management API The client can be used to call the management API. For example, listing users: ```csharp var usersApi = new UsersApi(client); var users = await usersApi.GetUsersAsync(); foreach (var user in users.Users) { Console.WriteLine($"Id: {user.Id}, Email: {user.Email}, Name: {user.FirstName} {user.LastName}."); } ``` Note this requires the `read:users` scope to be added to the API in the machine to machine application in Kinde. An example of creating an organization then renaming it: ```csharp var orgApi = new OrganizationsApi(client); var newOrg = await orgApi.CreateOrganizationAsync(new CreateOrganizationRequest("My new organization")); var response = await orgApi.UpdateOrganizationAsync(newOrg.Organization.Code, new UpdateOrganizationRequest() { Name = "A different name }); ``` Note this requires the `create:organizations` and `update:organizations` scopes to be added to the API in the machine to machine application in Kinde. For full details of the available management API functions, see the [Kinde Management API specification](/kinde-apis/management/). If you need help getting Kinde connected, contact us at [support@kinde.com](mailto:support@kinde.com).

# Developer tools - Sdks - Elixir SDK

> Complete guide for Elixir SDK including OAuth flows, Phoenix integration, token management, and user authentication for Elixir applications.

Elixir SDK, OAuth flows, client credentials, authorization code, PKCE, Phoenix, environment variables
developer-tools, sdks, elixir, backend

The Kinde Elixir SDK allows developers to connect their Elixir app to Kinde. This document is relevant for up to Elixir v1.2.0. You can also view the [Elixir docs](https://github.com/kinde-oss/kinde-elixir-sdk) and [Elixir starter kit](https://github.com/kinde-starter-kits/elixir-starter-kit) in GitHub. ## Register for Kinde If you haven’t already got a Kinde account, [register for free here](https://app.kinde.com/register) (no credit card required). Registering gives you a Kinde domain, which you need to get started, e.g. `yourapp.kinde.com`. ## Install Install erlang and elixir. Update the deps, update path to the SDK in `mix.exs`. ```elixir {:kinde_sdk, "~> 1.2.0"} ``` Add to your extra applications in `mix.exs`. ```elixir def application do [ extra_applications: [:logger, :kinde_sdk] ] end ``` ## Set callback URLs 1. In Kinde, go to **Settings > Applications > [Your app] > View details**. 2. Add your callback URLs in the relevant fields. For example: - Allowed callback URLs (also known as redirect URIs) - for example, `http://localhost:4000/callback` - Allowed logout redirect URLs - for example, `http://localhost:4000` 3. Select **Save**. **Note:** The `http://localhost:4000` is an example of a commonly used local development URL. It should be replaced with the URL where your app is running. ## Add environments Kinde comes with a production environment, but you can set up other environments if you want to. Note that each environment needs to be set up independently, so you need to use the Environment subdomain in the code block above for those new environments. ## Configure your app **API Keys** Follow these steps to set up the project: 1. Create a .env file at the root directory. 2. Add the following, but change the `“values”` to match your own information. ```elixir export KINDE_BACKEND_CLIENT_ID="test_x1y2z3a1 export KINDE_FRONTEND_CLIENT_ID="test_a1b2c3d4 export KINDE_CLIENT_SECRET="test_112233 export KINDE_REDIRECT_URL="http://text.com/callback export KINDE_DOMAIN="https://test.kinde.com export KINDE_LOGOUT_REDIRECT_URL="http://text.com/logout export KINDE_PKCE_LOGOUT_URL="http://test.com/logout export KINDE_PKCE_REDIRECT_URL="http://test.com/pkce-callback export KINDE_BASE_URL="https://app.kinde.com ``` 1. If required, set the scopes. You can include scopes such as `openid` `profile` `offline`, in addition to `email`. ```elixir config :kinde_sdk, scope: "email" ``` 1. Open the console and write `source .env` before any mix command. **Environment variables** You can also set these variables in .env file within your project directory. The following variables need to be replaced in the code snippets. - `KINDE_HOST` - your Kinde domain - e.g. `https://yourkindedomain.kinde.com` - `KINDE_REDIRECT_URL` - your callback url, make sure this URL is under your allowed callback redirect URLs. - e.g. `http://localhost:4000/callback` - `KINDE_POST_LOGOUT_REDIRECT_URL` - where you want users to be redirected to after logging out, make sure this URL is under your allowed logout redirect URLs. - e.g. `http://localhost:4000` - `KINDE_CLIENT_ID` - you can find this on the **Application details** page - `KINDE_CLIENT_SECRET` - you can find this on the **Application details** page ## Usage Execute following in your terminal to run: ```elixir mix deps.get mix phx.server ``` ## **OAuth Flows (Grant Types)** The KindeClientSDK struct implements three OAuth flows: - Client Credentials flow - Authorization Code flow - Authorization Code with PKCE flow Each flow can be used with their corresponding grant type when initializing a client. | **OAuth Flow** | **Grant Type** | **Type** | | ---------------------------- | ----------------------------- | -------- | | Client Credentials | :client_credentials | atom | | Authorization Code | :authorization_code | atom | | Authorization Code with PKCE | :authorization_code_flow_pkce | atom | ## Integrate with your app Create a new instance of the Kinde Auth client object before you initialize your app: ```elixir {conn, client} = KindeClientSDK.init( conn, Application.get_env(:kinde_sdk, :domain), Application.get_env(:kinde_sdk, :redirect_url), Application.get_env(:kinde_sdk, :backend_client_id), Application.get_env(:kinde_sdk, :client_secret), :client_credentials, Application.get_env(:kinde_sdk, :logout_redirect_url) ) ``` ## Log in and registration The Kinde client provides methods for easy log in and registration. You can add buttons in your HTML as follows: ```html <div class="navigation"> <a href="/login" type="button">Login</a> <a href="/register" type="button">Register</a> </div> ``` You will also need to route `/login` and `/register` to the SDK methods: ```elixir conn = KindeClientSDK.login(conn, client) conn = KindeClientSDK.register(conn, client) ``` ## **Test sign up** Register your first user by signing up yourself. You’ll see your newly registered user on the **Users** page of the relevant organization (or default organization) in Kinde. ## Manage redirects When the user is redirected back to your site from Kinde, this will call your callback URL defined in the `KINDE_REDIRECT_URL` variable. You will need to route `/callback` to call a function to handle this. ```elixir def callback(conn, _params) do {conn, client} = KindeClientSDK.get_token(conn) data = KindeClientSDK.get_all_data(conn) end ``` ## **Tokens** We use the Kinde helper function to get the tokens generated by `login` and `get_token`. ```elixir data = KindeClientSDK.get_all_data(conn) IO.inspect(data.login_time_stamp, label: "Login Time Stamp") ``` Or first calling the `get_token` function: ```elixir {conn, client} = KindeClientSDK.get_token(conn) ``` Example of a returned token: ```elixir %{ "access_token" => "eyJhbGciOiJSUzI1...", "expires_in" => 89274, "scope" => "openid profile email offline", "token_type" => "bearer } ``` ## **User details** This function returns the user object including Kinde ID. This function reads the information from the `id_token` that is returned after successful authentication. Include the required scopes if not added already (`openid profile email offline`). ```elixir KindeClientSDK.get_user_detail(conn) ``` **Note:** You need to have already authenticated before you call the API, otherwise an error will occur. ## **View users in Kinde** Go to the **Users** page in Kinde to see who has registered. ## O**rganizations** **Create an organization** There is an additional `create_org` method which allows an organization to be created. This method calls the current sign-up logic by setting the `is_create_org` parameter to true. Use this helper function to create an organization. ```elixir conn = KindeClientSDK.create_org(conn, client) conn = KindeClientSDK.create_org(conn, client) ``` **Sign up and sign in to organizations** Kinde has a unique code for every organization. You’ll have to pass this code when creating a client or registering a new user: `additional_parameters_org_code`. If you want a user to sign in to a particular organization, pass this code along with the sign in method. For more information about how organizations work in Kinde, see [Kinde organizations for developers](/build/organizations/orgs-for-developers/). ## **Logout** The Kinde SDK client comes with a logout method. ```elixir conn = KindeClientSDK.logout(conn) ``` ## **Authenticated** Returns whether if a user is signed in by verifying that the access token is still valid. ```elixir KindeClientSDK.authenticated?(conn) ``` ## **Claims** We have provided a helper to grab any claim from your ID or access tokens, which accepts a key for a token and returns the claim value. There is also an optional argument to define which token to check. The helper defaults to access tokens. ```elixir KindeClientSDK.get_claims(conn) KindeClientSDK.get_claim(conn, "jti", :id_token) ``` This function will returns claims as follows. ```elixir %{ "aud" => [], "azp" => "", "exp" => 1649314, "gty" => ["client_credentials"], "iat" => 1662914, "iss" => "https://smith.com", "jti" => "7fa15b8-086-495-bba-b191b2aa2f", "scp" => ["openid", "profile", "email", "offline"] } ``` For example, when a key is accepted for a token as `KindeClientSDK.get_claim(conn, "jti", :id_token)` the return claim value would be as follows. ```elixir "57012a4-82ca-41f-8f19-0a5c3cc653 ``` ## **Permissions** When a user signs in to an organization the access token your product/application contains a custom claim with an array of permissions for that user. You can set permissions in your Kinde account. Here’s an example. ```json "permissions":[ "create:todos", "update:todos", "read:todos", "delete:todos", "create:tasks", "update:tasks", "read:tasks", "delete:tasks", ] ``` For more details See [Define user permissions](/manage-users/roles-and-permissions/user-permissions/). We provide helper functions to more easily access permissions. ```elixir KindeClientSDK.get_permissions(conn) KindeClientSDK.get_permission(conn, "create:todos") ``` `get_permission` checks the permission value and returns if it is granted or not (i.e. checks if permission key exists in the `permissions` claim array) and checks the relevant org code by checking against claim `org_code`. ## **Audience** An `audience` is the intended recipient of an access token - for example the API for your application. The audience argument can be passed to the Kinde client to request an audience be added to the provided token. ```elixir additional_params = %{ audience: "api.yourapp.com" } KindeClientSDK.init( conn, Application.get_env(:kinde_sdk, :domain), Application.get_env(:kinde_sdk, :redirect_url), Application.get_env(:kinde_sdk, :backend_client_id), Application.get_env(:kinde_sdk, :client_secret), :authorization_code_flow_pkce, Application.get_env(:kinde_sdk, :logout_redirect_url), "openid profile email offline", additional_params ) ``` For details on how to connect, see [Register an API](/developer-tools/your-apis/register-manage-apis/). ## **Overriding scope** By default the KindeSDK requests the following scopes: - profile - email - offline - openid You can override this by passing scope into the KindeSDK. ## **Persisting authentication state on page refresh or new tab** When a user refreshes the page or opens a new tab, the authentication state can be lost. To work around this issue, there are two possible solutions: - Use cookies to store the authentication token. This can be done by setting an `httpOnly` cookie with the authentication token, which will be sent to the server with every request, allowing the server to maintain the authentication state. - Use a session store to store the authentication token. Elixir has several session store options available, including using a database, in-memory cache, or distributed cache. Once one of these solutions is implemented, there is no need for additional action to persist the authentication state. ## **Token storage** Once the user has successfully authenticated, you’ll have a JWT and possibly a refresh token that should be stored securely. ## API reference - C**reate Kinde Client** ### `domain` Either your Kinde URL or your custom domain. e.g `https://yourapp.kinde.com` Type: `string` Required: Yes ### `redirect_url` The URL that the user will be returned to after authentication. Type: `string` Required: Yes ### `backend_client_id` The unique ID of your backend application in Kinde. Type: `string` Required: Yes ### `frontend_client_id` The unique ID of your frontend application in Kinde. Type: `string` Required: Yes ### `client_secret` The unique client secret associated with your application in Kinde. Type: `string` Required: No ### `logout_redirect_url` Where your user will be redirected upon logout. Type: `string` Required: No, except for PKCE flow ### `scope` The scopes to be requested from Kinde. Type: `string` Required: No Default: `openid profile email offline` ### `additional_parameters` Additional parameters that will be passed in the authorization request. Type: `map` Required: No Default: `%{}` ### `additional_parameters_audience` The audience claim for the JWT. Type: `string` Required: No ### `additional_parameters_org_name` The org claim for the JWT. Type: `string` Required: No ### `additional_parameters_org_code` The org claim for the JWT. Type: `string` Required: No ## API reference - Kinde Client **Functions** ### `login` Constructs a redirect URL and sends the user to Kinde to sign in. Arguments: `conn, client` Usage: ```elixir KindeClientSDK.login(conn, client) ``` Sample output: `redirect` ### `register` Constructs a redirect URL and sends the user to Kinde to sign up. Arguments: `conn, client` Usage: ```elixir KindeClientSDK.register(conn, client) ``` Sample: `redirect` ### `logout` Logs the user out of Kinde. Arguments: `conn` Usage: ```elixir KindeClientSDK.logout(conn) ``` Sample: `redirect` ### `get_token` Returns the raw access token from URL after logged in from Kinde. Arguments: `conn` Usage: ```elixir KindeClientSDK.get_token(conn) ``` Sample: ```elixir eyJhbGciOiJIUzI1... ``` ### `create_org` Constructs the redirect URL to sign up and create a new organization in your business. Arguments: `conn`, `atom` Usage: ```elixir KindeClientSDK.create_org(conn, client) ``` Sample: `redirect` ### `get_claim` Gets a claim from an access or ID token. Arguments: `conn, string, atom` Usage: ```elixir KindeClientSDK.get_claim(conn, "jti") or KindeClientSDK.get_claim(conn, "jti", :id_token) ``` Sample: ```elixir %{name: "iss", value: "https://elixirsdk2.kinde.com"} ``` ### `get_claims` Gets all claims from an access or ID token. Arguments: `conn, atom` Usage: ```elixir KindeClientSDK.get_claims(conn) or KindeClientSDK.get_claims(conn, :id_token) ``` Sample: ```elixir %{"aud" => [], "azp" => "", ...} ``` ### `get_permission` Returns the state of a given permission. Arguments: `conn, string` Usage: ```elixir KindeClientSDK.get_permission(conn, "create:users") ``` Sample: ```elixir %{org_code: 'org_1234', is_granted: true} ``` ### `get_permissions` Returns all permissions for the current user for the organization they are signed into. Arguments: `conn, atom` Usage: ```elixir KindeClientSDK.get_permissions(conn, :id_token) ``` Sample: ```elixir %{org_code: 'org_1234', permissions: ['create:todos', 'update:todos', 'read:todos']} ``` ### `get_organization` Get details for the organization your user is signed into. Arguments: `conn` Usage: ```elixir KindeClientSDK.get_user_organization(conn) ``` Sample: ```elixir %{org_code: "org_9d78"} ``` ### `get_organizations` Gets an array of all organizations the user has access to. Arguments: `conn` Usage: ```elixir KindeClientSDK.get_user_organizations(conn) ``` Sample: ```elixir %{org_codes: ["org_9d78", "org_aca6c", "org_27e56"]} ``` ### `get_user_details` Returns the profile for the current user. Arguments: `conn` Usage: ```elixir KindeClientSDK.get_user_detail(conn) ``` Sample: ```elixir %{ email: "dev@smit.com", family_name: "Smith", given_name: "Dave", id: "kp:abcdef" } ``` ### `get_cache_pid` Returns the Kinde cache PID from the `conn`. Arguments: `conn` Usage: ```elixir KindeClientSDK.get_cache_pid(conn) ``` Sample: ```elixir #PID ``` ### `save_kinde_client` Saves the Kinde client created into the `conn`. Arguments: `conn` Usage: ```elixir KindeClientSDK.save_kinde_client(conn) ``` Sample: ```elixir :ok ``` ### `get_kinde_client` Returns the Kinde client created from the `conn`. Arguments: `conn` Usage: ```elixir KindeClientSDK.get_kinde_client(conn) ``` Sample: ```elixir %KindeClientSDK{ cache_pid: #PID<0.123.0>, domain: "abcd.com", redirect_uri: "…/callback", logout_redirect_uri: … } ``` ### `get_all_data` Returns all the Kinde data (tokens) returned. Arguments: `conn` Usage: ```elixir KindeClientSDK.get_all_data(conn) ``` Sample: ```elixir %{ access_token: "eyJhbGciOiJSU…”," expires_in: 1234, id_token: “abcdedhjshfsjg”,… } ``` ## **Feature flag helper functions** ### `get_flag/2` Details of a feature-flag. Arguments: `conn, code` Usage: ```elixir KindeClientSDK.get_flag(conn, code) ``` Sample output: ```elixir flag: %{ "code" => "theme", "is_default" => false, "type" => "string", "value" => "grayscale } ``` ### `get_flag/3` The default value of a feature flag. Arguments: `conn, code`, `default value` Usage: ```elixir KindeClientSDK.get_flag(conn, code, default_value) ``` Sample output: ```elixir flag: %{ "code" => "create_competition", "is_default" => true, "value" => false } ``` ### `get_flag/4` The type and default value of a feature flag. Arguments: `conn, code, default value, flag_type` Usage: ```elixir KindeClientSDK.get_flag(conn, code, default_value, flag_type) ``` Sample output: ```elixir flag: %{ "code" => "theme", "is_default" => true, "value" => "black } ``` ### `get_boolean_flag/2` Returns the boolean flag. Arguments: `conn, code` Usage: ```elixir KindeClientSDK.get_boolean_flag(conn, code) ``` Sample output: ```elixir **true** | **false** | flag: "Error e.g flag does not exist and no default provided”" ``` ### `get_boolean_flag/3` Returns the boolean flag value. Arguments: `conn, code, default value` Usage: ```elixir KindeClientSDK.get_boolean_flag(conn, code, default_value) ``` Sample output: ```elixir flag: false ``` ### `get_string_flag/2` Returns the string flag value. Arguments: `conn, code` Usage: ```elixir KindeClientSDK.get_string_flag(conn, code) ``` Sample output: corresponding values from object or error-messages ### `get_string_flag/3` Returns the string flag value. Arguments: `conn, code, default value` Usage: ```elixir KindeClientSDK.get_string_flag(conn, code, default_value) ``` Sample output: ```elixir flag: "black”" ``` ### `get_integer_flag/2` Returns the integer flag value. Arguments: `conn, code` Usage: ```elixir KindeClientSDK.get_integer_flag(conn, code) ``` Sample output: corresponding values from object or error-messages ### `get_integer_flag/3` Returns the integer flag value. Arguments: `conn, code, default value` Usage: ```elixir KindeClientSDK.get_integer_flag(conn, code, default_value) ``` Sample output: ```elixir flag: 46 ``` If you need help connecting to Kinde, please contact us at [support@kinde.com](mailto:support@kinde.com).

# Developer tools - Sdks - Express.js SDK

express.js, nodejs, authentication, jwt verification, route protection, middleware, session management
developer-tools, sdks, express, backend

If you haven’t already got a Kinde account, [register for free here](https://app.kinde.com/register) (no credit card required). Registering gives you a Kinde domain, which you need to get started, e.g. `yourapp.kinde.com`. This topic assumes you are building with ExpressJS and have the relevant `express` packages already installed. You can view Kinde’s [Express JS docs](https://github.com/kinde-oss/kinde-node-express) and [Express JS starter kit](https://github.com/kinde-starter-kits/expressjs-starter-kit) in GitHub. ## Set up your app ### Add Kinde ExpressJS SDK as a dependency Node version 18.x.x or newer. <PackageManagers pkg="@kinde-oss/kinde-node-express" /> ### Integrate with your app You’ll need to import our Kinde helpers into your project. We recommend you do this in the entry point of your application, typically `index.js` or `app.js` ```jsx const express = require("express"); const {setupKinde, protectRoute, getUser, GrantType} = require("@kinde-oss/kinde-node-express"); const app = express(); const config = { clientId: "<YOUR_CLIENT_ID>", issuerBaseUrl: "https://<YOUR_SUBDOMAIN>.kinde.com", siteUrl: "http://localhost:3000", secret: "<YOUR_CLIENT_SECRET>", redirectUrl: "http://localhost:3000", scope: "openid profile email", grantType: GrantType.AUTHORIZATION_CODE, //or CLIENT_CREDENTIALS or PKCE unAuthorisedUrl: "http://localhost:3000/unauthorised", postLogoutRedirectUrl: "http://localhost:3000" }; setupKinde(config, app); ``` 1. In Kinde, go to **Settings > Applications > [Your app] > View details**. 2. Replace the placeholders in the code block above with the the values from the **App Keys** section. 3. Replace `http://localhost:3000` with the url of wherever your app is running. ### Environments As part of your development process, we highly recommend you create a development environment within your Kinde account. In this case, you'd use the Environment subdomain and app key values in the code block above. ## Set your callback and logout URLs Kinde will redirect your user to authenticate. They'll be redirected back to your Express app after signing in or signing up. To authenticate your app, you need to specify which URL Kinde should redirect your user. 1. In Kinde, go to **Settings > Applications > [Your app] > View details**. 2. Set the **Allowed callback URLs** (redirect URIs) to the URL of your app. This is where your application is served. For local development this could be `http://localhost:3000`. This is required for your users to sign in to your app successfully. This should match the `redirectUrl` you set in the config in the previous step. 3. Set the URLs they'll be redirected to after signing out, by adding **Allowed logout redirect URLs** to your JavaScript applications logout page. For local development this could be `http://localhost:3000`. This should match the `siteUrl` you set in the config in the previous step. 4. Select **Save**. **Note**: `http://localhost:3000` is an example of a commonly used local development URL. It should be replaced with the URL where your app is running. ## Sign in / register Kinde provides sign in / register methods that are easy to implement. Here’s an example of adding buttons to your HTML: ```html <div id="logged_out_view"> <a href="/login">Sign in</a> <a href="/register">Register</a> </div> ``` Clicking either of these buttons redirects your user to Kinde, where they authenticate before being redirected back to your site. ## Handle redirect Once your user is redirected back to your site from Kinde, you can set a callback to take place. The callback automatically passes in the user object and any application state you set prior to the redirect. ```jsx app.get("/", (req, res) => { if (req.session && req.session.access_token) { res.send("You are authenticated!"); } else { res.send("You are not"); } }); ``` ## Protecting routes The `protectRoute` middleware included in the SDK allows you to tell Express which routes are for authorized users only. ```jsx app.get("/admin", protectRoute, (req, res) => { res.send("Welcome to the admin area"); }); ``` You can pass an `unAuthorisedUrl` into the `setupKinde` configuration object which will to tell Kinde where you would like the user to be redirected in the case of `protectRoute` identifying the user is not yet authenticated. ## Access the user object The `getUser` middleware included in the SDK allows you to add the user object to the request. ```jsx app.get("/admin", protectRoute, getUser, (req, res) => { console.log(req.user); res.send(`Hello, ${req.user.given_name}`); }); ``` ## Sign out This is implemented in much the same way as signing in or registering. The Kinde SDK already comes with a `/logout` method. ```html <a href="/logout">Sign out</a> ``` ## Test sign up Register your first user by signing up yourself. You'll see your newly registered user on the **Users** page of the relevant organization in Kinde. ## Verify JWT This SDK also contains a library for verifying JWTs signed by Kinde. used as a layer of protect API endpoints. Initialize the library as follows: ```jsx const {jwtVerify} = require("@kinde-oss/kinde-node-express"); const verifier = jwtVerify("https://<your_kinde_subdomain>.kinde.com"); ``` Replace `<your_kinde_subdomain>` above with the subdomain you registered on Kinde. The step above caches your JWKS for Kinde in your Express application. ### Protect endpoints If you add the verifier middleware to an endpoint it will validate the token. If valid the users Kinde id is added to the request, otherwise a 403 error is thrown. ```jsx app.get("/some-route", verifier, (req, res) => { console.log(req.user); // {id: kp:the-users-kinde-id} }); ``` ## Kinde Management API To use the Kinde management API please see [@kinde/management-api-js](https://github.com/kinde-oss/management-api-js) ## SDK API Reference - setupKinde ### `clientId` The unique ID of your application in Kinde. Type: `string` Required: Yes ### `issuerBaseUrl` Either your Kinde URL or your custom domain. e.g `https://yourapp.kinde.com` Type: `string` Required: Yes ### `redirectUrl` The URL that the user will be returned to after authentication. Type: `string` Required: Yes ### `secret` The unique **Client secret** of your application in Kinde Type: `string` Required: Yes ### `siteUrl` Where your user will be redirected when they sign out. Type: `string` Required: Yes ### `unAuthorisedUrl` The URL the user will be redirected to if `protectRoute` finds the user is not authenticated. Type: `string` Required: No Reach out to [support@kinde.com](mailto:support@kinde.com) if you need help getting Kinde connected.

# Developer tools - Sdks - Java SDK v1

> Legacy guide for Java SDK v1 including Maven/Gradle installation, OAuth flows, authentication setup, and user management for Java applications.

java sdk v1, maven, gradle, oauth flows, authentication, callback urls, user details
developer-tools, sdks, java, backend

The Kinde Java SDK allows developers to connect their Java app to Kinde. You can also find our [Java docs](https://github.com/kinde-oss/kinde-java-sdk) and [Java starter kit](https://github.com/kinde-starter-kits/kinde-java-starter-kit) in GitHub. ## Supported versions The SDK is officially only supported for version 8 or later of Java. ## Register with Kinde If you haven’t already created a Kinde account, [register for free here](https://app.kinde.com/register) (no credit card required). Registration gives you a Kinde domain, which you will need to get started. e.g. `yourapp.kinde.com`. ## Install Create a JAR file of your SDK project using the below command: ```bash mvn clean install ``` To deploy it to a remote Maven repository instead, configure the settings of the repository and execute: ```bash mvn clean deploy ``` Refer to the [OSSRH Guide](http://central.sonatype.org/pages/ossrh-guide.html) for more information. ### Maven users Kinde’s SDK is available through [Maven](https://search.maven.org/). To install it, simply add the following line to your `pom.xml` ```java <dependency> <groupId>com.kinde</groupId> <artifactId>java-sdk</artifactId> <version>1.0.0</version> </dependency> ``` ### Gradle users Add this dependency to your project’s build file: ```bash repositories { mavenCentral() // Needed if the ‘kinde’ jar has been published to maven central. mavenLocal() // Needed if the ‘kinda’ jar has been published to the local maven repo. } dependencies { implementation "com.kinde:java-sdk:1.0.0” } ``` ### Others Generate the JAR by executing the following code: ```bash mvn clean package ``` Then manually install the following JARs: - target/java-sdk-1.0.0.jar - target/lib/\*.jar ## Integrate with your app Create KindeClientSDK object to use the SDK methods. ```java @PostConstruct public void updateKindeClientSDK(){ this.kindeClientSDK=new KindeClientSDK( domain, redirectUri, clientId, clientSecret, grantType, logoutRedirectUri ); } ``` Add `@ComponentScan` annotation in your main application. It should include the packages where your controllers from both the main application and the dependency project are located. ```java @ComponentScan(basePackages = {"com.example.demo.controller", "org.openapitools.api", "org.openapitools.model", "org.openapitools.configuration"}) ``` ## Set callback URLs For your app to work with Kinde, you need to set callback and logout redirect URLs. 1. In Kinde, go to **Settings > Applications.** 2. Select **View details** on your app. 3. Scroll down to the **Callback URLs** section. 4. Add in the callback URLs for your app, which might look something like this: - Allowed callback URLs (also known as Redirect URIs)- `http://localhost:8080/api/auth/kinde_callback` - Allowed logout redirect URLs - `http://localhost:8080` 5. Select **Save**. **Tip**: Make sure there are no hidden spaces in URLs and remove the ‘/’ backslash at the end. ## Environments If you would like to use different Environments as part of your development process, you will need to [add them within your Kinde business](/build/environments/environments/) first. You will also need to add the Environment subdomain to the code block above. ## Configure your app Add following properties in the `application.properties` file: The following variables need to be replaced in the code snippets below. - kinde.host - your Kinde domain. E.g. `https://your_kinde_domain.kinde.com` - kinde.redirect.url - your callback URL, make sure this URL is under your allowed callback redirect URLs. E.g. `http://localhost:8080/api/auth/kinde_callback` - kinde_post.logout.redirect.url - where you want users to be redirected to after signing out, make sure this URL is under your allowed logout redirect URLs. E.g. `http://localhost:8080` - kinde.client.id - you can find this on the **Application details** page - kinde.client.secret - you can find this on the **Application details** page - kinde.grant.type - The `KindeClientSDK` struct implements three OAuth flows: `client_credentials`, `authorization_code`, `authorization_code_flow_pkce` ## Sign in and **sign up** Kinde supports an easy to implement login / register flow. ### Client-side redirection To redirect users to the `/login` and `/register` pages on the client side when a link is clicked, you can use HTML anchor tags. Here's an example: ```html <a href="/login">Sign in</a> <a href="/register">Sign up</a> ``` ### Server-side authentication handling After the user is redirected to the `/login` or `/register` page, your server will need to handle the authentication process. The SDK provides `login` and `register` methods that you can use to handle these requests on the server side. Use these methods in your server-side code: ```java Object resp=kindeClientSDK.login(response); Object resp=kindeClientSDK.register(response); ``` ## R**edirect after authentication** When the user is redirected back to your site from Kinde, this will call your callback URL defined in the `kinde.redirect.url` variable. You will need to route `/api/auth/kinde_callback` to call a function to handle this. ```java @GetMapping("/api/auth/kinde_callback") public RedirectView callback(@RequestParam("code") String code, @RequestParam("state") String state, HttpServletResponse response, HttpServletRequest request) throws Exception { RedirectView redirectView=new CallbackController(this.kindeClientSDK).callback(code,state,response,request); return redirectView; } ``` ## Signing out The Kinde SPA client comes with a logout method. ```java RedirectView redirectView=this.kindeClientSDK.logout(response); ``` ## Test sign up Register your first user by signing up yourself. You’ll see your newly registered user on the **Users** page in Kinde. ## Get user information ### User profile To access the user information, use the `getUserDetails` helper function: ```java Object userDetails = this.kindeClientSDK.getUserDetails(request); // returns [ 'given_name' => 'Dave', 'id' => 'abcdef', 'family_name' => 'Smith', 'email' => 'dave@smith.com', 'picture' => 'https://link_to_avatar_url.kinde.com', ] ``` ### User permissions After a user signs in and they are verified, the token return includes permissions for that user. [User permissions are set in Kinde](/manage-users/roles-and-permissions/user-permissions/), but you must also configure your application to unlock these functions. Example of a permissions array. ```java String[] permissions = { "create:todos", "update:todos", "read:todos", "delete:todos", "create:tasks", "update:tasks", "read:tasks", "delete:tasks", }; ``` Helper functions for permission access. ```java Object permission=this.kindeClientSDK.getPermission(request,"create:todos"); // ["orgCode" => "org_1234", "isGranted" => true] ``` Example in your code. ```java Object permissions=this.kindeClientSDK.getPermissions(request); // ["orgCode" => "org_1234", "permissions" => ["create:todos", "update:todos", "read:todos"]] ``` ## Call your API Once the user has successfully authenticated, you’ll have a JWT and a refresh token and that has been stored securely. Use the `getToken` method to get the token: ```java Object token=this.kindeClientSDK.getToken(resp,request); ``` Use the `getAccessToken` method of the Storage class to get an access token. ```java ... import org.openapitools.sdk.storage.Storage; ... private Storage storage; this.storage = Storage.getInstance(); String accessToken=storage.getAccessToken(req); System.out.println(accessToken); ``` The token will be stored in the cookie. To specify the expiration time, use the `setTokenTimeToLive` method. ```java setTokenTimeToLive(System.currentTimeMillis() + 3600000) // Live in 1 hour ``` Get the current authentication status with `isAuthenticated`. ```java Boolean isAuthenticated = this.kindeClientSDK.isAuthenticated(request, resp); ``` ## Audience An `audience` is the intended recipient of an access token - for example the API for your application. The `audience` argument can be passed to the Kinde client to request an audience be added to the provided token. ```java @PostConstruct public void createKindeClientSDK(){ this.kindeClientSDK=new KindeClientSDK( domain, redirectUri, clientId, clientSecret, grantType, logoutRedirectUri, Collections.singletonMap("audience","api.yourapp.com")); } ``` ## Organizations ### Create an organization To create a new organization within your application, run a similar function to below: ```java this.kindeClientSDK.createOrg(resp); ``` You can also pass org_name as your organization ```java Map<String,Object> additonalParameters = new HashMap<>(); additonalParameters.put("org_name","Your Organization"); Object result = kindeClientSDK.createOrg(response,additonalParameters); ``` ### Sign users up or in to an organization When a user signs up or in to an organization, the `org_code` needs to be passed with the request. The `org_code` refers to the one created automatically in Kinde when the organization was created, for example `org_0e9f496742ae`. Here’s an helper function for registering in below: ```java Map<String,Object> additonalParameters = new HashMap<>(); additonalParameters.put("org_code","your_org_code"); Object result = kindeClientSDK.register(response,additonalParameters); ``` If you want a user to sign in to a particular organization, pass this code along with the sign in method. ```java Map<String,Object> additonalParameters=new HashMap<>(); additonalParameters.put("org_code","your_org_code"); Object result = kindeClientSDK.login(response,additonalParameters); ``` Because a user can belong to multiple organizations, and because they may have different permissions for the different organizations, with pass both the `org_code` and `permissions` in the token. Here’s an example: ```json [ "aud" => [], "exp" => 1658475930, "iat" => 1658472329, "iss" => "https://your_subdomain.kinde.com", "jti" => "123457890", "org_code" => "org_1234", "permissions" => ["read:todos", "create:todos"], "scp" => [ "openid", "profile", "email", "offline ], "sub" => "kp:123457890 ]; ``` The `id_token` will also contain an array of organizations that a user belongs to - this is useful if you wanted to build out an organization switcher for example. ```json [ ... "org_codes" => ["org_1234", "org_4567"], ... ]; ``` There are two helper functions you can use to extract information: ```java this.kindeClientSDK.getOrganization(request); // ["orgCode" => "org_1234"] this.kindeClientSDK.getUserOrganizations(request); // ["orgCodes" => ["org_1234", "org_abcd"]] ``` ## Scopes ### Default scopes By default, Kinde requests the following scopes: - profile - email - offline - openid ### Overriding scopes You can also pass override scopes to the Kinde SDK as per this example: ```java @PostConstruct public void createKindeClientSDK(){ this.kindeClientSDK=new KindeClientSDK( domain, redirectUri, clientId, clientSecret, grantType, logoutRedirectUri, "profile email offline openid"); } ``` ### Getting claims Kinde provides a helper to grab any claim from your ID or access tokens. The helper defaults to access tokens: ```java Object claim=this.kindeClientSDK.getClaim(request,"aud"); // ["name" => "aud", "value" => ["api.yourapp.com"]] Object claim=this.kindeClientSDK.getClaim(request,"given_name","id_token"); // ["name" => "aud", "value" => "David"] ``` ## Feature flags When a user signs in, the access token your product or application receives contains a custom claim called `feature_flags`. Feature flags define what features a user can access after they sign in. You can set feature flags in Kinde through code (see below), or through the Kinde application. ```java <u>**Create feature flag**</u> _**POST**_ /api/v1/feature_flags **Content-Type:** application/json **Accept:** application/json **Authorization:** Bearer {access-token} <u>**Example:**</u> _**POST**_ https://{businessName}.kinde.com/api/v1/feature_flags <u>**Request Body**</u> { "name": "string", "description": "string", "key": "string", "type": "str", "allow_override_level": "env", "default_value": "string" } ``` To minimize the token payload we use single letter keys / values to represent the following: - `t = type` - `v = value` - `s = string` - `b = boolean` - `i = integer` We also provide helper functions to more easily access feature flags: ```java this.kindeClientSDK.getFlag(request,"theme"); ``` A practical example in code would look something like: ```java this.kindeClientSDK.getFlag(request,"theme"); // returns [ "code" => "theme", "type" => "string", "value" => "pink", "is_default" => false // whether the fallback value had to be used ] // Another usage case this.kindeClientSDK.getFlag(request,"is_dark_mode"); // returns [ "code": "is_dark_mode", "type": "boolean", "value": true, "is_default": false ] // This flag does not exist - default value provided Map<String,Object> options=new HashMap<>(); options.put("defaultValue",false); this.kindeClientSDK.getFlag(request,"create_competition",options); // returns [ "code": "create_competition", "type" => "boolean", "value": false, "is_default": true // because fallback value had to be used ] // The flag type was provided as string, but it is an integer Map<String,Object> options=new HashMap<>(); options.put("defaultValue",3); this.kindeClientSDK.getFlag(request,"competitions_limit",options,"s"); // should error out - Flag "competitions_limit" is type integer - requested type string // This flag does not exist, and no default value provided this.kindeClientSDK.getFlag(request,"new_feature"); // should error out - This flag was not found, and no default value has been provided ``` ### Wrapper functions We also require wrapper functions to be separated by type as part of the `getFlag` function. Boolean wrapper: ```java this.kindeClientSDK.getBooleanFlag(request,"is_dark_mode"); ``` String wrapper: ```java this.kindeClientSDK.getStringFlag(request,"theme"); ``` Integer wrapper: ```java this.kindeClientSDK.getIntegerFlag(request,"competitions_limit"); ``` Example of wrapper function: ```java // [--- Boolean ---] this.kindeClientSDK.getBooleanFlag(request,"is_dark_mode"); // with default value this.kindeClientSDK.getBooleanFlag(request,"is_dark_mode", false); // [--- Boolean ---] // [--- String ---] this.kindeClientSDK.getStringFlag(request,"theme"); // with default value this.kindeClientSDK.getStringFlag(request,"theme","blue"); // [--- String ---] // [--- Integer ---] this.kindeClientSDK.getIntegerFlag(request,"competitions_limit"); // with default value this.kindeClientSDK.getIntegerFlag(request,"competitions_limit", 1); // [--- Integer ---] ``` ## Token storage in the authentication state This applies to frontend SDKs only. By default the JWTs provided by Kinde are stored in memory. This protects you from both [CSRF](https://owasp.org/www-community/attacks/csrf) attacks (possible if stored as a client side cookie) and [XSS](https://owasp.org/www-community/attacks/xss/) attacks (possible if persisted in local storage). The trade off with this approach is that if a page is refreshed or a new tab is opened, then the token is wiped from memory, and the sign in button would need to be clicked to re-authenticate. There are two ways to prevent this behavior: 1. (Recommended) Use the [Kinde custom domain](/build/domains/pointing-your-domain/) feature. We can then set a secure, httpOnly cookie against your domain containing only the refresh token which is not vulnerable to CSRF attacks. 2. (Non-production solution only) Use an escape hatch for local development: `isDangerouslyUseLocalStorage`. This SHOULD NOT be used in production. This will store only the refresh token in local storage to silently re-authenticate. **Storing Tokens** The **`setToken`** method is used to store the token in a secure manner. It encodes the token (which can be a string or a map) and sets it as a cookie in the HTTP response. The token is stored with specific attributes such as **`MaxAge`**, **`Path`**, **`Domain`**, **`Secure`**, and **`HttpOnly`** to enhance security. ```java public static void setToken(HttpServletResponse response, Object token) { // Encode the token (either as a string or a map) String tok = (token instanceof String) ? (String) token : encodeTokenAsURL(token); // Set the token as a cookie with defined attributes setItem(response, StorageEnums.TOKEN.getValue(), tok, getTokenTimeToLive().intValue()); } ``` The **`setItem`** method is a utility function for setting a cookie with the provided attributes. ```java public static void setItem(HttpServletResponse response, String key, String value, int expiresOrOptions, String path, String domain, boolean secure, boolean httpOnly) { String newKey = getKey(key); Cookie cookie = new Cookie(newKey, value); cookie.setMaxAge(expiresOrOptions); cookie.setPath(path); cookie.setDomain(domain); cookie.setSecure(secure); cookie.setHttpOnly(httpOnly); response.addCookie(cookie); } ``` **Retrieving Tokens** ```java Object token=this.kindeClientSDK.getToken(response,request); ``` The **`getToken`** method is used to retrieve the token from the HTTP request. It decodes and reads the stored token from the cookie. ```java public static Map<String, Object> getToken(HttpServletRequest request) { try { // Get the token as a string String token = getItem(request, StorageEnums.TOKEN.getValue()); // Decode the token and convert it to a Map String decodedToken = java.net.URLDecoder.decode(token, "UTF-8"); return new ObjectMapper().readValue(decodedToken, new TypeReference<Map<String, Object>>() {}); } catch (Exception e) { return null; } } ``` The **`getItem`** method is a utility function for retrieving a specific cookie from the HTTP request. ```java public static String getItem(HttpServletRequest request, String key) { String cookieName = getKey(key); Cookie[] cookies = request.getCookies(); if (cookies != null) { for (Cookie cookie : cookies) { if (cookie.getName().equals(cookieName)) { return cookie.getValue(); } } } return ""; } ``` ## API reference - Types ### `host` Either your Kinde instance URL or your custom domain. e.g. `https://yourapp.kinde.com/` Type: string Required: yes ### `redirectUri` The URL that the user will be returned to after authentication. Type: string Required: yes ### `clientId` The unique ID of your application. Get this from the Application details section in Kinde. Type: string Required: yes ### `clientSecret` The unique client secret of your Kinde application. Get this from the Application details section in Kinde. Type: string Required: Not required if you use OAuth PKCE ### `grantType` The grantType for Kinde Authorization varies for each OAuth 2 flow. You can use: - Authorization code: GrantType._AUTHORIZATION_CODE_.getValue(): Intended for confidential clients, e.g. web-servers. - Authorization code with PKCE: GrantType._PKCE_.getValue(): Extension for public clients, e.g. single page web applications and mobile applications, and confidential clients, e.g. web-servers. Note that the `code_challenge` and `code_challenge_method` parameters are also required for this grant type. - Client credentials flow: GrantType._CLIENT_CREDENTIALS_.getValue(): Intended for confidential clients where machine-to-machine communication is required. Type: string Required: yes ### `logoutRedirectUri` Where your user will be redirected when they sign out. Type: string Required: yes ### `scope` The scopes to be requested from Kinde. Type: string Required: No Default: openid profile email offline ### `additionalParameters` Additional parameters that will be passed in the authorization request. Type: Map\<String, Object> Required: No Default: new Hashmap\<>() ### `additionalParameters - audience` The audience claim for the JWT. Type: string Required: No ## API reference - Kinde methods ### `login` Constructs redirect URL and sends user to Kinde to sign in. Arguments: ```java response?: HttpServletResponse additionalParameters?: Map<String, Object> //org_code -> String ``` Usage: ```java kindeClientSDK.login(response); ``` ### `register` Constructs redirect url and sends user to Kinde to sign up. Arguments: ```java response?: HttpServletResponse additionalParameters?: Map<String, Object> //org_code -> String ``` Usage: ```java kindeClientSDK.register(response); ``` ### `logout` Logs the user out of Kinde. Arguments: ```java response?: HttpServletResponse ``` Usage: ```java this.kindeClientSDK.logout(response); ``` ### `getToken` Returns the raw access token from URL after logged from Kinde. Arguments: ```java response?: HttpServletResponse request?: HttpServletRequest ``` Usage: ```java kindeClientSDK.getToken(response,request); ``` Sample output: ```java [ "access_token" => "eyJhbGciOiJSUzI...", "expires_in" => 86400, "id_token" => "eyJhbGciOiJSU...", "refresh_token" => "yXI1bFQKbXKLD7AIU...", "scope" => "openid profile email offline", "token_type" => "bearer ]; ``` ### `createOrg` Constructs redirect url and sends user to Kinde to sign up and create a new org for your business. Arguments: ```java response?: HttpServletResponse additionalParameters?: Map<String, Object> //org_name -> String ``` Usage: ```java kindeClientSDK.createOrg(response); or Map<String,Object> additionalParameters=new HashMap<>(); additionalParameters.put("org_name","your organization name"); kindeClientSDK.createOrg(response,additionalParameters); ``` Sample output: ```java RedirectView //Will return RedirectView if Grant type is either authorization_code or authorization_code_flow_pkce LinkedHashMap //Will return LinkedHashMap if Grant type is client_credentials ``` ### `getClaim` Gets a claim from an access or ID token. Arguments: ```java request?: HttpServletRequest, claim: string, tokenKey?: string ``` Usage: ```java kindeClientSDK.getClaim(request,"given_name", "id_token"); ``` Sample output: ```java David ``` ### `getPermission` Returns the state of a given permission. Arguments: ```java request?: HttpServletRequest, key: string ``` Usage: ```java this.kindeClientSDK.getPermission(request,"read:todos"); ``` Sample output: ```java [ "orgCode" => "org_1234", "isGranted" => true ]; ``` ### `getPermissions` Returns all permissions for the current user for the organization they are logged into. Arguments: ```java request?: HttpServletRequest ``` Usage: ```java this.kindeClientSDK.getPermissions(request); ``` Sample output: ```java [ "orgCode" => "org_1234", "permissions" => ["create:todos", "update:todos", "read:todos"] ]; ``` ### `getOrganization` Get details for the organization your user is logged into. Arguments: ```java request?: HttpServletRequest ``` Usage: ```java this.kindeClientSDK.getOrganization(request); ``` Sample output: ```java [ "orgCode" => "org_1234 ]; ``` ### `getUserDetails` Returns the profile for the current user. Arguments: ```java request?: HttpServletRequest ``` Usage: ```java this.kindeClientSDK.getUserDetails(request); ``` Sample output: ```java [ "given_name" => "Dave", "id" => "abcdef", "family_name" => "Smith", "email" => "mailto:dave@smith.com ]; ``` ### `getUserOrganizations` Gets an array of all organizations the user has access to. Arguments: ```java request?: HttpServletRequest ``` Usage: ```java this.kindeClientSDK.getUserOrganizations(request); ``` Sample output: ```java [ "orgCodes" => ["org_8de8711f46a", "org_820c0f318de"] ]; ``` ### `getFlag` Gets a feature flag from an access token. Arguments: ```java request?: HttpServletRequest, flagName: string, options?: Map<String, Object> //"defaultValue" => any ``` Usage: ```java this.kindeClientSDK.getFlag(request,"is_dark_mode"); ``` Sample output: ```java [ "code": "is_dark_mode", "type": "boolean", "value": true, "is_default": false ]; ``` ### `getBooleanFlag` Gets a boolean feature flag from an access token. Arguments: ```java request?: HttpServletRequest, flagName: string, defaultValue?: boolean ``` Usage: ```java kindeClientSDK.getBooleanFlag(request,"is_dark_mode", false); ``` Sample output: ```java [ "code": "is_dark_mode", "type": "boolean", "value": false, "is_default": true ]; ``` ### `getStringFlag` Gets a string feature flag from an access token. Arguments: ```java request?: HttpServletRequest, flagName: string, defaultValue?: string ``` Usage: ```java kindeClientSDK.getStringFlag(request,"theme"); ``` Sample output: ```java [ "code": "theme", "type": "string", "value": "black", "is_default": false ]; ``` ### `getIntegerFlag` Gets a integer feature flag from an access token. Arguments: ```java request?: HttpServletRequest, flagName: string, defaultValue?: integer ``` Usage: ```java kindeClientSDK.getIntegerFlag(request,"competitions_limit"); ``` Sample output: ```java [ "code": "competitions_limit", "type": "integer", "value": 1, "is_default": false ]; ``` ### `isAuthenticated` To check user authenticated or not. Arguments: ```java response?: HttpServletResponse request?: HttpServletRequest ``` Usage: ```java this.kindeClientSDK.isAuthenticated(request, response); ``` Sample output: ```java true or false ``` If you need help connecting to Kinde, please contact us at [support@kinde.com](mailto:support@kinde.com).

# Developer tools - Sdks - Java SDK

> Complete guide for Java SDK including Maven/Gradle installation, M2M token retrieval, PKCE authentication, and environment configuration for Java 17+ applications.

Java SDK, Maven, Gradle, M2M, PKCE, environment variables, client credentials
developer-tools, sdks, java, backend

The Kinde Java SDK allows developers to connect their Java app to Kinde. You can find our [Java SDK](https://github.com/kinde-oss/kinde-java-sdk) and [Java starter kit](https://github.com/kinde-starter-kits/kinde-java-starter-kit) in GitHub. The SDK is officially only supported for Java version 17 or later. ## Register with Kinde If you haven’t already created a Kinde account, [register for free here](https://app.kinde.com/register). Registration gives you a Kinde domain, which you will need to get started. e.g. `yourapp.kinde.com`. <Aside> If you’re using version 1, see [Java SDK v1](/developer-tools/sdks/backend/java-sdk-v1/) </Aside> ## Kinde Java core The Kinde Java core provides the core of the Kinde SDK for the Java platform. This is necessary to install for connecting to Kinde. ## Install ### Install from source Clone the SDK repository. ```shell git clone https://github.com/kinde-oss/kinde-java-sdk.git ``` Create a JAR file of your SDK project using the below command: ```bash cd kinde-java-sdk mvn clean install ``` #### Maven users Kinde’s SDK is available through [Maven](https://search.maven.org/). To install it, add the following line to your `pom.xml`. ```java <dependency> <groupId>com.kinde</groupId> <artifactId>java-sdk</artifactId> <version>[2.0.1,)</version> </dependency> ``` ### Gradle users Add this dependency to your project’s build file: ```bash repositories { mavenCentral() // Needed if the ‘kinde’ jar has been published to maven central. mavenLocal() // Needed if the ‘kinda’ jar has been published to the local maven repo. } dependencies { implementation "com.kinde:java-sdk:+” } ``` ## Connect to Kinde ### Set up environment variables The following environment variables are required for connecting to Kinde. This will enable the development of a M2M client service. ```shell export KINDE_DOMAIN=https://<replace>.kinde.com # This is the domain you setup at kinde export KINDE_CLIENT_ID=<replace> # the id for the client connecting to Kinde export KINDE_CLIENT_SECRET=<replace> # the secret used to authenticate the client against Kinde ``` Provide a redirect URI, so a user's login can be validated against Kinde. ```shell export KINDE_REDIRECT_URI=http://localhost:8080/kinde-j2ee-app/login ``` The redirect URI/URL is used post successful login. It is the URL that the PKCE client CODE will be set to. A query parameter of ?code='value' must be processed. ### Set up .env files The Kinde library supports .env files. The must be located in the directory from which the application is executed. ```shell KINDE_DOMAIN=https://<replace>.kinde.com KINDE_CLIENT_ID=<replace> KINDE_CLIENT_SECRET=<replace> KINDE_REDIRECT_URI=http://localhost:8080/kinde-j2ee-app/login ``` #### Core server example To make a M2M server token request onto Kinde, set up the environment variables. #### By shell export Run these exports before running your service. ```shell export KINDE_DOMAIN=https://<replace>.kinde.com # This is the domain you setup at kinde export KINDE_CLIENT_ID=<replace> # the id for the client connecting to Kinde export KINDE_CLIENT_SECRET=<replace> # the secret used to authenticate the client against Kinde ``` #### By .env file config Place this .env file in the directory from which you run your service. ```shell KINDE_DOMAIN=https://<replace>.kinde.com KINDE_CLIENT_ID=<replace> KINDE_CLIENT_SECRET=<replace> ``` #### Programmatic configuration If you want to pass in configuration programmatically, use the `KindeClientBuilder`. ```java KindeClient kindeClient = KindeClientBuilder .builder() .domain("<replace>") .clientId("<replace>") .clientSecret("<replace>") .build(); ``` ## Retrieve a M2M token The example below details how to implement a server-level token request. This is needed for M2M communication and authorization. ```java KindeClient kindeClient = KindeClientBuilder .builder() .build(); KindeClientSession kindeClientSession = kindeClient.clientSession(); KindeTokens tokens = kindeClientSession.retrieveTokens(); ``` ### User Code Authorization Example (PKCE) To authenticate a user on the client-side, configure as follows. #### By shell export Run these exports before running your service. ```shell export KINDE_DOMAIN=https://<replace>.kinde.com # This is the domain you setup at kinde export KINDE_CLIENT_ID=<replace> # the id for the client connecting to Kinde export KINDE_CLIENT_SECRET=<replace> # the secret used to authenticate the client against Kinde export KINDE_REDIRECT_URI=openid # the open id ``` #### By .env file config Place this .env file in the directory from which you run your service. ```shell KINDE_DOMAIN=https://<replace>.kinde.com KINDE_CLIENT_ID=<replace> KINDE_CLIENT_SECRET=<replace> KINDE_REDIRECT_URI=<replace> KINDE_SCOPES=openid ``` #### Programmatic configuration If you want to pass in configuration programmatically, use the `KindeClientBuilder`. ```java KindeClient kindeClient = KindeClientBuilder .builder() .domain("<replace>") .clientId("<replace>") .clientSecret("<replace>") .redirectUri("replace") .addScope("openid") .build(); ``` ## Generate the redirect URL Before the PKCE code can be processed, a user must be directed to Kinde to sign in. The client library can generate this URL as follows. ```java KindeClient kindeClient = KindeClientBuilder .builder() .build(); KindeClientSession kindeClientSession = kindeClient.clientSession(); AuthorizationUrl authorizationURL = kindeClientSession.authorizationUrl(); ``` The AuthorizationUrl contains the url and CodeVerify information. If using a code grant the code verify needs to be stored for the redirect call. This can be done using the J2EE session. Here is an example ```java req.getSession().setAttribute("AuthorizationUrl",authorizationUrl); resp.sendRedirect(authorizationUrl.getUrl().toString()); ``` ## Request tokens upon redirect If it is a code auth, then the `AuthorizationUrl` needs to be retrieved. ```java AuthorizationUrl authorizationUrl = (AuthorizationUrl)req.getSession().getAttribute("AuthorizationUrl"); ``` The token request looks like the following. ```java KindeClient kindeClient = KindeClientBuilder .builder() .build(); KindeTokens tokens = kindeClient.getKindeClient().initClientSession(code,authorizationUrl).retrieveTokens(); ``` ## Get user information It is possible to retrieve user information using an AccessToken. In the example below, an access token is passed in a client session. ```java KindeClient kindeClient = KindeClientBuilder .builder() .build(); KindeClientSession kindeClientSession = kindeClient.getKindeClient().initClientSession(accessToken); UserInfo userInfo = kindeClientSession.retrieveUserInfo(); ``` Retrieve the user details for the code that has been authenticated. ```java KindeClient kindeClient = KindeClientBuilder .builder() .build(); KindeClientSession kindeClientSession = kindeClient.getKindeClient().initClientSession(code,authorizationUrl); UserInfo userInfo = kindeClientSession.retrieveUserInfo(); ``` ### User profile The UserInfo object retrieved above contains the following member variables. | Variables | Description | | ---------- | ------------------------------------------- | | userInfo | The nimbus user object for more information | | subject | The subject of the user object | | id | The id of the user on Kinde | | givenName | The given or first name of the user | | familyName | The family or surname of the user on Kinde | | email | The email address of the user on Kinde | | picture | The picture of the user on Kinde | ## API reference - for the Kinde core #### `login` The login process generates an authorization url. This can be used by the browser to initiate the login on Kinde, and once completed the user will be re-directed back. ```java KindeClient kindeClient = KindeClientBuilder .builder() .build(); KindeClientSession kindeClientSession = kindeClient.getKindeClient().clientSession(); AuthorizationUrl authorizationURL = kindeClientSession.login(); ``` Send the redirect response using: ```java resp.sendRedirect(authorizationUrl.getUrl().toString()); ``` #### `register` authenticate flow The register process generates an authorization URL. This URL can be used to redirect the user to Kinde to register, and then redirect them back to complete the PKCE login. ```java KindeClient kindeClient = KindeClientBuilder .builder() .build(); KindeClientSession kindeClientSession = kindeClient.getKindeClient().clientSession(); AuthorizationUrl authorizationURL = kindeClientSession.register(); ``` Send the redirect response using: ```java resp.sendRedirect(authorizationUrl.getUrl().toString()); ``` #### `logout` The register process generates an authorization URL. This can be used by the browser to initiate the login. ```java KindeClient kindeClient = KindeClientBuilder .builder() .build(); KindeClientSession kindeClientSession = kindeClient.getKindeClient().clientSession(); AuthorizationUrl authorizationURL = kindeClientSession.logout(); ``` Send the redirect response using: ```java resp.sendRedirect(authorizationUrl.getUrl().toString()); ``` #### `getToken` To complete authentication of a user and retrieve their tokens, do the following. ```java KindeClient kindeClient = KindeClientBuilder .builder() .build(); KindeTokens tokens = kindeClient.getKindeClient().initClientSession(code,authorizationUrl).retrieveTokens(); ``` Retrieve a client session for the application and then retrieve the tokens for that client. ```java KindeClient kindeClient = KindeClientBuilder .builder() .build(); KindeTokens tokens = kindeClient.getKindeClient().clientSession().retrieveTokens(); ``` #### `createOrg` authentication flow The register process generates an authorization URL. This URL can be used to redirect the user to Kinde to register, and then redirect them back to complete the PKCE login. ```java KindeClient kindeClient = KindeClientBuilder .builder() .build(); KindeClientSession kindeClientSession = kindeClient.getKindeClient().clientSession(); AuthorizationUrl authorizationURL = kindeClientSession.createOrg("Org Value"); ``` Send the redirect response using: ```java resp.sendRedirect(authorizationUrl.getUrl().toString()); ``` #### `getClaim` Claims are available from the tokens. ```java KindeClient kindeClient = KindeClientBuilder .builder() .build(); KindeTokens tokens = kindeClient.getKindeClient().initClientSession(code,authorizationUrl).retrieveTokens(); tokens.getAccessToken().getClaim("key"); ``` The API on the token provides the `getClaim` method, which uses a key name to identify the claim in the token, and return the json object it refers to. #### `getPermission` The permissions are available from the token. ```java KindeClient kindeClient = KindeClientBuilder .builder() .build(); KindeTokens tokens = kindeClient.getKindeClient().initClientSession(code,authorizationUrl).retrieveTokens(); List<String> permissions = new ArrayList<String>(); permissions.addAll(tokens.getAccessToken().getPermissions()); ``` #### `getOrganization` The organization can be retrieved from the access token. ```java KindeClient kindeClient = KindeClientBuilder .builder() .build(); KindeTokens tokens = kindeClient.getKindeClient().initClientSession(code,authorizationUrl).retrieveTokens(); List<String> organizations = new ArrayList<String>(); permissions.addAll(tokens.getAccessToken().getOrganizations()); ``` #### `getUserDetails` The user details are available either via the AccessToken or via the OAuth2 user info endpoint. Using the Token API: ```java KindeClient kindeClient = KindeClientBuilder .builder() .build(); KindeTokens tokens = kindeClient.getKindeClient().initClientSession(code,authorizationUrl).retrieveTokens(); tokens.getAccessToken()... // retrieve user information // username // permissions // claims // feature flags ``` ### User profile If this is not sufficient, the OAuth2 user info endpoint can be invoked. This can be done using an access token, or just after code auth. The following scopes ware required, `openid, profile, email`. Using the code-created client: ```java KindeClientSession kindeClientSession = kindeClient.initClientSession(code, authorizationUrl); UserInfo userInfo = kindeClientSession.retrieveUserInfo(); assertNotNull(userInfo); assertNotNull(userInfo.getEmail()); assertNotNull(userInfo.getSubject()); assertNotNull(userInfo.getId()); assertNotNull(userInfo.getPicture()); assertNotNull(userInfo.getGivenName()); assertNotNull(userInfo.getFamilyName()); ``` Using a token-created client: ```java KindeClientSession kindeClientSession = kindeClient2.initClientSession(accessToken); UserInfo userInfo = kindeClientSession.retrieveUserInfo(); assertNotNull(userInfo); assertNotNull(userInfo.getEmail()); assertNotNull(userInfo.getSubject()); assertNotNull(userInfo.getId()); assertNotNull(userInfo.getPicture()); assertNotNull(userInfo.getGivenName()); assertNotNull(userInfo.getFamilyName()); ``` #### `getUserOrganizations` The organization can be retrieved from the access token. ```java KindeClient kindeClient = KindeClientBuilder .builder() .build(); KindeTokens tokens = kindeClient.getKindeClient().initClientSession(code,authorizationUrl).retrieveTokens(); List<String> organizations = new ArrayList<String>(); organizations.addAll(tokens.getAccessToken.getOrganizations()); ``` ### `getFlags` The flags can be retrieved from the token. Once you have referenced the access token, the `getFlag` method can be called. This method returns a `Map<String,Object>` ```java KindeClient kindeClient = KindeClientBuilder .builder() .build(); KindeTokens tokens = kindeClient.getKindeClient().initClientSession(code,authorizationUrl).retrieveTokens(); tokens.getAccessToken().getFlags(); ``` #### `getBooleanFlag` This method returns a boolean value of the internal flag value. ```java KindeClient kindeClient = KindeClientBuilder .builder() .build(); KindeTokens tokens = kindeClient.getKindeClient().initClientSession(code,authorizationUrl).retrieveTokens(); tokens.getAccessToken().getBooleanFlag(key); ``` #### `getStringFlag` This method returns a string value. ```java KindeClient kindeClient = KindeClientBuilder .builder() .build(); KindeTokens tokens = kindeClient.getKindeClient().initClientSession(code,authorizationUrl).retrieveTokens(); tokens.getAccessToken().getStringFlag(key); ``` #### `getIntegerFlag` The method returns the value for the key in type integer. ```java KindeClient kindeClient = KindeClientBuilder .builder() .build(); KindeTokens tokens = kindeClient.getKindeClient().initClientSession(code,authorizationUrl).retrieveTokens(); tokens.getAccessToken().getIntegerFlag(key); ``` ## Kinde-J2EE API This is the Kinde J2EE Library, and contains the core components needed to manage a client connection to the Kinde from a J2EE servlet container. ### Project dependencies #### Maven In order to use this SDK include following POM dependency. ```xml <dependency> <groupId>com.kinde</groupId> <artifactId>kinde-j2ee</artifactId> <version>[2.0.1,)</version> </dependency> ``` #### Gradle In order to use the SDK with a Gradle build process please use the following dependency. ```groovy configuration('com.kinde:kinde-j2ee:+') ``` ### Project configuration Configure the web.xml file to use these servlets. ```xml <?xml version="1.0" encoding="UTF-8"?> <web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd version="3.1"> <servlet> <servlet-name>KindeLoginServlet</servlet-name> <servlet-class>com.kinde.servlet.KindeLoginServlet</servlet-class> </servlet> <servlet> <servlet-name>KindeLogoutServlet</servlet-name> <servlet-class>com.kinde.servlet.KindeLogoutServlet</servlet-class> </servlet> <servlet> <servlet-name>KindeRegisterServlet</servlet-name> <servlet-class>com.kinde.servlet.KindeRegistrationServlet</servlet-class> </servlet> <filter> <filter-name>KindeLoginFilter</filter-name> <filter-class>com.kinde.filter.KindeLoginFilter</filter-class> </filter> <servlet-mapping> <servlet-name>KindeLoginServlet</servlet-name> <url-pattern>/login</url-pattern> </servlet-mapping> <servlet-mapping> <servlet-name>KindeRegisterServlet</servlet-name> <url-pattern>/register</url-pattern> </servlet-mapping> <servlet-mapping> <servlet-name>KindeLogoutServlet</servlet-name> <url-pattern>/logout</url-pattern> </servlet-mapping> <filter-mapping> <filter-name>KindeLoginFilter</filter-name> <url-pattern>/private/*</url-pattern> <!-- Apply to all URLs or specify specific patterns --> </filter-mapping> </web-app> ``` ### J2EE servlets and filters The above project configuration sets up an example web.xml using the Kinde-J2EE servlets and filters. These are all you need to secure a J2EE project and can be used with Spring Boot or Quarkus: 1. KindeLoginServlet: The servlet responsible for managing a login. It manages the re-direct to the Kinde Domain and and in the example above is setup to run from /login with the J2EE context. 2. KindeRegisterServlet: This servlet is responsible for triggering the registration flow. It redirects to the configured Kinde domain and provides Kinde with the flags to indicate this is a user registration flow. 3. KindeLogoutServlet: This servlet is responsible for triggering the logout flow, and for removing from the application any active session for the user. 4. KindeLoginFilter: This is a J2EE filter and acts as a gateway to the private section of your site. It will deny users access to anything its scope covers, unless they have successfully authenticated. It also sets up roles or permissions for the logged in user. ### Environment configuration Configuration can either be performed by exports or through an .env file. #### Shell ```shell export KINDE_DOMAIN=https://<replace>.kinde.com # This is the domain you set up at kinde export KINDE_CLIENT_ID=<replace> # the ID for the client connecting to Kinde export KINDE_CLIENT_SECRET=<replace> # the secret used to authenticate the client against Kinde export KINDE_REDIRECT_URI=http://localhost:8080/kinde-j2ee-app/login ``` #### .env The Kinde library supports .env files. The files must be located in the directory from which the application is executed. ```shell KINDE_DOMAIN=https://<replace>.kinde.com KINDE_CLIENT_ID=<replace> KINDE_CLIENT_SECRET=<replace> KINDE_REDIRECT_URI=http://localhost:8080/kinde-j2ee-app/login ``` ## Kinde Spring Boot starter The Spring Boot starter manages all the dependencies required by a spring boot application connecting to Kinde. ### Project Dependencies #### Maven To use configure Spring Boot to use Kinde for authentication, include the following dependency. ```xml <dependency> <groupId>com.kinde.spring</groupId> <artifactId>kinde-springboot-starter</artifactId> <version>[2.0.1,)</version> </dependency> ``` #### Gradle To use the SDK with a Gradle build process, use the following dependency. ```groovy configuration('com.kinde.spring:kinde-springboot-starter:+') ``` ### Usage This library can be configured in different ways, via environment variables, via .env file and via the Spring Boot application.yaml file. #### Environment configuration ```shell export KINDE_DOMAIN=https://<replace>.kinde.com # This is the domain you setup at kinde export KINDE_CLIENT_ID=<replace> # the id for the client connecting to Kinde export KINDE_CLIENT_SECRET=<replace> # the secret used to authenticate the client against Kinde export KINDE_REDIRECT_URI=http://localhost:< replace with port of application server >/kinde-j2ee-app/login export KINDE_GRANT_TYPE=CODE export KINDE_SCOPES=profile,email,openid ``` #### `.env` ```shell KINDE_DOMAIN=https://<replace>.kinde.com # This is the domain you setup at kinde KINDE_CLIENT_ID=<replace> # the id for the client connecting to Kinde KINDE_CLIENT_SECRET=<replace> # the secret used to authenticate the client against Kinde KINDE_REDIRECT_URI=http://localhost:< replace with port of application server >/kinde-j2ee-app/login KINDE_GRANT_TYPE=CODE KINDE_SCOPES=profile,email,openid ``` #### `application.yaml` ```yaml kinde: oauth2: domain: https://< replace >.kinde.com client-id: < replace > client-secret: < replace > scopes: openid,email,profile ``` ## Kinde Management API You can access Kinde's API endpoints through the Kinde Management API. This lets developers work programmatically, rather than through the main Kinde interface. ### Development The Kinde Management Library contains the components needed to access the Kinde Management API. It includes an OpenAPI-generated stub and a `KindeAdminSession` tool that instantiates the `ApiClient` using OIDC details. ### Project Dependencies #### Maven To use this SDK, include the following dependency in your `pom.xml`: ```xml <dependency> <groupId>com.kinde</groupId> <artifactId>kinde-management</artifactId> <version>[2.0.1,)</version> </dependency> ``` #### Gradle For Gradle, add the following dependency to your build file: ```groovy implementation('com.kinde:kinde-management:+') ``` ### Building the SDK from Source 1. Clone the repository to your machine: ```bash git clone https://github.com/kinde-oss/kinde-java-sdk ``` 2. Go into the project: ```bash cd kinde-java-sdk ``` 3. Install the dependencies: ```bash mvn clean install ``` ### Documentation Maven automatically downloads the dependency from your local repository and makes it available in your project. ### Library usage #### Set up environment variables The following basic environment variables are required at a mimimum for connecting to the Kinde Management API. ```shell export KINDE_DOMAIN=https://<replace>.kinde.com # This is the domain you setup at kinde export KINDE_CLIENT_ID=<replace> # the id for the client connecting to Kinde export KINDE_CLIENT_SECRET=<replace> # the secret used to authenticate the client against Kinde export KINDE_SCOPES=openid # the scope as we are using an OpenID connection export KINDE_AUDIENCE=https://<replace>.kinde.com/api # the audience we need access to ``` #### Set up .env files The Kinde library supports .env files. The must be located in the directory from which the application is executed. ```shell KINDE_DOMAIN=https://burntjam.kinde.com KINDE_CLIENT_ID=<replace> KINDE_CLIENT_SECRET=<replace> KINDE_SCOPES=openid KINDE_AUDIENCE=https://<replace>.kinde.com/api ``` #### Programmatic configuration If you want to pass in configuration programmatically, the `KindeClientBuilder` supports the following approach. ```java KindeClient kindeClient = KindeClientBuilder .builder() .domain("<replace>") .clientId("<replace>") .clientSecret("<replace>") .addScope("<replace>") .addAudience("https://<replace>.kinde.com/api") .build(); ``` ##### Get an `ApiClient` This example gets an `ApiClient` instance and then creates an `ApplicationApi` instance using the `ApiClient`. ```java KindeClient kindeClient = KindeClientBuilder .builder() .build(); KindeAdminSession kindeAdminSession = KindeAdminSessionBuilder.builder().client(kindeClient).build(); ApiClient apiClient = kindeAdminSession.initClient(); ApplicationsApi applicationsApi = new ApplicationsApi(apiClient); ``` ### Test sign up Register your first user by signing up yourself. You’ll see your newly registered user on the **Users** page in Kinde. ### User Permissions The user permissions are available in two ways. One is from the ID token as a claim, the other is via the Kinde Management API. #### Permissions in token ```java KindeClient kindeClient = KindeClientBuilder .builder() .build(); KindeTokens tokens = kindeClient.getKindeClient().initClientSession(code,authorizationUrl).retrieveTokens(); List<String> permissions = new ArrayList<String>(); permissions.addAll(tokens.getAccessToken().getPermissions()); ``` #### Permissions via the Management API The permissions are up to you to define. The code below provides an example on how to retrieve the permissions from the portal using the Kinde Management API. ```java KindeClient kindeClient = KindeClientBuilder .builder() .build(); KindeAdminSession kindeAdminSession = KindeAdminSessionBuilder.builder().client(kindeClient).build(); ApiClient apiClient = kindeAdminSession.initClient(); OrganizationApi organizationApi = new OrganizationApi(apiClient); // org code is the org that the user is associated with // user id is the user // expanded organizationApi.getOrganizationUserPermissions(orgCode, userId, expand) ``` ### Create an organization Use the `OrganizationApi` to create a new organization. ```java KindeClient kindeClient = KindeClientBuilder .builder() .build(); KindeAdminSession kindeAdminSession = KindeAdminSessionBuilder.builder().client(kindeClient).build(); ApiClient apiClient = kindeAdminSession.initClient(); OrganizationApi organizationApi = new OrganizationApi(apiClient); // org code is the org that the user is associated with // user id is the user // expanded organizationApi.createOrganization(new CreateOrganizationRequest().name("test")); ``` If you need help connecting to Kinde, please contact us at [support@kinde.com](mailto:support@kinde.com).

# Developer tools - Sdks - Next.js Pages Router SDK

> Legacy guide for Next.js Pages Router SDK including authentication setup, route handlers, and migration from previous versions.

next.js pages router, server side components, authentication, kinde provider, route handlers, migration guide
developer-tools, sdks, nextjs, backend

This SDK is for Next.js version 13 and later and uses Server Side Components and Pages Router. ## Next.js 13 and later App Router support We highly recommend using our dedicated [Next.js SDK](/developer-tools/sdks/backend/nextjs-sdk/) with App Router instead of this one. Whilst technically this SDK is compatible with Next.js 13, it isn’t optimal. It leverages the `use client;` escape hatch, which we don’t love. It also requires a single API file to be stored in the legacy `pages` directory. ## Other document versions - If you have not already installed the Next.js SDK, we recommend you use [Next.js App Router v2](/developer-tools/sdks/backend/nextjs-sdk/). - If you are already using the Next.js Pages Router, refer to the earlier version [Next.js Pages Router v1](/developer-tools/sdks/backend/nextjs-prev-sdkv1/). ## Register for Kinde If you haven’t already got a Kinde account, [register for free here](https://app.kinde.com/register) (no credit card required). This will give you a Kinde domain, which you need to get started, e.g. `yourapp.kinde.com`. ## Get started with a new project The easiest way to get started is to use the [Next.js starter kit](https://github.com/kinde-starter-kits/kinde-nextjs-app-router-starter-kit). You can try out a live demo at ## **Install for existing project** <PackageManagers pkg="@kinde-oss/kinde-auth-nextjs" /> ## **Set callback URLs** 1. In Kinde, go to **Settings > Applications > [Your app] > View details**. 2. Add your callback URLs in the relevant fields. For example: - Allowed callback URLs (also known as redirect URIs) - for example `http://localhost:3000/api/auth/kinde_callback` - Allowed logout redirect URLs - for example `http://localhost:3000` 3. Select **Save**. ## **Configure environment variables** Put these variables in a `.env.local` file in the root of your Next.js app. You can find these variables on your Kinde **Settings > Applications > [Your app] > View details** page. - `KINDE_CLIENT_ID` - Your business’s unique ID on Kinde - `KINDE_CLIENT_SECRET` - Your business’s secret key (do not share) - `KINDE_ISSUER_URL` - your kinde domain - `KINDE_SITE_URL` - where your app is running - `KINDE_POST_LOGOUT_REDIRECT_URL` - where you want users to be redirected to after logging out. Make sure this URL is under your allowed logout redirect URLs. - `KINDE_POST_LOGIN_REDIRECT_URL` - where you want users to be redirected to after authenticating. Replace the information in the example below with your own information. You might also set different URLs depending where your project is running. They need to be the same as the callback URLs you entered in Kinde, above. ```shell KINDE_CLIENT_ID=<your_kinde_client_id> KINDE_CLIENT_SECRET=<your_kinde_client_secret> KINDE_ISSUER_URL=https://<your_kinde_subdomain>.kinde.com KINDE_SITE_URL=http://localhost:3000 KINDE_POST_LOGOUT_REDIRECT_URL=http://localhost:3000 KINDE_POST_LOGIN_REDIRECT_URL=http://localhost:3000/dashboard ``` ## Set up KindeProvider Kinde uses a React Context Provider to maintain its internal state in your application. Import the `KindeProvider` component and wrap your application in it. ```jsx // app/layout.tsx "use client"; import { KindeProvider } from "@kinde-oss/kinde-auth-nextjs"; import Auth from "./auth"; export default function RootLayout({ children, }: { children: React.ReactNode; }) { return ( <KindeProvider> <html lang="en"> <body> <Auth>{children}</Auth> </body> </html> </KindeProvider> ); } ``` ## **Set up Kinde Auth Route Handlers** Create the following file `/pages/api/auth/[...kindeAuth].js` inside your Next.js project. Inside the file `[...kindeAuth].js` put this code: ```jsx import {handleAuth} from "@kinde-oss/kinde-auth-nextjs/server"; export default handleAuth(); ``` This will handle Kinde Auth endpoints in your Next.js app. **Important:** Our SDK relies on this file existing in this location specified above. ## Migration guide Updates since last version. **`handleAuth`** - is now imported from `“@kinde-oss/kinde-auth-nextjs/server”` ```jsx import { handleAuth } from "@kinde-oss/kinde-auth-nextjs/ ``` **`getKindeServerSession`** - functions returned from `getKindeServerSession` now return promises ```jsx const {getUser} = getKindeServerSession(); const user = await getUser(); ``` ## Authentication ### Sign up and sign in The SDK ships with `<LoginLink>` and `<RegisterLink>` components which can be used to start the auth flow. ```jsx import {RegisterLink, LoginLink} from "@kinde-oss/kinde-auth-nextjs/components"; ... <LoginLink>Sign in</LoginLink> <RegisterLink>Sign up</RegisterLink> ``` ### Redirecting after authentication **Static redirect** If you want to redirect users to a certain page after signing in, you can set the `KINDE_POST_LOGIN_REDIRECT_URL` environment variable in your `.env.local` file. **Dynamic redirect** You can also set a `postLoginRedirectURL` parameter to tell us where to redirect after authenticating. ```jsx import {RegisterLink, LoginLink} from "@kinde-oss/kinde-auth-nextjs/components"; ... <LoginLink postLoginRedirectURL="/dashboard">Sign in</LoginLink> <RegisterLink postLoginRedirectURL="/welcome">Sign up</RegisterLink> ``` This appends `post_login_redirect_url` to the search params when redirecting to Kinde Auth. That means you can achieve the same result as above, like this: ```jsx import { redirect } from "next/navigation"; ... redirect('/api/auth/login?post_login_redirect_url=/dashboard') ... ``` ### Logout This is implemented in much the same way as signing up or signing in. A component is provided for you. ```jsx import {LogoutLink} from "@kinde-oss/kinde-auth-nextjs/components"; ... <LogoutLink>Log out</LogoutLink> ``` ## Kinde Auth data ### getServerSideProps - `getKindeServerSession` You can get an authorized user’s Kinde Auth data from `getServerSideProps` using the `getKindeServerSession` helper. Example: ```jsx import { getKindeServerSession, } from "@kinde-oss/kinde-auth-nextjs/server"; export async function getServerSideProps({ req, res, }: { req: Request; res: Response; }) { const { getUser, getPermissions, getOrganization, } = getKindeServerSession(req, res); const organization = await getOrganization(); const permissions = await getPermissions(); const user = await getUser(); return { props: { user, permissions, organization, }, }; } export default function Server({ user, permissions, organization, }: any) { console.log("user", user); console.log("permissions", permissions); console.log("organization", organization); ... } ``` Reference: ```typescript { getAccessToken: () => Promise<string>; getBooleanFlag: (code: string, defaultValue: boolean) => Promise<boolean>; getFlag: (code: string, defaultValue: any, flagType: any) => Promise< | import("@kinde-oss/kinde-typescript-sdk").GetFlagType | { value: any; } >; getIntegerFlag: (code: string, defaultValue: number) => Promise<number>; getOrganization: () => Promise<{ orgCode: string; }>; getPermission: (name: any) => Promise<{ orgCode: string; isGranted: boolean; }>; getPermissions: () => Promise<{ permissions: string[]; orgCode: string; }>; getStringFlag: (code: string, defaultValue: string) => Promise<string>; getUser: () => Promise<any>; getUserOrganizations: () => Promise<{ orgCodes: string[]; }>; isAuthenticated: () => Promise<boolean>; } ``` ### Components - `useKindeAuth` You can get an authorized user’s Kinde Auth data from any component using the `useKindeAuth` helper. Example: ```jsx import {useKindeAuth} from "@kinde-oss/kinde-auth-nextjs"; export default function ClientPage() { const { isLoading, user, permissions, organization, userOrganizations, accessToken, getBooleanFlag, getClaim, getFlag, getIntegerFlag, getPermission, getStringFlag, isAuthenticated, error } = useKindeAuth(); if (isLoading) return <div>Loading...</div>; return ( <div className="pt-20"> <div className="mb-8"> <h4 className="text-2xl font-bold dark:text-white mb-2">User</h4> <pre className="p-4 rounded bg-slate-950 text-green-300"> {JSON.stringify(user, null, 2)} </pre> </div> <div className="mb-8"> <h4 className="text-2xl font-bold dark:text-white mb-2">Permissions</h4> <pre className="p-4 rounded bg-slate-950 text-green-300"> {JSON.stringify(permissions, null, 2)} </pre> </div> <div className="mb-8"> <h4 className="text-2xl font-bold dark:text-white mb-2">Organization</h4> <pre className="p-4 rounded bg-slate-950 text-green-300"> {JSON.stringify(organization, null, 2)} </pre> </div> <div className="mb-8"> <h4 className="text-2xl font-bold dark:text-white mb-2">User organizations</h4> <pre className="p-4 rounded bg-slate-950 text-green-300"> {JSON.stringify(userOrganizations, null, 2)} </pre> </div> <div className="mb-8"> <h4 className="text-2xl font-bold dark:text-white mb-2">Access Token</h4> <pre className="p-4 rounded bg-slate-950 text-green-300"> {JSON.stringify(accessToken, null, 2)} </pre> </div> <div className="mb-8"> <h4 className="text-2xl font-bold dark:text-white mb-2">Is Authenticated</h4> <pre className="p-4 rounded bg-slate-950 text-green-300"> {JSON.stringify(isAuthenticated, null, 2)} </pre> </div> <div className="mb-8"> <h4 className="text-2xl font-bold dark:text-white mb-2">error</h4> <pre className="p-4 rounded bg-slate-950 text-green-300"> {JSON.stringify(error, null, 2)} </pre> </div> <div className="mb-8"> <h4 className="text-2xl font-bold dark:text-white mb-2">Get boolean flag</h4> <pre className="p-4 rounded bg-slate-950 text-green-300"> {JSON.stringify(getBooleanFlag("bodsa", true), null, 2)} </pre> </div> <div className="mb-8"> <h4 className="text-2xl font-bold dark:text-white mb-2">Get claim</h4> <pre className="p-4 rounded bg-slate-950 text-green-300"> {JSON.stringify(getClaim("bodsa"), null, 2)} </pre> </div> <div className="mb-8"> <h4 className="text-2xl font-bold dark:text-white mb-2">Get integer flag</h4> <pre className="p-4 rounded bg-slate-950 text-green-300"> {JSON.stringify(getIntegerFlag("bodsa", 1), null, 2)} </pre> </div> <div className="mb-8"> <h4 className="text-2xl font-bold dark:text-white mb-2">Get string flag</h4> <pre className="p-4 rounded bg-slate-950 text-green-300"> {JSON.stringify(getStringFlag("bodsa", "dsad"), null, 2)} </pre> </div> <div className="mb-8"> <h4 className="text-2xl font-bold dark:text-white mb-2">Get permission</h4> <pre className="p-4 rounded bg-slate-950 text-green-300"> {JSON.stringify(getPermission("bodsa"), null, 2)} </pre> </div> <div className="mb-8"> <h4 className="text-2xl font-bold dark:text-white mb-2">Get flag</h4> <pre className="p-4 rounded bg-slate-950 text-green-300"> {JSON.stringify(getFlag("bodsa", "dsad", "s"), null, 2)} </pre> </div> </div> ); } ``` Reference: ```typescript export type State = { /** * - Kinde access token */ accessToken: string | null; error?: string | null; isAuthenticated: boolean | null; isLoading: boolean | null; /** * - The organization that the current user is logged in to */ organization: string | null; /** * - The current user's permissions */ permissions: string[] | null; /** * - Kinde user */ user: KindeUser | null; /** * - Organizations that the current user belongs to */ userOrganizations: string[] | null; getBooleanFlag: getBooleanFlag; getClaim: getClaim; getFlag: getFlag; getIntegerFlag: getIntegerFlag; getPermission: getPermission; getStringFlag: getStringFlag; }; ``` <Aside> Use `isLoading` to ensure the data is up to date. You can return a Loading spinner or something similar while it isLoading </Aside> ## Protecting routes It’s likely that your application will have both pages that are publicly available and private ones which should only be available to logged in users. There are multiple ways you can protect pages with Kinde Auth. ## Protect routes using Kinde Auth data On the page you want to protect, you can check if the user is authenticated and then handle it right then and there by grabbing the Kinde Auth data. Get Kinde Auth data: - server side in `getServerSideProps` with the `getKindeServerSession` help - client side using the `useKindeAuth` helper ```jsx // pages/protected.tsx - using getKindeServerSession import { LoginLink } from "@kinde-oss/kinde-auth-nextjs/dist/components"; import { getKindeServerSession } from "@kinde-oss/kinde-auth-nextjs/server"; export async function getServerSideProps({ req, res, }: { req: Request; res: Response; }) { const { isAuthenticated } = getKindeServerSession(req, res); const isAuthed = await isAuthenticated(); return { props: { isAuthed }, }; } export default async function Protected({isAuthed}) { return (isAuthed ? ( <div> This page is protected - but you can view it because you are authenticated </div> ) : ( <div> This page is protected, please <LoginLink>Login</LoginLink> to view it </div> ); } // pages/protected/page.tsx - using useKindeAuth import { useKindeAuth } from "@kinde-oss/kinde-auth-nextjs"; import { LoginLink } from "@kinde-oss/kinde-auth-nextjs/dist/components"; export default function Admin() { const { isAuthenticated, isLoading } = useKindeAuth(); if (isLoading) return <div>Loading...</div>; return isAuthenticated ? ( <div>Admin content</div> ) : ( <div> You have to <LoginLink>Login</LoginLink> to see this page </div> ); } ``` In the example above we show different content based on whether or not the user is authenticated. If you want to automatically send the user to the sign in screen, you can do something like the following: ```jsx // pages/protected.tsx import {useKindeAuth} from "@kinde-oss/kinde-auth-nextjs"; import {useRouter} from "next/router"; import {useEffect} from "react"; export default async function Protected() { const router = useRouter(); const {isAuthenticated} = useKindeAuth(); useEffect(() => { if (!isLoading && !isAuthenticated) { router.push("/api/auth/login"); } }, [isLoading, isAuthenticated, router]); return <div>Protected content</div>; } ``` If you want the user to be redirected back to that route after login, you can set `post_login_redirect_url` in the search params of the redirect. ```jsx router.push("/api/auth/login?post_login_redirect_url=/protected"); ``` ## Protect routes using middleware You can also protect routes with Next.js middleware. **Default page protection** We provide a `withAuth` helper that will protect routes covered by the matcher. If the user is not authenticated then they are redirected to login and once they have logged in they will be redirected back to the protected page which they should now have access to. ```jsx import {withAuth} from "@kinde-oss/kinde-auth-nextjs/middleware"; export default function middleware(req) { return withAuth(req, { isReturnToCurrentPage: true }); } export const config = { matcher: ["/admin"] }; ``` **Page protection with callback function after authorization** You can use the `withAuth` helper as shown below with a `middleware` callback function which has access to the `req.kindeAuth` object that exposes the token and user data. ```typescript import {withAuth} from "@kinde-oss/kinde-auth-nextjs/middleware"; export default withAuth(async function middleware(req) { console.log("look at me", req.kindeAuth); }); export const config = { matcher: ["/admin"] }; ``` **Middleware options** There are options that can be passed into the middleware function to configure its functionality. - `isReturnToCurrentPage` - redirect the user back to the page they were trying to access - `loginPage` - define the path of the login page (where the users are redirected to when not authenticated) - `publicPaths` - define the public paths - `isAuthorized` - define the criteria for authorization ```typescript import {withAuth} from "@kinde-oss/kinde-auth-nextjs/middleware"; export default withAuth( async function middleware(req) { console.log("look at me", req.kindeAuth); }, { isReturnToCurrentPage: true, loginPage: "/login", isAuthorized: ({token}) => { // The user will be considered authorized if they have the permission 'eat:chips' return token.permissions.includes("eat:chips"); } } ); export const config = { matcher: ["/admin"] }; ``` ## Kinde Management API To use our management API please see [@kinde/management-api-js](https://github.com/kinde-oss/management-api-js) `getServerSideProps` example: ```typescript import { Users } from "@kinde/management-api-js"; export async function getServerSideProps({ req, res, }: { req: Request; res: Response; }) { const { users } = await Users.getUsers(); return { props: { users, }, }; } export default function Server({ users }: any) { console.log(users) ... } ``` API route example: ```typescript import {Users} from "@kinde/management-api-js"; import type {NextApiRequest, NextApiResponse} from "next"; export default async function handler(req: NextApiRequest, res: NextApiResponse) { const users = await await Users.getUsers(); if (users.code === "OK") { return res.status(200).json({users}); } else { return res.status(400); } } ``` ## Organizations ### Create organizations To create an organization from your app, you can use the `CreateOrgLink` component. ```jsx import {CreateOrgLink} from "@kinde-oss/kinde-auth-nextjs/components"; <CreateOrgLink orgName="Hurlstone">Create org</CreateOrgLink>; ``` ### Signing into organizations You can have your users sign in to a specific organization by setting the `orgCode` param in the `LoginLink` and `RegisterLink` components. ```jsx import {LoginLink, RegisterLink} from "@kinde-oss/kinde-auth-nextjs/components"; <LoginLink orgCode="org_7392cf35a1e">Login</LoginLink> <RegisterLink orgCode="org_7392cf35a1e">Register</RegisterLink> ``` If the `orgCode` is not specified and the user belongs to multiple organizations, they will be prompted to choose which organization to log into during the login or register flow. ## Internationalization You can set the language you wish your users to see when they hit the login flow by including the `lang` attribute as a part of the `authUrlParams` when using the `LoginLink` and `RegisterLink` components. ```jsx import {LoginLink} from "@kinde-oss/kinde-auth-nextjs/components"; <LoginLink authUrlParams={{ lang: "en-AU" }} > Login </LoginLink>; ``` ## **Audience** An `audience` is the intended recipient of an access token - for example the API for your application. The `audience` argument can be passed to the Kinde client to request an audience be added to the provided token. The audience of a token is the intended recipient of the token. ```jsx // .env ... KINDE_AUDIENCE=<your-api> ``` For details on how to connect, see [Register an API](/developer-tools/your-apis/register-manage-apis/). ## Working with subdomains In the case you have a [custom domain](/build/domains/pointing-your-domain/) and you would like to start the authentication flow from a URL like **`auth`**`.mysite.com` and you want to redirect to a URL like **`app`**`.mysite.com` , all you have to do is set the `KINDE_COOKIE_DOMAIN` to match the domain. ```jsx // .env ... KINDE_COOKIE_DOMAIN=.mysite.com ``` If the URL you want to start the authentication flow from and the URL you want to redirect to don’t share the same domain, then this will not work. ## Debug mode In debug mode you will see more logs in your console that may help with debugging. ```jsx // .env KINDE_DEBUG_MODE = true; ```

# Developer tools - Sdks - Next.js Pages Router SDK v1

> Legacy guide for Next.js Pages Router SDK v1 including authentication setup, API endpoints, and provider configuration for older Next.js versions.

next.js pages router v1, legacy sdk, authentication, kinde provider, api endpoints, migration
developer-tools, sdks, nextjs, backend

This SDK is for developers already using the Next.js Pages Router SDK. This document is out of date for new users, use this document instead: [Next.js Pages Router](/developer-tools/sdks/backend/nextjs-prev-sdk/). ## Next.js 13 and App Router support We highly recommend using our dedicated [Next.js App Router SDK](/developer-tools/sdks/backend/nextjs-sdk/) with App Router instead of this one. Whilst technically this SDK is compatible with Next.js 13, it isn’t optimal. It leverages the `use client;` escape hatch, which we don’t love. It also requires a single API file to be stored in the legacy `pages` directory. ## **Installation** <PackageManagers pkg="@kinde-oss/kinde-auth-nextjs@1" /> ## **Set callback URLs** 1. In Kinde, go to **Settings > Applications > [Your app] > View details**. 2. Add your callback URLs in the relevant fields. For example: - Allowed callback URLs (also known as redirect URIs) - for example [`http://localhost:3000/api/auth/kinde_callback`](http://localhost:3000/api/auth/kinde_callback) - Allowed logout redirect URLs - for example `http://localhost:3000` 3. Select **Save**. ## **Environments** If you would like to use our Environments feature as part of your development process. You will need to create them first [within your Kinde account](/build/environments/environments/). In this case you would use the Environment subdomain in the code block above. ## **Configuring your app** ### **Environment variables** Put these variables in your .env file. You can find these variables on your Kinde Settings -> App keys page. - `KINDE_SITE_URL` - where your app is running - `KINDE_ISSUER_URL` - your kinde domain - `KINDE_POST_LOGOUT_REDIRECT_URL` - where you want users to be redirected to after logging out. Make sure this URL is under your allowed logout redirect URLs. - `KINDE_POST_LOGIN_REDIRECT_URL` - where you want users to be redirected to after authenticating. - `KINDE_CLIENT_ID` - you can find this on the Application details page - `KINDE_CLIENT_SECRET` - you can find this on the Application details page ```jsx KINDE_SITE_URL=http://localhost:3000 KINDE_ISSUER_URL=https://your_kinde_domain.kinde.com KINDE_POST_LOGOUT_REDIRECT_URL=http://localhost:3000 KINDE_POST_LOGIN_REDIRECT_URL=http://localhost:3000/dashboard KINDE_CLIENT_ID=your_kinde_client_id KINDE_CLIENT_SECRET=your_kinde_client_secret ``` ### **API endpoints** Create the following file `/pages/api/auth/[...kindeAuth].js` inside your Next.js project. Inside the file `[...kindeAuth].js` put this code: ```jsx import {handleAuth} from "@kinde-oss/kinde-auth-nextjs"; export default handleAuth(); ``` This will handle Kinde Auth endpoints in your Next.js app. - `/api/auth/me` - this endpoint will get user information - `/api/auth/login` - will redirect you to login at the KindeAuth server - `/api/auth/logout` - will log you out of the app - `/api/auth/register` - will redirect you to register at the KindeAuth server. Our SDK relies on this file existing in this location specified above. This includes Next.js 13 projects. ## **Integrate with your app** ### **Kinde Provider** Kinde uses a React Context Provider to maintain its internal state in your application. Import the `KindeProvider` component and wrap your application in it. **Next.js 13:** we suggest you include this in `app/layout.tsx` ```jsx // Next.js 13 "use client"; import { KindeProvider } from "@kinde-oss/kinde-auth-nextjs"; import Auth from "./auth"; export default function RootLayout({ children, }: { children: React.ReactNode; }) { return ( <KindeProvider> <html lang="en"> <body> <Auth>{children}</Auth> </body> </html> </KindeProvider> ); } ``` In the example above, there is a custom Auth component which handles routing depending on if the user is authenticated. Here is an example [Auth component](https://github.com/kinde-starter-kits/nextjs-starter-kit/blob/0ce95ff775677697b5eafd096469cc6007f2334c/src/app/auth.tsx) from our Starter Kit. **Next.js 12 and below:** we suggest you include this in the root file of your application in `_app.js` ```jsx // Next.js 12 and below import {KindeProvider} from "@kinde-oss/kinde-auth-nextjs"; function MyApp({Component, pageProps}) { return ( <KindeProvider> <Component {...pageProps} /> </KindeProvider> ); } export default MyApp; ``` ## Sign up and sign in The SDK ships with predefined API routes to generate the auth urls for sign up and sign in. **Next.js 13** Link prefetching causes issues with preflight options, so we need to use standard `<a>` tags for our links. So the build doesn’t break you’ll want to disable the linting that comes with Next as per the sample below: ```jsx // Next.js 13 "use client"; export default function MainNav() { return ( <ul> <li> {/* eslint-disable-next-line @next/next/no-html-link-for-pages */} <a href="/api/auth/login">Sign in</a> </li> <li> {/* eslint-disable-next-line @next/next/no-html-link-for-pages */} <a href="/api/auth/register">Sign up</a> </li> </ul> ); } ``` **Next.js 12 and below** You can use the `<Link>` component that ships with earlier versions of Next. ```jsx // Next.js 12 and below import Link from "next/link"; export default function MainNav() { return ( <ul> <li> <Link href="/api/auth/login"> <a>Sign in</a> </Link> </li> <li> <Link href="/api/auth/register"> <a>Sign up</a> </Link> </li> </ul> ); } ``` ## Log out This is implemented in much the same way as signing up or signing in. An API route is provided for you ```jsx // Next.js 13 {/* eslint-disable-next-line @next/next/no-html-link-for-pages */} <a href="/api/auth/logout"> Sign out </a> // Next.js 12 or below <Link href="/api/auth/logout"> <a>Sign out</a> </Link> ``` ### Test sign up Register your first user by signing up yourself. You’ll see your newly registered user on the **Users** page in Kinde. ## **View user profile** You can get an authorized user’s profile from any component using the Kinde Next.js hoo ```jsx import {useKindeAuth} from "@kinde-oss/kinde-auth-nextjs"; const SayHello = () => { const {user} = useKindeAuth(); return <p>Hi {user.given_name}!</p>; }; ``` To be on the safe side we have also provided `isAuthenticated` and `isLoading` state to prevent rendering errors. ```jsx "use client"; import { useKindeAuth } from "@kinde-oss/kinde-auth-nextjs"; const UserProfile = () => { const { user, isAuthenticated, isLoading } = useKindeAuth(); if (isLoading) { return <p>Loading</p>; } return ( { isAuthenticated ? <div> <h2>{user.given_name}</h2> <p>{user.email}</p> </div> : <p>Please sign in or register!</p> } ); }; ``` ## Call your API The `getToken` method lets you to securely call your API and pass the bearer token to validate that your user is authenticated. ```jsx const {getToken} = useKindeAuth(); const fetchData = async () => { try { const accessToken = await getToken(); const res = await fetch(`<your-api>`, { headers: { Authorization: `Bearer ${accessToken}` } }); const {data} = await res.json(); console.log({data}); } catch (err) { console.log(err); } }; ``` We recommend using JWT verification middleware on your back end to verify the token and protect your endpoints. ## **Audience** An `audience` is the intended recipient of an access token - for example the API for your application. The `audience` argument can be set against `KINDE_AUDIENCE` in your environment variables. The audience of a token is the intended recipient of the token. ```jsx // .env file KINDE_AUDIENCE = your_audience; ``` For details on how to connect, see [Register an API](/developer-tools/your-apis/register-manage-apis/). ## **User Permissions** Once a user has been verified as login in, your product/application will be returned the JWT token with an array of permissions for that user. You will need to configure your product/application to read permissions and unlock the respective functions. You set Permissions in your Kinde account (see help article), the below is an example set of permissions. ```json "permissions":[ "create:todos", "update:todos", "read:todos", "delete:todos", "create:tasks", "update:tasks", "read:tasks", "delete:tasks ] ``` We provide helper functions to more easily access permissions: ```jsx const {getPermission, getPermissions} = useKindeAuth(); getPermission("create:todos"); // {orgCode: "org_1234", isGranted: true} getPermissions(); // {orgCode: "org_1234", permissions: ["create:todos", "update:todos", "read:todos"]} ``` A practical example in code might look something like: ```jsx { getPermission("create:todos").isGranted ? <button>Create todo</button> : null; } ``` ## **Feature flags** When a user signs in the Access token your product/application receives contains a custom claim called `feature_flags` which is an object detailing the feature flags for that user. You can set feature flags in your Kinde account. Here’s an example. ```jsx feature_flags: { theme: { "t": "s", "v": "pink" }, is_dark_mode: { "t": "b", "v": true }, competitions_limit: { "t": "i", "v": 5 } } ``` In order to minimize the payload in the token we have used single letter keys / values where possible. The single letters represent the following: `t` = `type` `v` = `value` `s` = `string` `b` = `boolean` `i` = `integer` We provide helper functions to more easily access feature flags: ```jsx /** * Get a flag from the feature_flags claim of the access_token. * @param {string} code - The name of the flag. * @param {obj} [defaultValue] - A fallback value if the flag isn't found. * @param {'s'|'b'|'i'|undefined} [flagType] - The data type of the flag (integer / boolean / string). * @return {object} Flag details. */ const { getFlag } = useKindeAuth(); /* Example usage */ getFlag('theme'); /*{ // "code": "theme", // "type": "string", // "value": "pink", // "is_default": false // whether the fallback value had to be used */} getFlag('create_competition', {defaultValue: false}); /*{ "code": "create_competition", "value": false, "is_default": true // because fallback value had to be used }*/ ``` A practical example in code might look something like: ```jsx const {getFlag} = useKindeAuth(); { getFlag("create_competition").value ? <button>Create competition</button> : null; } ``` We also require wrapper functions by type which should leverage `getFlag` above. Booleans: ```jsx /** * Get a boolean flag from the feature_flags claim of the access_token. * @param {string} code - The name of the flag. * @param {bool} [defaultValue] - A fallback value if the flag isn't found. * @return {bool} */ const {getBooleanFlag} = useKindeAuth(); /* Example usage */ getBooleanFlag("is_dark_mode"); // true getBooleanFlag("is_dark_mode", false); // true getBooleanFlag("new_feature", false); // false (flag does not exist so falls back to default) ``` Strings and integers work in the same way as booleans above: ```jsx /** * Get a string flag from the feature_flags claim of the access_token. * @param {string} code - The name of the flag. * @param {string} [defaultValue] - A fallback value if the flag isn't found. * @return {string} */ const {getStringFlag} = useKindeAuth(); /** * Get an integer flag from the feature_flags claim of the access_token. * @param {string} code - The name of the flag. * @param {int} [defaultValue] - A fallback value if the flag isn't found. * @return {int} */ const {getIntegerFlag} = useKindeAuth(); ``` A practical example in code might look something like: ```jsx const {getBooleanFlag, getStringFlag} = useKindeAuth(); { getBooleanFlag("create_competition") ? ( <button className={`theme-${getStringFlag("theme")}`}>Create competition</button> ) : null; } ``` ## **Organizations** ### **Creating an organization** To have a new organization created within your application, you will need to run a similar function to below: **Next.js 13** ```jsx // Next.js 13 {/* eslint-disable-next-line @next/next/no-html-link-for-pages */} <a href={`/api/auth/create_org?org_name=${<org_name>}`}> Create org </a> ``` **Next.js 12 and below** ```jsx // Next.js 12 and below <Link href={{ pathname: "/api/auth/create_org", query: { org_name: "Organization name" } }} > Create org </Link> ``` ### Register and log in users to organizations Every organization in Kinde has a unique code. To sign up a new user into a particular organization you will need to pass through this code in the `register` method. (See where to find it). **Next.js 13** ```jsx // Next.js 13 {/* eslint-disable-next-line @next/next/no-html-link-for-pages */} <a href={`/api/auth/register?org_code=${<org_code>}`}> Create org </a> ``` **Next.js 12 and below** ```jsx // Next.js 12 and below <Link href={{ pathname: "/api/auth/register", query: { org_code: "org_af9078366f4" } }} > Register org </Link> ``` This code should also be passed along with the `login` method if you wish for a user to be logged into a specific organization. **Next.js 13** ```jsx // Next.js 13 {/* eslint-disable-next-line @next/next/no-html-link-for-pages */} <a href={`/api/auth/login?org_code=${<org_code>}`}> Sign in </a> ``` **Next.js 12 and below** ```jsx // Next.js 12 and below <Link href={{ pathname: "/api/auth/login", query: { org_code: "org_af9078366f4" } }} > Sign in to Org </Link> ``` For general information about how organizations work in Kinde, see [Kinde organizations for developers](/build/organizations/orgs-for-developers/). ## Customising the API path If your Next.js application uses a custom base path for your API. The default path is `/api/auth` but to override this setting you can change this in your .`env` file as follows: ```bash KINDE_AUTH_API_PATH="/my/custom/path ``` ## Kinde Management API You need to enable the application’s access to the Kinde Management API. You can do this in Kinde by going to **Settings > APIs > Kinde Management API** and then toggling on your Next.js application under the **Applications** tab. To use our management API please see [@kinde/management-api-js](https://github.com/kinde-oss/management-api-js) ### Troubleshooting **`undefined`** **cannot be serialized as JSON** This happens when the API returns an object with a property that is undefined and we try to return that object from `getServerSideProps`. You can use this workaround to avoid this error: ```jsx ... const users = await client.usersApi.getUsers(); return { props: { users: JSON.parse(JSON.stringify(users)) } } ... ``` ## Persisting app state If you want your project to remember which url your user was intending to visit before they were asked to authenticate, you can pass an additional parameter in the `/login` and `/register` links. After the user has completed authentication at your defined callback url they will be redirected to the path you define here. This value does not need to be added to your allowed callback urls in Kinde. **Next.js 13** ```jsx // Next.js 13 { /* eslint-disable-next-line @next/next/no-html-link-for-pages */ } <a href="api/auth/login?post_login_redirect_url=/dashboard">Sign in</a>; ``` **Next.js 12 and below** ```jsx // Next.js 12 and below <Link href={{ pathname: "/api/auth/login", query: { post_login_redirect_url: "/dashboard" } }} > Sign in </Link> ``` Note: the value of `post_login_redirect_url` should either be a url on the same origin or a relative path. If you need any assistance with getting Kinde connected reach out to us at [support@kinde.com](mailto:support@kinde.com).

# Developer tools - Sdks - Next.js App Router SDK

> Complete guide for Next.js App Router SDK including installation, configuration, middleware setup, route protection, and authentication integration for Next.js 13+ applications.

Next.js SDK, App Router, Server Side Components, middleware, authentication, route protection, environment variables
developer-tools, sdks, nextjs, backend

This SDK is for Next.js version 13+ and uses Server Side Components and App Router. New to Kinde? [Get started here](/get-started/guides/first-things-first/) <Aside> If you’re using version 1 see [Next.js App Router V1](/developer-tools/sdks/backend/nextjs-sdkv1/) If you’re using the pages router see [Next.js Pages Router](/developer-tools/sdks/backend/nextjs-prev-sdk/) </Aside> ## Install for a new project The easiest way to get started is to use the [Next.js starter kit](https://github.com/kinde-starter-kits/kinde-nextjs-app-router-starter-kit), and [watch a demo video](https://www.youtube.com/watch?v=oq3o00E6Xys). ## **Install for an existing project** <PackageManagers pkg="@kinde-oss/kinde-auth-nextjs" /> ## **Set callback URLs** 1. In Kinde, go to **Settings > Applications > [Your app] > View details**. 2. Add your callback URLs in the relevant fields. For example: - Allowed callback URLs (also known as redirect URIs) - for example `http://localhost:3000/api/auth/kinde_callback` - Allowed logout redirect URLs - for example `http://localhost:3000` 3. Select **Save**. ## **Configure environment variables** Put these variables in a `.env.local` file in the root of your Next.js app. You can find these variables on your Kinde **Settings > Applications > [Your app] > View details** page. - `KINDE_CLIENT_ID` - Your business’s unique ID on Kinde - `KINDE_CLIENT_SECRET` - Your business’s secret key (do not share) - `KINDE_ISSUER_URL` - your kinde domain - `KINDE_SITE_URL` - where your app is running - `KINDE_POST_LOGOUT_REDIRECT_URL` - where you want users to be redirected to after logging out. Make sure this URL is under your allowed logout redirect URLs. - `KINDE_POST_LOGIN_REDIRECT_URL` - where you want users to be redirected to after authenticating. - `KINDE_AUDIENCE` - optional - a whitespace separated list of audiences to populate the `aud` claim in the token. Replace the information in the example with your own information. You might also set different URLs depending where your project is running. They need to match the callback URLs you entered in Kinde, above. ```shell KINDE_CLIENT_ID=<your_kinde_client_id> KINDE_CLIENT_SECRET=<your_kinde_client_secret> KINDE_ISSUER_URL=https://<your_kinde_subdomain>.kinde.com KINDE_SITE_URL=http://localhost:3000 KINDE_POST_LOGOUT_REDIRECT_URL=http://localhost:3000 KINDE_POST_LOGIN_REDIRECT_URL=http://localhost:3000/dashboard ``` ## **Set up Kinde Auth Route Handlers** Create the following file `app/api/auth/[kindeAuth]/route.js` inside your Next.js project. Inside the file `route.js` put this code: ```jsx import {handleAuth} from "@kinde-oss/kinde-auth-nextjs/server"; export const GET = handleAuth(); ``` This will handle Kinde Auth endpoints in your Next.js app. **Important!** Our SDK relies on this file existing in this location specified above. ## **Customising Kinde Auth API paths** The default path for the Kinde Auth API is `/api/auth`. If your Next.js application uses a custom base path for your API, you can override this setting by setting the following variable in your `.env` file: ```bash KINDE_AUTH_API_PATH="/my/custom/path ``` You can also customise the Kinde Auth API sub-paths by setting the following variables in your `.env` file: - `KINDE_AUTH_LOGIN_ROUTE` - defaults to `login` - `KINDE_AUTH_LOGOUT_ROUTE` - defaults to `logout` - `KINDE_AUTH_REGISTER_ROUTE` - defaults to `register` - `KINDE_AUTH_CREATEORG_ROUTE` - defaults to `create_org` - `KINDE_AUTH_HEALTH_ROUTE` - defaults to `health` - `KINDE_AUTH_SETUP_ROUTE` - defaults to `setup` #### **Example** Given the following `.env` file: ```bash KINDE_AUTH_API_PATH="/my/custom/path KINDE_AUTH_LOGIN_ROUTE="app_login ``` The Kinde login route for your application will be `/my/custom/path/app_login`. ## **Set up middleware** Middleware is used to protect routes in your Next.js app, and is a requirement for a seamless authentication experience. We provide a `withAuth` helper that will protect routes covered by the matcher. If the user is not authenticated then they are redirected to login and once they have logged in they will be redirected back to the protected page which they should now have access to. We require this middleware to run on all routes beside Next.js internals and static files. The provided matcher will do this for you. This means that by default, all routes will be protected. You must opt-out public routes - see [opting routes out of middleware protection](#opting-routes-out-of-middleware-protection) for more information. <Aside> Want to learn more about middleware? Check out the [Next.js middleware docs](https://nextjs.org/docs/app/building-your-application/routing/middleware). </Aside> #### **Middleware configuration** Create a `middleware.ts` file in your project's root directory and add the following code: ```ts import { withAuth } from "@kinde-oss/kinde-auth-nextjs/middleware"; export default function middleware(req) { return withAuth(req); } export const config = { matcher: [ // Run on everything but Next internals and static files '/((?!_next|[^?]*\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)', ] }; ``` #### **Route protection with callback function after authorization** You can use the `withAuth` helper as shown below with a `middleware` callback function which has access to the `req.kindeAuth` object that exposes the token and user data. ```ts import {withAuth} from "@kinde-oss/kinde-auth-nextjs/middleware"; export default withAuth(async function middleware(req) { console.log("look at me", req.kindeAuth); }); export const config = { matcher: [ '/((?!_next|[^?]*\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)', ] }; ``` #### **Opting routes out of middleware protection** As the middleware matcher is set to protect all routes, you can opt routes out of middleware protection by adding them to the `publicPaths` array. ```ts import { withAuth } from "@kinde-oss/kinde-auth-nextjs/middleware"; export default withAuth( async function middleware(req) { }, { // Middleware still runs on all routes, but doesn't protect the blog route publicPaths: ["/blog"], } ); export const config = { matcher: [ '/((?!_next|[^?]*\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)', ], } ``` #### **Additional middleware options** There are options that can be passed into the middleware function to configure its functionality. - `isReturnToCurrentPage` - redirect the user back to the page they were trying to access - `loginPage` - define the path of the login page (where the users are redirected to when not authenticated) - `publicPaths` - define the public paths - `isAuthorized` - define the criteria for authorization ```ts import { withAuth } from "@kinde-oss/kinde-auth-nextjs/middleware"; export default withAuth( async function middleware(req) { console.log("look at me", req.kindeAuth); }, { isReturnToCurrentPage: true, loginPage: "/login", publicPaths: ["/public", '/more'], isAuthorized: ({token}) => { // The user will be considered authorized if they have the permission 'eat:chips' return token.permissions.includes("eat:chips"); } } ); export const config = { matcher: [ '/((?!_next|[^?]*\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)', ], } ``` ## **Set up the Kinde Auth Provider** Wrap your app in the Kinde Auth Provider. This will give you access to the Kinde Auth data in your app and will ensure that the tokens are refreshed when needed. Create a file `AuthProvider.tsx` in your app directory. ```jsx // AuthProvider.tsx "use client"; import {KindeProvider} from "@kinde-oss/kinde-auth-nextjs"; export const AuthProvider = ({children}) => { return <KindeProvider>{children}</KindeProvider>; }; ``` Then wrap your app in the `AuthProvider` component. ```jsx // layout.tsx ... import {AuthProvider} from './AuthProvider'; export const metadata = { title: 'Kinde Auth', description: 'Kinde with Next.js App Router' }; export default async function RootLayout({ children }: { children: React.ReactNode; }) { return ( <AuthProvider> <html lang="en"> // Your app code here </html> </AuthProvider> ); } ``` ## Authentication ### Sign up and sign in The SDK ships with `<LoginLink>` and `<RegisterLink>` components which can be used to start the auth flow. ```jsx import {RegisterLink, LoginLink} from "@kinde-oss/kinde-auth-nextjs/components"; ... <LoginLink>Sign in</LoginLink> <RegisterLink>Sign up</RegisterLink> ``` ### Redirecting after authentication **Static redirect** If you want to redirect users to a certain page after logging in, you can set the `KINDE_POST_LOGIN_REDIRECT_URL` environment variable in your `.env.local` file. **Dynamic redirect** You can also set a `postLoginRedirectURL` parameter to tell us where to redirect after authenticating. ```jsx import {RegisterLink, LoginLink} from "@kinde-oss/kinde-auth-nextjs/components"; ... <LoginLink postLoginRedirectURL="/dashboard">Sign in</LoginLink> <RegisterLink postLoginRedirectURL="/welcome">Sign up</RegisterLink> ``` This appends `post_login_redirect_url` to the search params when redirecting to Kinde Auth. You can achieve the same result as above, like this: ```jsx import { redirect } from "next/navigation"; ... redirect('/api/auth/login?post_login_redirect_url=/dashboard') ... ``` ### Logout This is implemented in much the same way as signing up or signing in. A component is provided for you. ```jsx import {LogoutLink} from "@kinde-oss/kinde-auth-nextjs/components"; ... <LogoutLink>Log out</LogoutLink> ``` ## Kinde Auth data - Server You can get an authorized user’s Kinde Auth data from any server component using the `getKindeServerSession` helper. | Method | Description | | ----------------------------------------------- | ----------------------------------------------------- | | [`isAuthenticated`](#isauthenticated) | Check if the user is authenticated | | [`getUser`](#getuser) | Get the current user's details | | [`getOrganization`](#getorganization) | Get the current user's organization | | [`getUserOrganizations`](#getuserorganizations) | Get all the organizations the current user belongs to | | [`getPermission`](#getpermission) | Check if the current user has a permission | | [`getPermissions`](#getpermissions) | Get the current user's permissions | | [`getFlag`](#getflag) | Get a feature flag | | [`getBooleanFlag`](#getbooleanflag) | Get a boolean feature flag | | [`getIntegerFlag`](#getintegerflag) | Get an integer feature flag | | [`getStringFlag`](#getstringflag) | Get a string feature flag | | [`getAccessToken`](#getaccesstoken) | Get the decoded access token | | [`getAccessTokenRaw`](#getaccesstokenraw) | Get the access token | | [`getIdToken`](#getidtoken) | Get the decoded ID token | | [`getIdTokenRaw`](#getidtokenraw) | Get the ID token | | [`getClaim`](#getclaim) | Get a claim from either token | ### `isAuthenticated` Check if the user is authenticated. #### Example ```jsx import {getKindeServerSession} from "@kinde-oss/kinde-auth-nextjs/server"; const {isAuthenticated} = getKindeServerSession(); const isUserAuthenticated = await isAuthenticated(); ``` #### Returns ```typescript true; ``` ### `getUser` Get the logged in user's details. #### Example ```jsx import {getKindeServerSession} from "@kinde-oss/kinde-auth-nextjs/server"; const {getUser} = getKindeServerSession(); const user = await getUser(); console.log(user); ``` #### Returns ```json { "id": "kp_123", "email": "example@email.com", "family_name": "Example", "given_name": "User", "picture": null, "username": "ExampleUsername", "phone_number": "1234567890", "properties": { "usr_city": "", "usr_industry": "", "usr_job_title": "", "usr_middle_name": "", "usr_postcode": "", "usr_salutation": "", "usr_state_region": "", "usr_street_address": "", "usr_street_address_2": "" } } ``` ### `getOrganization` Get the current user’s organization #### Example ```jsx import {getKindeServerSession} from "@kinde-oss/kinde-auth-nextjs/server"; const {getOrganization} = getKindeServerSession(); const org = await getOrganization(); console.log(org); ``` #### Returns ```json { "orgCode": "org_123", "orgName": "Deafault Org", "properties": { "org_city": "", "org_country": "", "org_industry": "", "org_postcode": "", "org_state_region": "", "org_street_address": "", "org_street_address_2": "" } } ``` ### `getUserOrganizations` Get all the organizations the current user belongs to #### Example ```jsx import {getKindeServerSession} from "@kinde-oss/kinde-auth-nextjs/server"; const {getUserOrganizations} = getKindeServerSession(); const userOrgs = await getUserOrganizations(); console.log(userOrgs); ``` #### Returns ```json { "orgCodes": ["org_123", "org_456"], "orgs": [ { "code": "org_123", "name": "Deafault Org" }, { "code": "org_456", "name": "Another Org" } ] } ``` ### `getPermission` Check if the current user has a permission. | Parameter | Type | Description | | --------- | -------- | ---------------------------- | | code | `string` | The permission code to check | #### Example ```jsx import {getKindeServerSession} from "@kinde-oss/kinde-auth-nextjs/server"; const {getPermission} = getKindeServerSession(); const canEatTacos = await getPermission("eat:tacos"); console.log(canEatTacos); ``` #### Returns ```json { "isGranted": true, "orgCode": "org_123" } ``` ### `getPermissions` Get the current user’s permissions. #### Example ```jsx import {getKindeServerSession} from "@kinde-oss/kinde-auth-nextjs/server"; const {getPermissions} = getKindeServerSession(); const permissions = await getPermissions(); console.log(permissions); ``` #### Returns ```json { "permissions": ["eat:tacos", "read:books"], "orgCode": "org_123" } ``` ### `getFlag` Get a feature flag | Parameter | Type | Description | | ------------ | --------------------------------- | -------------------------------------------------- | | code | `string` | The flag code to check | | defaultValue | `boolean` \| `string` \| `number` | The default value to return if the flag is not set | | type | `enum` (`b` \| `s` \| `i`) | The type of the flag | #### Example ```jsx import {getKindeServerSession} from "@kinde-oss/kinde-auth-nextjs/server"; const {getFlag} = getKindeServerSession(); const billingFlag = await getFlag("billing", false, "b"); console.log(billingFlag); ``` #### Returns ```json { "code": "billing", "type": "boolean", "value": true, "defaultValue": false, "is_default": false } ``` ### `getBooleanFlag` Get a boolean feature flag | Parameter | Type | Description | | ------------ | --------- | -------------------------------------------------- | | code | `string` | The flag code to check | | defaultValue | `boolean` | The default value to return if the flag is not set | #### Example ```jsx import {getKindeServerSession} from "@kinde-oss/kinde-auth-nextjs/server"; const {getBooleanFlag} = getKindeServerSession(); const billingFlag = await getBooleanFlag("billing", false); console.log(billingFlag); ``` #### Returns ```json true; ``` ### `getIntegerFlag` Get a boolean feature flag | Parameter | Type | Description | | ------------ | --------- | -------------------------------------------------- | | code | `string` | The flag code to check | | defaultValue | `boolean` | The default value to return if the flag is not set | #### Example ```jsx import {getKindeServerSession} from "@kinde-oss/kinde-auth-nextjs/server"; const {getIntegerFlag} = getKindeServerSession(); const billingVersion = await getIntegerFlag("billingVersion", 0); console.log(billingVersion); ``` #### Returns ```json 2 ``` ### `getStringFlag` Get a string feature flag | Parameter | Type | Description | | ------------ | -------- | -------------------------------------------------- | | code | `string` | The flag code to check | | defaultValue | `string` | The default value to return if the flag is not set | #### Example ```jsx import {getKindeServerSession} from "@kinde-oss/kinde-auth-nextjs/server"; const {getStringFlag} = getKindeServerSession(); const theme = await getStringFlag("theme", "system"); console.log(theme); ``` #### Returns ```json "light ``` ### `refreshTokens` Refresh tokens to get up-to-date Kinde data #### Example ```jsx import {getKindeServerSession} from "@kinde-oss/kinde-auth-nextjs/server"; import {someUpdateFunction} from "@/app/actions"; const {refreshTokens} = getKindeServerSession(); await someUpdateFunction({ param_1: "value_1", param_2: "value_2" }); await refreshTokens(); ``` ### `getAccessToken` Get the decoded access token #### Example ```jsx import {getKindeServerSession} from "@kinde-oss/kinde-auth-nextjs/server"; const {getAccessToken} = getKindeServerSession(); const accessToken = await getAccessToken(); console.log(accessToken); ``` #### Returns ```json { "aud": ["your-api"], "azp": 1234567890, "email": "example@email.com", "exp": 1234567890, "feature_flags": { "isonboardingcomplete": { "t": "b", "v": false } }, "iat": 1234567890, "iss": "https://your-kinde-subdomain.kinde.com", "jti": "7802e2d2-asdf-431e-bc72-5ed95asdf475d", "org_code": "org_123", "org_name": "Default Org", "organization_properties": { "kp_org_city": {} }, "permissions": ["create:template"], "roles": [ { "id": "018ee9aa-f92b-83fc-1d40-1234567890", "key": "admin", "name": "Admin" } ], "scp": ["openid", "profile", "email", "offline"], "sub": "kp_6123456789009876", "user_properties": { "kp_usr_city": {} } } ``` ### `getAccessTokenRaw` Get the access token #### Example ```jsx import {getKindeServerSession} from "@kinde-oss/kinde-auth-nextjs/server"; const {getAccessTokenRaw} = getKindeServerSession(); const accessToken = await getAccessTokenRaw(); console.log(accessToken); ``` #### Returns ```json eyJhxxx.eyJhdxxx.A4djjxxx ``` ### `getIdToken` Get the decoded ID token #### Example ```jsx import {getKindeServerSession} from "@kinde-oss/kinde-auth-nextjs/server"; const {getIdToken} = getKindeServerSession(); const idToken = await getIdToken(); console.log(idToken); ``` #### Returns ```json { "at_hash": "ZY6jx1SGjzgkHGJ_2Jabcd", "aud": ["feb8e697b967466eacb96d26c5ca0e12"], "auth_time": 1234567890, "azp": "feb8e099xxx", "email": "example@email.com", "email_verified": true, "exp": 123456789, "ext_provider": { "claims": { "connection_id": "bcc486xxx", "email": "example@email.com", "family_name": "User", "given_name": "Example", "is_confirmed": true, "picture": "https://lh3.googleusercontent.com/a/ACgxxx", "profile": { "email": "example@email.com", "family_name": "User", "given_name": "Example", "id": "1234567890", "name": "Example user", "picture": "https://lh3.googleusercontent.com/a/ACgxxx", "verified_email": true } }, "connection_id": "bccxxx", "name": "Google" }, "family_name": "User", "given_name": "Example", "iat": 1234567890, "iss": "https://your-kinde-subdomain.kinde.com", "jti": "e7e18303-0ea5-402d-932c-xxx", "name": "Example user", "org_codes": ["org_123"], "organizations": [ { "id": "org_123", "name": "Default Organization" } ], "picture": "https://lh3.googleusercontent.com/a/ACgxxx", "rat": 1234567890, "sub": "kp_1234567890", "updated_at": 1234567890, "user_properties": { "kp_usr_city": {} } } ``` ### `getIdTokenRaw` Get the ID token #### Example ```jsx import {getKindeServerSession} from "@kinde-oss/kinde-auth-nextjs/server"; const {getIdTokenRaw} = getKindeServerSession(); const idToken = await getIdTokenRaw(); console.log(idToken); ``` #### Returns ```json eyJhxxx.eyJhdxxx.A4djjxxx ``` ### `getClaim` Get a claim from either token | Parameter | Type | Description | | --------- | ------------------------------------- | ------------------------------- | | claim | `string` | The claim key | | type | `enum` (`access_token` \| `id_token`) | The token to get the claim from | #### Example ```jsx import {getKindeServerSession} from "@kinde-oss/kinde-auth-nextjs/server"; const {getClaim} = getKindeServerSession(); const username = await getClaim("preferred_username", "id_token"); console.log(idToken); ``` #### Returns ```json "exampleUsername ``` ## Kinde Auth data - Client You can get an authorized user’s Kinde Auth data from any client component using the `useKindeBrowser` helper. | Variable / Method | Description | | ------------------------------------------------------------------------------------------------------------------------------------ | ----------------------------------------------------- | | [`isAuthenticated`](#isauthenticated-1) | Get a feature flag | | [`user`](#user--getuser) / [`getUser`](#user--getuser) | The current in user's details | | [`organization`](#organization--getorganization) / [`getOrganization`](#organization--getorganization) | The current user’s organization | | [`userOrganizations`](#userorganizations--getuserorganizations) / [`getUserOrganizations`](#userorganizations--getuserorganizations) | All the organizations the current user belongs to | | [`getPermission`](#getpermission-1) | Check if the current user has a permission | | [`permissions`](#permissions--getpermissions) / [`getPermissions`](#permissions--getpermissions) | The current user’s permissions | | [`getFlag`](#getflag-1) | Get the access token | | [`getBooleanFlag`](#getbooleanflag-1) | Get the access token | | [`getIntegerFlag`](#getintegerflag-1) | Get the access token | | [`getStringFlag`](#getstringflag-1) | Get the access token | | [`refreshData`](#refreshdata) | Refresh tokens to get up-to-date Kinde data | | [`accessToken`](#accesstoken--getaccesstoken) / [`getAccessToken`](#accesstoken--getaccesstoken) | Check if the user is authenticated | | [`accessTokenRaw`](#accesstokenraw--getaccesstokenraw) / [`getAccessTokenRaw`](#accesstokenraw--getaccesstokenraw) | Get the current user's details | | [`idToken`](#idtoken--getidtoken) / [`getIdToken`](#idtoken--getidtoken) | Get all the organizations the current user belongs to | | [`idTokenRaw`](#idtokenraw--getidtokenraw) / [`getIdTokenRaw`](#idtokenraw--getidtokenraw) | Check if the current user has a permission | | [`isLoading`](#isloading) | Is Kinde data loading | | [`error`](#error) | Error message if there is an error | **Tip**: Use `isLoading` to ensure the data is up to date. You can return a loading spinner or something similar if you want. ### `isAuthenticated` Check if the user is authenticated. #### Example ```jsx "use client"; import {useKindeBrowserClient} from "@kinde-oss/kinde-auth-nextjs"; const {isAuthenticated} = useKindeBrowserClient(); console.log(isAuthenticated); ``` #### Returns ```typescript true; ``` ### `user` / `getUser` Get the logged in user's details. #### Example ```jsx "use client"; import {useKindeBrowserClient} from "@kinde-oss/kinde-auth-nextjs"; const {user, getUser} = useKindeBrowserClient(); const alsoUser = getUser(); console.log(user); ``` #### Returns ```json { "id": "kp_123", "email": "example@email.com", "family_name": "Example", "given_name": "User", "picture": null, "username": "ExampleUsername", "phone_number": "1234567890", "properties": { "usr_city": "", "usr_industry": "", "usr_job_title": "", "usr_middle_name": "", "usr_postcode": "", "usr_salutation": "", "usr_state_region": "", "usr_street_address": "", "usr_street_address_2": "" } } ``` ### `organization` / `getOrganization` Get the current user’s organization #### Example ```jsx "use client"; import {useKindeBrowserClient} from "@kinde-oss/kinde-auth-nextjs"; const {organization, getOrganization} = useKindeBrowserClient(); const org = getOrganization(); console.log(organization, org); ``` #### Returns ```json { "orgCode": "org_123", "orgName": "Deafault Org", "properties": { "org_city": "", "org_country": "", "org_industry": "", "org_postcode": "", "org_state_region": "", "org_street_address": "", "org_street_address_2": "" } } ``` ### `userOrganizations` / `getUserOrganizations` Get all the organizations the current user belongs to #### Example ```jsx "use client"; import {useKindeBrowserClient} from "@kinde-oss/kinde-auth-nextjs"; const {userOrganizations, getUserOrganizations} = useKindeBrowserClient(); const userOrgs = getUserOrganizations(); console.log(userOrganizations, userOrgs); ``` #### Returns ```json { "orgCodes": ["org_123", "org_456"], "orgs": [ { "code": "org_123", "name": "Deafault Org" }, { "code": "org_456", "name": "Another Org" } ] } ``` ### `getPermission` Check if the current user has a permission. | Parameter | Type | Description | | --------- | -------- | ---------------------------- | | code | `string` | The permission code to check | #### Example ```jsx "use client"; import {useKindeBrowserClient} from "@kinde-oss/kinde-auth-nextjs"; const {getPermission} = useKindeBrowserClient(); const canEatTacos = getPermission("eat:tacos"); console.log(canEatTacos); ``` #### Returns ```json { "isGranted": true, "orgCode": "org_123" } ``` ### `permissions` / `getPermissions` Get the current user’s permissions. #### Example ```jsx "use client"; import {useKindeBrowserClient} from "@kinde-oss/kinde-auth-nextjs"; const {permissions, getPermissions} = useKindeBrowserClient(); const perms = getPermissions(); console.log(permissions, permis); ``` #### Returns ```json { "permissions": ["eat:tacos", "read:books"], "orgCode": "org_123" } ``` ### `getFlag` Get a feature flag | Parameter | Type | Description | | ------------ | --------------------------------- | -------------------------------------------------- | | code | `string` | The flag code to check | | defaultValue | `boolean` \| `string` \| `number` | The default value to return if the flag is not set | | type | `enum` (`b` \| `s` \| `i`) | The type of the flag | #### Example ```jsx "use client"; import {useKindeBrowserClient} from "@kinde-oss/kinde-auth-nextjs"; const {getFlag} = useKindeBrowserClient(); const billingFlag = getFlag("billing", false, "b"); console.log(billingFlag); ``` #### Returns ```json { "code": "billing", "type": "boolean", "value": true, "defaultValue": false, "is_default": false } ``` ### `getBooleanFlag` Get a boolean feature flag | Parameter | Type | Description | | ------------ | --------- | -------------------------------------------------- | | code | `string` | The flag code to check | | defaultValue | `boolean` | The default value to return if the flag is not set | #### Example ```jsx "use client"; import {useKindeBrowserClient} from "@kinde-oss/kinde-auth-nextjs"; const {getBooleanFlag} = useKindeBrowserClient(); const billingFlag = getBooleanFlag("billing", false); console.log(billingFlag); ``` #### Returns ```json true; ``` ### `getIntegerFlag` Get a boolean feature flag | Parameter | Type | Description | | ------------ | --------- | -------------------------------------------------- | | code | `string` | The flag code to check | | defaultValue | `boolean` | The default value to return if the flag is not set | #### Example ```jsx "use client"; import {useKindeBrowserClient} from "@kinde-oss/kinde-auth-nextjs"; const {getIntegerFlag} = useKindeBrowserClient(); const billingVersion = getIntegerFlag("billingVersion", 0); console.log(billingVersion); ``` #### Returns ```json 2 ``` ### `getStringFlag` Get a string feature flag | Parameter | Type | Description | | ------------ | -------- | -------------------------------------------------- | | code | `string` | The flag code to check | | defaultValue | `string` | The default value to return if the flag is not set | #### Example ```jsx "use client"; import {useKindeBrowserClient} from "@kinde-oss/kinde-auth-nextjs"; const {getStringFlag} = useKindeBrowserClient(); const theme = getStringFlag("theme", "system"); console.log(theme); ``` #### Returns ```json "light ``` ### `refreshData` Refresh tokens to get up-to-date Kinde data #### Example ```jsx "use client"; import {useKindeBrowserClient} from "@kinde-oss/kinde-auth-nextjs"; import {someUpdateFunction} from "@/app/actions"; const {refreshData} = useKindeBrowserClient(); await someUpdateFunction({ param_1: "value_1", param_2: "value_2" }); await refreshData(); ``` ### `accessToken` / `getAccessToken` Get the decoded access token #### Example ```jsx "use client"; import {useKindeBrowserClient} from "@kinde-oss/kinde-auth-nextjs"; const {accessToken, getAccessToken} = useKindeBrowserClient(); const aTok = getAccessToken(); console.log(accessToken, aTok); ``` #### Returns ```json { "aud": ["your-api"], "azp": 1234567890, "email": "example@email.com", "exp": 1234567890, "feature_flags": { "isonboardingcomplete": { "t": "b", "v": false } }, "iat": 1234567890, "iss": "https://your-kinde-subdomain.kinde.com", "jti": "7802e2d2-asdf-431e-bc72-5ed95asdf475d", "org_code": "org_123", "org_name": "Default Org", "organization_properties": { "kp_org_city": {} }, "permissions": ["create:template"], "roles": [ { "id": "018ee9aa-f92b-83fc-1d40-1234567890", "key": "admin", "name": "Admin" } ], "scp": ["openid", "profile", "email", "offline"], "sub": "kp_6123456789009876", "user_properties": { "kp_usr_city": {} } } ``` ### `accessTokenRaw` / `getAccessTokenRaw` Get the access token #### Example ```jsx import {useKindeBrowserClient} from "@kinde-oss/kinde-auth-nextjs"; const {accessTokenRaw, getAccessTokenRaw} = useKindeBrowserClient(); const aTokRaw = getAccessTokenRaw(); console.log(accessTokenRaw, aTokRaw); ``` #### Returns ```json eyJhxxx.eyJhdxxx.A4djjxxx ``` ### `idToken` / `getIdToken` Get the decoded ID token #### Example ```jsx import {useKindeBrowserClient} from "@kinde-oss/kinde-auth-nextjs"; const {idToken, getIdToken} = useKindeBrowserClient(); const idTok = getIdToken(); console.log(idToken, idTok); ``` #### Returns ```json { "at_hash": "ZY6jx1SGjzgkHGJ_2Jabcd", "aud": ["feb8e697b967466eacb96d26c5ca0e12"], "auth_time": 1234567890, "azp": "feb8e099xxx", "email": "example@email.com", "email_verified": true, "exp": 123456789, "ext_provider": { "claims": { "connection_id": "bcc486xxx", "email": "example@email.com", "family_name": "User", "given_name": "Example", "is_confirmed": true, "picture": "https://lh3.googleusercontent.com/a/ACgxxx", "profile": { "email": "example@email.com", "family_name": "User", "given_name": "Example", "id": "1234567890", "name": "Example user", "picture": "https://lh3.googleusercontent.com/a/ACgxxx", "verified_email": true } }, "connection_id": "bccxxx", "name": "Google" }, "family_name": "User", "given_name": "Example", "iat": 1234567890, "iss": "https://your-kinde-subdomain.kinde.com", "jti": "e7e18303-0ea5-402d-932c-xxx", "name": "Example user", "org_codes": ["org_123"], "organizations": [ { "id": "org_123", "name": "Default Organization" } ], "picture": "https://lh3.googleusercontent.com/a/ACgxxx", "rat": 1234567890, "sub": "kp_1234567890", "updated_at": 1234567890, "user_properties": { "kp_usr_city": {} } } ``` ### `idTokenRaw` / `getIdTokenRaw` Get the ID token #### Example ```jsx import {useKindeBrowserClient} from "@kinde-oss/kinde-auth-nextjs"; const {idTokenRaw, getIdTokenRaw} = useKindeBrowserClient(); const idTokRaw = getIdTokenRaw(); console.log(idTokenRaw, idTokRaw); ``` #### Returns ```json eyJhxxx.eyJhdxxx.A4djjxxx ``` ### `isLoading` Is Kinde data loading #### Example ```jsx import {useKindeBrowserClient} from "@kinde-oss/kinde-auth-nextjs"; const {user, isLoading} = useKindeBrowserClient(); if (isLoading) return <div>Loading...</div>; return <div>Hello {user.given_name}</div>; ``` #### Returns ```json true ``` ### `error` Error message if there is an error #### Example ```jsx import {useKindeBrowserClient} from "@kinde-oss/kinde-auth-nextjs"; const {user, isLoading, error} = useKindeBrowserClient(); if (isLoading) return <div>Loading...</div>; if (error) return <div>There was an error</div>; return <div>Hello {user.given_name}</div>; ``` #### Returns ```json true ``` ## Protecting routes It’s likely that your application will have both pages that are publicly available and private ones which should only be available to logged in users. There are multiple ways you can protect pages with Kinde Auth. ### Protect routes with Kinde Auth data On the page you want to protect, you can check if the user is authenticated and then handle it right then and there by grabbing the Kinde Auth data. - In **Server Components** you can get the Kinde Auth data by using the `getKindeServerSession` helper - In **Client Components** you can get the Kinde Auth Data using the `useKindeBrowserClient` helper ```jsx // app/protected/page.tsx - Server Component import { LoginLink } from "@kinde-oss/kinde-auth-nextjs/components"; import { getKindeServerSession } from "@kinde-oss/kinde-auth-nextjs/server"; export default async function Protected() { const { isAuthenticated } = getKindeServerSession(); return (await isAuthenticated()) ? ( <div> This page is protected - but you can view it because you are authenticated </div> ) : ( <div> This page is protected, please <LoginLink>Login</LoginLink> to view it </div> ); } // app/protected/page.tsx - Client component "use client"; import { useKindeBrowserClient } from "@kinde-oss/kinde-auth-nextjs"; import { LoginLink } from "@kinde-oss/kinde-auth-nextjs/components"; export default function Admin() { const { isAuthenticated, isLoading } = useKindeBrowserClient(); if (isLoading) return <div>Loading...</div>; return isAuthenticated ? ( <div>Admin content</div> ) : ( <div> You have to <LoginLink>Login</LoginLink> to see this page </div> ); } ``` In the example above, we show different content based on whether or not the user is authenticated. If you want to automatically send the user to the sign in screen, you can do something like the following: ```jsx // app/protected/page.tsx - Server Component import {getKindeServerSession} from "@kinde-oss/kinde-auth-nextjs/server"; import {redirect} from "next/navigation"; export default async function Protected() { const {isAuthenticated} = getKindeServerSession(); if (!(await isAuthenticated())) { redirect("/api/auth/login"); } return <div>Protected content</div>; } // app/protected/page.tsx - Client Component // As of right now, this can't be done in Client Components because of how Next.js handles // navigation in client components with prefetching and caching. // But you can still achieve an automatic redirect with middleware ``` If you want the user to be redirected back to that route after signing in, you can set `post_login_redirect_url` in the search params of the redirect. ```jsx if (!(await isAuthenticated())) { redirect("/api/auth/login?post_login_redirect_url=/protected"); } ``` ## Refreshing Kinde data Our middleware will automatically refresh the tokens in your session in the background. Sometimes, you may want to refresh these tokens on demand. An example of this is when you update Kinde data via the UI or with the Management API. To immediately get the most up-to-date Kinde data in your session, use the `refreshData` function provided by `useKindeBrowserClient`. <Aside title="Warning" type="warning"> This utility only works in Next.js 14 and above. Attempting to use it in an older version will result in a warning. Due to limitations in Next.js, refreshing data on demand can only occur from a client component. For more information, see the [Next.js docs](https://nextjs.org/docs/app/api-reference/functions/cookies#understanding-cookie-behavior-in-server-components). </Aside> <Aside title="Important"> The `refreshData` function is an asynchronous server action, and it's important to await it so that you receive immediate access to the latest data. </Aside> ```tsx "use client"; import { useKindeBrowserClient } from "@kinde-oss/kinde-auth-nextjs"; export const UpdatePermissionsButton = () => { const { refreshData, getPermissions } = useKindeBrowserClient(); const handleUpdatePermissions = async () => { // For example purposes, lets say you have an API route that updates the permissions for a user await fetch("/api/user/permissions"); // Then you can refresh the data and have the changes reflected immediately await refreshData(); const newPermissions = getPermissions(); // Do something with the new permissions // ... } return ( <button type="button onClick={handleUpdatePermissions} > Update Permissions </button> ); }; ``` ## Kinde Management API To use our management API please see [@kinde/management-api-js](https://github.com/kinde-oss/management-api-js) Server Component example: ```typescript import { Roles, Users } from "@kinde/management-api-js"; export default async function Dashboard() { const { roles } = await Roles.getRoles(); const { users } = await Users.getUsers(); return ( <div className="container"> <div className="card start-hero"> <p className="text-body-2 start-hero-intro">Woohoo!</p> <p className="text-display-2"> Your authentication is all sorted. <br /> Build the important stuff. </p> </div> <section className="next-steps-section"> <h2 className="text-heading-1">Next steps for you</h2> </section> <pre>{JSON.stringify(users, null, 2)}</pre> </div> ); } ``` Route Handler example: ```typescript import {NextResponse} from "next/server"; import {Users} from "@kinde/management-api-js"; export async function GET() { const {users} = await Users.getUsers(); return NextResponse.json({users}); } ``` ## Organizations ### Create organizations To create an organization from your app, you can use the `CreateOrgLink` component. ```jsx import {CreateOrgLink} from "@kinde-oss/kinde-auth-nextjs/components"; <CreateOrgLink orgName="Hurlstone">Create org</CreateOrgLink>; ``` ### Sign in to organizations You can have your users sign in to a specific organization by setting the `orgCode` param in the `LoginLink` and `RegisterLink` components. ```jsx import {LoginLink, RegisterLink} from "@kinde-oss/kinde-auth-nextjs/components"; <LoginLink orgCode="org_7392cf35a1e">Login</LoginLink> <RegisterLink orgCode="org_7392cf35a1e">Register</RegisterLink> ``` If the `orgCode` is not specified and the user belongs to multiple organizations, they will be prompted to choose which organization to sign in to during the login or register flow. ## Self Serve Portal To allow your users to be sent to the self-serve portal, you can use the `PortalLink` component. Check here for information on enabling [self-serve portal for Organizations](https://docs.kinde.com/build/self-service-portal/self-serve-portal-for-orgs/). Check here for information on enabling [self-serve portal for users](https://docs.kinde.com/build/self-service-portal/self-serve-portal-for-users/). To use our self-serve portal API please see [Get self-serve portal link](https://docs.kinde.com/kinde-apis/frontend/). ```jsx import {PortalLink} from "@kinde-oss/kinde-auth-nextjs/components"; <PortalLink>Portal Link Name</PortalLink> ``` ### subNav The `subNav=""` property allows you to set the area of the portal you want the user to land on. By default, it will send users to their profile. ```jsx import {PortalLink} from "@kinde-oss/kinde-auth-nextjs/components"; import { PortalPage } from "@kinde/js-utils"; <PortalLink subNav={PortalPage.organizationPaymentDetails}></PortalLink> ``` ### returnUrl The `returnUrl` property is the URL to redirect the user to after they have completed their actions in the portal. The url must be an absolute url to work correctly. ```jsx import {PortalLink} from "@kinde-oss/kinde-auth-nextjs/components"; <PortalLink returnUrl="http://yourdomain.example"></PortalLink> ``` ## Analytics ### UTM tags UTM tags can be used with the `LoginLink` and `RegisterLink` components to track auth traffic from its origin. You can then track the tags on the Analytics dashboard from within the Kinde app. ```jsx import {LoginLink} from "@kinde-oss/kinde-auth-nextjs/components"; <LoginLink authUrlParams={{ utm_source: "reddit", utm_medium: "social", utm_campaign: "redjune23", utm_term: "save90", utm_content: "desktop" }} > Login </LoginLink>; ``` ## Internationalization You can set the language you wish your users to see when they hit the login flow by including the `lang` attribute as a part of the `authUrlParams` when using the `LoginLink` and `RegisterLink` components. ```jsx import {LoginLink} from "@kinde-oss/kinde-auth-nextjs/components"; <LoginLink authUrlParams={{ lang: "en-AU" }} > Login </LoginLink>; ``` ## **Audience** An `audience` is the intended recipient of an access token - for example the API for your application. The `audience` argument can be passed to the Kinde client to request an audience be added to the provided token. ```jsx // .env.local ... KINDE_AUDIENCE=<your-api> ``` You can request multiple audiences by providing a white space separated list ```jsx // .env.local ... KINDE_AUDIENCE=<your-api-1> <your-api-2> ``` For details on how to connect, see [Register an API](/developer-tools/your-apis/register-manage-apis/). ## Working with subdomains In the case you have a [custom domain](/build/domains/pointing-your-domain/) and you would like to start the authentication flow from a URL like **`auth`**`.mysite.com` and you want to redirect to a URL like **`app`**`.mysite.com` , all you have to do is set the `KINDE_COOKIE_DOMAIN` to match the domain. ```jsx // .env ... KINDE_COOKIE_DOMAIN=.mysite.com ``` If the URL you want to start the authentication flow from and the URL you want to redirect to don’t share the same domain, then this will not work. ## Working with preview URLs Our Kinde Next.js SDK currently requires that these environment variables `KINDE_SITE_URL`, `KINDE_POST_LOGOUT_REDIRECT_URL`, and `KINDE_POST_LOGIN_REDIRECT_URL` are defined, and that the **callback URLs** and **logout redirect URLs** are added to your app in Kinde. To add Vercel’s dynamically generated URLs you can either securely use our API to add them on the fly or you can use [wildcard URLs](/get-started/connect/callback-urls/#wildcards-in-callback-urls). It should be noted that whilst wildcards are more convenient it is not as secure as explicitly adding the url to the allowlist via API as we outline below. Add the following to your `next.config.js`. ```jsx /** @type {import('next').NextConfig} */ const nextConfig = { env: { KINDE_SITE_URL: process.env.KINDE_SITE_URL ?? `https://${process.env.VERCEL_URL}`, KINDE_POST_LOGOUT_REDIRECT_URL: process.env.KINDE_POST_LOGOUT_REDIRECT_URL ?? `https://${process.env.VERCEL_URL}`, KINDE_POST_LOGIN_REDIRECT_URL: process.env.KINDE_POST_LOGIN_REDIRECT_URL ?? `https://${process.env.VERCEL_URL}/dashboard` } }; module.exports = nextConfig; ``` This ensures Vercel uses its generated preview URLs to populate the three Kinde variables. - Make sure the above values match your application (e.g. “/dashboard” for `KINDE_POST_LOGIN_REDIRECT_URL`) - Also make sure variables are not set for the preview environment in your Vercel project. If they are, they will be overridden by the new variables in the `next.config.js` file. ### Add callback URLs and logout redirect URLs to Kinde dynamically Create a script that will run each time a new preview is deployed by Vercel, which will add the newly generated URL to Kinde. You need to create a [machine to machine (M2M)](/developer-tools/kinde-api/connect-to-kinde-api/) application to connect to the [Kinde Management API](/kinde-apis/management/). 1. Create a **Machine to machine (M2M)** app. 1. In Kinde, go to **Settings > Applications** and click on **Add application**. 2. Give your application a name and select **Machine to machine (M2M)**. 3. Select **Save**. 4. On the next screen, take note of the **Client ID** and **Client secret** values and add them to your `.env.local` file as `KINDE_M2M_CLIENT_ID` and `KINDE_M2M_CLIENT_SECRET`. 5. On the same screen, click on **APIs** on the left menu. 6. Authorize your M2M application to access the Kinde Management API by selecting the three dots (`...`) and clicking **Authorize application**. 7. Once the application is authorized, select the three dots (`...`) again and this time select **Manage scopes**. 8. Since we will be adding callback and redirect URLs dynamically via the Kinde Management API, you will need to toggle the switch for `create:application_redirect_uris` and `create:application_logout_uris`. 9. Select **Save**. 2. In your application source code, create a folder at the top level called `scripts`. 3. Within that folder, create a file called `add-urls-to-kinde.js` and add the following code: ```jsx async function getAuthToken() { try { const response = await fetch(`${process.env.KINDE_ISSUER_URL}/oauth2/token`, { method: "POST", headers: { "Content-Type": "application/x-www-form-urlencoded", Accept: "application/json" }, body: new URLSearchParams({ client_id: process.env.KINDE_M2M_CLIENT_ID, client_secret: process.env.KINDE_M2M_CLIENT_SECRET, grant_type: "client_credentials", audience: `${process.env.KINDE_ISSUER_URL}/api` }) }); if (!response.ok) { throw new Error(`Failed to get auth token: ${response.statusText}`); } const data = await response.json(); return data.access_token; } catch (error) { console.error("Error getting auth token:", error); throw error; } } async function addLogoutUrlToKinde(token) { try { const response = await fetch( `${process.env.KINDE_ISSUER_URL}/api/v1/applications/${process.env.KINDE_CLIENT_ID}/auth_logout_urls`, { method: "POST", headers: { Authorization: `Bearer ${token}`, Accept: "application/json", "Content-Type": "application/json" }, body: JSON.stringify({ urls: [`https://${process.env.VERCEL_URL}`] }) } ); if (!response.ok) { throw new Error(`Failed to add logout URL to Kinde: ${response.statusText}`); } const responseData = await response.json(); console.log(`SUCCESS: Logout URL added to Kinde: ${process.env.VERCEL_URL}`, responseData); } catch (error) { console.error("Failed to add logout URL to Kinde", error); throw error; } } async function addCallbackUrlToKinde(token) { try { const response = await fetch( `${process.env.KINDE_ISSUER_URL}/api/v1/applications/${process.env.KINDE_CLIENT_ID}/auth_redirect_urls`, { method: "POST", headers: { Authorization: `Bearer ${token}`, Accept: "application/json", "Content-Type": "application/json" }, body: JSON.stringify({ urls: [`https://${process.env.VERCEL_URL}/api/auth/kinde_callback`] }) } ); if (!response.ok) { throw new Error(`Failed to add callback URL to Kinde: ${response.statusText}`); } const responseData = await response.json(); console.log( `SUCCESS: Callback URL added to Kinde: ${process.env.VERCEL_URL}/api/auth/kinde_callback`, responseData ); } catch (error) { console.error("Failed to add callback URL to Kinde", error); throw error; } } (async () => { if (process.env.VERCEL == 1) { try { const authToken = await getAuthToken(); await addCallbackUrlToKinde(authToken); await addLogoutUrlToKinde(authToken); } catch (error) { console.error("Script failed:", error); } } })(); ``` <Aside> You can adapt the script above to use our [Kinde Management API JS](https://github.com/kinde-oss/management-api-js) package. Please note that in this case you would have to add this package as a dependency in your project along with a few required environment variables. [See configuration details](https://github.com/kinde-oss/management-api-js?tab=readme-ov-file#installation). </Aside> 4. In your `package.json`, add a `postbuild` script that will run the `/scripts/add-urls-to-kinde.js` file after Vercel builds your app. ```json "scripts": { "dev": "next dev", "build": "next build", "start": "next start", "lint": "next lint", "postbuild": "node ./scripts/add-urls-to-kinde.js" } ``` 5. Commit these changes. The next deploy will add the newly created preview URLs to your Kinde application. ## Health check To check your configuration, the SDK exposes an endpoint with your settings. **Note**: The client secret will indicate only if the secret is set or not set correctly. `/api/auth/health` ```jsx { "apiPath": "/api/auth", "redirectURL": "http://localhost:3000/api/auth/kinde_callback", "postLoginRedirectURL": "http://localhost:3000/dashboard", "issuerURL": "https://<your_kinde_subdomain>.kinde.com", "clientID": "<your_kinde_client_id>", "clientSecret": "Set correctly", "postLogoutRedirectURL": "http://localhost:3000", "logoutRedirectURL": "http://localhost:3000" } ``` ## State not found error ### Solution 1. Confirm that the domain you start the auth flow from is different from the domain you are redirected to after the auth flow is complete. If this is not the case, see the explanation. 2. Dynamically set the KINDE_SITE_URL and `KINDE_POST_LOGIN_REDIRECT_URL` when working with vercel preview domains. If you are using Vercel, you can set the `KINDE_SITE_URL` and `KINDE_POST_LOGIN_REDIRECT_URL` dynamically. ```jsx title="next.config.js const nextConfig = { env: { KINDE_SITE_URL: process.env.KINDE_SITE_URL ?? `https://${process.env.VERCEL_URL}`, KINDE_POST_LOGOUT_REDIRECT_URL: process.env.KINDE_POST_LOGOUT_REDIRECT_URL ?? `https://${process.env.VERCEL_URL}`, KINDE_POST_LOGIN_REDIRECT_URL: process.env.KINDE_POST_LOGIN_REDIRECT_URL ?? `https://${process.env.VERCEL_URL}/dashboard` } }; module.exports = nextConfig; ``` ### Explanation The `State not found error` in production is usually a result of a mismatch between a few variables. - `KINDE_SITE_URL` and/or `KINDE_POST_LOGIN_REDIRECT_URL` - The domain you are on e.g. `your-app-projects.vercel.app` - Callback URL set on the Kinde dashboard If you set `KINDE_SITE_URL=https:// your-app-projects.vercel.app` and `KINDE_POST_LOGIN_REDIRECT_URL=https:// your-app-projects.vercel.app/dashboard`. And you also set your Callback URL to be `your-app-\*.vercel.app/api/auth/kinde_callback`. You should be able to click login and complete the auth flow. However if you start the auth flow from a Vercel preview domain `your-app-PREVIEW-projects.vercel.app` and complete the auth flow, you will be redirected to `your-app-projects.vercel.app/api/auth/kinde_callback` which is **NOT** the same as the domain you started the auth flow on. The error happens because when you start the auth flow, a `state` cookie is set which needs to be checked against when you return back to your app. In this case, you are **NOT** being redirect to the app you started the flow on, but rather another domain where the app is running which does not have the `state` cookie. Since there is a `state` cookie mismatch, the auth flow is aborted for security reasons. The reason why you are redirected to the wrong domain because is likely because your `KINDE_POST_LOGIN_REDIRECT_URL` environment variable is static and is set for all your deployments/domains. You should set the `KINDE_POST_LOGIN_REDIRECT_URL` dynamically based on the domain you initiating the auth flow from. ## Debug mode In debug mode you will see more logs in your console that may help with debugging. ```jsx // .env KINDE_DEBUG_MODE = true; ``` ## Migration guide Changes when moving from the previous version. `handleAuth` - is now imported from `“@kinde-oss/kinde-auth-nextjs/server”` ```jsx import {handleAuth} from "@kinde-oss/kinde-auth-nextjs/server"; export const GET = handleAuth(); ``` `getKindeServerSession` - functions returned from `getKindeServerSession` now return promises ```jsx const {getUser} = getKindeServerSession(); const user = await getUser(); ```

# Developer tools - Sdks - Next.js App Router SDK v1

> Legacy guide for Next.js App Router SDK v1 including authentication setup, server-side components, and client component integration.

next.js app router v1, legacy sdk, server side components, authentication, client components, migration
developer-tools, sdks, nextjs, backend

This SDK is for developers already using the Next.js SDK v1.8.25 or earlier document. It is relevant for Next.js version 13+ and uses Server Side Components and App Router. ## Other document versions - If you have not already installed the Next.js SDK, we recommend you use the latest [Next.js App Router](/developer-tools/sdks/backend/nextjs-sdk/) document. - If you are using the Pages Router, refer to the latest [Next.js Pages Router](/developer-tools/sdks/backend/nextjs-prev-sdk/) document. The older version is still available at [Next.js Pages Router v1](/developer-tools/sdks/backend/nextjs-prev-sdkv1/) SDK. ## Register for a Kinde account If you haven’t already got a Kinde account, [register for free here](https://app.kinde.com/register) (no credit card required). Registering gives you a Kinde domain, which you need to get started, e.g. **yourapp.kinde.com**. You can also view the [Next.js docs](https://github.com/kinde-oss/kinde-auth-nextjs) and [Next.js starter kit](https://github.com/kinde-starter-kits/kinde-nextjs-app-router-starter-kit) in GitHub. ## **Installation** <PackageManagers pkg="@kinde-oss/kinde-auth-nextjs@1" /> ## **Set callback URLs** 1. In Kinde, go to **Settings > Applications > [Your app] > View details**. 2. Add your callback URLs in the relevant fields. For example: - Allowed callback URLs (also known as redirect URIs) - for example [`http://localhost:3000/api/auth/kinde_callback`](http://localhost:3000/api/auth/kinde_callback) - Allowed logout redirect URLs - for example `http://localhost:3000` 3. Select **Save**. ## **Environments** If you would like to use our Environments feature as part of your development process. You will need to create them first [within your Kinde account](/build/environments/environments/). In this case you would use the Environment subdomain in the code block above. ## **Configuring your app** ### **Environment variables** Put these variables in your `.env.local` file. You can find these variables on your Kinde **Settings > Applications > [Your app] > View details** page. - KINDE_CLIENT_ID - Your business’s unique ID on Kinde - KINDE_CLIENT_SECRET - Your business’s secret key (do not share) - KINDE_ISSUER_URL - your kinde domain - KINDE_SITE_URL - where your app is running - KINDE_POST_LOGOUT_REDIRECT_URL - where you want users to be redirected to after logging out. Make sure this URL is under your allowed logout redirect URLs. - KINDE_POST_LOGIN_REDIRECT_URL - where you want users to be redirected to after authenticating. Replace the information in the \<angle brackets> with your own information. You might also set different URLs depending where your project is running. They need to be the same as the callback URLs you entered in Kinde, above. ```bash KINDE_CLIENT_ID=<your_kinde_client_id> KINDE_CLIENT_SECRET=<your_kinde_client_secret> KINDE_ISSUER_URL=https://<your_kinde_subdomain>.kinde.com KINDE_SITE_URL=http://localhost:3000 KINDE_POST_LOGOUT_REDIRECT_URL=http://localhost:3000 KINDE_POST_LOGIN_REDIRECT_URL=http://localhost:3000/dashboard ``` ### **API endpoints** Create the following file `src/app/api/auth/[kindeAuth]/route.js` inside your Next.js project. Inside the file `route.js` put this code: ```jsx import {handleAuth} from "@kinde-oss/kinde-auth-nextjs/server"; export async function GET(request, {params}) { const endpoint = params.kindeAuth; return await handleAuth(request, endpoint); } ``` This will handle Kinde Auth endpoints in your Next.js app. **Important!** Our SDK relies on this file existing in this location specified above. ## **Integrate with your app** ### Sign up and sign in The SDK ships with `<LoginLink>` and `<RegisterLink>` components which can be used to start the auth flow. ```jsx import {RegisterLink, LoginLink} from "@kinde-oss/kinde-auth-nextjs/server"; ... <LoginLink>Sign in</LoginLink> <RegisterLink>Sign up</RegisterLink> ``` ### Log out This is implemented in much the same way as signing up or signing in. A component is provided for you. ```jsx import {LogoutLink} from "@kinde-oss/kinde-auth-nextjs/server"; ... <LogoutLink>Log out</LogoutLink> ``` ### Test sign up Register your first user by signing up yourself. You’ll see your newly registered user on the **Users** page in Kinde. ## **View user profile** You can get an authorized user’s profile from any component using the Kinde Next.js `getKindeServerSession` helper: ```jsx import {getKindeServerSession} from "@kinde-oss/kinde-auth-nextjs/server"; const SayHello = async () => { const {getUser} = getKindeServerSession(); const user = await getUser(); return <p>Hi {user.given_name}!</p>; }; ``` To be on the safe side we also provide `isAuthenticated` flag in this helper: ```jsx import { getKindeServerSession } from "@kinde-oss/kinde-auth-nextjs/server"; const UserProfile = async () => { const { getUser, isAuthenticated } = getKindeServerSession(); const user = await getUser(); return ( { (await isAuthenticated()) ? <div> <h2>{user.given_name}</h2> <p>{user.email}</p> </div> : <p>Please sign in or register!</p> } ); }; ``` ## Client Components In Next.js you can opt into using Client Components which give you interactivity benefits and access to the browser APIs. You can read more about them in the [Next.js docs](https://nextjs.org/docs/app/building-your-application/rendering/client-components). To get the Kinde session data in your Client Components follow these two steps: 1. Create an API route in your Next.js project that returns the data from `getKindeServerSession`. ```typescript // app/api/kindeSession/route.ts import {getKindeServerSession} from "@kinde-oss/kinde-auth-nextjs/server"; import {NextResponse} from "next/server"; export async function GET() { const {getUser, isAuthenticated, getPermissions, getOrganization} = getKindeServerSession(); const user = await getUser(); const authenticated = await isAuthenticated(); const permissions = await getPermissions(); const organization = await getOrganization(); return NextResponse.json({user, authenticated, permissions, organization}); } ``` 2. Fetch the data from the API endpoint in your component inside a `useEffect` and then save the data to the component state. ```typescript // some client component "use client"; import { useEffect, useState } from "react"; export default function UploadProfilePic() { const [user, setUser] = useState<any>(); const [authStatus, setAuthStatus] = useState(null); console.log(user); useEffect(() => { const getKindeSession = async () => { const res = await fetch("/api/kindeSession"); const data = await res.json(); setUser(data.user); setAuthStatus(data.authenticated); }; getKindeSession(); }, []); ``` ## **Protecting pages** It’s likely that your application will have both pages that are publicly available and private ones which should only be available to logged in users. 1. Inside your `src` folder create a `middleware.js` file containing the following code: ```jsx import {authMiddleware} from "@kinde-oss/kinde-auth-nextjs/server"; export const config = { matcher: [ /* * Match all request paths except for the ones starting with: * - api (API routes) * - _next/static (static files) * - _next/image (image optimization files) * - favicon.ico (favicon file) */ "/((?!api|_next/static|_next/image|favicon.ico).*) ] }; export default authMiddleware; ``` 2. Create a page at `src/app/dashboard/page.js` ```jsx export default function Dashboard() { return ( <div> <p>Welcome to the dashboard!</p> </div> ); } ``` 3. Try to access this page when signed in and when signed out. Notice how you’ll be redirected to the home page when not authenticated. ### Protect your API The `getKindeServerSession` helper is also available in your API. Create an endpoint in the new App Router pattern at `app/api/protected/route.js` and include the following code block: ```jsx import {NextResponse} from "next/server"; import {getKindeServerSession} from "@kinde-oss/kinde-auth-nextjs/server"; export async function GET() { const {getUser, isAuthenticated} = getKindeServerSession(); if (await !isAuthenticated()) { return new Response("Unauthorized", {status: 401}); } const user = await getUser(); const data = {message: "Hello User", id: user.id}; return NextResponse.json({data}); } ``` This will check if the user is authenticated, and if not, will throw a 401 error. ## **User Permissions** Once a user has been verified as signed in, your product/application will receive the JWT token with an array of permissions for that user. You will need to configure your product/application to read permissions and unlock the respective functions. You set permissions in your Kinde account (see help article), the below is an example set of permissions. ```json "permissions":[ "create:todos", "update:todos", "read:todos", "delete:todos", "create:tasks", "update:tasks", "read:tasks", "delete:tasks ] ``` We provide helper functions to more easily access permissions: ```jsx const {getPermission, getPermissions} = getKindeServerSession(); getPermission("create:todos"); // {orgCode: "org_1234", isGranted: true} getPermissions(); // {orgCode: "org_1234", permissions: ["create:todos", "update:todos", "read:todos"]} ``` A practical example in code might look something like: ```jsx { (await getPermission("create:todos").isGranted) ? <button>Create todo</button> : null; } ``` ## **Audience** An `audience` is the intended recipient of an access token - for example the API for your application. The `audience` argument can be set against `KINDE_AUDIENCE` in your environment variables. The audience of a token is the intended recipient of the token. ```jsx // .env file KINDE_AUDIENCE = your_audience; ``` For details on how to connect, see [Register an API](/developer-tools/your-apis/register-manage-apis/). ## **Feature flags** When a user signs in the Access token your product/application receives contains a custom claim called `feature_flags` which is an object detailing the feature flags for that user. You can set feature flags in your Kinde account. Here’s an example. ```jsx feature_flags: { theme: { "t": "s", "v": "pink" }, is_dark_mode: { "t": "b", "v": true }, competitions_limit: { "t": "i", "v": 5 } } ``` In order to minimize the payload in the token we have used single letter keys / values where possible. The single letters represent the following: `t` = `type` `v` = `value` `s` = `string` `b` = `boolean` `i` = `integer` We provide helper functions to more easily access feature flags: ```jsx /** * Get a flag from the feature_flags claim of the access_token. * @param {string} code - The name of the flag. * @param {obj} [defaultValue] - A fallback value if the flag isn't found. * @param {'s'|'b'|'i'|undefined} [flagType] - The data type of the flag (integer / boolean / string). * @return {object} Flag details. */ const { getFlag } = getKindeServerSession(); /* Example usage */ getFlag('theme'); /*{ // "code": "theme", // "type": "string", // "value": "pink", // "is_default": false // whether the fallback value had to be used */} getFlag('create_competition', {defaultValue: false}); /*{ "code": "create_competition", "value": false, "is_default": true // because fallback value had to be used }*/ ``` A practical example in code might look something like: ```jsx const {getFlag} = getKindeServerSession(); { (await getFlag("create_competition").value) ? <button>Create competition</button> : null; } ``` We also require wrapper functions by type which should leverage `getFlag` above. Booleans: ```jsx /** * Get a boolean flag from the feature_flags claim of the access_token. * @param {string} code - The name of the flag. * @param {bool} [defaultValue] - A fallback value if the flag isn't found. * @return {bool} */ const {getBooleanFlag} = getKindeServerSession(); /* Example usage */ getBooleanFlag("is_dark_mode"); // true getBooleanFlag("is_dark_mode", false); // true getBooleanFlag("new_feature", false); // false (flag does not exist so falls back to default) ``` Strings and integers work in the same way as booleans above: ```jsx /** * Get a string flag from the feature_flags claim of the access_token. * @param {string} code - The name of the flag. * @param {string} [defaultValue] - A fallback value if the flag isn't found. * @return {string} */ const {getStringFlag} = getKindeServerSession(); /** * Get an integer flag from the feature_flags claim of the access_token. * @param {string} code - The name of the flag. * @param {int} [defaultValue] - A fallback value if the flag isn't found. * @return {int} */ const {getIntegerFlag} = getKindeServerSession(); ``` A practical example in code might look something like: ```jsx const {getBooleanFlag, getStringFlag} = getKindeServerSession(); { (await getBooleanFlag("create_competition")) ? ( <button className={`theme-${getStringFlag("theme")}`}>Create competition</button> ) : null; } ``` ## **Organizations** ### **Creating an organization** To have a new organization created within your application, you can use the `<CreateOrgLink>` component that ships with the SDK. This will redirect the user to Kinde and create an organization with them as a member. ```jsx import {CreateOrgLink} from "@kinde-oss/kinde-auth-nextjs/server"; ... <CreateOrgLink orgName="My org">Create Org</CreateOrgLink> ``` ### Signing up/login users to organizations Every organization in Kinde has a unique code. To sign up a new user into a particular organization you will need to pass through this code in the `<RegisterLink />` component. ```jsx import {RegisterLink} from "@kinde-oss/kinde-auth-nextjs/server"; ... <RegisterLink orgCode="org_123456">Sign up to org</RegisterLink> ``` This code should also be passed along with the `<LoginLink>` component if you wish for a user to be logged into a specific organization. ```jsx <LoginLink orgCode="org_123456">Sign into org</LoginLink> ``` For more information about using organizations, see [Kinde organizations for developers](/build/organizations/orgs-for-developers/). ## Kinde Management API You need to enable the application’s access to the Kinde Management API. You can do this in Kinde by going to **Settings > APIs > Kinde Management API** and then toggling on your Next.js application under the **Applications** tab. To use our management API please see [@kinde/management-api-js](https://github.com/kinde-oss/management-api-js) ## Persisting app state If you want your project to remember which url your user was intending to visit before they were asked to authenticate, you can pass an additional parameter in the `/login` and `/register` links. After the user has completed authentication at your defined callback url they will be redirected to the path you define here. This value does not need to be added to your allowed callback urls in Kinde. **Next.js 13** ```jsx // Next.js 13 {/* eslint-disable-next-line @next/next/no-html-link-for-pages */} <a href="api/auth/login?post_login_redirect_url=/dashboard"> Sign in </a> <LoginLink postLoginRedirectURL={'/dashboard'}>Login</LoginLink> <RegisterLink postLoginRedirectURL={'/dashboard'}>Register</RegisterLink> ``` Note: the value of `post_login_redirect_url` should either be a url on the same origin or a relative path. ## Working with preview URLs Our Kinde Next.js SDK currently requires that these environment variables `KINDE_SITE_URL`, `KINDE_POST_LOGOUT_REDIRECT_URL`, and `KINDE_POST_LOGIN_REDIRECT_URL` are defined, and that the **callback URLs** and **logout redirect URLs** are added to your app in Kinde. To add Vercel’s dynamically generated URLs you can either securely use our API to add them on the fly or you can use [wildcard URLs](/get-started/connect/callback-urls/#wildcards-in-callback-urls). It should be noted that whilst wildcards are more convenient it is not as secure as explicitly adding the url to the allowlist via API as we outline below. Add the following to your `next.config.js`. ```jsx /** @type {import('next').NextConfig} */ const nextConfig = { env: { KINDE_SITE_URL: process.env.KINDE_SITE_URL ?? `https://${process.env.VERCEL_URL}`, KINDE_POST_LOGOUT_REDIRECT_URL: process.env.KINDE_POST_LOGOUT_REDIRECT_URL ?? `https://${process.env.VERCEL_URL}`, KINDE_POST_LOGIN_REDIRECT_URL: process.env.KINDE_POST_LOGIN_REDIRECT_URL ?? `https://${process.env.VERCEL_URL}/dashboard` } }; module.exports = nextConfig; ``` This ensures Vercel uses its generated preview URLs to populate the three Kinde variables. - Make sure the above values match your application (e.g. “/dashboard” for `KINDE_POST_LOGIN_REDIRECT_URL`) - Also make sure variables are not set for the preview environment in your Vercel project. If they are, they will be overridden by the new variables in the `next.config.js` file. ### Add callback URLs and logout redirect URLs to Kinde dynamically Create a script that will run each time a new preview is deployed by Vercel, which will add the newly generated URL to Kinde. It is important to note that for this part you will need to create a [machine to machine (M2M)](http://localhost:4321/developer-tools/kinde-api/connect-to-kinde-api/) application in Kinde to interface with the [Kinde Management API](/kinde-apis/management/). 1. Create a **Machine to machine (M2M)** app. 1. In Kinde, go to **Settings > Applications** and click on **Add application**. 2. Give your application a name and select **Machine to machine (M2M)**. 3. Select **Save**. 4. On the next screen, take note of the **Client ID** and **Client secret** values and add them to your `.env.local` file as `KINDE_M2M_CLIENT_ID` and `KINDE_M2M_CLIENT_SECRET`. 5. On the same screen, click on **APIs** on the left menu. 6. Authorize your M2M application to access the Kinde Management API by selecting the three dots (`...`) and clicking **Authorize application**. 7. Once the application is authorized, select the three dots (`...`) again and this time select **Manage scopes**. 8. Since we will be adding callback and redirect URLs dynamically via the Kinde Management API, you will need to toggle the switch for `create:application_redirect_uris` and `create:application_logout_uris`. 9. Select **Save**. 2. In your application source code, create a folder at the top level called `scripts`. 3. Within that folder, create a file called `add-urls-to-kinde.js` and add the following code: ```jsx async function getAuthToken() { try { const response = await fetch(`${process.env.KINDE_ISSUER_URL}/oauth2/token`, { method: "POST", headers: { "Content-Type": "application/x-www-form-urlencoded", Accept: "application/json" }, body: new URLSearchParams({ client_id: process.env.KINDE_M2M_CLIENT_ID, client_secret: process.env.KINDE_M2M_CLIENT_SECRET, grant_type: "client_credentials", audience: `${process.env.KINDE_ISSUER_URL}/api` }) }); if (!response.ok) { throw new Error(`Failed to get auth token: ${response.statusText}`); } const data = await response.json(); return data.access_token; } catch (error) { console.error("Error getting auth token:", error); throw error; } } async function addLogoutUrlToKinde(token) { try { const response = await fetch( `${process.env.KINDE_ISSUER_URL}/api/v1/applications/${process.env.KINDE_CLIENT_ID}/auth_logout_urls`, { method: "POST", headers: { Authorization: `Bearer ${token}`, Accept: "application/json", "Content-Type": "application/json" }, body: JSON.stringify({ urls: [`https://${process.env.VERCEL_URL}`] }) } ); if (!response.ok) { throw new Error(`Failed to add logout URL to Kinde: ${response.statusText}`); } const responseData = await response.json(); console.log(`SUCCESS: Logout URL added to Kinde: ${process.env.VERCEL_URL}`, responseData); } catch (error) { console.error("Failed to add logout URL to Kinde", error); throw error; } } async function addCallbackUrlToKinde(token) { try { const response = await fetch( `${process.env.KINDE_ISSUER_URL}/api/v1/applications/${process.env.KINDE_CLIENT_ID}/auth_redirect_urls`, { method: "POST", headers: { Authorization: `Bearer ${token}`, Accept: "application/json", "Content-Type": "application/json" }, body: JSON.stringify({ urls: [`https://${process.env.VERCEL_URL}/api/auth/kinde_callback`] }) } ); if (!response.ok) { throw new Error(`Failed to add callback URL to Kinde: ${response.statusText}`); } const responseData = await response.json(); console.log( `SUCCESS: Callback URL added to Kinde: ${process.env.VERCEL_URL}/api/auth/kinde_callback`, responseData ); } catch (error) { console.error("Failed to add callback URL to Kinde", error); throw error; } } (async () => { if (process.env.VERCEL == 1) { try { const authToken = await getAuthToken(); await addCallbackUrlToKinde(authToken); await addLogoutUrlToKinde(authToken); } catch (error) { console.error("Script failed:", error); } } })(); ``` 4. In your `package.json`, add a `postbuild` script that will run the `/scripts/add-urls-to-kinde.js` file after Vercel builds your app. ```json "scripts": { "dev": "next dev", "build": "next build", "start": "next start", "lint": "next lint", "postbuild": "node ./scripts/add-urls-to-kinde.js" } ``` 5. Commit these changes. The next deploy will add the newly created preview URLs to your Kinde application.

# Developer tools - Sdks - Node/Express GraphQL

> Guide to securing Node.js Express GraphQL endpoints with Kinde authentication using context and resolver protection.

node express graphql, authentication, bearer token, context, resolvers, authorization
developer-tools, sdks, node, express, graphql, backend

These instructions assume you already have a Kinde account. You can [register for free here](https://app.kinde.com/register) (no credit card required). This guide details how to protect your GraphQL endpoints, when running on ExpressJS. It assumes you already have a front end connected to Kinde which is sending a Kinde issued bearer token to your API for verification. If you don’t yet have a front end setup, please set this up first following the relevant guide: [React](/developer-tools/sdks/frontend/react-sdk/) [Next.js](/developer-tools/sdks/backend/nextjs-sdk/) [VanillaJS](/developer-tools/sdks/frontend/javascript-sdk/) ## **Configure Express** ### **Add Kinde Node as a dependency** <PackageManagers pkg="@kinde-oss/kinde-node" /> ### **Integrate with your app** Import as you would any other Node package - we recommend you do this in you `app.js` or `index.js` file depending on your structure. ```jsx const kindeNode = require("@kinde-oss/kinde-node"); ``` ### **Initialize** In the same file after any other imports initialize the library by entering your Kinde domain. This grabs the verification keys for your app. ```jsx let authenticate; (async () => { authenticate = await kindeNode(YOUR_KINDE_DOMAIN); })(); ``` ### **Protect!** We recommend you create a context for holding contextual data and use our `authenticate` function to verify if the Bearer token sent with the api call matches the keys on your domain and prevent access to unauthorized users. ```jsx const context = (req) => { const user = new Promise((resolve, reject) => { authenticate(req, (err, user) => { if (err) { return reject(err); } resolve(user); }); }); return { user }; }; ``` ### **Access** It’s pretty common that a Graph will have a mix of public and private fields. Because we’ve added the user to context we can access this in the individual field resolvers and decide what to return. As an example, this resolver is only accessible with a valid user: ```jsx users: (args, context) => { // In this case, we’ll pretend there is no data when // we’re not logged in. Another option would be to // throw an error if (!context.user) return null; return ["bob", "jake"]; }; ``` If you need any assistance with getting Kinde connected reach out to us at [support@kinde.com](mailto:support@kinde.com).

# Developer tools - Sdks - Node.js SDK

> Overview of Kinde SDKs for Node.js frameworks including Apollo Server, Express, Next.js, Nuxt, Remix, and SvelteKit.

node.js sdk, framework sdk, apollo server, express, next.js, nuxt, remix, sveltekit
developer-tools, sdks, nodejs, backend

Kinde has a number of SDKs tailored to frameworks run on Node.js. Refer to the SDK for your framework: - [Apollo Server](/developer-tools/sdks/backend/apollo-graphql/) - [Express](/developer-tools/sdks/backend/express-sdk/) - [Express + GraphQL](/developer-tools/sdks/backend/node-express-graphql/) - [Next.js App Router](/developer-tools/sdks/backend/nextjs-sdk/) - [Next.js Pages Router](/developer-tools/sdks/backend/nextjs-prev-sdk/) - [Nuxt](/developer-tools/sdks/backend/nuxt-module/) - [Remix](/developer-tools/sdks/backend/remix-sdk/) - [SvelteKit](/developer-tools/sdks/backend/sveltekit-sdk/) For all other frameworks, the [TypeScript SDK](/developer-tools/sdks/backend/typescript-sdk/) can be used to integrate with Kinde. If you need help connecting to Kinde, please contact us at [support@kinde.com](mailto:support@kinde.com).

# Developer tools - Sdks - Nuxt module

> Complete guide for Nuxt module including authentication setup, route protection, permissions management, and feature flags for Nuxt 3+ applications.

nuxt module, authentication, route protection, permissions, feature flags, middleware
developer-tools, sdks, nuxt, backend

The Nuxt Kinde module allows developers to integrate Kinde authentication into their existing Nuxt projects. For new projects, you can also find our [Starter Kit on GitHub](https://github.com/kinde-starter-kits/nuxt-starter-kit). ## Supported versions Nuxt 3+. ## Register with Kinde If you haven’t already got a Kinde account, [register for free here](https://app.kinde.com/register) (no credit card required). Registering gives you a Kinde domain, which you need to get started, e.g. **yourapp.kinde.com**. ## Install the module Install the `@nuxtjs/kinde` dependency using your package manager of choice. ```bash npx nuxi@latest module add kinde ``` ## Integrate with your app Add `@nuxtjs/kinde` to the modules section of your `nuxt.config.ts`. ```jsx export default defineNuxtConfig({ modules: ["@nuxtjs/kinde"] }); ``` Add the following values to your `.env` file. If you don't have one create a file in the root of your project. ```bash NUXT_KINDE_CLIENT_ID=<your_kinde_client_id> NUXT_KINDE_CLIENT_SECRET=<your_kinde_client_secret> NUXT_KINDE_AUTH_DOMAIN=https://<your_kinde subdomain>.kinde.com NUXT_KINDE_REDIRECT_URL=http://localhost:3000/api/callback NUXT_KINDE_LOGOUT_REDIRECT_URL=http://localhost:3000 NUXT_KINDE_PASSWORD=<a random password which will be used to encrypt the session cookie> NUXT_KINDE_POST_LOGIN_REDIRECT_URL=http://localhost:3000/dashboard ``` Replace [`http://localhost:3000`](http://localhost:3000/) with the URL where your project is running. ## Set callback URLs For your app to work with Kinde, you need to set callback and logout redirect URLs. Replace the values you see in `<code brackets>` with your own values. 1. In Kinde, go to **Settings > Applications.** 2. Select **View details** on your app. 3. Scroll down to the **Callback URLs** section. 4. Add in the callback URLs for your project, which might look something like this: - Allowed callback URLs (also known as Redirect URIs)- `<http://localhost:3000>/api/callback>` - Allowed logout redirect URLs - `<http://localhost:3000>` 5. Select **Save**. **Tip**: Make sure there are no hidden spaces in URLs and remove the ‘/’ backslash at the end. ## Environments If you would like to use different Environments as part of your development process, you will need to [add them within your Kinde business](/build/environments/environments/) first. You will also need to add the Environment subdomain to the code block above. ## Login and register Kinde supports an easy to implement login / register flow. Use the button examples below to redirect your users to Kinde, where they authenticate before being redirected back to your site. ```jsx <LoginLink to="/api/login" external> Sign in </LoginLink> <RegisterLink to="/api/register" external> Sign up </RegisterLink> ``` ## R**edirect after authentication** After your user has authenticated they will be redirected to the URL set in your `.env` file ```bash NUXT_KINDE_POST_LOGIN_REDIRECT_URL=<where_your_project_is_running> ``` ## Protecting pages It’s likely that your project will have both pages that are publicly available and private ones which should only be available to logged in users. Route protection is set up in within the `routeRules` in `nuxt.config.ts` In the below example, - `/**` - This protected all routes redirecting the login route. - `/dashboard` - route is protected for users with `admin` permissions. - `/public` - this is flagged as a public route and will be open to all visitors. ```jsx routeRules: { '/**': { appMiddleware: ['auth-logged-in'], kinde: { redirectUrl: '/api/login', external: true, }, }, '/dashboard': { appMiddleware: ['auth-logged-in'], kinde: { // list of permissions that are required to access the route permissions: { admin: true, }, redirectUrl: '/api/login', external: true, }, }, '/public': { appMiddleware: ['auth-logged-in'], kinde: { public: true, }, }, }, ``` ## Getting all permissions for the current user Once a user has been verified, your project or app returns the JWT token with an array of permissions for that user. Configure your app to read permissions and unlock the respective functions. [Set permissions](/manage-users/roles-and-permissions/user-permissions/) in your Kinde account. Here’s an example set of permissions. ```jsx const permissions = [ "create:todos", "update:todos", "read:todos", "delete:todos", "create:tasks", "update:tasks", "read:tasks", "delete:tasks ]; ``` We provide helper functions to more easily access the permissions claim, example of usage: ```jsx const client = useKindeClient(); const {data: permissions} = await useAsyncData(async () => { const {permissions} = (await client?.getPermissions()) ?? {}; return permissions; }); // { orgCode: 'org_1234', permissions: ['create:todos', 'update:todos', 'read:todos'] } const {data: hasAccess} = await useAsyncData(async () => { return (await client?.getPermission("create:todos")) ?? {}; }); // { orgCode: 'org_1234', isGranted: true } ``` ## Feature flags When a user signs in, the access token your project/application receives contains a custom claim called `feature_flags` which is an object detailing the feature flags for that user. You can [set feature flags](/releases/feature-flags/add-feature-flag/) in your Kinde account. Here’s an example. ```jsx feature_flags: { theme: { "t": "s", "v": "pink" }, is_dark_mode: { "t": "b", "v": true }, competitions_limit: { "t": "i", "v": 5 } } ``` We have provided a helper to grab any feature flag. For example: ```jsx const getFeatureFlag = async (feature: string) => { return await client?.getFlag(feature); } ``` You can find specific `string`, `boolean` and `integer` helpers in the [TypeScript SDK ](/developer-tools/sdks/backend/typescript-sdk/#feature-flags)docs. ## Check if the user is authenticated You can check if a user is logged in with the `$auth.loggedIn` context. ```jsx <p v-if="$auth.loggedIn"> I'm signed in! </p> <p v-else> I'm signed out :( </p> ``` ## Logout This is implemented in much the same way as signing up or signing in. ```jsx <NuxtLink to="/api/logout" external> Sign out </NuxtLink> ``` ## Test sign up Register your first user by signing up yourself. You’ll see your newly registered user on the **Users** page in Kinde. ## Get user information ### User profile User details can be found on the `$auth.user` object ```jsx {{ $auth.user }} // returns { id: "kp_12345556666", given_name: "Sally", family_name: "Smith", email: "sally.smith@example.com", picture: "https://lh3.googleusercontent.com/a/1234", updated_at: 1697769735 } ``` ## Organizations ### Create an organization To have a new organization created within your project, you can use the register api end point and pass `is_create_org="true"`. This will redirect the user to Kinde and create an organization with them as a member. ```jsx <NuxtLink to="/api/register?is_create_org=true" external> Register and create org </NuxtLink> ``` ### Sign users up or in to an organization When a user signs up or in to an organization, the `org_code` needs to be passed with the request. The `org_code` refers to the one created automatically in Kinde when the organization was created. Here’s an helper function for registering or signing in below using `org_0e9f496742ae` as an example: ```jsx <NuxtLink to="/api/login?org_code=org_0e9f496742ae" external> Sign in to org </NuxtLink> <NuxtLink to="/api/register?org_code=org_0e9f496742ae" external> Sign up to org </NuxtLink> ``` Because a user can belong to multiple organizations, and because they may have different permissions for the different organizations, we will pass you both the `org_code` and `permissions` back in the token when authentication is initiated like this. ## Health check To check your configuration, the SDK exposes an endpoint with your settings. `/api/health` **Note**: The client secret will indicate only if the secret is set or not set correctly. To enable set the debug property within the Kinde config. ```jsx export default defineNuxtConfig({ kinde: { debug: true } }); ``` ```jsx { "apiPath": "https://<your_kinde subdomain>.kinde.com", "redirectURL": "http://localhost:3000/api/callback", "postLoginRedirectURL": "http://localhost:3000/dashboard", "logoutRedirectURL": "http://localhost:3000", "clientID": "<your_kinde_client_id>", "clientSecret": "Set correctly" } ``` ## Kinde Management API To use our management API please see [@kinde/management-api-js](https://github.com/kinde-oss/management-api-js) If you need help using Kinde, please contact us at [support@kinde.com](mailto:support@kinde.com) or join the Kinde community on [Discord](https://discord.com/invite/tw5ng5tK6V) or [Slack](https://join.slack.com/t/thekindecommunity/shared_invite/zt-2k5i0aeet-d6Z_2qYphcNCpj0bFa4oCg).

# Developer tools - Sdks - PHP SDK

> Complete guide for PHP SDK including Composer installation, OAuth integration, authentication flow, user permissions, and cookie configuration for PHP applications.

PHP SDK, Composer, OAuth, authentication, user permissions, cookie settings, callback URLs
developer-tools, sdks, php, backend

{/* @case-police-ignore Sdk */} The Kinde PHP SDK allows developers to integrate with Composable Commerce APIs using PHP native interfaces, models and helpers instead of manually using the HTTP and JSON API. You can also view the [PHP docs](https://github.com/kinde-oss/kinde-php-sdk) and [PHP starter kit](https://github.com/kinde-starter-kits/php-starter-kit) in GitHub. ## Register for Kinde If you haven’t already got a Kinde account, [register for free here](https://app.kinde.com/register) (no credit card required). This will give you a Kinde domain, which you need to get started, e.g. `yourapp.kinde.com` ## Install Install [Composer](https://getcomposer.org/) and then execute the following command: ```bash php composer.phar require kinde-oss/kinde-auth-php ``` Or add the following to your **composer.json** file: ```json "require": { "kinde-oss/kinde-auth-php": "*" } ``` ## Set callback URLs 1. In Kinde, go to **Settings > Applications > [Your app] > View details**. 2. Add your callback URLs in the relevant fields. For example: - Allowed callback URLs (also known as redirect URIs) - for example, `http://localhost:8000/callback` - Allowed logout redirect URLs - for example, `http://localhost:8000` 3. Select **Save**. ## Add environments Kinde comes with a production environment, but you can set up other environments if you want to. Note that each environment needs to be set up independently, so you need to use the Environment subdomain in the code block above for those new environments. ## Configure your app **Environment variables** The following variables need to be replaced in the code snippets below. - `KINDE_HOST` - your Kinde domain - e.g. `https://your_kinde_domain.kinde.com` - `KINDE_REDIRECT_URL` - your callback url, make sure this URL is under your allowed callback redirect URLs. - e.g. `http://localhost:8000/callback` - `KINDE_POST_LOGOUT_REDIRECT_URL` - where you want users to be redirected to after logging out, make sure this URL is under your allowed logout redirect URLs. - e.g. `http://localhost:8000` - `KINDE_CLIENT_ID` - you can find this on the **Application details** page - `KINDE_CLIENT_SECRET` - you can find this on the **Application details** page ### Integrate with your app Add the composer autoloader to your app. ```php require_once(__DIR__ . "/vendor/autoload.php"); ``` Create a new instance of the Kinde Auth client object before you initialize your app. ```php ... use Kinde\KindeSDK\KindeClientSDK; use Kinde\KindeSDK\Configuration; use Kinde\KindeSDK\Sdk\Enums\GrantType; ... private $kindeClient; private $kindeConfig; public function __construct() { ... $this->kindeClient = new KindeClientSDK("KINDE_HOST", "KINDE_REDIRECT_URL", "KINDE_CLIENT_ID", "KINDE_CLIENT_SECRET", "KINDE_GRANT_TYPE"); $this->kindeConfig = new Configuration(); $this->kindeConfig->setHost("KINDE_HOST"); ... } ``` ## Sign in and registration The Kinde client provides methods for easy login and registration. You can add buttons in your HTML as follows: ```html <div class="navigation"> <a href="/login" type="button">Login</a> <a href="/register" type="button">Register</a> </div> ``` You will also need to route `/login` and `/register` to the SDK methods: ```php $this->kindeClient->login(); $this->kindeClient->register(); ``` ### Manage redirects When the user is redirected back to your site from Kinde, this will call your callback URL defined in the `KINDE_REDIRECT_URL` variable. You will need to route `/callback` to call a function to handle this. ```php public function callback() { // Need to implement, e.g: call an api,etc... In this case, we will get a token: $token = $this->kindeClient->getToken(); $this->kindeConfig->setAccessToken($token->access_token); print_r($token); } ``` You can also get the current authentication status with `isAuthenticated` ```php public function callback() { if (!$this->kindeClient->isAuthenticated) { // Need to implement, e.g: call an api,etc... In this case, we will get a token: $token = $this->kindeClient->getToken(); $this->kindeConfig->setAccessToken($token->access_token); print_r($token); } } ``` For more information, please check out `Kinde\KindeSDK\Sdk\Enums\AuthStatus` ## Cookie settings By default, your cookie will apply to the full domain and sub folder from which the code is called from. You can override both the path and domain using the following helper functions. ```php $storage = Storage::getInstance(); // Set the cookie path to root so it applies to the whole domain $storage->setCookiePath('/'); // Set the cookie domain without a prefix so it can be applied to all subdomains $storage->setCookieDomain('yourdomain.com'); ``` ## Logout The Kinde SPA client comes with a logout method. ```php $this->kindeClient->logout(); ``` ## Get user information To access the user information, use the `getUserDetails` helper function: ```php $this->kindeClient->getUserDetails(); // returns [ 'given_name' => 'Dave', 'id' => 'abcdef', 'family_name' => 'Smith', 'email' => 'dave@smith.com', 'picture' => 'https://link_to_avatar_url.kinde.com', ] ``` ### View users in Kinde Go to the **Users** page in Kinde to see who has registered. ## User permissions After a user signs in and they are verified, the token return includes permissions for that user. [User permissions are set in Kinde](/manage-users/roles-and-permissions/user-permissions/), but you must also configure your application to unlock these functions. ```php "permissions" => [ "create:todos", "update:todos", "read:todos", "delete:todos", "create:tasks", "update:tasks", "read:tasks", "delete:tasks", ]; ``` We provide helper functions to more easily access permissions: ```php $this->kindeClient->getPermission("create:todos"); // ["orgCode" => "org_1234", "isGranted" => true] $this->kindeClient->getPermissions(); // ["orgCode" => "org_1234", "permissions" => ["create:todos", "update:todos", "read:todos"]] ``` A practical example in code might look something like: ```php if ($this->kindeClient->getPermission("create:todos")["isGranted"]) { // create new a todo } ``` ## Audience An `audience` is the intended recipient of an access token - for example the API for your application. The audience argument can be passed to the Kinde client to request an audience be added to the provided token. The audience of a token is the intended recipient of the token. ```php public function __construct() { ... $this->kindeClient = new KindeClientSDK("KINDE_HOST", "KINDE_REDIRECT_URL", "KINDE_CLIENT_ID", "KINDE_CLIENT_SECRET", "KINDE_GRANT_TYPE", "KINDE_POST_LOGOUT_REDIRECT_URL", "YOUR_SCOPES", [ "audience" => "api.yourapp.com ]); ... } ``` For details on how to connect, see [Register an API](/developer-tools/your-apis/register-manage-apis/) ## Overriding scope By default the `KindeSDK` requests the following scopes: - profile - email - offline - openid You can override this by passing scope into the `KindeSDK` ```php public function __construct() { ... $this->kindeClient = new KindeClientSDK("KINDE_HOST", "KINDE_REDIRECT_URL", "KINDE_CLIENT_ID", "KINDE_CLIENT_SECRET", "KINDE_GRANT_TYPE", "KINDE_POST_LOGOUT_REDIRECT_URL", "profile email offline openid"); ... } ``` ## Getting claims We have provided a helper to grab any claim from your id or access tokens. The helper defaults to access tokens: ```php $this->kindeClient->getClaim("aud"); // ["name" => "aud", "value" => ["api.yourapp.com"]] $this->kindeClient->getClaim("given_name", "id_token"); // ["name" => "aud", "value" => "David"] ``` ## Organizations ### Create an organization To create a new organization within your application, run a similar function to below: ```php public function register() { $this->kindeClient->createOrg(); } ``` You can also pass `org_name` as your organization ```php $this->kindeClient->createOrg(["org_name" => "Your Organization"]); ``` ### Sign up and sign in to organizations Kinde has a unique code for every organization. You’ll have to pass this code through when you register a new user. Example function below: ```php $this->kindeClient->register(["org_code" => "your_org_code"]); ``` If you want a user to sign in to a particular organization, pass this code along with the sign in method. ```php $this->kindeClient->login(["org_code" => "your_org_code"]); ``` Following authentication, Kinde provides a json web token (jwt) to your application. Along with the standard information we also include the `org_code` and the permissions for that organization (this is important as a user can belong to multiple organizations and have different permissions for each). Example of a returned token: ```php [ "aud" => [], "exp" => 1658475930, "iat" => 1658472329, "iss" => "https://your_subdomain.kinde.com", "jti" => "123457890", "org_code" => "org_1234", "permissions" => ["read:todos", "create:todos"], "scp" => [ "openid", "profile", "email", "offline ], "sub" => "kp:123457890 ]; ``` The `id_token` will also contain an array of organizations that a user belongs to - this is useful if you wanted to build out an organization switcher for example. ```php [ ... "org_codes" => ["org_1234", "org_4567"], ... ]; ``` There are two helper functions you can use to extract information: ```php $this->kindeClient->getOrganization(); // ["orgCode" => "org_1234"] $this->kindeClient->getUserOrganizations(); // ["orgCodes" => ["org_1234", "org_abcd"]] ``` For more information about how organizations work in Kinde, see [Kinde organizations for developers](/build/organizations/orgs-for-developers/). ## Feature flags We have provided a helper to grab any feature flag from `access_token`: ```php $this->kindeClient->getFlag('theme'); // returns [ "code" => "theme", "type" => "string", "value" => "pink", "is_default" => false // whether the fallback value had to be used ] // Another usage case $this->kindeClient->getFlag('is_dark_mode'); // returns [ "code": "is_dark_mode", "type": "boolean", "value": true, "is_default": false ] // This flag does not exist - default value provided $this->kindeClient->getFlag('create_competition', ["defaultValue" => false]); // returns [ "code": "create_competition", "type" => "boolean", "value": false, "is_default": true // because fallback value had to be used ] // The flag type was provided as string, but it is an integer $this->kindeClient->getFlag('competitions_limit', {defaultValue: 3}, 's'); // should error out - Flag "competitions_limit" is type integer - requested type string // This flag does not exist, and no default value provided $this->kindeClient->getFlag('new_feature'); // should error out - This flag was not found, and no default value has been provided ``` We also provide wrapper functions which should leverage `getFlag` above: ```php // [--- Boolean ---] $this->kindeClient->getBooleanFlag('is_dark_mode'); // with default value $this->kindeClient->getBooleanFlag('is_dark_mode', false); // [--- Boolean ---] // [--- String ---] $this->kindeClient->getStringFlag('theme'); // with default value $this->kindeClient->getStringFlag('theme', 'blue'); // [--- String ---] // [--- Integer ---] $this->kindeClient->getIntegerFlag('competitions_limit'); // with default value $this->kindeClient->getIntegerFlag('competitions_limit', 1); // [--- Integer ---] ``` ## Token Storage Once the user has successfully authenticated, you'll have a JWT stored in a local cookie containing an access token, refresh token and ID token if requested. You can use the `getAccessToken` method of the `Storage` class to retrieve the access token from the cookie. There are also helper functions to get the decoded access token or id token. ```php ... use Kinde\\KindeSDK\\Sdk\\Storage\\Storage; ... $storage = Storage::getInstance(); $accessToken = $storage->getAccessToken(); $decodedAccessToken = $storage->getDecodedAccessToken(); $decodedIdToken = $storage->getDecodedIdToken(); print_r($accessToken); print_r($decodedAccessToken); print_r($decodedIdToken); ``` To specify the expiration time, you can use the `setTokenTimeToLive` method. ```php $storage->setTokenTimeToLive(time() + 3600) // Live in 1 hour ``` ## Using your token cookie across multiple subdomains By default, your token cookie will be local to the subdomain that made the login request (e.g. [login.yourdomain.com](http://login.yourdomain.com/)), so [app.yourdomain.com](http://app.yourdomain.com/) will have no visibility of this. You can confirm this in your browser, for example in Chrome go to **Developer tools** and under **Application > Storage > Cookies**, look at the **Domain** column. To achieve cross sub-domain use the cookie needs to be set to the root domain rather than the subdomain. You can do this by adding the following code after initializing the KindeClient: ```php $storage = Storage::getInstance(); $storage->setCookieDomain('yourdomain.com'); ``` ## SDK API reference ### `host` Either your Kinde instance URL or your custom domain. e.g `https://yourapp.kinde.com/` Type: `string` Required: yes ### `redirectUri` The url that the user will be returned to after authentication. Type: `string` Required: yes ### `clientId` The unique ID of your application. Get this from the Application details section in Kinde. Type: `string` Required: yes ### `clientSecret` The unique client secret of your Kinde application. Get this from the Application details section in Kinde. Type: `string` Required: yes ### `grantType` The `grantType` for Kinde Authorization varies for each OAuth 2 flow. You can use: - **Authorization code:** `GrantType::authorizationCode:` Intended for confidential clients, e.g. web-servers. - **Authorization code with PKCE:** `GrantType::PKCE:` Extension for public clients, e.g. single page web applications and mobile applications, and confidential clients, e.g. web-servers. Note that the `code_challenge` and `code_challenge_method` parameters are also required for this grant type. - **Client credentials flow:** `GrantType::clientCredentials:` Intended for confidential clients where machine-to-machine communication is required. Type: `string` Required: yes ### `logoutRedirectUri` Where your user will be redirected when they sign out. Type: `string` Required: yes ### `scope` The scopes to be requested from Kinde. Type: `string` Required: No Default: ```php openid profile email offline ``` ### `additionalParameters` Additional parameters that will be passed in the authorization request. Type: `array` Required: No Default: `[ ]` ### `additionalParameters` - `audience` The audience claim for the JWT. Type: `string` Required: No ## KindeSDK methods ### `login` Constructs redirect url and sends user to Kinde to sign in. Arguments: ```php org_code?: string ``` Usage: ```php $kinde->login(); ``` ### `register` Constructs redirect url and sends user to Kinde to sign up. Arguments: ```php org_code?: string ``` Usage: ```php $kinde->register(); ``` ### `logout` Logs the user out of Kinde. Usage: ```php $kinde->logout(); ``` ### `getToken` Returns the raw access token from URL after logged from Kinde. Usage: ```php $kinde->getToken(); ``` Sample output: ```php [ "access_token" => "eyJhbGciOiJSUzI...", "expires_in" => 86400, "id_token" => "eyJhbGciOiJSU...", "refresh_token" => "yXI1bFQKbXKLD7AIU...", "scope" => "openid profile email offline", "token_type" => "bearer ]; ``` ### `createOrg` Constructs redirect url and sends user to Kinde to sign up and create a new org for your business. Arguments: ```php org_name?: string ``` Usage: ```php $kinde->createOrg(); or $kinde->createOrg(["org_name" => "your organization name"}); ``` Sample output: ```php redirect ``` ### `getClaim` Gets a claim from an access or ID token. Arguments: ```php claim: string, tokenKey?: string ``` Usage: ```php $kinde->getClaim("given_name", "id_token"); ``` Sample output: ```php David ``` ### `getPermission` Returns the state of a given permission. Arguments: ```php key: string ``` Usage: ```php $kinde->getPermission("read:todos"); ``` Sample output: ```php [ "orgCode" => "org_1234", "isGranted" => true ]; ``` ### `getPermissions` Returns all permissions for the current user for the organization they are logged into. Usage: ```php $kinde->getPermissions(); ``` Sample output: ```php [ "orgCode" => "org_1234", "permissions" => ["create:todos", "update:todos", "read:todos"] ]; ``` ### `getOrganization` Get details for the organization your user is logged into. Usage: ```php $kinde->getOrganization(); ``` Sample output: ```php [ "orgCode" => "org_1234 ]; ``` ### `getUserDetails` Returns the profile for the current user. Usage: ```php $kinde->getUserDetails(); ``` Sample output: ```php [ "given_name" => "Dave", "id" => "abcdef", "family_name" => "Smith", "email" => "mailto:dave@smith.com ]; ``` ### `getUserOrganizations` Gets an array of all organizations the user has access to. Usage: ```php $kinde->getUserOrganizations(); ``` Sample output: ```php [ "orgCodes" => ["org_8de8711f46a", "org_820c0f318de"] ]; ``` ### `getFlag` Gets a feature flag from an access token. Arguments: ```php flagName: string, options?: ["defaultValue" => any] ``` Usage: ```php $kinde->getFlag("is_dark_mode"); ``` Sample output: ```php [ "code": "is_dark_mode", "type": "boolean", "value": true, "is_default": false ]; ``` ### `getBooleanFlag` Gets a boolean feature flag from an access token. Arguments: ```php flagName: string, defaultValue?: boolean ``` Usage: ```php $kinde->getBooleanFlag("is_dark_mode", false); ``` Sample output: ```php [ "code": "is_dark_mode", "type": "boolean", "value": false, "is_default": true ]; ``` ### `getStringFlag` Gets a string feature flag from an access token. Arguments: ```php flagName: string, defaultValue?: string ``` Usage: ```php $kinde->getStringFlag('theme'); ``` Sample output: ```php [ "code": "theme", "type": "string", "value": "black", "is_default": false ]; ``` ### `getIntegerFlag` Gets a integer feature flag from an access token. Arguments: ```php flagName: string, defaultValue?: integer ``` Usage: ```php $kinde->getIntegerFlag("competitions_limit"); ``` Sample output: ```php [ "code": "competitions_limit", "type": "integer", "value": 1, "is_default": false ]; ``` ### `isAuthenticated` To check user authenticated or not. Usage: ```php $kinde->isAuthenticated ``` Sample output: ```php true or false ``` If you need help connecting to Kinde, please contact us at [support@kinde.com](mailto:support@kinde.com).

# Developer tools - Sdks - Python SDK v1

> Legacy guide for Python SDK v1 including authentication setup, OAuth flows, user permissions, and callback management for Python 3.8+ applications.

python sdk v1, legacy sdk, authentication, oauth flows, user permissions, callback urls
developer-tools, sdks, python, backend

<Aside type="warning"> This SDK has been superseded by a [new version](/developer-tools/sdks/backend/python-sdk/). </Aside> The Kinde Python SDK allows developers to quickly and securely integrate a new or an existing Python application into the Kinde platform. ## Before you begin - Kinde Python SDK supports Python 3.8+ - If you haven’t already got a Kinde account, [register for free here](https://app.kinde.com/register) (no credit card required). Registering gives you a Kinde domain, which you need to get started, e.g. `yourapp.kinde.com`. For new projects, you can also find our [Starter Kit on GitHub](https://github.com/kinde-starter-kits/python-starter-kit). ## Install Install [PIP](https://pip.pypa.io/en/stable/installation/) and then execute the following command: ```bash pip install kinde-python-sdk ``` ### Set callback URLs 1. In Kinde, go to **Settings > Applications > [Your app] > View details**. 2. Add your callback URLs in the relevant fields. For example: - Allowed callback URLs (also known as redirect URIs) - for example, `http://localhost:8000/callback` - Allowed logout redirect URLs - for example, `http://localhost:8000` 3. Select **Save**. ### Add environments Kinde comes with a production environment, but you can set up other environments if you want to. Note that each environment needs to be set up independently, so you need to use the Environment subdomain in the code block above for those new environments. ## Configure your app **Environment variables** The following variables need to be replaced in the code snippets below. - `KINDE_HOST` - your Kinde domain, e.g. `https://yourdomain.kinde.com` - `KINDE_CLIENT_ID` - In Kinde, go to **Settings > Applications > [your application] > View details**. - `KINDE_CLIENT_SECRET` - In Kinde, go to **Settings > Applications > [your application] > View details**. - `KINDE_REDIRECT_URL` - your callback urls or redirect URIs, e.g. `http://localhost:8000/callback` - `KINDE_POST_LOGOUT_REDIRECT_URL` - where you want users to be redirected to after signing out, e.g. `http://localhost:8000` ## Integrate with your app Create a new instance of the Kinde Auth client object before you initialize your app. ```python ... from kinde_sdk import Configuration from kinde_sdk.kinde_api_client import GrantType, KindeApiClient ... configuration = Configuration(host=KINDE_HOST) kinde_api_client_params = { "configuration": configuration, "domain": KINDE_HOST, "client_id": KINDE_CLIENT_ID, "client_secret": KINDE_CLIENT_SECRET, "grant_type": GRANT_TYPE, # client_credentials | authorization_code | authorization_code_with_pkce "callback_url": KINDE_REDIRECT_URL } kinde_client = KindeApiClient(**kinde_api_client_params) ``` With **PKCE** flow, the `code_verifier` is required. ```python from authlib.common.security import generate_token CODE_VERIFIER = generate_token(48) kinde_api_client_params["code_verifier"] = CODE_VERIFIER ``` ## Sign in and sign up The Kinde client provides methods for easy sign in and sign up. You can add buttons in your HTML as follows: ```html <div class="navigation"> <a href="{{ url_for('login') }}" type="button">Sign in</a> <a href="{{ url_for('register') }}" type="button">Sign up</a> </div> ``` You will also need to route `/login` and `/register` to the SDK methods: ```python @app.route("/login") def login(): return app.redirect(kinde_client.get_login_url()) @app.route("/register") def register(): return app.redirect(kinde_client.get_register_url()) ``` ## Manage redirects When the user is redirected back to your site from Kinde, this will call your callback URL defined in the `KINDE_REDIRECT_URL` variable. You will need to route `/callback` to call a function to handle this. ```python @app.route("/callback") def callback(): kinde_client.fetch_token(authorization_response=request.url) print(configuration.access_token) # Token here ``` The code above setups up the Kinde client as a single instance per user session. If you want to setup the Kinde client as a singleton, you can do the following: ```python @app.route("/callback") def callback(): access_token: dict = kinde_client.fetch_token_value(authorization_response=request.url) print(access_token) # Token here ``` This logic leaves the Kinde client responsible for managing the access_token, but not for storing them. This is left up to the developer to implement. You can also get the current authentication status with `is_authenticated`. ```python if kinde_client.is_authenticated(): # Core here ``` The code above will check if a user is authenticated by checking its internal state. The down side is that the there will have to be an instance of the Kinde client for each user session. This is costly and not scalable. ```python if kinde_client.is_authenticated_token(access_token): # Core here ``` **Note:** The kinde_client object that is created stores the access_token. This means you need to create a kinde_client object for each unique user that is signing in to your application, so that you can keep track of whether the user is authenticated or not. ## Logout The SDK comes with a logout method that returns a logout URL. ```python kinde_client.logout(redirect_to=KINDE_POST_LOGOUT_REDIRECT_URL) @app.route("/logout") def logout(): return app.redirect( kinde_client.logout(redirect_to=KINDE_POST_LOGOUT_REDIRECT_URL) ) ``` ## Get user information To access the user information, use the `get_user_details` helper function: ```python kinde_client.get_user_details(); { "given_name":"Dave", "id":"abcdef", "family_name":"Smith", "email":"dave@smith.com", "picture": "https://link_to_avatar_url.kinde.com" } ``` ### View users in Kinde Go to the **Users** page in Kinde to see who has registered. ## User permissions After a user signs in and they are verified, the token return includes permissions for that user. [User permissions are set in Kinde](/manage-users/roles-and-permissions/user-permissions/), but you must also configure your application to unlock these functions. ```python permissions = [ "create:todos", "update:todos", "read:todos", "delete:todos", "create:tasks", "update:tasks", "read:tasks", "delete:tasks", ] ``` We provide helper functions to more easily access permissions: ```python kinde_client.get_permission("create:todos") kinde_client.get_permissions() ``` A practical example in code might look something like: ```python -if kinde_client.get_permission("create:todos").get("is_granted")): +if kinde_client.get_permission("create:todos").get("is_granted"): The code above will check against a session managed through the Kinde client. If you want to check against a specific access token, you can do the following: ```python permission: dict = kinde_client.get_permission_token(access_token, "create:todos") ``` ## Feature Flags We have provided a helper to grab any feature flag from `access_token`: ```python kinde_client.get_flag("theme"); { "code": "theme", "type": "string", "value": "pink", "is_default": False # whether the fallback value had to be used } kinde_client.get_flag("is_dark_mode"); { "code": "is_dark_mode", "type": "boolean", "value": True, "is_default": False } kinde_client.get_flag("create_competition", default_value = False); { "code": "create_competition", "type" => "boolean", "value": False, "is_default": True # because fallback value had to be used } kinde_client.get_flag("competitions_limit", default_value = 3, flat_type = "s"); kinde_client.get_flag("new_feature"); # this will return the flag value for the given access token kinde_client.get_flag_token(access_token, "new_feature"); ``` We also provide wrapper functions which should leverage `getFlag` above. **Get boolean flags** ```python kinde_client.get_boolean_flag("is_dark_mode"); kinde_client.get_boolean_flag("is_dark_mode", False); kinde_client.get_boolean_flag("new_feature", False); kinde_client.get_boolean_flag("new_feature"); kinde_client.get_boolean_flag("theme", False); kinde_client.get_boolean_flag_token(access_token, "new_feature"); ``` **Get string flags** ```python kinde_client.get_string_flag("theme"); kinde_client.get_string_flag("theme", False); kinde_client.get_string_flag("cta_color", False); kinde_client.get_string_flag("cta_color"); kinde_client.get_string_flag("is_dark_mode", False); kinde_client.get_string_flag_token(access_token, "cta_color"); ``` **Get integer flags** ```python kinde_client.get_integer_flag("competitions_limit"); kinde_client.get_integer_flag("competitions_limit", 3); kinde_client.get_integer_flag("team_count", 2); kinde_client.get_integer_flag("team_count"); kinde_client.get_integer_flag("is_dark_mode", False); kinde_client.get_integer_flag_token(access_token, "team_count"); ``` ## Audience An `audience` is the intended recipient of an access token - for example the API for your application. The audience argument can be passed to the Kinde client to request an audience be added to the provided token. The audience of a token is the intended recipient of the token. ```python kinde_api_client_params["audience"] = "api.yourapp.com ``` For details on how to connect, see [Register an API](/developer-tools/your-apis/register-manage-apis/) ## Overriding scope By default the `KindeSDK` requests the following scopes: - profile - email - offline - openid You can override this by passing scope into the `KindeSDK`. ```python kinde_api_client_params["scope"] = "profile email offline openid ``` ### Getting claims We have provided a helper to grab any claim from your id or access tokens. The helper defaults to access tokens: ```python kinde_client.get_claim("aud") kinde_client.get_claim("given_name", "id_token") kinde_client.get_claim_token(access_token, "given_name") ``` ## Organizations ### Create an organization To create a new organization within your application, you will need to run a similar function to below: ```python return app.redirect(kinde_client.create_org()) ``` ### Sign up and sign in to organizations Kinde has a unique code for every organization. You’ll have to pass this code through when you register a new user or sign in to a particular organization. Example function below: ```python kinde_api_client_params["org_code"] = 'your_org_code' @app.route("/login") def login(): return app.redirect(kinde_client.get_login_url()) @app.route("/register") def register(): return app.redirect(kinde_client.get_register_url()) ``` Following authentication, Kinde provides a json web token (jwt) to your application. Along with the standard information we also include the `org_code` and the permissions for that organization (this is important as a user can belong to multiple organizations and have different permissions for each). Example of a returned token: ```python { "aud": [], "exp": 1658475930, "iat": 1658472329, "iss": "https://your_subdomain.kinde.com", "jti": "123457890", "org_code": "org_1234", "permissions": ["read:todos", "create:todos"], "scp": [ "openid", "profile", "email", "offline ], "sub": "kp:123457890" } ``` The `id_token` will also contain an array of organizations that a user belongs to - this is useful if you wanted to build out an organization switcher for example. ```python { ... "org_codes": ["org_1234", "org_4567"], ... }; ``` There are two helper functions you can use to extract information: ```python kinde_client.get_organization() kinde_client.get_user_organizations() ``` For more information about how organizations work in Kinde, see [Kinde organizations for developers](/build/organizations/orgs-for-developers/). ### Token storage Once the user has successfully authenticated, you'll get a JWT and possibly a refresh token that should be stored securely. ## SDK API reference ### `domain` Either your Kinde instance url or your custom domain. e.g. `https://yourapp.kinde.com`. Type: `string` Required: Yes ### `callback_url` The url that the user will be returned to after authentication. Type: `string` Required: Yes ### `client_id` The ID of your application in Kinde. Type: `string` Required: Yes ### `grant_type` Define the grant type when using the SDK. Type: `string` Required: Yes ### `client_secret` The unique client secret associated with your application in Kinde. Type: `string` Required: No ### `code_verifier` PKCE works by having the app generate a random value at the beginning of the flow called a Code Verifier. Type: `string` Required: No, except for PKCE flow ### `scope` The scopes to be requested from Kinde. Type: `string` Required: No Default: `openid profile email offline` ### `audience` The audience claim for the JWT. Type: `string` Required: No ### `org_code` Additional parameters that will be passed in the authorization request. Type: `string` Required: No ## KindeSDK methods ### `get_login_url` Constructs a redirect URL and sends the user to Kinde to sign in. Optional parameters are used for custom sign-up and sign-in and are documented [here](/authenticate/custom-configurations/custom-authentication-pages/). Arguments (optional): ```python auth_url_params: Optional[Dict[str, Dict[str, str]]] ``` Usage: ```python kinde_client.get_login_url() kinde_client.get_login_url({ "auth_url_params": { "connection_id": "conn_6a95dec504d34dc286dc80e8df9f6099" } }) ``` Sample output: ```python https://your_host.kinde.com/oauth2/auth?response_type=code&… ``` ### `get_register_url` Constructs a redirect URL and sends the user to Kinde to sign up. Optional parameters are used for custom sign-up and sign-in and are documented [here](/authenticate/custom-configurations/custom-authentication-pages/). Arguments (optional): ```python auth_url_params: Optional[Dict[str, Dict[str, str]]] ``` Usage: ```python kinde_client.get_register_url() kinde_client.get_register_url({ "auth_url_params": { "connection_id": "conn_6a95dec504d34dc286dc80e8df9f6099" } }) ``` Sample: ```python https://your_host.kinde.com/oauth2/auth?response_type=code&… ``` ### `logout` Logs the user out of Kinde. Arguments: ```python redirect_to: str ``` Usage: ```python kinde_client.logout(redirect_to="KINDE_POST_LOGOUT_REDIRECT_URL") ``` Sample: ```python https://your_host.kinde.com/logout?redirect=https://… ``` ### `fetch_token` Returns the raw access token from URL after logged in from Kinde. Arguments: ```python authorization_response: str ``` Usage: ```python kinde_client.fetch_token(authorization_response=”[http://localhost:8000?code=42..e9&state=d..t](https://example.com/github?code=42..e9&state=d..t)”) token: dict = kinde_client.fetch_token_value(authorization_response=”[http://localhost:8000?code=42..e9&state=d..t](https://example.com/github?code=42..e9&state=d..t)”) ``` Sample: ```python eyJhbGciOiJIUzI1... ``` ### `refresh_token` Get new access token from Kinde if existed `refresh_token`. Usage: ```python kinde_client.refresh_token() kinde_client._refresh_token_value(refresh_value) ``` ### `create_org` Return the redirect URL to sign up and create a new organization in your business. Usage: ```python kinde_client.create_org() ``` Sample: ```python https://your_host.kinde.com/oauth2/auth?response_type=code&… ``` ### `get_claim` Gets a claim from an access or ID token. Arguments: ```python claim: str, token_name?: str # default: access_token ``` Usage: ```python kinde_client.get_claim("given_name", "id_token") kinde_client.get_claim_token(access_token, "given_name") ``` Sample: ```python {"name": "given_name", "value": "David"} ``` ### `get_permission` Returns the state of a given permission. Arguments: ```python key: str ``` Usage: ```python kinde_client.get_permission(”read:todos”) kinde_client.get_permission_token(access_token, "read:todos") ``` Sample: ```python {”org_code”: "org_b235c067b7e4", is_granted: True} ``` ### `get_permissions` Returns all permissions for the current user for the organization they are signed into. Usage: ```python kinde_client.get_permissions() kinde_client.get_permissions_token(access_token) ``` Sample: ```python {"org_code": "org_b235c067b7e4", permissions: [ "create:users", "view:users" ]} ``` ### `get_organization` Get details for the organization your user is signed into. Usage: ```python kinde_client.get_organization() kinde_client.get_organization_token(access_token) ``` Sample: ```python {"org_code": "org_1234"} ``` ### `get_organizations` Gets an array of all organizations the user has access to. Usage: ```python kinde_client.get_user_organizations() kinde_client.get_user_organizations_token(access_token) ``` Sample: ```python {"org_codes": ["org_1234", "org_abcd"]} ``` ### `get_user_details` Returns the profile for the current user. Usage: ```python kinde_client.get_user_details() kinde_client.get_user_details_token(access_token) ``` Sample: ```python { "given_name":"Dave", "id":"abcdef", "family_name":"Smith", "email":"dave@smith.com", "picture": "https://link_to_avatar_url.abc.com" } ``` ### `get_flag` Gets a feature flag from an access token. Arguments: ```python code: str default_value?: str flag_type?: str ``` Usage: ```python kinde_client.get_flag("theme"); kinde_client.get_flag_token(access_token, "theme"); ``` Sample: ```python { "code": "theme", "type": "string", "value": "pink", "is_default": False } ``` ### `get_boolean_flag` Gets a boolean feature flag from an access token. Arguments: ```python code: str default_value?: str ``` Usage: ```python kinde_client.get_boolean_flag("is_dark_mode"); kinde_client.get_boolean_flag_token(access_token, "is_dark_mode"); ``` Sample: `True` or `False` ### `get_string_flag` Gets a string feature flag from an access token. Arguments: ```python code: str default_value?: str ``` Usage: ```python kinde_client.get_string_flag("theme"); kinde_client.get_string_flag_token(access_token, "theme"); ``` Sample: `“pink”` ### `get_integer_flag` Gets a integer feature flag from an access token Arguments: ```python code: str default_value?: str ``` Usage: ```python kinde_client.get_integer_flag("competitions_limit"); kinde_client.get_integer_flag_token(access_token, "competitions_limit"); ``` Sample: `5` ### `is_authenticated()` To check user authenticated or not. Sample: `true` or `false` If you need help connecting to Kinde, please contact us at [support@kinde.com](mailto:support@kinde.com).

# Developer tools - Sdks - Python SDK

> Complete guide for Python SDK including Flask and FastAPI integration, OAuth configuration, environment variables, and session management for Python 3.9+ applications.

Python SDK, Flask, FastAPI, OAuth, environment variables, callback URLs, session management
developer-tools, sdks, python, backend

The Kinde Python SDK allows developers to quickly and securely integrate a new or an existing Python application into the Kinde platform. The SDK supports both Flask and FastAPI frameworks through a single unified interface. ## Before you begin - Kinde Python SDK supports Python 3.9+ - If you haven't already got a Kinde account, [register for free here](https://app.kinde.com/register) (no credit card required). Registering gives you a Kinde domain, which you need to get started, e.g. `yourapp.kinde.com`. If you are using a previous version of Python, you may need to refer to the [previous v1 SDK](/developer-tools/sdks/backend/python-sdk-v1/). If you're migrating from an older version of the SDK, see our [migration guide](https://github.com/kinde-oss/kinde-python-sdk/blob/main/MIGRATION.md) for detailed instructions. For new projects, you can find our [Starter Kit on GitHub](https://github.com/kinde-starter-kits/python-starter-kit). ## Install Install [PIP](https://pip.pypa.io/en/stable/installation/) and then execute the following command: ```bash pip install kinde-python-sdk ``` ### Environment variables The Kinde Python SDK uses environment variables for configuration. Here are all the supported variables: #### Required variables - `KINDE_CLIENT_ID` - Your application's client ID from Kinde - `KINDE_CLIENT_SECRET` - Your application's client secret from Kinde - `KINDE_REDIRECT_URI` - The callback URL where Kinde will redirect after authentication - `KINDE_HOST` - Your Kinde domain (e.g., `https://yourdomain.kinde.com`) - `KINDE_ISSUER_URL` - Your Kinde issuer URL (typically same as KINDE_HOST) - `GRANT_TYPE` - The OAuth grant type to use (e.g., `AUTHORIZATION_CODE_WITH_PKCE`) #### Optional variables - `KINDE_AUDIENCE` - The intended recipient of the access token (for API access) - `KINDE_CALLBACK_URL` - Alternative name for KINDE_REDIRECT_URI - `LOGOUT_REDIRECT_URL` - Where users are redirected after logout - `SITE_HOST` - Your application's host (default: `127.0.0.1`) - `SITE_PORT` - Your application's port (default: `5000`) - `SITE_URL` - Your application's base URL - `CODE_VERIFIER` - Required for PKCE flow (auto-generated if not provided) **Session management variables** (core SDK features): - `SECRET_KEY` - Used for session management and token security - `SESSION_TYPE` - Session storage type (e.g., `filesystem`) - `SESSION_PERMANENT` - Whether sessions are permanent (default: `False`) **Application configuration**: - `TEMPLATES_AUTO_RELOAD` - Whether to auto-reload templates (default: `True`) **Management API variables** (only needed if using Management API features): - `MGMT_API_CLIENT_ID` - Management API client ID - `MGMT_API_CLIENT_SECRET` - Management API client secret Example `.env` file: ```bash KINDE_CLIENT_ID=your_client_id KINDE_CLIENT_SECRET=your_client_secret KINDE_REDIRECT_URI=http://localhost:5000/api/auth/kinde_callback KINDE_HOST=https://yourdomain.kinde.com KINDE_ISSUER_URL=https://yourdomain.kinde.com GRANT_TYPE=AUTHORIZATION_CODE_WITH_PKCE SITE_HOST=localhost SITE_PORT=5000 SITE_URL=http://localhost:5000 LOGOUT_REDIRECT_URL=http://localhost:8000 SECRET_KEY=your_secret_key SESSION_TYPE=filesystem SESSION_PERMANENT=False TEMPLATES_AUTO_RELOAD=True ``` ### Set callback URLs 1. In Kinde, go to **Settings > Applications > [Your app] > View details**. 2. Add your callback URLs in the relevant fields. For example: - Allowed callback URLs (also known as redirect URIs) - for example, `http://localhost:8000/callback` - Allowed logout redirect URLs - for example, `http://localhost:8000` 3. Select **Save**. ### Add environments Kinde comes with a production environment, but you can set up other environments if you want to. Note that each environment needs to be set up independently, so you need to use the Environment subdomain in the code block above for those new environments. ## Configure your app The OAuth client is now automatically configured based on the framework you're using. Simply import the OAuth class from the auth module and create an instance: ```python from kinde_sdk.auth.oauth import OAuth # For Flask applications from flask import Flask app = Flask(__name__) oauth = OAuth( framework="flask", app=app # optional: pass your Flask app instance ) # For FastAPI applications from fastapi import FastAPI app = FastAPI() oauth = OAuth( framework="fastapi", app=app # optional: pass your FastAPI app instance ) ``` The SDK will automatically detect and configure the appropriate framework implementation based on the framework parameter and app instance you provide. ## Sign in and sign up The Kinde client provides methods for easy sign in and sign up. You can add buttons in your HTML as follows: ```html <div class="navigation"> <a href="{{ url_for('login') }}" type="button">Sign in</a> <a href="{{ url_for('register') }}" type="button">Sign up</a> </div> ``` ### Automatic Route Registration The framework wrapper can automatically register all necessary routes. For Flask: ```python from kinde_sdk.auth.oauth import OAuth from flask import Flask app = Flask(__name__) oauth = OAuth( framework="flask", app=app ) ``` For FastAPI: ```python from kinde_sdk.auth.oauth import OAuth from fastapi import FastAPI app = FastAPI() oauth = OAuth( framework="fastapi", app=app ) ``` ### Manual route implementation If you prefer to implement the routes manually, here's how you can do it: For Flask: ```python import asyncio from flask import Flask, request, session, redirect from kinde_sdk.auth.oauth import OAuth app = Flask(__name__) oauth = OAuth( framework="flask", app=app ) @app.route('/login') def login(): """Redirect to Kinde login page."" loop = asyncio.get_event_loop() login_url = loop.run_until_complete(oauth.login()) return redirect(login_url) @app.route('/register') def register(): """Redirect to Kinde registration page."" loop = asyncio.get_event_loop() register_url = loop.run_until_complete(oauth.register()) return redirect(register_url) @app.route('/callback') def callback(): """Handle the OAuth callback from Kinde."" try: code = request.args.get('code') state = request.args.get('state') if not code: return "Authentication failed: No code provided", 400 # Generate a unique user ID for the session user_id = session.get('user_id') or str(uuid.uuid4()) # Use OAuth's handle_redirect method to process the callback loop = asyncio.get_event_loop() result = loop.run_until_complete(oauth.handle_redirect(code, user_id, state)) # Store user ID in session session['user_id'] = user_id return redirect('/') except Exception as e: return f"Authentication failed: {str(e)}", 400 @app.route('/logout') def logout(): """Logout the user and redirect to Kinde logout page."" user_id = session.get('user_id') session.clear() loop = asyncio.get_event_loop() logout_url = loop.run_until_complete(oauth.logout(user_id)) return redirect(logout_url) @app.route('/user') def get_user(): """Get the current user's information."" try: if not oauth.is_authenticated(request): loop = asyncio.new_event_loop() asyncio.set_event_loop(loop) try: login_url = loop.run_until_complete(oauth.login()) return redirect(login_url) finally: loop.close() return oauth.get_user_info(request) except Exception as e: return f"Failed to get user info: {str(e)}", 400 ``` For FastAPI: ```python from fastapi import FastAPI, Request from fastapi.responses import RedirectResponse @app.get("/login") async def login(request: Request): url = await oauth.login() return RedirectResponse(url=url) @app.get("/register") async def register(request: Request): url = await oauth.register() return RedirectResponse(url=url) @app.get("/callback") async def callback(request: Request, code: str, state: Optional[str] = None): try: result = await oauth.handle_redirect(code, state) return RedirectResponse(url="/") except Exception as e: return HTMLResponse(f"Authentication failed: {str(e)}") @app.get("/logout") async def logout(request: Request): request.session.clear() return RedirectResponse(url=await oauth.logout()) @app.get("/user") async def get_user(request: Request): if not oauth.is_authenticated(request): return RedirectResponse(url=await oauth.login()) return oauth.get_user_info(request) ``` The manual implementation gives you more control over the authentication flow and allows you to add custom logic like session management, error handling, and logging. Note that Flask requires special handling of async methods using `asyncio` since it doesn't natively support async/await like FastAPI does. ## User permissions The Kinde Python SDK provides a simple way to check user permissions in your application. First, import the permissions module: ```python from kinde_sdk.auth import permissions ``` ### Checking permissions To check if a user has a specific permission: ```python # Check a single permission permission = await permissions.get_permission("create:todos") if permission["isGranted"]: # User has permission print(f"User has permission in organization: {permission['orgCode']}") ``` To get all permissions for the current user: ```python # Get all permissions all_permissions = await permissions.get_permissions() print(f"User belongs to organization: {all_permissions['orgCode']}") print("User permissions:", all_permissions["permissions"]) ``` ### Practical examples Here's how to use permissions in your application: ```python # Example 1: Conditional Feature Access async def create_todo_button(): permission = await permissions.get_permission("create:todos") if permission["isGranted"]: return "<button>Create Todo</button> return None # Example 2: Permission-Based API Endpoint @router.post("/todos") async def create_todo(todo_data: dict): permission = await permissions.get_permission("create:todos") if not permission["isGranted"]: raise HTTPException(status_code=403, detail="Permission denied") # Create todo logic here... ``` ### Common permission patterns Here are some common permission patterns you might use: ```python # Resource-based permissions "create:todos "read:todos "update:todos "delete:todos # Feature-based permissions "can:export_data "can:manage_users "can:view_analytics # Organization-based permissions "org:manage_members "org:view_billing "org:update_settings ``` For more information about setting up permissions in Kinde, see [User permissions](/manage-users/roles-and-permissions/user-permissions/). ## Feature flags The Kinde Python SDK provides a simple way to access feature flags from your application. First, import the feature flags module: ```python from kinde_sdk.auth import feature_flags ``` ### Getting feature flags To get a specific feature flag value: ```python # Get a string feature flag theme_flag = await feature_flags.get_flag("theme") print(f"Current theme: {theme_flag.value}") # Get a boolean feature flag with default value dark_mode = await feature_flags.get_flag("is_dark_mode", default_value=False) if dark_mode.value: print("Dark mode is enabled") # Get a numeric feature flag competitions_limit = await feature_flags.get_flag("competitions_limit") print(f"User can create up to {competitions_limit.value} competitions") ``` To get all feature flags for the current user: ```python # Get all feature flags all_flags = await feature_flags.get_all_flags() for code, flag in all_flags.items(): print(f"- {code}: {flag.value} ({flag.type})") ``` ### Practical examples Here's how to use feature flags in your application: ```python # Example 1: Conditional Feature Rendering async def render_create_competition_button(): can_create = await feature_flags.get_flag("create_competition", default_value=False) if can_create.value: return "<button>Create Competition</button> return None # Example 2: Theme Configuration async def get_user_theme(): theme = await feature_flags.get_flag("theme", default_value="light") dark_mode = await feature_flags.get_flag("is_dark_mode", default_value=False) return { "theme": theme.value, "is_dark_mode": dark_mode.value } # Example 3: Feature Limits @router.post("/competitions") async def create_competition(competition_data: dict): limit_flag = await feature_flags.get_flag("competitions_limit", default_value=3) current_count = await get_user_competition_count() if current_count >= limit_flag.value: raise HTTPException( status_code=403, detail=f"Competition limit reached (max: {limit_flag.value}) ) # Create competition logic here... ``` ### Feature flag types The SDK supports the following feature flag types: ```python # String flags { "t": "s", "v": "pink" } # Boolean flags { "t": "b", "v": true } # Integer flags { "t": "i", "v": 5 } ``` ### Common use cases ```python # Feature Toggles can_use_feature = await feature_flags.get_flag("enable_new_feature", default_value=False) # User Preferences theme = await feature_flags.get_flag("theme", default_value="light") dark_mode = await feature_flags.get_flag("is_dark_mode", default_value=False) # Usage Limits max_uploads = await feature_flags.get_flag("max_uploads", default_value=10) # A/B Testing test_group = await feature_flags.get_flag("ab_test_group", default_value="control") ``` ## Claims The Kinde Python SDK provides a simple way to access user claims from your application. First, import the claims module: ```python from kinde_sdk.auth import claims ``` ### Getting claims To get a specific claim from the user's tokens: ```python # Get the audience claim from the access token claim = await claims.get_claim("aud") print(f"Token audience: {claim['value']}") # Get the given_name claim from the ID token claim = await claims.get_claim("given_name", token_type="id_token") print(f"User's given name: {claim['value']}") ``` To get all claims from the user's tokens: ```python # Get all claims from the access token all_claims = await claims.get_all_claims() for claim_name, claim_value in all_claims.items(): print(f"- {claim_name}: {claim_value}") # Get all claims from the ID token id_token_claims = await claims.get_all_claims(token_type="id_token") ``` ### Practical examples Here's how to use claims in your application: ```python # Example 1: Accessing User Information async def get_user_profile(): given_name = await claims.get_claim("given_name", token_type="id_token") family_name = await claims.get_claim("family_name", token_type="id_token") if given_name["value"] and family_name["value"]: return { "name": f"{given_name['value']} {family_name['value']}", "email": (await claims.get_claim("email", token_type="id_token"))["value"] } return None # Example 2: Token Validation @router.get("/api/protected") async def protected_endpoint(): aud_claim = await claims.get_claim("aud") if not aud_claim["value"] or "api.yourapp.com" not in aud_claim["value"]: raise HTTPException(status_code=401, detail="Invalid token audience") return {"message": "Access granted"} ``` ### Common claims Here are some common claims you might want to access: ```python # User Information (ID Token) "given_name "family_name "email "picture # Token Information (Access Token) "aud" # Audience "iss" # Issuer "exp" # Expiration time "iat" # Issued at time # Organization Information "org_code "org_name "org_id ``` ## Organizations ### Create an organization To create a new organization within your application, you will need to run a similar function to below: ```python return app.redirect(oauth.create_org()) ``` ### Sign up and sign in to organizations Kinde has a unique code for every organization. You'll have to pass this code through when you register a new user or sign in to a particular organization. Example function below: ```python oauth.get_claim("org_code") @app.route("/login") def login(): return app.redirect(oauth.get_login_url()) @app.route("/register") def register(): return app.redirect(oauth.get_register_url()) ``` Following authentication, Kinde provides a json web token (jwt) to your application. Along with the standard information we also include the `org_code` and the permissions for that organization (this is important as a user can belong to multiple organizations and have different permissions for each). Example of a returned token: ```python { "aud": [], "exp": 1658475930, "iat": 1658472329, "iss": "https://your_subdomain.kinde.com", "jti": "123457890", "org_code": "org_1234", "permissions": ["read:todos", "create:todos"], "scp": [ "openid", "profile", "email", "offline ], "sub": "kp:123457890" } ``` The `id_token` will also contain an array of organizations that a user belongs to - this is useful if you wanted to build out an organization switcher for example. ```python { ... "org_codes": ["org_1234", "org_4567"], ... }; ``` There are two helper functions you can use to extract information: ```python oauth.get_organization() oauth.get_user_organizations() ``` For more information about how organizations work in Kinde, see [Kinde organizations for developers](/build/organizations/orgs-for-developers/). ### Token and session management The Kinde Python SDK automatically handles token and session management for your application. Once a user has successfully authenticated, the SDK manages: - **Token acquisition and storage**: Automatically obtains and securely stores access tokens, ID tokens, and refresh tokens - **Token refresh**: Automatically refreshes tokens when they expire - **Session management**: Handles user sessions across requests - **Framework integration**: Works seamlessly with Flask and FastAPI session systems The SDK uses the session configuration from your environment variables (`SECRET_KEY`, `SESSION_TYPE`, `SESSION_PERMANENT`) to manage sessions appropriately for your chosen framework. #### Token types The SDK supports two types of tokens: 1. **Access Token** (`token_type="access_token"`): - Contains authorization information - Used for API access - Contains permissions and organization context - Default token type 2. **ID Token** (`token_type="id_token"`): - Contains user identity information - Used for user profile data - Contains name, email, and other user details - Must be explicitly requested using `token_type="id_token"` #### Session handling The SDK automatically integrates with your framework's session system: - **Flask**: Uses Flask's built-in session management - **FastAPI**: Integrates with FastAPI's session handling You don't need to manually manage tokens or sessions - the SDK handles this automatically for you. ## Management API The Kinde Python SDK provides a Management API client for interacting with Kinde's management endpoints. This allows you to programmatically manage users, organizations, and other resources. ### Getting started To use the Management API, you'll need to initialize the client with your Kinde credentials: ```python from kinde_sdk.auth.oauth import OAuth oauth = OAuth( framework="flask", app=app ) # Get the management client management = oauth.get_management() ``` ### Available endpoints The Management API provides methods for common operations on resources. Here are some examples: ```python # List users users = await management.get_users() # Get a specific user user = await management.get_user(user_id="user_123") # Create a new user new_user = await management.create_user( email="user@example.com", given_name="John", family_name="Doe ) # Update a user updated_user = await management.update_user( user_id="user_123", given_name="Johnny ) # Delete a user await management.delete_user(user_id="user_123") ``` ### Organization management ```python # List organizations orgs = await management.get_organizations() # Get a specific organization org = await management.get_organization(org_id="org_123") # Create a new organization new_org = await management.create_organization( name="My Organization ) # Update an organization updated_org = await management.update_organization( org_id="org_123", name="Updated Name ) # Delete an organization await management.delete_organization(org_id="org_123") ``` ### Error handling The Management API methods will raise exceptions for API errors. It's recommended to handle these appropriately: ```python try: user = await management.get_user(user_id="user_123") except Exception as e: # Handle API-specific errors print(f"Error: {e}") ``` ### Token management The Management API client has its own token management system for API authentication, which is separate from the core SDK's user session token management. The Management API client automatically handles: - **accessing Kinde Management API endpoints**: Obtains tokens for accessing Kinde's management endpoints - **Token refresh**: Automatically refreshes management API tokens when they expire - **Token storage**: Securely stores management API tokens - **Thread safety**: Ensures thread-safe token handling for concurrent requests You don't need to manually manage Management API tokens - the client handles this for you. This is different from the core SDK's user session token management, which handles user authentication tokens automatically. ### Best practices 1. Always use async/await when calling Management API methods 2. Handle API errors appropriately 3. Cache results when appropriate to reduce API calls 4. Use appropriate error handling for production environments 5. Keep your client credentials secure For more information about the Management API endpoints and capabilities, see the [Kinde Management API documentation](https://docs.kinde.com/kinde-apis/management/).

# Developer tools - Sdks - Remix SDK

> Complete guide for Remix SDK including authentication setup, route protection, session management, and internationalization for Remix applications.

Remix SDK, authentication, route protection, session management, internationalization, organizations
developer-tools, sdks, remix, backend

This SDK is for developers using Remix. New to Kinde? [Get started here](/get-started/guides/first-things-first/). ## Create a back end application in Kinde The Remix SDK works with back end applications. Create one in Kinde. See [Add and manage applications](/build/applications/add-and-manage-applications/). ## Install the Kinde Remix SDK into your Remix project <PackageManagers pkg="@kinde-oss/kinde-remix-sdk" /> ## **Set callback URLs** 1. In Kinde, go to **Settings > Applications > [Your app] > View details**. 2. Add your callback URLs in the relevant fields. For example: - Allowed callback URLs (also known as redirect URIs) - for example `http://localhost:3000/kinde-auth/callback` - Allowed logout redirect URLs - for example `http://localhost:3000` 3. Select **Save**. ## Set up environment variables While you are in your Kinde backend application, copy the Client ID and Client secret, redirect URLs, etc. Add these details to the Environment variables for your application. `.env` ```shell KINDE_CLIENT_ID=<your-client-id> KINDE_CLIENT_SECRET=<your-client-secret> KINDE_ISSUER_URL=https://<your-kinde-subdomain>.kinde.com KINDE_SITE_URL=http://localhost:3000 KINDE_POST_LOGOUT_REDIRECT_URL=http://localhost:3000 KINDE_POST_LOGIN_REDIRECT_URL=http://localhost:3000 ``` ## Set up authentication routes Create this file `app/routes/kinde-auth.$index.tsx`. ```jsx import { handleAuth } from "@kinde-oss/kinde-remix-sdk"; import { LoaderFunctionArgs } from "@remix-run/node"; export async function loader({ params, request }: LoaderFunctionArgs) { return await handleAuth(request, params.index); } ``` ## Authentication ### Sign up and sign in Authenticate users by redirecting them to `/kinde-auth/login` and `/kinde-auth/register` with the Remix `<Link />` component. ```jsx import { Link } from "@remix-run/react"; <Link to={"/kinde-auth/login"}> Login </Link> <Link to={"/kinde-auth/register"}> Register </Link> ``` **Sign into organizations** To log into specific organizations you can specify the `org_code` in the search params. ```typescript <Link to={{ pathname: "/kinde-auth/login", search: "?org_code=org_af90783xxxx", }} > Sign in </Link> ``` **Internationalization** You can set the language you wish your users to see when they hit the login flow by including `lang` in the search params. ```typescript <Link to={{ pathname: "/kinde-auth/login", search: "?lang=fr", }} > Sign in </Link> ``` ### Logout This is implemented in much the same way as signing up or signing in. Use the remix `<Link />` component to redirect users to `/kinde-auth/logout`. ```jsx import {Link} from "@remix-run/react"; <Link to={"/kinde-auth/logout"}>Logout</Link>; ``` ### Protect routes In the `loader`, check if the user exists and then handle route protection there. In this example we will redirect the user to sign in if there is no login data. ```typescript export const loader = async ({request}: LoaderFunctionArgs) => { const {getUser, headers} = await getKindeSession(request); const user = await getUser(); if (user === null) { throw redirect("/kinde-auth/login"); } return json({user}, {headers}); }; ``` <Aside> Note that passing the headers through in the `json` response is required to ensure refresh tokens can be used in the background to keep the session alive. </Aside> ### Return to a specific page after authentication After a user has logged in following a redirect from a protected route, we usually want to send the user back to the page they were trying to access prior to logging in. This can be achieved with the `returnTo` search parameter added to the login/register url. ```typescript export const loader = async ({request}: LoaderFunctionArgs) => { const {getUser, headers} = await getKindeSession(request); const user = await getUser(); if (user === null) { throw redirect("/kinde-auth/login?returnTo=/protected-route"); } return json({user}, {headers}); }; ``` ### Call a function after authentication After a user has authenticated, you may want to call a function to update your database or perform some other action. This can be achieved by passing `onRedirectCallback` to the handleAuth function. ```typescript import {handleAuth} from "@kinde-oss/kinde-remix-sdk"; import {LoaderFunctionArgs} from "@remix-run/node"; export async function loader({params, request}: LoaderFunctionArgs) { return await handleAuth(request, params.index, { onRedirectCallback({user}) { console.log("This is called after the user is authenticated!", user); } }); } ``` ## Kinde session data - `getKindeSession()` ```jsx const { getUser, getBooleanFlag, getFlag, getIntegerFlag, getStringFlag, getPermission, getClaim, getClaimValue, getOrganization, getPermissions, getToken, getUserOrganizations, getUserProfile, isAuthenticated } = await getKindeSession(request); ``` ### **Claims** `getClaim(claim, type)`: Fetches a specific claim from the user's session based on the provided claim name and type. Returns an object with `name` and `value` properties, or null on error. `getClaimValue(claim, type)`: Similar to `getClaim`, but retrieves only the claim's value. Returns the value or null on error. ### **Authentication and user information** `getToken()`: Retrieves the current access token from the session. Returns the token or null when the user is not authenticated or on error. `refreshTokens()`: Attempts to refresh the user's access and refresh tokens. Returns true on success or throws an error. `isAuthenticated()`: Checks if a valid session exists, indicating a logged-in user. Returns true if authenticated, otherwise false. `getUser()`: Retrieves the user information associated with the current session. Returns a user object or null on error or if the user is not authenticated. `getUserProfile()`: Fetches the user's profile details from Kinde. Returns a user profile object or null on error or if the user is not authenticated. ### **Feature flags** `getFlag(code, defaultValue, type)`: Retrieves a feature flag value by code. Optionally provides a default value and type for parsing the retrieved value. Returns the flag value or the default value on error. `getBooleanFlag(code, defaultValue)`: Retrieves a boolean feature flag. `getIntegerFlag(code, defaultValue)`: Retrieves an integer feature flag. `getStringFlag(code, defaultValue)`: Retrieves a string feature flag. ### **Permissions** `getPermission(permission)`: Checks if a specific permission is granted to the user. Returns true if granted, false otherwise. `getPermissions()`: Retrieves all permissions associated with the user's session. Returns an array of permission strings or an empty array on error. ### **Organizations** `getOrganization()`: Fetches information about the user's current organization. Returns an organization object or null on error. `getUserOrganizations()`: Retrieves a list of organizations the user belongs to. Returns an array of organization objects or an empty array on error. ## Using refresh tokens Refresh tokens used to keep the user session alive. You can pass through the `headers` from `getKindeSession` through to the loader fetch response. Or you can use the `refreshTokens` function to refresh the user's access and refresh tokens manually. ```typescript // Refresh tokens in the background export const loader = async ({request}: LoaderFunctionArgs) => { const {headers} = await getKindeSession(request); return json({paylod: "Refreshing tokens in the backgrounf"}, {headers}); }; // Refresh tokens manually export const action = ({request}: ActionFunctionArgs) => { const {refreshTokens} = await getKindeSession(request); const headers = refreshTokens(); return redirect("/profile", {headers}); }; ``` ## Get up-to-date Kinde data To get up-to-date Kinde data into your app you can use the `refreshTokens` function in an `action` function and then include the headers in the response. ```jsx export const action = ({request}: ActionFunctionArgs) => { const {refreshTokens} = await getKindeSession(request); const headers = refreshTokens(); return redirect('/profile', {headers}); } ``` ## Kinde Management API To use our management API please see [@kinde/management-api-js](https://github.com/kinde-oss/management-api-js) ``` ```

# Developer tools - Sdks - Ruby SDK

> Complete guide for Ruby SDK including Rails integration, OAuth2 flows, AuthController, and configuration for Ruby-based applications.

Ruby SDK, Rails, OAuth2, client credentials, authorization code, PKCE, AuthController
developer-tools, sdks, ruby, backend

{/* @case-police-ignore Api */} The Kinde Ruby SDK gem allows developers to integrate Kinde API into any ruby-based applications, Rails or non-Rails. The gem contains all the related oauth2 authorization, and 3 pre-built OAuth flows: **client credentials**, **authorization code** and **authorization code with PKCE code verifier**. You can also view the [Ruby docs](https://github.com/kinde-oss/kinde-ruby-sdk) and [Ruby starter kit](https://github.com/kinde-starter-kits/ruby-starter-kit) in GitHub. ## Register for Kinde If you haven’t already got a Kinde account, [register for free here](https://app.kinde.com/register) (no credit card required). Registering gives you a Kinde domain, which you need to get started, e.g. `yourapp.kinde.com` ## Install Add this line into your Gemfile and run a bundler or install manually through a gem command. ```ruby gem 'kinde_sdk', '~> 1.6.1' ``` ## Set callback URLs 1. In Kinde, go to **Settings > Applications > [Your app] > View details**. 2. Add your callback URLs in the relevant fields. For example: - Allowed callback URLs (also known as redirect URIs) - for example, `http://localhost:3000/kinde_sdk/callback` - Allowed logout redirect URLs - for example, `http://localhost:3000` 3. Select **Save**. ## Add environments Kinde comes with a production environment, but you can set up other environments if you want to. Note that each environment needs to be set up independently, so you need to use the Environment subdomain in the code block above for those new environments. ## Configure your app ### **Environment variables** The following variables need to be replaced in the code snippets below. - `KINDE_DOMAIN` - your Kinde domain - e.g. `https://your_kinde_domain.kinde.com` - `KINDE_REDIRECT_URL` - your callback url, make sure this URL is under your allowed callback redirect URLs. - e.g. `http://localhost:3000/kinde_sdk/callback` - `KINDE_POST_LOGOUT_REDIRECT_URL` - where you want users to be redirected to after logging out, make sure this URL is under your allowed logout redirect URLs. - e.g. `http://localhost:3000` - `KINDE_CLIENT_ID` - you can find this on the **Application details** page - e.g. `your_kinde_client_id` - `KINDE_CLIENT_SECRET` - you can find this on the **Application details** page - e.g. `your_kinde_client_secret` ## Integrate with your app You can easily configure via the gem. For example, in a typical Rails-app it can be configured through the initializer file: ```ruby KindeSdk.configure do |c| c.domain = domain c.client_id = client_id c.client_secret = client_secret c.callback_url = callback_url c.logout_url = logout_url # c.scope = 'openid offline email profile' # default value # c.pkce_enabled = true # default value # c.authorize_url = '/oauth2/auth' # default value # c.token_url = '/oauth2/token' # default value # c.debugging = false # default value c.logger = Rails.logger end ``` The snippet above contains all the possible configuration values. Here is a detailed explanation of them: - `Domain` refers to your organization - for example, `your-biz.kinde.com`. - `Client id` and `Client secret` can be found in Kinde. Go to **Settings > Applications > [yourapplication] > Details.** - `Callback url` (or redirect URI) refers to the callback processing action. The URL must be defined in the **Allowed callback URLs** section of your application. - `Logout url` will open when the user signs out. The URL must be defined in the **Allowed callback URLs** section of your application. - `Scope` is an OAuth special parameter which is used to limit some rights. - `PKCE enabled` is a flag that can turn off PKCE auth flow. By default it is activated to improve security. - `Authorize url` and `Token url` are paths to Oauth2 methods in kinde. - `Debugging` set to `True` for long request logs. Can be useful while developing your application. - `Business name` is a parameter which is used in requests building. By default it is extracted from your Kinde `domain` endpoint. For example, if your domain is `your-biz.kinde.com`, then business name will be set to`your-biz`. You don't need to change it. - `Logger` set to whichever kind of loggers you are using. By default it is set to `Rails.logger` if gem is used in rails application or `Logger.new(STDOUT)` if it is not a rails app. - `auto_refresh_tokens` defines the default behaviour on API instance method calls. If the config is set to false, there will not be any auto refreshes during method calling, otherwise each time the client will try to refresh expired tokens if `expires_at` is present (see [token expiration and refreshing](https://github.com/kinde-oss/kinde-ruby-sdk#token-expiration-and-refreshing) section). These variables can be handled with any system you want: .env files, settings.yml or any type of config files. For example, .env file (you can name variables yourself): ```ruby KINDE_DOMAIN=https://<your_kinde_subdomain>.kinde.com KINDE_CLIENT_ID=<your_kinde_client_id> KINDE_CLIENT_SECRET=<your_kinde_client_secret> KINDE_CALLBACK_URL=http://localhost:3000/callback KINDE_LOGOUT_URL=http://localhost:3000/logout_callback ``` This can be used as: ```ruby KindeSdk.configure do |c| c.domain = ENV['KINDE_DOMAIN'] c.client_id = ENV['KINDE_CLIENT_ID'] # .... end ``` The `KINDE_MANAGEMENT_CLIENT_ID` and the `KINDE_MANAGEMENT_CLIENT_SECRET` can be used for accessing the Kinde management API using the `client_credentials` grant, without redirection, see details in the [management API section](https://github.com/kinde-oss/kinde-ruby-sdk#management-api). ```ruby KindeSdk.client_credentials_access( client_id: ENV["KINDE_MANAGEMENT_CLIENT_ID"], # client_id: # default to @config.client_id client_secret: ENV["KINDE_MANAGEMENT_CLIENT_SECRET"], # client_secret: # default to @config.client_secret, # audience: # default to "#{@config.domain}/api", # domain: # default to @config.domain ) ``` ## Rails Authentication integration The Kinde Ruby SDK gem provides a Rails authentication integration that simplifies the process of integrating Kinde authentication into your Rails application. This is provided by the AuthController class, which is responsible for handling the authentication flow and redirecting users to the appropriate page. ### AuthController The AuthController class is responsible for handling the authentication flow and redirecting users to the appropriate page. It is provided by the SDK gem and is located in 'lib/kinde_sdk/controllers/auth_controller.rb'. ### Routes To enable the AuthController, you need to add the following routes to your `config/routes.rb` file: ```ruby namespace :kinde_sdk do get "callback" => "auth#callback get "auth" => "auth#auth get "logout" => "auth#logout get "logout_callback" => "auth#logout_callback get "client_credentials_auth" => "auth#client_credentials_auth end ``` If you decide instead to use the rails engine, you can add the following to your `config/routes.rb` file: ```ruby mount KindeSdk::Engine, at: "/kinde_sdk" ``` ### Usage the AuthController in your application To use the AuthController consume the routes in your application. For example in a Rails view file use the auth path to trigger the login flow: ```ruby <div class="buttons"> <a class="button is-primary" href="<%= kinde_sdk_auth_path %>"> <strong>Log in</strong> </a> </div> ``` The full list of paths exposed by the controller are the following: ```ruby kinde_sdk_auth_path kinde_sdk_callback_path kinde_sdk_logout_path kinde_sdk_logout_callback_path kinde_sdk_client_credentials_auth_path ``` #### Using the engine When using the AuthController with the engine your application can use the paths as follows: ```ruby <div class="buttons"> <a class="button is-primary" href="<%= kinde_sdk.auth_path %>"> <strong>Log in</strong> </a> </div> ``` The full list of paths exposed by the engine are the following: ```ruby kinde_sdk.auth_path kinde_sdk.callback_path kinde_sdk.logout_path kinde_sdk.logout_callback_path kinde_sdk.client_credentials_auth_path ``` ## Sign in and registration The Kinde client provides methods for easy login and registration. For this, you need to acquire an auth URL by calling: ```ruby KindeSdk.auth_url( # client_id: # default to @config.client_id, # client_secret: # default to @config.client_secret, # domain: # default to @config.domain, # redirect_uri: # default to @config.callback_url, **kwargs ) { url: "https://<domain>/oauth2/auth?client_id=<client_id>&code_challenge=<generated code>&code_challenge_method=S256&redirect_uri=<redirect_uri>&response_type=code&scope=openid+offline+email+profile&state=<random string>", code_verifier: "<challenge verifier>" } ``` By default, gem uses the PKCE verification flow. This means that the `code challenge` param will be added to your auth url, and the method returns verification string for the code. This can also be used in token requests. You can disable PKCE by setting `pkce_enabled` to false in your configuration. In this case, `KindeSdk.auth_url` will only return a url: ```ruby KindeSdk.auth_url ``` If you are about to use PCKE, our recommendation is to save the code verifier output somewhere near your later tokens output. The `#auth_url` method can have another redirect url just in runtime. Use it with the argument: ```text KindeSdk.auth_url(redirect_uri: "your-another-desired-callback") ``` You can put the link right in your web-application page or you can use it under the hood through redirection. After visiting the link you'll be redirected to Kinde's sign in/sign up form. And after authorizing in Kinde, you'll be redirected to callback url. ## Manage redirects The next step is to extract code from the callback redirect. Your callback endpoint should contain logic to call the exchange method. Callback is triggered in the body with the code. Use the whole `params` object or to extract code from `params["code"]`. Next, exchange access and refresh tokens. You will receive `code` as the parameter in the callback endpoint, and `code_verifier` (if PKCE enabled) as per the previous step. ```ruby KindeSdk.fetch_tokens( params_or_code, # client_id: # default to @config.client_id, # client_secret: # default to @config.client_secret, # domain: # default to @config.domain, # code_verifier: # default to nil, # redirect_uri: # default to @config.callback_url ) {"access_token"=>"eyJhbGciOiJSUzI1NiIsIm...", "expires_in"=>86399, "id_token"=>"eyJhbGciOiJSUz", "refresh_token"=>"eyJhbGciOiJSUz", "scope"=>"openid offline email profile", "token_type"=>"bearer"} ``` Save the whole hash in your session, redis or any other storage, and use it to build your client. ```ruby session[:kinde_auth] = KindeSdk.fetch_tokens(code).slice(:access_token, :refresh_token, :expires_at) client = KindeSdk.client(session[:kinde_auth]) # => #<KindeSdk::Client:0x00007faf31e5ecb8> ``` ## Fetch tokens The `#fetch_tokens` method can have another callback url (just lake the `#auth_url` method), just use it in a same way: ```text KindeSdk.fetch_tokens(code, redirect_uri: "your-another-desired-callback") ``` ### **Token expiration and refreshing** For proper refreshing you'll need to use `access_token`, `refresh_token` and probably `expires_in` if you want to know if your access token still actual. Use these two methods to work with refreshing: ```text KindeSdk.token_expired?(session[:kinde_auth])# => false KindeSdk.refresh_token(session[:kinde_auth])# => {"access_token" => "qwe...", "refresh_token" => "fqw...", "expires_at"=>1685474405} ``` Or from your client instance: ```text client.token_expired?# => false client.refresh_token# => {"access_token" => "qwe...", ...., "expires_at"=>1685474405} ``` If you are calling `#refresh_token` on a client instance, the instance token data will be automatically updated. If you are calling `KindeSdk#refresh_token`, you'll need to store new token data in your configured storage (redis, session, etc). ## **Audience** An `audience` is the intended recipient of an access token - for example the API for your application. The audience argument can be passed to the Kinde `#auth_url` method to request an audience be added to the provided token: ```text KindeSdk.auth_url(audience: "https://your-app.kinde.com/api") ``` For details on how to connect, see [Register an API](/developer-tools/your-apis/register-manage-apis/) ## **Overriding scope** By default `KindeSdk` requests the following scopes: - profile - email - offline - openid You are able to change it - by configuring as per the integration instructions above - or by direct param passing into `auth_url` method: ```text KindeSdk.auth_url(scope: "openid offline") ``` ## **Getting claims** We have provided a helper to grab any claim from your ID or access tokens. The helper defaults to access tokens: ```text client = KindeSdk.client(session[:kinde_auth]) client.get_claim("aud")#=> {name: "aud", value: ['api.yourapp.com']} client.get_claim("scp")#=> {name: "scp", value: ["openid", "offline"]} ``` By default claim data is fetched from access_token, but you can also do it with id_token as well: ```text client.get_claim("some-claim", :id_token)# => {name: "some-claim", value: "some-data"} ``` ## **User permissions** After a user signs in and they are verified, the token return includes permissions for that user. [User permissions](/manage-users/roles-and-permissions/user-permissions/) are set in Kinde, but you must also configure your application to unlock these functions. ```text permissions" => [ "create:todos", "update:todos", "read:todos", "delete:todos", "create:tasks", "update:tasks", "read:tasks", "delete:tasks", ] ``` We provide helper functions to more easily access permissions: ```text client = KindeSdk.client(session[:kinde_auth]) client.get_permission("create:todos")# => {org_code: "org_1234", is_granted: true} client.permission_granted?("create:todos")# => true client.permission_granted?("create:orders")# => false ``` ## **Feature flags** Kinde provides [feature flag functionality](/releases/about/about-feature-flags/). So, the SDK provides methods to work with them. Here’s an example: ```text { "asd": { "t": "b", "v": true }, "eeeeee": { "t": "i", "v": 111 }, "qqq": { "t": "s", "v": "aa" } } ``` Note that `t` refers to type (`b` - boolean, `i` - integer, `s` - string) and `v` refers to value. You can fetch these flags with methods below: ```text client.get_flag("asd")# => { code: "asd", is_default: false, type: "boolean", value: true } client.get_flag("eeeeee")# => { code: "eeeeee", is_default: false, type: "integer", value: 111 } client.get_flag("qqq")# => { code: "qqq", is_default: false, type: "string", value: "aa" } ``` If you try to call an call undefined flag, you will get an exception. In addition to fetch existing flags, you can use fallbacks. For example: ```text client.get_flag("undefined", { default_value: true })# => { code: "undefined", is_default: true, value: true } ``` Set the type explicitly (output omitted except value): ```text client.get_flag("undefined_bool", { default_value: true }, "b")# => value = true client.get_flag("undefined_string", { default_value: "true" }, "s")# => value = "true client.get_flag("undefined_int", { default_value: 111 }, "i")# => value = 111 ``` In the example above if you try to set default_value of different types (for example: `get_flag("flag", {default_value: 1}, "s")`), you'll get an exception. Also you have wrapper methods, for example: ```text client.get_boolean_flag("eeeeee")# => leads to exception "Flag eeeeee value type is different from requested type client.get_boolean_flag("asd")# => true client.get_boolean_flag("undefined", false)# => false client.get_integer_flag("asd")# => exception "Flag asd value type is different from requested type client.get_integer_flag("undefined", "true")# => exception "Flag undefined value type is different from requested type client.get_integer_flag("eeeeee")# => 111 client.get_integer_flag("undefined", 123)# => 123 client.get_string_flag("qqq")# => "aa client.get_string_flag("undefined", "111")# => "111 ``` ## **Client usage** The API part is mounted in the `KindeSdk::Client` instance, so the short usage is: ```text client.oauth.get_user client.users.create_user(args) client.organizations.get_organizations ``` The method name will be the same as API module from the SDK without `-Api` part. Alternatively, you can initialize each API module: ```text api_client = KindeSdk.api_client(access_token) instance_client = KindeApi::UsersApi.new(api_client) instance_client.create_user(args) ``` ## Logout For logout you need to call in the controller (in the case of a rails app): ```ruby redirect_to KindeSdk.logout_url, allow_other_host: true ``` Your app should handle the logout callback url (which was configured separately). After calling redirect to logout_url (if set), Kinde redirects it back to logout callback path, where you need to clear your session: ```ruby # ....... def logout_callback Rails.logger.info("logout callback successfully received") reset_session redirect_to root_path end # ...... ``` If you configured a logout redirect url in Kinde, you’ll receive a logout callback. Otherwise a Kinde logout message will be shown. ## Organizations ### Create an organization To have a new organization created within your application, you will need to run something like: ```ruby client.organizations.create_organization(name: "new_org") ``` ### Sign up and sign in to organizations Kinde has a unique code for every organization. If you want a user to sign in to a particular organization, call the `#auth_url` method with `org_code` param passing: ```ruby KindeSdk.auth_url(org_code: "org_1234", start_page: "registration") # to enforce new user creation form KindeSdk.auth_url(org_code: "org_1234") # to login by default ``` Following authentication, Kinde provides a json web token (jwt) to your application. Along with the standard information we also include the `org_code` and the permissions for that organization (this is important as a user can belong to multiple organizations and have different permissions for each). Example of a returned token: ```ruby [ { "aud" => [], "exp" => 1658475930, "iat" => 1658472329, "iss" => "https://your_subdomain.kinde.com", "jti" => "123457890", "org_code" => "org_1234", "permissions" => ["read:todos", "create:todos"], "scp" => [ "openid", "profile", "email", "offline ], "sub" => "kp:123457890", "feature_flags" => { "asd" => { "t" => "b", "v" => true }, "eeeeee" => { "t" => "i", "v" => 111 }, "qqq" => { "t" => "s", "v" => "aa" } } } ] ``` The `id_token` will also contain an array of organizations that a user belongs to - this is useful if you wanted to build out an organization switcher for example: ```ruby client.get_claim("org_codes", :id_token) # => {name: "org_codes", value: [ ``` For more information about how organizations work in Kinde, see [Kinde organizations for developers](/build/organizations/orgs-for-developers/). ## Get user info ```ruby KindeSdk.client(session[:kinde_auth]).oauth.get_user ``` ## Kinde management API To get started, you will need an access token, the Ruby SDK includes a helper to get one. Or see [@kinde/management-api-js](https://github.com/kinde-oss/management-api-js/) ```ruby result = KindeSdk.client_credentials_access( client_id: ENV["KINDE_MANAGEMENT_CLIENT_ID"], client_secret: ENV["KINDE_MANAGEMENT_CLIENT_SECRET"] ) $redis.set("kinde_m2m_token", result["access_token"], ex: result["expires_in"].to_i) ``` This token can then be used to call any of the endpoints in the [Kinde Management API](/kinde-apis/management/). ### Organizations handling ```ruby client = KindeSdk.client({"access_token" => $redis.get("kinde_m2m_token")}) client.organizations.get_organizations client.organizations.create_organization(name: "new_org") ``` ### Create new user ```ruby client.users.create_user( create_user_request: { profile: {given_name: "AAAname", family_name: "AAAsurname"}, identities: [{type: "email", details: {email: "aaexample@asd.com"}}] } ) ``` Alternatively, using model instances: ```jsx request = KindeApi::CreateUserRequest.new( profile: KindeApi::CreateUserRequestProfile.new(given_name: "AAAfirstname1", family_name: "AAAlastname1"), identities: [ KindeApi::CreateUserRequestIdentitiesInner.new(type: "email", details: KindeApi::CreateUserRequestIdentitiesInnerDetails.new(email: "aaaaexample@example.com")) ] ) client.users.create_user(create_user_request: request) ``` ### Add organization users ```ruby client.organizations.add_organization_users(code: "org_1111", users: ["kp:12311...."]) ``` ### Token expiration and refreshing For proper refreshing you'll need to use `access_token`, `refresh_token` and probably `expires_in` if you want to know if your access token is still active. Use these two methods to work with refreshing: ```ruby KindeSdk.token_expired?( session[:kinde_auth], # client_id: # default to @config.client_id, # client_secret: # default to @config.client_secret, # audience: # default to "#{@config.domain}/api", # domain: # default to @config.domain ) # => false KindeSdk.refresh_token( session[:kinde_auth], # client_id: # default to @config.client_id, # client_secret: # default to @config.client_secret, # audience: # default to "#{@config.domain}/api", # domain: # default to @config.domain ) # => {"access_token" => "qwe...", "refresh_token" => "fqw...", .....} ``` `KindeSdk#refresh_token` returns a new token hash, so it needs to be updated in your storage. ## SDK API reference ### `host` Either your Kinde URL or your custom domain. e.g `https://yourapp.kinde.com`. Type: `string` Required: Yes ### `redirectUri` The URL that the user will be returned to after authentication. Type: `string` Required: Yes ### `clientId` The unique ID of your application in Kinde. Type: `string` Required: Yes ### `clientSecret` The unique ID key or secret of your application in Kinde. Type: `string` Required: Yes ### `logoutRedirectUri` Where your user will be redirected when they sign out. Type: `string` Required: Yes ### `scope` The scopes to be requested from Kinde. Type: `boolean` Required: No Default: `openid profile email offline` ### `additionalParameters` Additional parameters that will be passed in the authorization request. Type: `object` Required: No Default: `{}` ### `additionalParameters` `- audience` The audience claim for the JWT. Type: `string` Required: No ## Kinde SDK methods ### `login` Constructs a redirect URL and sends the user to Kinde to sign in. Arguments: ```ruby {org_code?: string} ``` Usage: ```ruby $kinde->login(); ``` Allow `org_code` to be provided if a specific organization is being signed into. ### `register` Constructs a redirect URL and sends the user to Kinde to sign up. Arguments: ```ruby {org_code?: string} ``` Usage: ```ruby $kinde->register(); ``` ### `logout` Logs the user out of Kinde. Usage: ```ruby $kinde->logout(); ``` ### `getToken` Returns the raw Access token from URL after logged from Kinde. Usage: ```ruby $kinde->getToken(); ``` Sample output: ```ruby eyJhbGciOiJIUzI1... ``` ### `createOrg` Constructs a redirect URL and sends the user to Kinde to sign up and create a new organization in your business. Arguments: ```ruby {org_name?: string} ``` Usage: ```ruby $kinde->createOrg(); or $kinde->createOrg(['org_name' => 'your organization name'}); ``` Allow `org_name` to be provided if you want a specific organization name when you create. Sample output: ```ruby redirect ``` ### `getClaim` Gets a claim from an access or ID token. Arguments: ```ruby claim: string, tokenKey?: string ``` Usage: ```ruby $kinde->getClaim('given_name', 'id_token'); ``` Sample output: ```ruby "David ``` ### `getPermission` Returns the state of a given permission. Arguments: `key: string` Usage: ```ruby $kinde->getPermission('read:todos'); ``` Sample output: ```ruby ['orgCode' => 'org_1234', 'isGranted' => true] ``` ### `getPermissions` Returns all permissions for the current user for the organization they are signed into. Usage: ```ruby $kinde->getPermissions(); ``` Sample output: ```ruby ['orgCode' => 'org_1234', permissions => ['create:todos', 'update:todos', 'read:todos']] ``` ### `getOrganization` Get details for the organization your user is signed into. Usage: ```ruby $kinde->getOrganization(); ``` Sample output: ```ruby ['orgCode' => 'org_1234'] ``` ### `getUserDetails` Returns the profile for the current user. Usage: ```ruby $kinde->getUserDetails(); ``` Sample output: ```ruby ['given_name' => 'Dave', 'id' => 'abcdef', 'family_name' => 'Smith', 'email' => 'mailto:dave@smith.com'] ``` ### `getUserOrganizations` Gets an array of all organizations the user has access to. If you need help connecting to Kinde, contact us at [support@kinde.com](mailto:support@kinde.com).

# Developer tools - Sdks - SvelteKit SDK

> Complete guide for SvelteKit SDK including OAuth 2.0 flows, session management, authentication integration, and user profile access for SvelteKit applications.

SvelteKit SDK, OAuth 2.0, Authorization Code, PKCE, Client Credentials, session hooks, authentication
developer-tools, sdks, sveltekit, backend

Kinde SvelteKit SDK allows developers to integrate Kinde Authentication into their SvelteKit projects. This SDK implements the following OAuth 2.0 flows. - Authorization Code - Intended for confidential clients for e.g. web-servers - Authorization Code with PKCE extension - For public clients for e.g. single page web application and or mobile applications, and confidential clients for e.g. web-servers. - Client Credentials Flow - Intended for confidential clients, where machine to machine communication is required. For new project, you can find our [Svelte Starter Kit](https://github.com/kinde-starter-kits/sveltekit-starter-kit) ## Requirements - Node version 18.16.x or newer ## Register for Kinde If you haven’t already got a Kinde account, [register for free here](https://app.kinde.com/register) (no credit card required). Registering gives you a Kinde domain, which you need to get started, e.g. `yourapp.kinde.com`. ## Install <PackageManagers pkg="@kinde-oss/kinde-auth-sveltekit" /> ## Configure Kinde ### Set callback URLs 1. In Kinde, go to **Settings > Applications** and then navigate to the relevant **frontend app** or **backend app**. 2. Add your callback URLs in the relevant fields. For example: - Allowed callback URLs (also known as redirect URIs): `https://<your_app_domain>/api/auth/kinde_callback` e.g: `http://localhost:5173/api/auth/kinde_callback` - Allowed logout redirect URLs: `https://<your_app_domain>` e.g:`http://localhost:5173` 3. Select **Save**. ### Add environments Kinde comes with a production environment, but you can set up other environments if you want to. Each environment has a unique subdomain so be sure to use the correct one in the **Configure your app section** which follows. ## Configure your app **Environment variables** Put these variables in your `.env` file. You can find these variables on your **Settings > Applications > [Your app] > View details** page. - `KINDE_ISSUER_URL` - your Kinde domain - `KINDE_CLIENT_ID` - your Kinde Client ID - `KINDE_CLIENT_SECRET` - your Kinde Client secret. Leave this field empty if you are using Authentication Code Flow with PKCE - `KINDE_REDIRECT_URL` - this is the URL Kinde will redirect to after the authentication process. Note that the Kinde `api/auth/kinde_callback` path must be included in the URL (see example below). You also need to make sure this URL is included in your list of **Allowed callback URLs**. - `KINDE_POST_LOGOUT_REDIRECT_URL` - Specify the destination where you want users to be redirected to after logging out. Make sure this URL is listed under your **Allowed logout redirect URLs**. - `KINDE_POST_LOGIN_REDIRECT_URL`- the URL users will be redirected to after signing in. - `KINDE_AUTH_WITH_PKCE` - Set `true` if you want to use Authentication Code Flow with PKCE Below is an example of a `.env` file ```bash KINDE_ISSUER_URL=https://<your_kinde_subdomain>.kinde.com KINDE_CLIENT_ID=<your_kinde_client_id> KINDE_CLIENT_SECRET=<your_kinde_client_secret> KINDE_REDIRECT_URL=http://localhost:5173/api/auth/kinde_callback KINDE_POST_LOGOUT_REDIRECT_URL=http://localhost:5173 KINDE_POST_LOGIN_REDIRECT_URL=http://localhost:5173/dashboard KINDE_AUTH_WITH_PKCE=true // Set `true` if you want to use Authentication Code Flow with PKCE ``` ## Integrate with your app Implement `sessionHooks` in your hooks. ```typescript // src/hooks.server.ts import { sessionHooks, type Handler } from '@kinde-oss/kinde-auth-sveltekit'; ... export const handle: Handler = async ({ event, resolve }) => { ... sessionHooks({ event }); const response = await resolve(event); return response; }; ``` Then implement the Kinde routes in your app by creating a server file. ```typescript // src/routes/api/auth/[...kindeAuth]/+server.ts import {handleAuth} from "@kinde-oss/kinde-auth-sveltekit"; import type {RequestEvent} from "@sveltejs/kit"; export function GET(requestEvents: RequestEvent) { return handleAuth(requestEvents); } ``` This will handle Kinde Auth endpoints in your SvelteKit app. - `/api/auth/login` - will redirect you to login at the KindeAuth server. - `/api/auth/logout` - will log you out of the app. - `/api/auth/register` - will redirect you to register at the KindeAuth server. - `/api/auth/kinde_callback` - the endpoint to handle the redirect after logging in from Kinde - `/api/auth/health` - See Health Below ## Sign in and sign up (login and register) The SDK ships with predefined API routes to generate the auth urls for sign up and sign in. ```html <ul> <li> <a href="/api/auth/login">Sign in</a> </li> <li> <a href="/api/auth/register">Sign up</a> </li> </ul> ``` ### Direct users post login / registration In addition to `KINDE_POST_LOGIN_REDIRECT_URL` which will direct your users to a single place, you direct the users more granularly. Both login and register support passing a url param `post_login_redirect_url` which will direct the user once the flow is completed. ```html <a class="btn btn-ghost sign-in-btn" href="/api/auth/login?post_login_redirect_url=/custom_url"> Sign in </a> ``` ## Log out This is implemented in much the same way as signing up or signing in. An API route is provided for you ```html <a href="/api/auth/logout"> Sign out </a> ``` ## Check if the user is authenticated We’ve provided a helper to get a boolean value that checks if a user is signed in by verifying that the access token is valid. ```typescript // +layout.server.ts ... import {kindeAuthClient, type SessionManager} from '@kinde-oss/kinde-auth-sveltekit'; import type {RequestEvent} from '@sveltejs/kit'; export async function load({request}: RequestEvent) { const isAuthenticated = await kindeAuthClient.isAuthenticated( request as unknown as SessionManager ); // Boolean: true or false if (isAuthenticated) { // Need to implement, e.g: call an api, etc... } else { // Need to implement, e.g: redirect user to sign in, etc.. } ... return { isAuthenticated }; } ``` ## View user profile You need to have already authenticated before you call the API, otherwise an error will occur. To access the user information, use the `getUser` helper function: ```typescript await kindeAuthClient.getUser(request as unknown as SessionManager); // returns { "given_name":"Dave", "id":"kp_12345678910", "family_name":"Smith", "email":"dave@smith.com", "picture": "https://link_to_avatar_url.kinde.com" } ``` ## Health check To check your configuration, the SDK exposes an endpoint with your settings. `/api/auth/health` **Note**: The client secret will indicate only if the secret is set or not set correctly. To enable set the `KINDE_DEBUG` environment variable to `true` ```jsx KINDE_DEBUG = true; ``` ```jsx { "authDomain": "https://danielkinde.kinde.com", "clientId": "0eb39a3b1cd64e99b4461d9660f7b97c", "logoutRedirectURL": "http://localhost:5173", "redirectURL": "http://localhost:5173/api/auth/kinde_callback", "audience": "", "scope": "profile email openid", "clientSecret": "Set correctly", "loginRedirectURL": "http://localhost:5173", "authUsePKCE": false, "version": "1710935446027", "framework": "sveltekit" } ``` ## **View users in Kinde** If you navigate to the “**Users**” page within Kinde you will see your newly registered user there. ## Audience An `audience` is the intended recipient of an access token - for example the API for your application. The `audience` argument can be set against `KINDE_AUDIENCE` in your environment variables. The audience of a token is the intended recipient of the token. ```typescript // .env KINDE_AUDIENCE = your_audience; ``` For details on how to connect, see [Register an API](/developer-tools/your-apis/register-manage-apis/) ## Overriding scope By default the `KindeSDK` requests the following scopes: - profile - email - offline - openid To override this, you can set the value against the `KINDE_SCOPE` in your environment variables. ```typescript // .env KINDE_SCOPE=profile email offline openid ``` ## Organizations ### Create an organization To create a new organization within your application, set up the following route: ```typescript <a href="/api/auth/create_org?org_name={<org_name>}"> Create org </a> ``` ### Sign up and sign in to organizations The Kinde client provides methods for you easily sign up and sign in users into organizations. You can add links in your HTML as follows: ```typescript <a href="/api/auth/login?org_code={<your_org_code>}">Sign in</a> <a href="/api/auth/register?org_code={<your_org_code>}">Sign up</a> ``` Following authentication, Kinde provides a json web token (JWT) to your application. Along with the standard information we also include the `org_code` and the permissions for that organization (this is important as a user can belong to multiple organizations and have different permissions for each). Example of a returned token: ```json { "aud": [], "exp": 1658475930, "iat": 1658472329, "iss": "https://your_subdomain.kinde.com", "jti": "123457890", "org_code": "org_1234", "permissions": ["read:todos", "create:todos"], "scp": ["openid", "profile", "email", "offline"], "sub": "kp:123457890" } ``` The `id_token` will also contain an array of organizations that a user belongs to - this is useful if you wanted to build out an organization switcher for example. ```json [ ... "org_codes": ["org_1234", "org_4567"] ... ]; ``` There are two helper functions you can use to extract information: ```typescript await kindeAuthClient.getOrganization(request as unknown as SessionManager); // { orgCode: 'org_1234' } await kindeAuthClient.getUserOrganizations(request as unknown as SessionManager); // { orgCodes: ['org_1234', 'org_abcd'] } ``` ## User permissions Once a user has been verified, your product/application will return the JWT with an array of permissions for that user. You will need to configure your product/application to read permissions and unlock the respective functions. [Set permissions](/manage-users/roles-and-permissions/user-permissions/) in your Kinde account. Here’s an example set of permissions. ```jsx const permissions = [ "create:todos", "update:todos", "read:todos", "delete:todos", "create:tasks", "update:tasks", "read:tasks", "delete:tasks ]; ``` We provide helper functions to more easily access the permissions claim: ```typescript await kindeAuthClient.getPermission(request as unknown as SessionManager, "create:todos"); // { orgCode: 'org_1234', isGranted: true } await kindeAuthClient.getPermissions(request as unknown as SessionManager); // { orgCode: 'org_1234', permissions: ['create:todos', 'update:todos', 'read:todos'] } ``` ## Getting claims We have provided a helper to grab any claim from your id or access tokens. The helper defaults to access tokens: ```typescript await kindeAuthClient.getClaim(request as unknown as SessionManager, "aud"); // { name: "aud", value: ["local-testing@kinde.com"] } await kindeAuthClient.getClaimValue(request as unknown as SessionManager, "aud"); // ["local-testing@kinde.com"] await kindeAuthClient.getClaim(request as unknown as SessionManager, "email", "id_token"); // { name: "email", value: "first.last@test.com" } await kindeAuthClient.getClaimValue(request as unknown as SessionManager, "email", "id_token"); // "first.last@test.com ``` ## Feature flags We have provided a helper to grab any feature flag from `access_token`: ```typescript await kindeAuthClient.getFlag(request as unknown as SessionManager, 'theme') // returns { "is_default": false "value": "pink", "code": "theme", "type": "string", } await kindeAuthClient.getFeatureFlag(request as unknown as SessionManager, 'no-feature-flag') // returns // Error: "Flag no-feature-flag was not found, and no default value has been provided" await kindeAuthClient.getFeatureFlag(request as unknown as SessionManager, 'no-feature-flag', 'default-value') // returns { "is_default": true "code": "no-feature-flag", "value": "default-value", } await kindeAuthClient.getFeatureFlag(request as unknown as SessionManager, 'theme', 'default-theme', 'b') // returns // Error: "Flag theme is of type string, expected type is boolean" ``` We also require wrapper functions by type which should leverage `getFlag` above. ### **Get boolean flags** ```typescript /** * Get a boolean flag from the feature_flags claim of the access_token. * @param {Object} request - Request object * @param {String} code - The name of the flag. * @param {Boolean} [defaultValue] - A fallback value if the flag isn't found. * @return {Boolean} */ await kindeAuthClient.getBooleanFlag(request as unknown as SessionManager, code, defaultValue); await kindeAuthClient.getBooleanFlag(request as unknown as SessionManager, "is_dark_mode"); // true await kindeAuthClient.getBooleanFlag(request as unknown as SessionManager, "is_dark_mode", false); // true await kindeAuthClient.getBooleanFlag(request as unknown as SessionManager, "new_feature"); // Error - flag does not exist and no default provided await kindeAuthClient.getBooleanFlag(request as unknown as SessionManager, "new_feature", false); // false (flag does not exist so falls back to default) await kindeAuthClient.getBooleanFlag(request as unknown as SessionManager, "theme", "blue"); // Error - Flag "theme" is of type string not boolean ``` ### **Get string flags** ```typescript /** * Get a string flag from the feature_flags claim of the access_token. * @param {Object} request - Request object * @param {String} code - The name of the flag. * @param {String} [defaultValue] - A fallback value if the flag isn't found. * @return {String} */ await kindeAuthClient.getStringFlag(request as unknown as SessionManager, code, defaultValue); /* Example usage */ await kindeAuthClient.getStringFlag(request as unknown as SessionManager, "theme"); // pink await kindeAuthClient.getStringFlag(request as unknown as SessionManager, "theme", "black"); // true await kindeAuthClient.getStringFlag(request as unknown as SessionManager, "cta_color"); // Error - flag does not exist and no default provided await kindeAuthClient.getStringFlag(request as unknown as SessionManager, "cta_color", "blue"); // blue (flag does not exist so falls back to default) await kindeAuthClient.getStringFlag(request as unknown as SessionManager, "is_dark_mode", false); // Error - Flag "is_dark_mode" is of type boolean not string ``` ### **Get integer flags** ```typescript /** * Get an integer flag from the feature_flags claim of the access_token. * @param {Object} request - Request object * @param {String} code - The name of the flag. * @param {Integer} [defaultValue] - A fallback value if the flag isn't found. * @return {Integer} */ await kindeAuthClient.getIntegerFlag(request as unknown as SessionManager, code, defaultValue); await kindeAuthClient.getIntegerFlag(request as unknown as SessionManager, "competitions_limit"); // 5 await kindeAuthClient.getIntegerFlag(request as unknown as SessionManager, "competitions_limit", 3); // 5 await kindeAuthClient.getIntegerFlag(request as unknown as SessionManager, "team_count"); // Error - flag does not exist and no default provided await kindeAuthClient.getIntegerFlag(request as unknown as SessionManager, "team_count", 2); // false (flag does not exist so falls back to default) await kindeAuthClient.getIntegerFlag(request as unknown as SessionManager, "is_dark_mode", false); // Error - Flag "is_dark_mode" is of type boolean not integer ``` ## Token storage After the user has successfully logged in, you will have a JSON Web Token (JWT) and a refresh token securely stored. You can retrieve an access token using the `getToken` method. ```typescript const access_token = await kindeAuthClient.getToken(request as unknown as SessionManager); ``` ## Kinde Management API To use our management API please see [@kinde/management-api-js](https://github.com/kinde-oss/management-api-js) ## **SDK API reference** ### `login` Constructs redirect url and sends user to Kinde to sign in. **Usage:** ```dart sdk.login(); ``` ### `register` Constructs redirect url and sends user to Kinde to sign up. **Usage:** ```dart sdk.register(); ``` ### `logout` Logs the user out of Kinde. **Usage:** ```dart sdk.logout(); ``` ### `isAuthenticated` Checks if the user is authenticated. **Usage:** ```dart sdk.isAuthenticated(); ``` **Sample output:** ```dart true or false ``` ### `createOrg` Constructs redirect url and sends the user to Kinde to sign up and creates a new org for your business. **Arguments:** ```dart options?: CreateOrgURLOptions { org_name?: "string"; org_code?: "string"; state?: "string"; } ``` **Usage:** ```dart sdk.createOrg( org_name: "org_1234" ); ``` ### `getClaim` Extracts the provided claim from the provided token type in the current session, the returned object includes the provided claim. **Arguments:** ```dart claim: "string", tokenKey?: TokenType "access_token" | "id_token ``` **Usage:** ```dart sdk.getClaim(claim:"given_name", tokenType: TokenType); ``` ### `getPermission` Returns the state of a given permission. **Arguments:** ```dart key: "string ``` **Usage:** ```dart sdk.getPermission("permission"); ``` **Sample output:** ```dart { orgCode : 'org_1234', isGranted : true} ``` ### `getPermissions` Returns all permissions for the current user for the organization they are logged into. **Usage:** ```dart sdk.getPermissions(); ``` **Sample output:** ```dart { orgCode : 'org_1234', permissions : ['create:todos', 'update:todos', 'read:todos'] } ``` ### `getOrganization` Get details for the organization your user is logged into. **Usage:** ```dart sdk.getOrganization(); ``` **Sample output:** ```dart { orgCode : 'org_1234' } ``` ### `getUserOrganizations` Gets an array of all organizations the user has access to. **Usage:** ```dart sdk.getUserOrganizations(); ``` **Sample output:** ```dart { orgCodes: ['org_7052552de68', 'org_5a5c29381327'] } ``` ### `getUser` Extracts the user details from the ID token obtained after authentication. **Usage:** ```dart sdk.getUser(); ``` **Sample output:** ```dart { "id":"kp_12345678910", "preferredEmail":"dave@smith.com", "lastName":"smith", "firstName":"dave", } ``` ### `getToken` Returns the access token obtained after authentication. **Usage:** ```dart sdk.getToken(); ``` **Sample output:** ```dart eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9 .eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ .SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c; ``` --- ### `getUserProfile` Makes use of the `getToken` method above to fetch user details. **Usage:** ```dart sdk.getUserProfile(); ``` **Sample output:** ```dart { given_name: 'Dave', id: 'abcdef', family_name : 'Smith', email : 'mailto:dave@smith.com' } ``` ### `getFlag` Get a flag from the feature_flags claim of the `access_token` **Arguments:** ```dart code : "string" defaultValue? : FlagType[keyof FlagType] flagType? : [key of FlagType] interface FlagType { s: string; b: boolean; i: number; } interface GetFlagType { type?: 'string' | 'boolean' | 'number'; value: FlagType[keyof FlagType]; is_default: boolean; code: "string"; } ``` **Usage:** ```dart sdk.getFlag(code:"theme"); ``` **Sample output:** ```dart { "code": "theme", "type": "string", "value": "pink", "is_default": false } ``` ### `getBooleanFlag` Get a boolean flag from the feature_flags claim of the `access_token` **Arguments:** ```dart code : "string" defaultValue? : boolean ``` **Usage:** ```dart sdk.getBooleanFlag(code:"is_dark_mode"); ``` **Sample output:** ```dart true or false ``` ### `getStringFlag` Get a string flag from the feature_flags claim of the `access_token` **Arguments:** ```dart code : "string" defaultValue? : "string ``` **Usage:** ```dart sdk.getStringFlag(code:"theme"); ``` **Sample output:** ```dart pink ``` ### `getIntegerFlag` Get an integer flag from the feature_flags claim of the `access_token` **Arguments:** ```dart code : "string" defaultValue? : number ``` **Usage:** ```dart sdk.getIntegerFlag(code:"team_count"); ``` **Sample output:** ```dart 2 ``` If you need help connecting to Kinde, contact us at [support@kinde.com](mailto:support@kinde.com).

# Developer tools - Sdks - TypeScript SDK

> Complete guide for TypeScript SDK including OAuth 2.0 flows, session management, user authentication, and profile access for Node.js applications.

TypeScript SDK, OAuth 2.0, Authorization Code, PKCE, Client Credentials, session management, user profile
developer-tools, sdks, typescript, backend

Kinde’s TypeScript SDK allows developers to integrate Kinde Authentication into their JavaScript or TypeScript projects. This SDK implements the following OAuth2.0 flows. [Learn more here](https://kinde.com/guides/authentication/protocols/oauth-flows-explained/) - **Authorization Code** - Intended for confidential clients, e.g. web-servers - **Authorization Code with PKCE extension** - For public clients, e.g. single page web application and or mobile applications - **Client Credentials flow** - Intended for confidential clients, where machine to machine communication is required. ## Requirements Node version 16 or newer ## Register for Kinde If you haven’t already got a Kinde account, [register for free here](https://app.kinde.com/register) (no credit card required). Registering gives you a Kinde domain, which you need to get started, e.g. `<your_subdomain>.kinde.com`. ## Install <PackageManagers pkg="@kinde-oss/kinde-typescript-sdk" /> ## Configure Kinde ### Set callback URLs Kinde will redirect your user to authenticate. They’ll be redirected back to your JavaScript app after signing in or signing up. To authenticate your app, you need to specify which URL Kinde should redirect your user. 1. In Kinde, go to **Settings > Applications** and then navigate to **Front-end app** or **Back-end app** which ever applies - or add a new application. 2. Add your callback URLs in the relevant fields. For example: - Allowed callback URLs (also known as redirect URIs): `https://<your_app_domain>/callback` e.g: `http://localhost:3000/callback` - Allowed logout redirect URLs: `https://<your_app_domain>` e.g:`http://localhost:3000` 3. Select **Save**. ### Add environments Kinde comes with a production environment, but you can set up other environments if you want to. Each environment has a unique subdomain so be sure to use the correct one in the **Configure your app section** which follows. ## Integrate with your app First step is to configure and create a client. The following settings are needed depending on which authentication flow you are using. You can find these values on your **Settings > Applications > [Your app] > View details** page. - `authDomain` - your Kinde domain - `clientId` - your Kinde client ID - `clientSecret` - your Kinde client secret - `redirectURL` - your callback url to redirect to after authentication. Make sure this URL is under your **Allowed callback URLs**. - `logoutRedirectURL` - where you want users to be redirected to after logging out. Make sure this URL is under your **Allowed logout redirect URLs**. ```typescript import {createKindeServerClient, GrantType} from "@kinde-oss/kinde-typescript-sdk"; // Client for authorization code flow const kindeClient = createKindeServerClient(GrantType.AUTHORIZATION_CODE, { authDomain: "https://<your_kinde_subdomain>.kinde.com", clientId: "<your_kinde_client_id>", clientSecret: "<your_kinde_client_secret>", redirectURL: "http://localhost:3000/callback", logoutRedirectURL: "http://localhost:3000" }); // Client for client credentials flow const kindeApiClient = createKindeServerClient(GrantType.CLIENT_CREDENTIALS, { authDomain: "https://<your_kinde_subdomain>.kinde.com", clientId: "<your_kinde_client_id>", clientSecret: "<your_kinde_client_secret>", logoutRedirectURL: "http://localhost:3000" }); ``` ## Log in and register To incorporate the login and register features, you'll need to redirect to Kinde for authentication. One way to do this is to create routes for `/login` and `/register`. ```typescript const app = express(); app.get("/login", async (req, res) => { const loginUrl = await kindeClient.login(sessionManager); return res.redirect(loginUrl.toString()); }); app.get("/register", async (req, res) => { const registerUrl = await kindeClient.register(sessionManager); return res.redirect(registerUrl.toString()); }); app.listen(3000); ``` With that in place you can simply add links in your HTML as follows: ```html <a href="/login">Sign in</a> <a href="/register">Sign up</a> ``` In the above example there is a `sessionManager` which has not been defined. In order to track the authenticated session between requests a session store is required. Any key-value store can be used for this, you just need to implement the `SessionManager` interface to provide it to the SDK. An example session manager storing in memory could be implemented as: ```typescript let store: Record<string, unknown> = {}; const sessionManager: SessionManager = { async getSessionItem(key: string) { return store[key]; }, async setSessionItem(key: string, value: unknown) { store[key] = value; }, async removeSessionItem(key: string) { delete store[key]; }, async destroySession() { store = {}; } }; ``` This would work for a single user for local development purposes, but would need to be expanded for a production environment. The appropriate session store for your application will depend on your application architecture, for example encrypted cookies in a stateless server environment or a shared cache/database for a load balanced cluster of servers. Commonly, the session manager will be a wrapper around an existing session management library - often provided by a web framework, or a third party library. ## **Manage redirects** You will also need to route `/callback`. When the user is redirected back to your site from Kinde, it will trigger a call to the callback URL defined in the `redirectURL` client option. ```typescript app.get("/callback", async (req, res) => { const url = new URL(`${req.protocol}://${req.get("host")}${req.url}`); await kindeClient.handleRedirectToApp(sessionManager, url); return res.redirect("/"); }); ``` ## Logout The Kinde SDK comes with a logout method. ```typescript app.get("/logout", async (req, res) => { const logoutUrl = await kindeClient.logout(sessionManager); return res.redirect(logoutUrl.toString()); }); ``` ```html <a href="/logout">Log out</a> ``` ## Check if user is authenticated We’ve provided a helper to get a boolean value to check if a user is signed in by verifying that the access token is still valid. The `isAuthenticated` function is only available for authentication code and PKCE flows. ```typescript const isAuthenticated = await kindeClient.isAuthenticated(sessionManager); // Boolean: true or false if (isAuthenticated) { // Need to implement, e.g: call an api, etc... } else { // Need to implement, e.g: redirect user to sign in, etc.. } ``` ## View user profile You need to have already authenticated before you call the API, otherwise an error will occur. To access the user information, use the `getUserProfile` helper function: ```typescript const profile = await kindeClient.getUserProfile(sessionManager); // returns { "given_name":"Dave", "id":"kp_12345678910", "family_name":"Smith", "email":"dave@smith.com", "picture": "https://link_to_avatar_url.kinde.com" } ``` ## **View users in Kinde** Go to the **Users** page in Kinde to see your newly registered user. ## Audience An `audience` is the intended recipient of an access token - for example the API for your application. The audience argument can be passed to the Kinde client to request an audience be added to the provided token. ```typescript const clientOptions = { ..., audience: 'api.yourapp.com', }; const kindeClient = createKindeServerClient( GrantType.AUTHORIZATION_CODE, clientOptions ); ``` ## Overriding scope By default the Kinde SDK requests the following scopes: - `profile` - `email` - `offline` - `openid` You can override this by passing scopes into the Kinde SDK ```typescript const clientOptions = { ..., scope: 'openid profile email offline', }; const kindeClient = createKindeServerClient( GrantType.AUTHORIZATION_CODE, clientOptions ); ``` ## Organizations ### Create an organization To have a new organization created within your application during registration, you can create a route as follows: ```typescript app.get("/createOrg", async (req, res) => { const org_name = req.query.org_name?.toString(); const createUrl = await kindeClient.createOrg(sessionManager, {org_name}); return res.redirect(createUrl.toString()); }); ``` You can also pass `org_name` as part of the query string as per the following HTML: ```html <a href="/createOrg?org_name=<your_org_name>">Create Org</a> ``` ### Log in and register to organizations The Kinde client provides methods for you to easily log in and register users into existing organizations. Update the routes to accept an `org_code` parameter and pass it to the SDK: ```typescript const loginUrl = await kindeClient.login(sessionManager, {org_code: "org_1234"}); const registerUrl = await kindeClient.register(sessionManager, {org_code: "org_1234"}); ``` Following authentication, Kinde provides a JSON web token (JWT) to your application. Along with the standard information we also include the `org_code` and the permissions for that organization (this is important as a user can belong to multiple organizations and have different permissions for each). Example of a returned token: ```json { "aud": [], "exp": 1658475930, "iat": 1658472329, "iss": "https://your_subdomain.kinde.com", "jti": "123457890", "org_code": "org_1234", "permissions": ["read:todos", "create:todos"], "scp": ["openid", "profile", "email", "offline"], "sub": "kp:123457890" } ``` The `id_token` will also contain an array of organizations that a user belongs to - this is useful if you wanted to build out an organization switcher for example. ```json [ ... "org_codes": ["org_1234", "org_4567"] ... ]; ``` There are two helper functions you can use to extract information: ```typescript const org = await kindeClient.getOrganization(sessionManager); // { orgCode: 'org_1234' } const orgs = await kindeClient.getUserOrganizations(sessionManager); // { orgCodes: ['org_1234', 'org_abcd'] } ``` ## User permissions Once a user has been verified, your product/application will return the JWT token with an array of permissions for that user. You will need to configure your product/application to read permissions and unlock the respective functions. [Set permissions](/manage-users/roles-and-permissions/user-permissions/) in your Kinde account. Here’s an example set of permissions. ```typescript const permissions = [ "create:todos", "update:todos", "read:todos", "delete:todos", "create:tasks", "update:tasks", "read:tasks", "delete:tasks ]; ``` We provide helper functions to more easily access the permissions claim: ```typescript const permission = await kindeClient.getPermission(sessionManager, "create:todos"); // { orgCode: 'org_1234', isGranted: true } const permissions = await kindeClient.getPermissions(sessionManager); // { orgCode: 'org_1234', permissions: ['create:todos', 'update:todos', 'read:todos'] } ``` A practical example in code might look something like: ```typescript const permission = await kindeClient.getPermission(sessionManager, "create:todos"); if (permission.isGranted) { ... } ``` ## Getting claims We have provided a helper to grab any claim from your id or access tokens. The helper defaults to access tokens: ```typescript client.getClaim(sessionManager, "aud"); // { name: "aud", value: ["local-testing@kinde.com"] } client.getClaimValue(sessionManager, "aud"); // ["local-testing@kinde.com"] client.getClaim(sessionManager, "email", "id_token"); // { name: "email", value: "first.last@test.com" } client.getClaimValue(sessionManager, "email", "id_token"); // "first.last@test.com ``` ## Feature Flags We have provided a helper to return any features flag from the access token: ```typescript client.getFeatureFlag(sessionManager, 'theme') // returns { "is_default": false "value": "pink", "code": "theme", "type": "string", } client.getFeatureFlag(sessionManager, 'no-feature-flag') // returns // Error: "Flag no-feature-flag was not found, and no default value has been provided" client.getFeatureFlag(sessionManager, 'no-feature-flag', 'default-value') // returns { "is_default": true "code": "no-feature-flag", "value": "default-value", } client.getFeatureFlag(sessionManager, 'theme', 'default-theme', 'b') // returns // Error: "Flag theme is of type string, expected type is boolean" ``` We also require wrapper functions by type which should leverage `getFlag` above. ### **Get boolean flags** ```typescript /** * Get a boolean flag from the feature_flags claim of the access_token. * @param {Object} request - Request object * @param {String} code - The name of the flag. * @param {Boolean} [defaultValue] - A fallback value if the flag isn't found. * @return {Boolean} */ kindeClient.getBooleanFlag(sessionManager, code, defaultValue); kindeClient.getBooleanFlag(sessionManager, "is_dark_mode"); // true kindeClient.getBooleanFlag(sessionManager, "is_dark_mode", false); // true kindeClient.getBooleanFlag(sessionManager, "new_feature"); // Error - flag does not exist and no default provided kindeClient.getBooleanFlag(sessionManager, "new_feature", false); // false (flag does not exist so falls back to default) kindeClient.getBooleanFlag(sessionManager, "theme", "blue"); // Error - Flag "theme" is of type string not boolean ``` ### **Get string flags** ```typescript /** * Get a string flag from the feature_flags claim of the access_token. * @param {Object} request - Request object * @param {String} code - The name of the flag. * @param {String} [defaultValue] - A fallback value if the flag isn't found. * @return {String} */ kindeClient.getStringFlag(sessionManager, code, defaultValue); /* Example usage */ kindeClient.getStringFlag(sessionManager, "theme"); // pink kindeClient.getStringFlag(sessionManager, "theme", "black"); // true kindeClient.getStringFlag(sessionManager, "cta_color"); // Error - flag does not exist and no default provided kindeClient.getStringFlag(sessionManager, "cta_color", "blue"); // blue (flag does not exist so falls back to default) kindeClient.getStringFlag(sessionManager, "is_dark_mode", false); // Error - Flag "is_dark_mode" is of type boolean not string ``` ### **Get integer flags** ```typescript /** * Get an integer flag from the feature_flags claim of the access_token. * @param {Object} request - Request object * @param {String} code - The name of the flag. * @param {Integer} [defaultValue] - A fallback value if the flag isn't found. * @return {Integer} */ kindeClient.getIntegerFlag(sessionManager, code, defaultValue); kindeClient.getIntegerFlag(sessionManager, "competitions_limit"); // 5 kindeClient.getIntegerFlag(sessionManager, "competitions_limit", 3); // 5 kindeClient.getIntegerFlag(sessionManager, "team_count"); // Error - flag does not exist and no default provided kindeClient.getIntegerFlag(sessionManager, "team_count", 2); // false (flag does not exist so falls back to default) kindeClient.getIntegerFlag(sessionManager, "is_dark_mode", false); // Error - Flag "is_dark_mode" is of type boolean not integer ``` ## Token storage After the user has successfully logged in, you will have a JSON Web Token (JWT) and a refresh token securely stored. You can retrieve an access token by utilizing the `getToken` method. ```typescript const accessToken = await kindeClient.getToken(sessionManager); ``` ## Kinde Management API To use our management API please see [@kinde/management-api-js](https://github.com/kinde-oss/management-api-js) ## **SDK API reference** ### `authDomain` Either your Kinde instance url or your custom domain. e.g. `https://yourapp.kinde.com`. Type: `string` Required: Yes ### `redirectUri` The url that the user will be returned to after authentication. Type: `string` Required: Yes ### `LogoutRedirectUri` The url that the user will be returned to after they sign out. Type: `string` Required: Yes ### `clientId` The ID of your application in Kinde. Type: `string` Required: Yes ### `clientSecret` The unique client secret associated with your application in Kinde. Type: `string` Required: Yes ### `scope` The scopes to be requested from Kinde. Type: `string` Required: No Default: `openid profile email offline` ### `audience` The audience claim for the JWT. Type: `string` Required: No ## **Kinde SDK methods** ### `login` Constructs a redirect URL and sends the user to Kinde to sign in. Arguments: ```typescript sessionManager: SessionManager; ``` Usage: ```typescript kindeClient.login(sessionManager); ``` ### `register` Constructs a redirect URL and sends the user to Kinde to sign up. Arguments: ```typescript sessionManager: SessionManager; ``` Usage: ```typescript kindeClient.register(sessionManager); ``` ### `logout` Logs the user out of Kinde. Arguments: ```typescript sessionManager: SessionManager; ``` Usage: ```typescript kindeClient.logout(sessionManager); ``` ### `handleRedirectToApp` Callback middleware function for Kinde OAuth 2.0 flow. Arguments: ```typescript sessionManager: SessionManager; callbackURL: URL; ``` Usage: ```typescript kindeClient.handleRedirectToApp(sessionManager, callbackURL); ``` ### `isAuthenticated` Check if the user is authenticated. Arguments: ```typescript sessionManager: SessionManager; ``` Usage: ```typescript await kindeClient.isAuthenticated(sessionManager); ``` Output: `true` or `false` ### `createOrg` Constructs redirect url and sends user to Kinde to sign up and create a new org for your business. Arguments: ```typescript sessionManager : SessionManager options?: CreateOrgURLOptions { org_name?: string; org_code?: string; state?: string; } ``` Usage: ```typescript kindeClient.createOrg(sessionManager, { org_name: "org_1234" }); ``` ### `getClaim` Extract the provided claim from the provided token type in the current session, the returned object includes the provided claim. Arguments: ```typescript sessionManager : SessionManager tokenKey?: ClaimTokenType 'access_token' | 'id_token’ ``` Usage: ```typescript kindeClient.getClaim(sessionManager, "given_name", "id_token"); ``` ### `getClaimValue` Extract the provided claim from the provided token type in the current session. Arguments: ```typescript sessionManager : SessionManager claim: string, tokenKey?: ClaimTokenType 'access_token' | 'id_token’ ``` Usage: ```typescript client.getClaimValue(sessionManager, "given_name"); ``` Output: `'David'` ### `getPermission` Returns the state of a given permission. Arguments: ```typescript sessionManager: SessionManager; key: string; ``` Usage: ```typescript kindeClient.getPermission(sessionManager, "read:todos"); ``` Output sample: ```json { "orgCode": "org_1234", "isGranted": true } ``` ### `getPermissions` Returns all permissions for the current user for the organization they are logged into. Arguments: ```typescript sessionManager: SessionManager; ``` Usage: ```typescript kindeClient.getPermissions(sessionManager); ``` Sample output: ```json { "orgCode": "org_1234", "permissions": ["create:todos", "update:todos", "read:todos"] } ``` ### `getOrganization` Get details for the organization your user is logged into. Arguments: ```typescript sessionManager: SessionManager; key: string; ``` Usage: ```typescript kindeClient.getOrganization(sessionManager); ``` Sample output: ```json {"orgCode": "org_1234"} ``` ### `getUserOrganizations` Gets an array of all organizations the user has access to. Arguments: ```typescript sessionManager: SessionManager; ``` Usage: ```typescript kindeClient.getUserOrganizations(sessionManager); ``` Sample output: ```json {"orgCodes": ["org_7052552de", "org_5a5c293813"]} ``` ### `getUser` Extracts the user details from the ID token obtained post authentication. Arguments: ```typescript sessionManager: SessionManager; ``` Usage: ```typescript kindeClient.getUser(sessionManager); ``` ### `getToken` Returns a valid access token if available. Arguments: ```typescript sessionManager: SessionManager; ``` Usage: ```typescript kindeClient.getToken(sessionManager); ``` ### `refreshTokens` Uses the refresh token to update and return new tokens. Arguments: ```typescript sessionManager: SessionManager; ``` Usage: ```typescript kindeClient.refreshTokens(sessionManager); ``` ### `getUserProfile` Extracts makes use of the `getToken` method above to fetch user details. Arguments: ```typescript sessionManager: SessionManager; ``` Usage: ```typescript kindeClient.getUserProfile(sessionManager); ``` Sample output: ```json {"given_name": "Dave", "id": "abcdef", "family_name": "Smith", "email": "mailto:dave@smith.com"} ``` ### `getFlag` Get a flag from the feature_flags claim of the `access_token`. Arguments: ```typescript sessionManager : SessionManager code : string defaultValue? : FlagType[keyof FlagType flagType? : keyof FlagType interface FlagType { s: string; b: boolean; i: number; } interface GetFlagType { type?: 'string' | 'boolean' | 'number'; value: FlagType[keyof FlagType]; is_default: boolean; code: string; } ``` Usage: ```typescript kindeClient.getFlag(sessionManager, "theme"); ``` Sample output: ```json { "code": "theme", "type": "string", "value": "pink", "is_default": false } ``` ### `getBooleanFlag` Get a boolean flag from the `feature_flags` claim of the access token. Arguments: ```typescript sessionManager : SessionManager code : string defaultValue? : boolean ``` Usage: ```typescript kindeClient.getBooleanFlag(sessionManager, "is_dark_mode"); ``` Sample output: `true` ### `getStringFlag` Get a string flag from the `feature_flags` claim of the access token. Arguments: ```typescript sessionManager : SessionManager code : string defaultValue? : string ``` Usage: ```typescript kindeClient.getStringFlag(sessionManager, "theme"); ``` Sample output: `pink` ### `getIntegerFlag` Get an integer flag from the `feature_flags` claim of the access token. Arguments: ```typescript sessionManager : SessionManager code : string defaultValue? : number ``` Usage: ```typescript kindeClient.getIntegerFlag(sessionManager, "team_count"); ``` Sample output: `2` If you need help connecting to Kinde, please contact us at [support@kinde.com](mailto:support@kinde.com).

# Developer tools - Sdks - JavaScript SDK

> Complete guide for JavaScript SDK including PKCE authentication, login/register flows, organization management, and API integration for single-page applications.

JavaScript SDK, PKCE, authentication, login, register, logout, organizations, access tokens, JWT
developer-tools, sdks, javascript, frontend

If you haven’t already got a Kinde account, [register for free here](https://app.kinde.com/register) (no credit card required). This will give you a Kinde domain, which you need to get started, e.g. `yourapp.kinde.com` You can also view the [JavaScript starter kit](https://github.com/kinde-starter-kits/javascript-starter-kit) in GitHub. ## **Set up Kinde** ### **Set your callback and logout URLs** Kinde will redirect your user to authenticate. They’ll be redirected back to your JavaScript app after signing in or signing up. To authenticate your app, you need to specify which URL Kinde should redirect your user. These need to match the ones listed in your application details in Kinde. The `http://localhost:3000` is an example of a commonly used local development URL. It should be replaced with the URL where your app is running. 1. In Kinde, go to **Settings > Applications > [your app] > View details**. 2. Set the **Allowed callback URLs** (also known as redirect URIs) to the URL of your app. This is where the Kinde client app is served. For local development this could be `http://localhost:3000`. This is required for your users to sign in to your app successfully. 3. Set the URLs they’ll be redirected to after signing out, by adding **Allowed logout redirect URLs** to your JavaScript applications logout page. For local development this could be `http://localhost:3000`. 4. Select **Save**. ### **Environments** As part of your development process, we highly recommend you create a development environment within your Kinde account. In this case, you’d use the Environment subdomain in the code block above. ## **Set up your app** ### Installation <PackageManagers pkg="@kinde-oss/kinde-auth-pkce-js" /> ### **Integrate with your app** You’ll need to create a new instance of the Kinde Auth client object. We recommend using the async/await method. It must be the first thing that happens before you initialize your app. ```jsx import createKindeClient from "@kinde-oss/kinde-auth-pkce-js"; (async () => { const kinde = await createKindeClient({ client_id: <your_kinde_client_id>, domain: "https://<your_kinde_subdomain>.kinde.com", redirect_uri: window.location.origin }); } ``` 1. In Kinde, go to **Settings > Applications > [your app] > View details**. 2. Replace the **client_id** and **domain** placeholders in the code block above with the the values from the **App keys** section. Note: The `redirect_uri` value you enter here needs to be the same as the redirect URI you entered in the Kinde application (see above). ## Log in / register Kinde provides login / register methods that are easy to implement. Here’s an example of adding buttons to your HTML: ```html <div id="logged_out_view"> <button id="login" type="button">Sign in</button> <button id="register" type="button">Register</button> </div> ``` You can bind events to buttons. ```jsx document.getElementById("login").addEventListener("click", async () => { await kinde.login(); }); document.getElementById("register").addEventListener("click", async () => { await kinde.register(); }); ``` Clicking either of these buttons redirects your user to Kinde, where they authenticate before being redirected back to your site. ### **Test sign up** Register your first user by signing up yourself. You’ll see your newly registered user on the **Users** page of the relevant organization in Kinde. ## **Handle redirect** Once your user is redirected back to your site from Kinde, you can set a callback to take place. The callback automatically passes in the user object and any application state you set prior to the redirect. ```jsx on_redirect_callback: (user, appState) => { console.log({user, appState}); if (user) { // render logged in view } else { // render logged out view } }; ``` ## Log out This is implemented in much the same way as signing in or registering. The Kinde single page application client already comes with a sign out method. ```jsx document.getElementById("logout").addEventListener("click", async () => { await kinde.logout(); }); ``` ## **Call your API** The `getToken` method lets you to securely call your API and pass the bearer token to validate that your user is authenticated. ```jsx (async () => { try { const token = await kinde.getToken(); const response = await fetch(YOUR_API, { headers: new Headers({ Authorization: "Bearer " + token }) }); const data = await response.json(); console.log({data}); } catch (err) { console.log(err); } })(); ``` We recommend using our middleware on your back end to verify users and protect endpoints. Our current implementation is Node/Express, but we’re working on more. ## **Organizations** For general information about using organizations, see [Kinde organizations for developers](/build/organizations/orgs-for-developers/). **Create an organization** To create a new organization within your application, you will need to run a similar function below. ```jsx document.getElementById("createOrganization").addEventListener("click", async () => await kinde.createOrg();}); ``` **Sign up / sign in users to organizations** Kinde has a unique code for every organization. You’ll have to pass this code through when you register a new user. Example function below: ```jsx kinde.register({org_code: ‘org_1234’}); ``` If you want a user to sign in to a particular organization, pass this code along with the sign in method. ```jsx kinde.login({org_code: ‘org_1234’}); ``` Following authentication, Kinde provides a json web token (jwt) to your application. Along with the standard information we also include the `org_code` and the `permissions` for that organization (this is important as a user can belong to multiple organizations and have different permissions for each). Example of a returned token: ```json { "aud": [], "exp": 1658475930, "iat": 1658472329, "iss": "https://your_subdomain.kinde.com", "jti": "123457890", "org_code": "org_1234", "permissions": [“read:todos”, “create:todos”], "scp": [ "openid", "profile", "email", "offline ], "sub": "kp:123457890" } ``` The `id_token` will also contain an array of Organizations that a user belongs to - this is useful if you wanted to build out an organization switcher for example. ```json { ... "org_codes": ["org_1234", "org_4567"] ... } ``` There are two helper functions you can use to extract information: ```jsx kinde.getOrganization(); // {orgCode: "org_1234"} kinde.getUserOrganizations(); // {orgCodes: ["org_1234", "org_abcd"]} ``` ## **Get user information** Use the `getUser()` helper function to request the user information from Kinde. Use the `getUserProfile()` function to request the latest user information from the server. ```jsx const user = kinde.getUser(); const user = await kinde.getUserProfile(); // user will be populated with a user object { id: "kp_0123456789abcdef0123456789abcdef", given_name: "Billy", family_name: "Hoyle", email: "billy@example.com", picture: "https://link_to_avatar_url.kinde.com" } ``` ## **User permissions** When a user signs in to an organization the Access token your product/application receives contains a custom claim with an array of permissions for that user. You can set permissions in your Kinde account. Here’s an example. ```json "permissions":[ "create:todos", "update:todos", "read:todos", "delete:todos", "create:tasks", "update:tasks", "read:tasks", "delete:tasks", ] ``` We provide helper functions to more easily access permissions: ```jsx kinde.getPermission("create:todos"); // {orgCode: "org_1234", isGranted: true} kinde.getPermissions(); // {orgCode: "org_1234", permissions: ["create:todos", "update:todos", "read:todos"]} ``` A practical example in code might look something like: ```jsx if (kinde.getPermission("create:todos").isGranted) { // show Create Todo button in UI } ``` ## **Feature flags** When a user signs in the Access token your product/application receives contains a custom claim called `feature_flags` which is an object detailing the feature flags for that user. You can set feature flags in your Kinde account. Here’s an example. ```jsx feature_flags: { theme: { "t": "s", "v": "pink" }, is_dark_mode: { "t": "b", "v": true }, competitions_limit: { "t": "i", "v": 5 } } ``` In order to minimize the payload in the token we have used single letter keys / values where possible. The single letters represent the following: `t` = `type` `v` = `value` `s` = `string` `b` = `boolean` `i` = `integer` We provide helper functions to more easily access feature flags: ```jsx /** * Get a flag from the feature_flags claim of the access_token. * @param {string} code - The name of the flag. * @param {obj} [defaultValue] - A fallback value if the flag isn't found. * @param {'s'|'b'|'i'|undefined} [flagType] - The data type of the flag (integer / boolean / string). * @return {object} Flag details. */ kinde.getFlag(code, defaultValue, flagType); /* Example usage */ kinde.getFlag('theme'); /*{ // "code": "theme", // "type": "string", // "value": "pink", // "is_default": false // whether the fallback value had to be used */} kinde.getFlag('create_competition', {defaultValue: false}); /*{ "code": "create_competition", "value": false, "is_default": true // because fallback value had to be used }*/ ``` We also require wrapper functions by type which should leverage `getFlag` above. Booleans: ```jsx /** * Get a boolean flag from the feature_flags claim of the access_token. * @param {string} code - The name of the flag. * @param {bool} [defaultValue] - A fallback value if the flag isn't found. * @return {bool} */ kinde.getBooleanFlag(code, defaultValue); /* Example usage */ kinde.getBooleanFlag("is_dark_mode"); // true kinde.getBooleanFlag("is_dark_mode", false); // true kinde.getBooleanFlag("new_feature", false); // false (flag does not exist so falls back to default) ``` Strings and integers work in the same way as booleans above: ```jsx /** * Get a string flag from the feature_flags claim of the access_token. * @param {string} code - The name of the flag. * @param {string} [defaultValue] - A fallback value if the flag isn't found. * @return {string} */ getStringFlag(code, defaultValue); /** * Get an integer flag from the feature_flags claim of the access_token. * @param {string} code - The name of the flag. * @param {int} [defaultValue] - A fallback value if the flag isn't found. * @return {int} */ getIntegerFlag(code, defaultValue); ``` ## **Audience** An `audience` is the intended recipient of an access token - for example the API for your application. The audience argument can be passed to the Kinde client to request an audience be added to the provided token. The audience of a token is the intended recipient of the token. ```jsx const kinde = await createKindeClient({ audience: "<your_api>" ... }); ``` To request multiple audiences, pass them separated by white space. See example. ```jsx const kinde = await createKindeClient({ audience: "<your_api1> <your_api2" ... }); ``` For details on how to connect, see [Register an API](/developer-tools/your-apis/register-manage-apis/). ## **Overriding scope** By default the JavaScript SDK requests the following scopes: - `profile` - `email` - `offline` - `openid` You can override this by passing `scope` into the `createKindeClient` ```jsx const kinde = await createKindeClient({ client_id: "<your_kinde_client_id>", domain: "https://<your_kinde_subdomain>.kinde.com", redirect_uri: "http://localhost:3000", scope: "openid" }); ``` ## **Getting claims** We have provided a helper to grab any claim from your id or access tokens. The helper defaults to access tokens: ```jsx kinde.getClaim("aud"); // {name: "aud", "value": ["api.yourapp.com"]} kinde.getClaim("given_name", "id_token"); // {name: "given_name", "value": "David"} ``` ## **Persisting authentication state on page refresh or new tab** You will find that when you refresh the browser using a front-end based SDK that the authentication state is lost. This is because there is no secure way to persist this in the front-end. There are two ways to work around this. - (Recommended) use our [Custom Domains](/build/domains/pointing-your-domain/) feature which then allows us to set a secure, httpOnly first party cookie on your domain. - (Non-production solution only) If you’re not yet ready to add your custom domain, or for local development, we offer an escape hatch you can provide to the Kinde Client `is_dangerously_use_local_storage`. This will use local storage to store the refresh token. DO NOT use this in production. Once you implement one of the above, you don’t need to do anything else. ## **Persisting application state** The options argument passed into the `login` and `register` methods accepts an `app_state` key where you can pass in the current application state prior to redirecting to Kinde. This is then returned to you in the second argument of the `on_redirect_callback` as seen above. A common use case is to allow redirects to the page the user was trying to access prior to authentication. This could be achieved as follows: Login handler: ```jsx login({ app_state: { redirectTo: window.location } }); ``` Redirect handler: ```jsx const kinde = await createKindeClient({ client_id: "<your_kinde_client_id>", domain: "https://<your_kinde_subdomain>.kinde.com", redirect_uri: "http://localhost:3000", on_redirect_callback: (user, appState) => { if (appState?.redirectTo) { window.location = appState?.redirectTo; } } }); ``` ## **Token storage in the authentication state** By default the JWTs provided by Kinde are stored in memory. This protects you from both [CSRF](https://owasp.org/www-community/attacks/csrf) attacks (possible if stored as a client side cookie) and [XSS](https://owasp.org/www-community/attacks/xss/) attacks (possible if persisted in local storage). The trade off with this approach however is that if a page is refreshed or a new tab is opened then the token is wiped from memory, and the sign in button would need to be clicked to re-authenticate. There are two ways to prevent this behaviour: 1. Use the Kinde custom domain feature. We can then set a secure, httpOnly cookie against your domain containing only the refresh token which is not vulnerable to CSRF attacks. 2. There is an escape hatch which can be used for local development: `is_dangerously_use_local_storage`. This absolutely should not be used in production and we highly recommend you use a custom domain. This will store only the refresh token in local storage and is used to silently re-authenticate. ```jsx const kinde = await createKindeClient({ client_id: "[YOUR_KINDE_CLIENT_ID]", domain: "[YOUR_KINDE_DOMAIN]", redirect_uri: window.location.origin, is_dangerously_use_local_storage: true }); ``` ## **SDK API Reference - createKindeClient** ### `audience` The audience claim for the JWT. Type: `string` Required: No ### `client_id` The unique ID of your application in Kinde. Type: `string` Required: Yes ### `domain` Either your Kinde instance URL, e.g `https://yourapp.kinde.com` or your custom domain. Type: `string` Required: Yes ### `logout_uri` Where your user will be redirected when they sign out. Type: `string` Required: No ### `is_dangerously_use_local_storage` An escape hatch for storing the refresh token in local storage. Recommended for local development only, and not production. Type: `boolean` Required: No Default: `false` ### `redirect_uri` The URL that the user will be returned to after authentication. Type: `string` Required: Yes ### `scope` The scopes to be requested from Kinde. Type: `string` Required: No ```jsx openid profile email offline ``` ## **SDK API Reference - kindeClient methods** ### `createOrg` Constructs redirect url and sends user to Kinde to sign up and create a new org for your business. usage: ```jsx kinde.createOrg(); ``` Sample output: ```jsx redirect; ``` ### `getClaim` Gets a claim from an access or ID token. Arguments: ```jsx claim: string, tokenKey?: string ``` Usage: ```jsx kinde.getClaim("given_name", "id_token"); ``` Sample output: ```jsx "David"; ``` ### `getPermission` Returns the state of a given permission. Arguments: ```jsx key: string; ``` Usage: ```jsx kinde.getPermission("read:todos"); ``` Sample output: ```jsx { orgCode: "org_1234", isGranted: true } ``` ### `getPermissions` Returns all permissions for the current user for the organization they are signed in to. Usage: ```jsx kinde.getPermissions(); ``` Sample output: ```jsx { orgCode:"org_1234", permissions:["create:todos", "update:todos", "read:todos"] } ``` ### `getOrganization` Get details for the organization your user is signed in to. Usage: ```jsx kinde.getOrganization(); ``` Sample output: ```jsx { orgCode: "org_1234"; } ``` ### `getToken` Returns the raw Access token from memory. Usage: ```jsx kinde.getToken(); ``` Sample output: ```jsx eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9 .eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ .SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c; ``` ### `getUser` Returns the profile for the current user. Usage: ```jsx kinde.getUser(); ``` Sample output: ```jsx { given_name: "Dave"; id: "abcdef"; family_name: "Smith"; email: "dave@smith.com"; } ``` ### `getUserOrganizations` Gets an array of all organizations the user has access to. Usage: ```jsx kinde.getUserOrganizations(); ``` Sample output: ```jsx { orgCodes: ["org_1234", "org_5678"]; } ``` ### `login` Constructs redirect URL and sends user to Kinde sign in. Arguments ```jsx org_code?: string ``` Usage: ```jsx kinde.login(); ``` Example output: ```jsx redirect; ``` ### `logout` Logs the user out of Kinde. Argument: ```jsx org_code?: string ``` Usage: ```jsx kinde.logout(); ``` Example output: ```jsx redirect; ``` ### `register` Constructs redirect url and sends user to Kinde to sign up. Usage: ```jsx kinde. ``` Sample output: ```jsx redirect; ``` Reach out to [support@kinde.com](mailto:support@kinde.com) if you need help getting Kinde connected.

# Developer tools - Sdks - React SDK

> Complete guide for React SDK including installation, provider setup, authentication hooks, callback handling, and API integration for React 18+ applications.

React SDK, React Context Provider, useKindeAuth hook, authentication, login, register, logout, access tokens
developer-tools, sdks, react, frontend

The Kinde React SDK allows developers to quickly and securely integrate a new or an existing React application to the Kinde platform. You can also view the [React package](https://github.com/kinde-oss/kinde-auth-react) and [React starter kit](https://github.com/kinde-starter-kits/react-starter-kit) in GitHub. This new SDK (v5) is optimized to work with React version 18+. If you are currently using v4, refer to this [migration information](/developer-tools/sdks/frontend/react-sdk/#migration-from-v4-to-v5) to update to v5. ## **Register for Kinde** If you haven’t already got a Kinde account, [register for free here](https://app.kinde.com/register) (no credit card required). Registering gives you a Kinde domain, which you need to get started, e.g. `yourapp.kinde.com`. ## **Configure React** ### Installation <PackageManagers pkg=" @kinde-oss/kinde-auth-react" /> ## **Integrate with your app** Kinde uses a React Context Provider to maintain its internal state in your application. Import the Kinde Provider component and wrap your application in it. ```jsx import { KindeProvider } from '@kinde-oss/kinde-auth-react'; const App = () => ( <KindeProvider clientId="<your_kinde_client_id>" domain="<your_kinde_domain>" logoutUri={window.location.origin} redirectUri={window.location.origin} > <Routes /> </KindeProvider> ); ``` ## **Set callback and logout URLs** Set the URLs in Kinde so that after your user signs up, signs in, or signs out, they will be redirected back to your application. 1. In Kinde, go to **Settings > Applications > [your app] > View details**. 2. Replace the `your_kinde_client_id` and `your_kinde_domain` placeholders in the code block above with the the values from the **App keys** section. 3. Add your callback URLs in the relevant fields. For example: - Allowed callback URLs (also known as redirect URIs) - for example `https://localhost:3000/home/callback` - Allowed logout redirect URLs - for example `https://localhost:3000` 4. Select **Save**. Tip: Make sure there are no hidden spaces and remove any ‘/’ forward slashes from the end of URLs. ## Environments If you would like to use different Environments as part of your development process, you will need to [add them within your Kinde business](/build/environments/environments/) first. You will also need to add the Environment subdomain to the code block above. ## Sign in and sign up Kinde provides a `useKindeAuth` hook with the methods `login` and `register` method to start the flow and also `LoginLink` and `RegisterLink` components Use the button examples below to redirect your users to Kinde, where they authenticate before being redirected back to your site. ```jsx import { LoginLink, RegisterLink } from '@kinde-oss/kinde-auth-react/components'; <LoginLink>Sign in</LoginLink> <RegisterLink>Sign up</RegisterLink> ``` ```jsx import { useKindeAuth } from '@kinde-oss/kinde-auth-react'; const { login, register } = useKindeAuth(); <button onClick={() => register(/* params here */)} type="button">Sign up</button> <button onClick={() => login(/* params here */)} type="button">Sign In</button> ``` ### Callback Events To handle the result of auth there are three callback events. - `onSuccess` - On Successful authentication, this includes the user authenticated along with the passed state and context to the Kinde hook - `onError` - When an error occurs during authentication, this includes the error along with the passed state and context to the Kinde hook ```jsx <KindeProvider callbacks={ { onSuccess: (user, state, context) => console.log("onSuccess", user, state, context), onError: (error, state, context) => console.log("onError", error, state, context), } } > <Routes /> </KindeProvider> ``` ### Passing additional params to the auth url Both the `login` and `register` methods accept all the extra authentication params that can be passed to Kinde as part of the auth flow. All the params are also accepted as attributes to the `LoginLink` and `RegisterLink` components. Some things you may wish to pass are: - `loginHint` this allows you to ask Kinde to prepopulate a users email address on the sign-up and sign-in screens. - `lang` if you offer multi-language support Kinde will automatically figure out the best language for your user based on their browser. However, if you want to force a language and override the users preference, you can do so by passing this attribute. ```javascript login({ loginHint: "jenny@example.com", lang: "ru" }) ``` ### Signing out Kinde provides a `useKindeAuth` hook with the method `logout` and component `LogoutLink` which can be used to end the current session. ```jsx const { logout } = useKindeAuth(); <button onClick={() => logout(/* params here */)} type="button">Sign out</button> ``` ```jsx import { LogoutLink } from '@kinde-oss/kinde-auth-react/components'; <LogoutLink>Sign out</LogoutLink> ``` ## Test sign up Register your first user by signing up yourself. You’ll see your newly registered user on the **Users** page in Kinde. ### **View user profile** You can get an authorized user’s profile from any component using the Kinde React hook. ```jsx import { useKindeAuth } from '@kinde-oss/kinde-auth-react'; const SayHello = () => { const { user } = useKindeAuth(); return <p>Hi {user.firstName}!</p>; }; ``` To be on the safe side we have also provided `isAuthenticated` and `isLoading` state to prevent rendering errors. ```jsx import { useKindeAuth } from '@kinde-oss/kinde-auth-react'; const UserProfile = () => { const { user, isAuthenticated, isLoading } = useKindeAuth(); if (isLoading) { return <p>Loading</p>; } return ({ isAuthenticated ? <div> <h2>{user.firstName}</h2> <p>{user.preferredEmail}</p> </div> : <p>Please sign in or register!</p> }); }; ``` ## Access control ### Check if user is authenticated ```jsx const { isAuthenticated } = useKindeAuth(); ``` ### Check user rights There are two ways to check if a user has a specific permission: - Using the `has` function from the `@kinde-oss/kinde-auth-react/utils` package - Using the `<ProtectedRoute>` component #### Using the `has` function The `has` function is a helper function that checks if a user has specific roles, permissions, feature flags, or billing entitlements. It returns a boolean value indicating whether the user meets all the specified criteria. ```typescript import { has } from '@kinde-oss/kinde-auth-react/utils'; // Basic usage - check multiple criteria at once const userHasAccess = has({ roles: ['admin'], permissions: ['create:todos'], featureFlags: ['theme'], billingEntitlements: ['premium'] }); ``` **Parameters:** - `roles` (optional): Array of role names the user must have - `permissions` (optional): Array of permission names the user must have - `featureFlags` (optional): Array of feature flag names the user must have - `billingEntitlements` (optional): Array of billing entitlement names the user must have **Return value:** `boolean` - `true` if user meets all criteria, `false` otherwise ### API vs Token-based checks By default, the `has` function performs checks using the user's tokens. You can override this behavior by passing the `forceApi` option to perform server-side validation: ```typescript // Force all checks to use API calls instead of tokens has({ roles: ['admin'], permissions: ['create:todos'], forceApi: true }) // Force only specific checks to use API calls has({ roles: ['admin'], permissions: ['create:todos'], forceApi: { permissions: true } // Only permissions use API, roles use tokens }) ``` ### Advanced usage with conditions You can add custom conditions to any check by expanding the object structure: ```typescript // Add custom conditions to role checks has({ roles: [{ role: 'admin', condition: (user) => user.isAdmin && user.isActive }], }) // Add custom conditions to permission checks has({ permissions: [{ permission: 'create:todos', condition: (user) => user.organizationId === 'org123' }], }) ``` ### Feature flag value checking For feature flags, you can check both the flag's existence and its specific value: ```typescript // Check if feature flag exists has({ featureFlags: ['theme'] }) // Check if feature flag has a specific value has({ featureFlags: [{ flag: 'theme', value: 'dark' }] }) // Check multiple feature flags with values has({ featureFlags: [ { flag: 'theme', value: 'dark' }, { flag: 'beta_features', value: true } ] }) ``` ### Complete example ```typescript import { has } from '@kinde-oss/kinde-auth-react/utils'; const checkUserAccess = () => { const canAccessAdminPanel = has({ roles: ['admin', 'super_admin'], permissions: ['read:users', 'write:users'], featureFlags: ['admin_panel'], billingEntitlements: ['enterprise_plan'] }); const canUseDarkTheme = has({ featureFlags: [{ flag: 'theme', value: 'dark' }], permissions: ['customize:theme'] }); return { canAccessAdminPanel, canUseDarkTheme }; }; ``` ### TypeScript type safety You can enhance type safety by declaring your specific roles, permissions, feature flags and billing entitlements. This provides autocomplete and compile-time checking for your access control. Create a type declaration file (e.g., `kinde-types.d.ts`) in your project: ```typescript declare module "@kinde-oss/kinde-auth-react/utils" { interface KindeConfig { roles: ['admin', 'user', 'moderator', 'super_admin']; permissions: ['read:users', 'write:users', 'delete:users', 'manage:settings']; featureFlags: ['dark_mode', 'beta_features', 'admin_panel']; billingEntitlements: ['basic', 'premium', 'enterprise']; } } ``` **Note:** Make sure your `tsconfig.json` includes the type declaration file, or place it in a directory that TypeScript automatically includes (like `src/types/` or the root of your project). ### Using the `<ProtectedRoute>` component **Note:** The `<ProtectedRoute>` component requires the `react-router-dom` package to be installed. The `<ProtectedRoute>` component is a wrapper component that checks if a user has specific permissions and renders the child component if they do. If the user doesn't have the required permissions, they are redirected to a fallback path. ```jsx import { ProtectedRoute } from '@kinde-oss/kinde-auth-react/react-router'; // Basic usage - protect a route with role-based access <ProtectedRoute has={{ roles: ['admin'] }} fallbackPath="/"> <div>You have access to this admin page</div> </ProtectedRoute> ``` **Props:** - `has` (required): Object containing the access requirements (same format as the `has` function) - `fallbackPath` (required): Path to redirect to if user doesn't have access - `children` (required): React components to render if user has access #### Basic examples ```jsx // Protect with single role <ProtectedRoute has={{ roles: ['admin'] }} fallbackPath="/unauthorized"> <AdminDashboard /> </ProtectedRoute> // Protect with multiple roles (user must have at least one) <ProtectedRoute has={{ roles: ['admin', 'moderator'] }} fallbackPath="/"> <ModeratorPanel /> </ProtectedRoute> // Protect with permissions <ProtectedRoute has={{ permissions: ['read:users', 'write:users'] }} fallbackPath="/dashboard"> <UserManagement /> </ProtectedRoute> // Protect with feature flags <ProtectedRoute has={{ featureFlags: ['beta_features'] }} fallbackPath="/"> <BetaFeatures /> </ProtectedRoute> ``` #### Complex access control ```jsx // Multiple criteria - user must have ALL specified requirements <ProtectedRoute has={{ roles: ['admin'], permissions: ['manage:users'], featureFlags: ['admin_panel'], billingEntitlements: ['premium'] }} fallbackPath="/upgrade" > <PremiumAdminPanel /> </ProtectedRoute> // Using API-based checks for real-time validation <ProtectedRoute has={{ roles: ['admin'], permissions: ['manage:users'], forceApi: true }} fallbackPath="/" > <RealTimeAdminPanel /> </ProtectedRoute> ``` #### Integration with React Router ```jsx import { Routes, Route } from 'react-router-dom'; import { ProtectedRoute } from '@kinde-oss/kinde-auth-react/react-router'; function App() { return ( <Routes> <Route path="/" element={<HomePage />} /> <Route path="/admin" element={ <ProtectedRoute has={{ roles: ['admin'] }} fallbackPath="/"> <AdminPage /> </ProtectedRoute> } /> <Route path="/premium" element={ <ProtectedRoute has={{ billingEntitlements: ['premium'] }} fallbackPath="/upgrade" > <PremiumPage /> </ProtectedRoute> } /> </Routes> ); } ``` #### Complete example with multiple protected routes ```jsx import { Routes, Route } from 'react-router-dom'; import { ProtectedRoute } from '@kinde-oss/kinde-auth-react/react-router'; function App() { return ( <Routes> <Route path="/" element={<HomePage />} /> {/* Basic admin access */} <Route path="/admin" element={ <ProtectedRoute has={{ roles: ['admin'] }} fallbackPath="/"> <AdminDashboard /> </ProtectedRoute> } /> {/* Premium features */} <Route path="/premium" element={ <ProtectedRoute has={{ billingEntitlements: ['premium'] }} fallbackPath="/upgrade" > <PremiumFeatures /> </ProtectedRoute> } /> {/* Beta features with specific permissions */} <Route path="/beta" element={ <ProtectedRoute has={{ featureFlags: ['beta_access'], permissions: ['beta:test'] }} fallbackPath="/" > <BetaFeatures /> </ProtectedRoute> } /> </Routes> ); } ``` ## Call your API The `getAccessToken` method lets you to securely call your API and pass the bearer token to validate that your user is authenticated. ```jsx const { getAccessToken } = useKindeAuth(); const fetchData = async () => { try { const accessToken = await getAccessToken(); const res = await fetch(`<your-api>`, { headers: { Authorization: `Bearer ${accessToken}` } }); const {data} = await res.json(); console.log({data}); } catch (err) { console.log(err); } }; ``` We have a range of backend SDKs available to assist you in securing your back end application using this token, alternatively you can use any JWT validator and decoder to assit you here. ## Audience An `audience` is the intended recipient of an access token - for example the API for your application. The `audience` argument can be passed to the Kinde client to request an audience be added to the provided token. The audience of a token is the intended recipient of the token. ```jsx <KindeProvider audience="<your_api> > ``` To request multiple audiences, pass them separated by white space. ```jsx <KindeProvider audience="<your_api1> <your_api2> > ``` For details on how to connect, see [Register an API](/developer-tools/your-apis/register-manage-apis/). ## Organizations ### Create an organization To create a new organization with the user registration, you can use the `createOrg` function to start the registration process: ```jsx <LoginLink isCreateOrg={true}>Sign in</LoginLink> <button onClick={() => login({isCreateOrg: true})} type="button">Sign in</button> ``` ### Sign up/sign in users to organizations To sign up a user to a particular organization, you must pass the `orgCode` from your Kinde account as the user is created. You can find the `orgCode` on the **Details** page of each organization in Kinde. ```jsx <LoginLink orgCode="org_1234">Sign in</LoginLink> <button onClick={() => login({orgCode: "org_1234"})} type="button">Sign in</button> ``` Following authentication Kinde provides a json web token (jwt) to your application. Along with the standard information we also include the `org_code` and the `permissions` for that organization (this is important as a user can belong to multiple organizations and have different permissions for each). Example of a returned token: ```json { "aud": ["https://your_subdomain.kinde.com"], "exp": 1658475930, "iat": 1658472329, "iss": "https://your_subdomain.kinde.com", "jti": "123457890", "org_code": "org_1234", "permissions": ["read:todos", "create:todos"], "scp": ["openid", "offline"], "sub": "kp:123457890" } ``` For more information about how organizations work in Kinde, see [Kinde organizations for developers](/build/organizations/orgs-for-developers/). ## User Permissions Once a user has been verified as signed in, your project/application will be returned in the JWT token with an array of permissions for that user. You need to configure your project to read permissions and unlock the respective functions. [Configure permissions](/manage-users/roles-and-permissions/user-permissions/) in Kinde first. Here is an example set of permissions. ```json "permissions":[ "create:todos", "update:todos", "read:todos", "delete:todos", "create:tasks", "update:tasks", "read:tasks", "delete:tasks", ] ``` We provide helper functions to more easily access permissions: ```jsx const {getPermission, getPermissions} = useKindeAuth(); await getPermission("create:todos"); // {permissionKey: "create:todos", orgCode: "org_1234", isGranted: true} await getPermissions(); // {orgCode: "org_1234", permissions: ["create:todos", "update:todos", "read:todos"]} ``` A practical example in code might look something like: ```jsx { (await getPermission("create:todos")).isGranted ? <button>Create todo</button> : null; } ``` ## **Feature flags** When a user signs in, the access token your project/application receives contains a custom claim called `feature_flags` which is an object detailing the feature flags for that user. You can [set feature flags](/releases/feature-flags/add-feature-flag/) in your Kinde account. Here’s an example. ```jsx feature_flags: { theme: { "t": "s", "v": "pink" }, is_dark_mode: { "t": "b", "v": true }, competitions_limit: { "t": "i", "v": 5 } } ``` In order to minimize the payload in the token we have used single letter keys / values where possible. The single letters represent the following: `t` = `type` `v` = `value` `s` = `string` `b` = `boolean` `i` = `integer` We provide helper functions to more easily access feature flags: ```jsx const { getFlag } = useKindeAuth(); /* Example usage */ await getFlag('theme'); // string value await getFlag<boolean>('theme'); // boolean value await getFlag<number>('theme'); // numeric value /*{ // "code": "theme", // "type": "string", // "value": "pink", // "is_default": false // whether the fallback value had to be used */} getFlag('create_competition', {defaultValue: false}); /*{ "code": "create_competition", "value": false, "is_default": true // because fallback value had to be used }*/ ``` A practical example in code might look something like: ```jsx const { getFlag } = useKindeAuth(); { (await getFlag<boolean>('create_competition')) ? <button>Create competition</button> : null; } ``` A practical example in code might look something like: ```jsx const {getFlag} = useKindeAuth(); { getFlag<boolean>("create_competition") ? ( <button className={`theme-${getFlag("theme")}`}>Create competition</button> ) : null; } ``` ## **Overriding scope** By default the JavaScript SDK requests the following scopes: - `profile` - `email` - `offline` - `openid` You can override this by passing `scope` into the `<KindeProvider>`. ```jsx <KindeProvider scope="openid > ``` ## **Getting claims** We have provided a helper to grab any claim from your ID or access tokens. The helper defaults to access tokens: ```jsx const { getClaim } = useKindeAuth(); getClaim("aud"); // {name: "aud", "value": ["api.yourapp.com"]} getClaim("given_name", "idToken"); // {name: "given_name", "value": "David"} ``` ## **Persisting authentication state on page refresh or new tab** You will find that when you refresh the browser using a front-end based SDK that the authentication state is lost. This is because there is no secure way to persist this in the front-end. There are two ways to work around this. - (Recommended) use our [Custom Domains](/build/domains/pointing-your-domain/) feature which then allows us to set a secure, httpOnly first party cookie on your domain. - (Non-production solution only) If you’re not yet ready to add your custom domain, or for local development, we offer an escape hatch `<KindeProvider>` `useInsecureForRefreshToken`. This will use local storage to store the refresh token. DO NOT use this in production. Once you implement one of the above, you don’t need to do anything else. ## **Persisting application state** The options argument passed into the `login` and `register` methods accepts an `state` key where you can pass in the current application state prior to redirecting to Kinde. This is then returned to you in the second argument of the `onSuccess` callback as seen above. A common use case is to allow redirects to the page the user was trying to access prior to authentication. This could be achieved as follows: Login handler: ```jsx <button onClick={() => login({ state: { redirectTo: location.state ? location.state?.from?.pathname : null } }) } /> ``` Redirect handler: ```jsx <KindeProvider callbacks={ { onSuccess: (user, state, context) => { window.location = state?.redirectTo }, } } > ``` ## **Token storage in the authentication state** By default the JWTs provided by Kinde are stored in memory. This protects you from both [CSRF](https://owasp.org/www-community/attacks/csrf) attacks (possible if stored as a client side cookie) and [XSS](https://owasp.org/www-community/attacks/xss/) attacks (possible if persisted in local storage). The trade off with this approach however is that if a page is refreshed or a new tab is opened then the token is wiped from memory, and the sign in button would need to be clicked to re-authenticate. There are two ways to prevent this behaviour: 1. Use the Kinde custom domain feature. We can then set a secure, httpOnly cookie against your domain containing only the refresh token which is not vulnerable to CSRF attacks. 2. There is an escape hatch which can be used for local development: `useInsecureForRefreshToken`. This SHOULD NOT be used in production. We recommend you use a custom domain. This will store only the refresh token in local storage and is used to silently re-authenticate. ```jsx <KindeProvider useInsecureForRefreshToken={process.env.NODE_ENV === 'development'} ... > ``` ## Migration from v4 to v5 ### login and register method params No longer need to use authUrlParams parameter, all url params are now passed at top level and are now camel case instead of snake case. e.g. ``` login({ authUrlParams: { login_hint: "jenny@example.com", lang: "ru" } }) ``` becomes ``` login({ loginHint: "jenny@example.com", lang: "ru" }) ``` ### Callbacks `onRedirectCallback` has been removed in favor of a richer event system. This has been replaced by `callbacks > onSuccess` ### Create organization `createOrg` method has been removed and replaced by using `isCreateOrg` on the login or register methods or Components ### Accessing access token `getToken` has been replaced by `await getAccessToken` ### Token helpers all token helpers are now async methods ### getClaims token attribute changed to camelCase. e.g. ```javascript getClaim("given_name", "id_token"); ``` becomes ```javascript await getClaim("given_name", "idtoken"); ``` ## **API References - KindeProvider** ### **`audience`** The audience claim for the JWT. Type: `string` Required: No ### **`clientId`** The ID of your application as it appears in Kinde. Type: `string` Required: Yes ### **`domain`** Either your Kinde instance url or your custom domain. e.g `https://yourapp.kinde.com` Type: `string` Required: Yes ### **`logoutUri`** Where your user will be redirected when they log out. Type: `string` Required: No ### `useInsecureForRefreshToken` An escape hatch for storing the refresh in local storage for local development. Type: `boolean` Required: No Default: `false` ### **`redirectUri`** The URL that the user will be returned to after authentication. Type: `string` Required: Yes ### **`scope`** The scopes to be requested from Kinde. Type: `string` Required: No Default: `openid profile email offline` ## **API References- useKindeAuth hook** ### `getClaim` Gets a claim from an access or ID token. Arguments: ```typescript claim: string, tokenKey?: "accessToken" | "idToken" ``` Usage: ```jsx getClaim("givenName", "idToken"); ``` Sample: ```jsx "David"; ``` ### `getOrganization` Get details for the organization your user is signed into. Usage: ```jsx getOrganization(); ``` Sample: ```jsx { orgCode: "org_1234"; } ``` ### `getPermission` Returns the state of a given permission. Arguments: ```jsx key: string; ``` Usage: ```jsx getPermission("read:todos"); ``` Sample: ```jsx { orgCode: "org_1234", isGranted: true } ``` ### `getPermissions` Returns all permissions for the current user for the organization they are signed into. Usage: ```jsx getPermissions(); ``` Sample: ```jsx { orgCode: "org_1234", permissions: [ "create:todos", "update:todos", "read:todos ] } ``` ### `getToken` Returns the raw Access token from memory. Usage: ```jsx getToken(); ``` Sample: ```jsx eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c; ``` ### `getUserProfile` Returns the profile for the current user. Usage: ```jsx getUserProfile(); ``` Sample: ```jsx { givenName: "Dave"; id: "abcdef"; familyName: "Smith"; email: "dave@smith.com"; } ``` ### `getUserOrganizations` Gets an array of all organizations the user has access to. Usage: ```jsx getUserOrganizations(); ``` Sample: ```jsx { orgCodes: ["org_1234", "org_5678"]; } ``` ### `login` Constructs redirect url and sends user to Kinde to sign in. Arguments: ```typescript orgCode?: string; state?: object; ``` Usage: ```jsx login(); ``` Sample: ```jsx redirect; ``` ### `logout` Logs the user out of Kinde. Argument: ```typescript orgCode?: string ``` Usage: ```jsx logout(); ``` Sample: ```jsx redirect; ``` ### `register` Constructs redirect url and sends user to Kinde to sign up. Arguments: ```typescript orgCode?: string; state?: object; ``` Usage: ```jsx register(); ``` Sample: ```jsx redirect; ``` ## **API References- login** ### `getClaim` Gets a claim from an access or ID token. Arguments: ```typescript claim: string, tokenKey?: "accessToken" | "idToken" ``` Usage: ```jsx getClaim("given_name", "idToken"); ``` Sample: ```jsx "David"; ``` If you need any assistance with getting Kinde connected reach out to us at [support@kinde.com](mailto:support@kinde.com).

# Developer tools - Sdks - Android SDK

> Complete guide for Android SDK including Maven installation, Retrofit integration, PKCE authentication, and native Android app integration.

android sdk, kotlin, java, maven, retrofit, gson, pkce, user permissions, meta-data
developer-tools, sdks, android, native

The Kinde Android SDK allows developers to quickly and securely integrate a new or existing application into the Kinde platform. You can also view the [Android docs](https://github.com/kinde-oss/kinde-sdk-android) and [Android starter kit](https://github.com/kinde-starter-kits/android-starter-kit) in GitHub. ## Register for Kinde If you don’t already have a Kinde account, [register for free here](https://app.kinde.com/register) (no credit card required). Registering gives you a Kinde domain to get started, e.g. `https://yourapp.kinde.com`. ## Install KindeSDK is available through [Maven](https://search.maven.org/). To install it, simply add the following line to your `build.gradle`: ```kotlin ... implementation "com.kinde:android-sdk:<sdk_version> ... ``` You should also include Retrofit and the GSON converter as dependencies: ```kotlin implementation "com.squareup.retrofit2:retrofit:<retrofit_version> implementation "com.squareup.retrofit2:converter-gson:<retrofit_version> ``` ## Configure Kinde ### Set callback URLs 1. In Kinde, go to **Settings > Applications > [Your app] > View details**. 2. Add your callback URLs in the relevant fields. For example: - Allowed callback URLs (also known as redirect URIs): `{your_url_scheme}://<your_kinde_host>//kinde_callback` - for example `myapp://myhost.kinde.com//kinde_callback` - Allowed logout redirect URLs: `{your_url_scheme}://<your_kinde_host>//kinde_logoutcallback` - for example `myapp://myhost.kinde.com//kinde_logoutcallback` 3. Select **Save**. ### Add environments If you would like to use our Environments feature as part of your development process, you will need to create them within your Kinde account. In this case you would use the Environment subdomain in the code block above. ## **Configure your app** ### Environment variables The SDK reads configuration from `meta-data`, so you should add `meta-data` to the `<application>` section of your `AndroidManifest.xml`. You can find these variables in Kinde. Go to **Settings > Applications > [Your app] > View details**. Then scroll to the **App keys** section. - `au.kinde.domain:` - your Kinde domain - `au.kinde.clientId` ```xml ... <application ...> ... <meta-data android:name="au.kinde.domain android:value="your_kinde_url" /> <meta-data android:name="au.kinde.clientId android:value="your_kinde_client_id" /> ... </application> ... ``` Configuration example: ```xml ... <application ...> ... <meta-data android:name="au.kinde.domain android:value="app.kinde.com" /> <meta-data android:name="au.kinde.clientId android:value="test@live" /> ... </application> ... ``` ## Integrate with your app You'll need to import the SDK package in your Android app. ```kotlin ... import android.os.Handler import android.util.Log ... class YourActivity : AppCompatActivity() { ... private lateinit var sdk: KindeSDK ... override fun onCreate(savedInstanceState: Bundle?) { ... sdk = KindeSDK(this, object : KindeSDK.SDKListener { override fun onNewToken(token: String) { // Need to implement } override fun onLogout() { // Need to implement } override fun onException(exception: Exception) { Handler(Looper.getMainLooper()).post { Log.e("Kinde", "Something wrong init KindeSDK: " + exception.message)" } } }) ... } ``` ## Login / Register The Kinde client provides methods for a simple login / register flow. Add buttons in your view as follows: ```kotlin ... findViewById<View>(R.id.b_sign_in).setOnClickListener { sdk.login(GrantType.PKCE) } findViewById<View>(R.id.b_sign_up).setOnClickListener { sdk.register(GrantType.PKCE) } ... ``` ### Handle redirect Once your user is redirected back to your site from Kinde, it means you’ve logged in successfully. You will need to implement the `onNewToken` function from the SDK. ```kotlin ... sdk = KindeSDK(this, object : KindeSDK.SDKListener { override fun onNewToken(token: String) { // Need to implement } ... } ``` ## Logout This is implemented in much the same way as logging in or registering. The Kinde SPA client comes with a logout method. ```kotlin findViewById<View>(R.id.b_sign_out).setOnClickListener { sdk.logout() } ``` ## Get user information To access the user information, call the `getUserDetails` method. ```kotlin sdk.getUserDetails().let { Log.i("Kinde", it.givenName + " " + it.familyName) } ``` ### View users in Kinde In Kinde, go to **Users** to view all users and subscribers. ## User Permissions Once a user has been verified, your application will be returned the JWT token with an array of permissions for that user. You will need to configure your application to read permissions and unlock the respective functions. [Set roles and permissions](/manage-users/roles-and-permissions/apply-roles-and-permissions-to-users/) at the Business level in Kinde. Here’s an example of permissions. ```kotlin String[] permissions = { "create:todos", "update:todos", "read:todos", "delete:todos", "create:tasks", "update:tasks", "read:tasks", "delete:tasks", } ``` We provide helper functions to more easily access permissions: ```kotlin sdk.getPermission("create:todos") // {orgCode: "org_b235c067b7e4", isGranted: true} sdk.getPermissions() // {orgCode: "org_b235c067b7e4", permissions: [ "create:users", "view:users" ]} ``` A practical example in code might look something like: ```kotlin if(sdk.getPermission("create:todos").isGranted) { // create new a todo } ``` ## Audience An `audience` is the intended recipient of an access token - for example the API for your application. The audience argument can be passed to the Kinde client to request an audience to be added to the provided token. The audience of a token is the intended recipient of the token. ```xml <meta-data android:name="au.kinde.audience" android:value="example@example" /> ``` For details on how to connect, see [Register an API](/developer-tools/your-apis/register-manage-apis/). ## Overriding scope By default the `KindeSDK` requests the following scopes: - `profile` - `email` - `offline` - `openid` You can override this by passing scope into the `KindeSDK`. ```kotlin sdk = KindeSDK( ... scopes = listOf("openid", "offline", "email", "profile"), ... ) ``` ## Getting claims We have provided a helper to grab any claim from your id or access tokens. The helper defaults to access tokens: ```kotlin sdk.getClaim("aud") // ["api.yourapp.com"] sdk.getClaim("given_name", TokenType.ID_TOKEN) // "David ``` ## Feature flags We have provided a helper to grab any feature flag from `access_token`. ```kotlin ... import au.kinde.sdk.model.FlagType ... sdk.getFlag("theme"); // returns { "code": "theme", "type": "String", "value": "pink", "isDefault": true // whether the fallback value had to be used } // Another usage case sdk.getFlag("is_dark_mode"); // returns { "code": "is_dark_mode", "type": "Boolean", "value": true, "isDefault": false } // This flag does not exist - default value provided sdk.getFlag("create_competition", false); // returns { "code": "create_competition", "type": "Boolean", "value": false, "isDefault": true // because fallback value had to be used } // The flag type was provided as string, but it is an integer sdk.getFlag("competitions_limit", 3, FlagType.String); // should error out - Flag "competitions_limit" is type integer - requested type string // This flag does not exist, and no default value provided sdk.getFlag("new_feature"); // should error out - This flag was not found, and no default value has been provided ``` We also provide wrapper functions which should leverage `getFlag` above. **Get boolean flags** ```kotlin sdk.getBooleanFlag("is_dark_mode"); // true sdk.getBooleanFlag("is_dark_mode", false); // true sdk.getBooleanFlag("new_feature", false); // false (flag does not exist so falls back to default) sdk.getBooleanFlag("new_feature"); // Error - flag does not exist and no default provided sdk.getBooleanFlag("theme", false); // Error - Flag "theme" is of type string not boolean ``` **Get string flags** ```kotlin sdk.getStringFlag("theme"); // "pink sdk.getStringFlag("theme", "blue"); // "pink sdk.getStringFlag("cta_color", "blue"); // "blue" (flag does not exist so falls back to default) sdk.getStringFlag("cta_color"); // Error - flag does not exist and no default provided sdk.getStringFlag("is_dark_mode", false); // Error - Flag "is_dark_mode" is of type boolean not string ``` **Get integer flags** ```kotlin sdk.getIntegerFlag("competitions_limit"); // 5 sdk.getIntegerFlag("competitions_limit", 3); // 5 sdk.getIntegerFlag("team_count", 2); // 2 (flag does not exist so falls back to default) sdk.getIntegerFlag("team_count"); // Error - flag does not exist and no default provided sdk.getIntegerFlag("is_dark_mode", false); // Error - Flag "is_dark_mode" is of type boolean not integer ``` ## Organizations ### Create an organization To have a new organization created within your application, you will need to run a similar function to below: ```kotlin ... findViewById<View>(R.id.create_org).setOnClickListener { sdk.createOrg(orgName = "Your Organization") } ... ``` ### Sign up and sign in to organizations Kinde has a unique code for every organization. You’ll have to pass this code through when you register a new user or sign in to a particular organization. Example function below: ```kotlin findViewById<View>(R.id.b_sign_in).setOnClickListener { sdk.login(GrantType.PKCE, orgCode = "your_org_code") } findViewById<View>(R.id.b_sign_up).setOnClickListener { sdk.register(GrantType.PKCE, orgCode = "your_org_code") } ``` Following authentication, Kinde provides a json web token (jwt) to your application. Along with the standard information, we also include the `org_code` and the permissions for that organization. This is important as a user can belong to multiple organizations and have different permissions for each. Example of a returned token: ```kotlin { "aud": [], "exp": 1658475930, "iat": 1658472329, "iss": "https://your_subdomain.kinde.com", "jti": "123457890", "org_code": "org_1234", "permissions": ["read:todos", "create:todos"], "scp": [ "openid", "profile", "email", "offline ], "sub": "kp:123457890" } ``` The `id_token` will also contain an array of organizations that a user belongs to. This is useful if you wanted to build out an organization switcher, for example. ```json { ... "org_codes": ["org_1234", "org_4567"], ... }; ``` There are two helper functions you can use to extract information: ```kotlin sdk.getOrganization() // {'orgCode': 'org_1234'} sdk.getUserOrganizations() // {'orgCodes': ['org_1234', 'org_abcd']} ``` For more information about how organizations work in Kinde, see [Kinde organizations for developers](/build/organizations/orgs-for-developers/). ### Token storage Once the user has successfully authenticated, you'll have a JWT and possibly a refresh token that should be stored securely. ## SDK API reference ### `activity` Activity of the application. Type: `AppCompatActivity` Required: Yes ### `loginRedirect` The URL that the user will be returned to after authentication. Type: `string` Required: Yes ### `logoutRedirect` Where the user will be redirected when they sign out. Type: `string` Required: Yes ### `scopes` Type: `List<String>` Is required: No Default: ```kotlin listOf("openid", "offline", "email", "profile") ``` ### `SDKListener` The listener that receives callbacks from the SDK. Type: ```kotlin SDKListener { fun onNewToken(token: String) fun onLogout() fun onException(exception: Exception) } ``` Required: Yes ## KindeSDK methods ### `login` Starts the authorization flow. Arguments: ```kotlin grantType: GrantType?, orgCode: String? // GrantType { PKCE, NONE } ``` Usage: ```kotlin sdk.login(GrantType.PKCE)orsdk.login(GrantType.PKCE, orgCode = "your_org_code") ``` ### `register` Starts the registration flow. Arguments: ```kotlin grantType: GrantType?, orgCode: String? ``` Usage: ```kotlin sdk.register(GrantType.PKCE)orsdk.register(GrantType.PKCE, orgCode = "your_org_code") ``` ### `createOrg` Starts the registration flow and creates a new organization in your business. Arguments: ```kotlin grantType: GrantType?, orgCode: String? ``` Usage: ```kotlin sdk.createOrg(orgName =”Your Organization”)orsdk.register(GrantType.PKCE, orgName =”Your Organization”) ``` ### `logout` Logs the user out of Kinde. Usage: `sdk.logout()` ### `isAuthenticated` Checks that access token is present. Usage: `sdk.isAuthenticated()` Sample output: `true` or `false` ### `getUserDetails` Gets user details from an access or ID token. Usage: `sdk.getUserDetails()` Sample output: ```kotlin { givenName: "Dave"; id: "abcdef"; familyName: "Smith"; email: "dave@smith.com" } ``` ### `getClaim` Gets a claim from an access or ID token. Arguments: ```kotlin claim: String, tokenType: TokenType // TokenType { ID_TOKEN, ACCESS_TOKEN} ``` Usage: ```kotlin sdk.getClaim('given_name', TokenType.ID_TOKEN); ``` Sample output: `"David"` ### `getPermission` Returns the state of a given permission. Usage: ```kotlin sdk.getPermission("read:todos") ``` Sample output: ```kotlin { orgCode: "org_1234", isGranted: true } ``` ### `getPermissions` Returns all permissions for the current user for the organization they are logged into. Arguments: `permission: String` Usage: `sdk.getPermissions()` Sample output: ```kotlin { orgCode: "org_1234", permissions: [ "create:todos", "update:todos", "read:todos", "create:todos", "update:todos", "read:todos ] } ``` ### `getUserOrganizations` Gets an array of all organizations the user has access to. Usage: `sdk.getUserOrganizations()` Sample output: ```kotlin { orgCodes: [ "org_1234", "org_5678", "org1_234", "org_5678 ] } ``` ### `getOrganization` Get details for the organization your user is signed into. Usage: `sdk.getOrganization()` Sample output: ```kotlin {orgCode: "org_1234"} ``` ### `getFlag` Gets a feature flag from an access token. Arguments: ```kotlin code: String, defaultValue: Any? = null; flagType: FlagType? = null // FlagType { String, Integer, Boolean } ``` Usage: `sdk.getFlag("theme");` Sample output: ```kotlin {"code": "theme", "type": "string", "value": "pink","is_default": False} ``` ### `getBooleanFlag` Gets a boolean feature flag from an access token Arguments: ```kotlin code: String; defaultValue: Boolean? = null ``` Usage: ```kotlin sdk.getBooleanFlag(”is_dark_mode”); ``` Sample output: `true` or `false` ### `getStringFlag` Gets a string feature flag from an access token Arguments: ```kotlin code: String; defaultValue: String? = null ``` Usage: ```kotlin sdk.getStringFlag("theme"); ``` Sample output: `“pink”` ### `getIntegerFlag` Gets a integer feature flag from an access token Arguments: ```kotlin code: String; defaultValue: Int? = null ``` Usage: ```kotlin sdk.getIntegerFlag("competitions_limit"); ``` Sample output: `5` If you need help getting Kinde connected, contact us at [support@kinde.com](mailto:support@kinde.com). ```

# Developer tools - Sdks - Expo

> Complete guide for Expo SDK including authentication setup, token utilities, user profile management, and mobile app integration for React Native applications.

expo, react native, mobile authentication, token utilities, user profile, feature flags, permissions
developer-tools, sdks, expo, native

The Kinde React Native SDK allows developers to quickly and securely integrate a new or an existing React Native application into the Kinde platform. This SDK is for people using Expo. ## Register for Kinde If you haven't already got a Kinde account, [register for free here](https://app.kinde.com/register) (no credit card required). Registering gives you a Kinde domain, which you need to get started, e.g. `yourapp.kinde.com`. ## Before you install You will need Node, the React Native command line interface, a JDK, Android Studio (for Android) and Xcode (for iOS). Follow [the installation instructions for your chosen OS](https://reactnative.dev/docs/environment-setup) to install dependencies. ## Installation with Expo Managed Workflow ### Install package <PackageManagers pkg="@kinde/expo" /> ### Setup provider ```jsx <KindeAuthProvider config={{ domain: "<KINDE DOMAIN>", // e.g https://mybusiness.kinde.com clientId: "<CLIENT ID>", }} // All callbacks are optional callbacks={{ onSuccess: async (token, state, context) => { }, onError: (error) => { }, onEvent: async (event, state, context) => { }, }} > {/* Your app components go here */} </KindeAuthProvider> ``` ### Auth Methods ```jsx const kinde = useKindeAuth(); const handleSignUp = async () => { const token = await kinde.register(); if (token) { // User was authenticated } }; const handleSignIn = async () => { const token = await kinde.login(); if (token) { // User was authenticated } }; const handleLogout = async () => { console.log("logout", await kinde.logout()); }; ``` #### Example usage ```jsx <Pressable onPress={handleSignIn}> <ThemedText>Sign In</ThemedText> </Pressable> ``` Login and register methods accept and object containing all [Kinde supported URL parameters](https://docs.kinde.com/developer-tools/about/using-kinde-without-an-sdk/#request-parameters). Logout accepts object which allows you to revoke the token ```jsx kinde.logout({ revokeToken: true }) ``` #### Properties (Only available from `useKindeAuth`) - `isAuthenticated` - Returns true/false if the user is authenticated ## Kinde configuration 1. In Kinde, go to **Settings > Applications.** 2. Select **View details** on the **Frontend app**. 3. Scroll down to the **Callback URLs** section. 4. Add in the callback URLs for your React Native app, which should look something like this: - Allowed callback URLs - `<myapp://localhost:3000>` - Allowed logout redirect URLs - `<myapp://localhost:3000>` Make sure you press the Save button at the bottom of the page! Note: The `<myapp://localhost:3000>` is used as an example of local URL Scheme, change to the local URL Scheme or production URL Scheme that you use. ## Token Utilities A selection of utility functions are available. *Expo 53+*: Import from `@kinde/expo/utils` and `useKindeAuth` hook *Expo 51 and 52*: Import from `@kinde/js-utils` and `useKindeAuth` hook ```ts import { getUserProfile, getFlag, getRoles } from "@kinde/expo/utils"; // Example usage const checkUserProfile = async () => { const profile = await getUserProfile(); console.log("User profile:", profile); }; ``` #### Utility functions include: - `getDecodedToken` - Get token decoded values - `getUserProfile` - Get the current user's profile - `getFlag` - Check feature flag values - `getRoles` - Get the current user's roles - `getCurrentOrganization` - Get the current organization - `getUserOrganizations` - Get all organizations the user belongs to - `getPermission` - get a single permission value - `getPermissions` - get all user permissions - `getClaim` - Get a specific claim from the token - `getClaims` - Get all claims from the token - `refreshToken` - Manually refresh the access token ### `getDecodedToken` Get the decoded access token or ID token. ```typescript getDecodedToken = async <T = JWTDecoded>( tokenType: "accessToken" | "idToken" = StorageKeys.accessToken, ): Promise<(T & JWTDecoded) | null> ``` Example usage: ```javascript // Get the decoded access token const decodedAccessToken = await getDecodedToken("accessToken"); // Get the decoded ID token const decodedIdToken = await getDecodedToken("idToken"); // Adding custom claims to the decoded token const decodedAccessTokenWithCustomClaims = await getDecodedToken<{ customClaim: string; }>("accessToken"); ``` ### `getClaim` Gets a claim from an access or ID token. ```typescript getClaim = async <T = JWTDecoded, V = string | number | string[]>( keyName: keyof T, tokenType: "accessToken" | "idToken" = "accessToken", ): Promise<{ name: keyof T; value: V; } | null> ``` Example usage: ```javascript // Get the decoded access token const roles = await getClaim("roles", "accessToken"); // Get the decoded ID token const givenName = await getClaim("given_name", "idToken"); // Acessing custom claims const decodedAccessTokenWithCustomClaims = await getClaim<{ customClaim: string; }>("customClaim", "accessToken"); ``` ### `getCurrentOrganization` Returns the current users logged in organization code. ```typescript getCurrentOrganization = async (): Promise<string | null> ``` Example usage: ```javascript // Get the decoded access token const orgCode = await getCurrentOrganization(); // org_123456 ``` ### `getUserOrganizations` Returns all organization codes the current user belongs to. ```typescript getUserOrganizations = async (): Promise<string[] | null> ``` Example usage: ```javascript // Get the decoded access token const orgCode = await getUserOrganizations(); // [ // "org_0000000000001", // "org_0000000000002", // "org_0000000000003", // "org_0000000000004 // ] ``` ### `getFlag` Get the value of a feature flag. ```typescript getFlag = async <T = string | boolean | number | object>( name: string, ): Promise<T | null> ``` Example usage: ```javascript // Get the feature flag value const featureValue = await getFlag("feature_flag_name"); // Define the type of the feature flag const featureValue = await getFlag<string>("feature_flag_name"); const featureValue = await getFlag<boolean>("feature_flag_name"); const featureValue = await getFlag<number>("feature_flag_name"); const featureValue = await getFlag<object>("feature_flag_name"); ``` ### `getPermission` Get the value of a feature flag. ```typescript getPermission = async <T = string>( permissionKey: T, ): Promise<PermissionAccess> ``` Example usage: ```javascript // Get the feature flag value const permission = await getPermission("feature_flag_name"); // { // permissionKey: "feature_flag_name", // orgCode: "org_123456", // isGranted: true / false, // } ``` ### `getPermissions` Get the permissions for the current user for the organization they are signed into. ```typescript getPermissions = async <T = string>( permissionKey: T, ): Promise<PermissionAccess> ``` Example usage: ```javascript // Get the feature flag value const permissions = await getPermissions("feature_flag_name"); // { // orgCode: "org_123456", // permissions: [ // "create:todos", // "update:todos", // "read:todos", // "delete:todos", // "create:tasks", // "update:tasks", // "read:tasks", // "delete:tasks // ] // } ``` ### `getRoles` Get the users Roles <Aside> **Note:** Roles are optional in the token, will need to add to the token in your application settings </Aside> ```typescript getRoles = async (): Promise<Role[]> ``` Example usage: ```javascript // Get the feature flag value const roles = await getRoles(); // [ // { // id: "01932730-c828-c01c-9f5d-c8f15be13e24", // key: "admin", // name: "admin", // }, // ] ``` ### `getUserProfile` ```typescript getUserProfile = async <T>(): Promise< (UserProfile & T) | null > ``` Example usage: ```javascript // Get the feature flag value const roles = await getUserProfile(); // { // "email": "someuser@emaildomain.com", // "familyName": "Bloggs", // "givenName": "Joe", // "id": "kp_1234...", // "picture": "https://example.com/image.png", // } ``` ### `refreshToken` ```typescript refreshToken = async ({ domain, clientId, refreshType = RefreshType.refreshToken, onRefresh, }: { domain: string; clientId: string; refreshType?: RefreshType; onRefresh?: (data: RefreshTokenResult) => void; }): Promise<RefreshTokenResult> ``` Example usage: ```javascript const refreshToken = await refreshToken({ domain: "https://mybusiness.kinde.com", clientId: "client_id" }); // { // accessToken: "eyJhbGciOiJSUzI1N...", // idToken: "eyJhbGciOiJSUzI1N...", // refreshToken: "E5hxe-AOSTcFjri3YV...", // success: true, // } ``` ### **Caching Issues** Sometimes there will be issues related to caching when you develop React Native. There are some recommendations for cleaning the cache: 1. Remove `node_modules`, `yarn.lock` or `package-lock.json`. 2. Clean cache: `yarn cache clean` or `npm cache clean --force`. 3. Make sure you have changed values in `.env` file. 4. Trying to install packages again: `yarn install` or `npm install`. 5. Run Metro Bundler: `yarn start --reset-cache` or `npm start --reset-cache`. Assume your StarterKit path is `<StarterKit_PATH>`. **Clean cache for Android** 1. Run this: ```shell cd <StarterKit_PATH>/android ./gradlew clean ``` **Clean cache for iOS** 1. Run this: ```shell cd <StarterKit_PATH>/ios rm -rf Pods && rm Podfile.lock ``` 2. Clean build folders on **Xcode**. If you need help connecting to Kinde, please contact us at [support@kinde.com](mailto:support@kinde.com).

# Developer tools - Sdks - Flutter SDK

> Complete guide for Flutter SDK including authentication setup, Android/iOS configuration, PKCE flow, and mobile app integration for Flutter 3.10+ applications.

flutter sdk, dart, mobile authentication, android setup, ios setup, pkce flow, custom schemes
developer-tools, sdks, flutter, native

The Kinde’s Flutter SDK allows developers to integrate Kinde Authentication into their Flutter projects. Integrate [Kinde](https://kinde.com/) authentication with your Flutter app. When you configure, register, log in, and log out, the authentication state is securely stored across app restarts. ## Register with Kinde If you haven’t already got a Kinde account, [register for free here](https://app.kinde.com/register) (no credit card required). Registering gives you a Kinde domain, which you need to get started, e.g. yourapp.kinde.com. ## Before you install This SDK is suitable for: - Flutter 3.10.0 or later. - Dart 3.0.6 or later. ## Install SDK KindeSDK is available through [pub.dev](https://pub.dev/packages/kinde_flutter_sdk). To install it, simply add the following line to your pubspec.yaml: ```dart kinde_flutter_sdk: <latest-version> ``` ## Integrate with your app The `kinde_flutter_sdk` package is intended to work with Flutter Projects. Within the main function, ensure WidgetsFlutterBinding is initialized. `KindeFlutterSDK.initializeSDK()` must be called before using the SDK. If you’re using an .env file, provide the .env filename inside the load function. See below: ```dart import 'package:flutter/material.dart'; import 'package:flutter_dotenv/flutter_dotenv.dart'; import 'package:kinde_flutter_sdk/kinde_flutter_sdk.dart'; WidgetsFlutterBinding.ensureInitialized(); await dotenv.load(fileName: ".env"); await KindeFlutterSDK.initializeSDK( authDomain: dotenv.env[KINDE_AUTH_DOMAIN]!, authClientId: dotenv.env[KINDE_AUTH_CLIENT_ID]!, loginRedirectUri: dotenv.env[KINDE_LOGIN_REDIRECT_URI]!, logoutRedirectUri: dotenv.env[KINDE_LOGOUT_REDIRECT_URI]!, audience: dotenv.env[KINDE_AUDIENCE], //optional scopes: ["email","profile","offline","openid"] // optional ); ``` **Note:** To setup the .env file in your flutter package, check the [**flutter_dotenv**](https://pub.dev/packages/flutter_dotenv) package. ### **Environment variables:** Put these variables in your `.env` file. You can find these variables on your **Settings > Applications > [Your app] > View details** page. - KINDE_AUTH_DOMAIN - your Kinde domain - KINDE_CLIENT_ID - your Kinde client ID - KINDE_LOGIN_REDIRECT_URI - your callback url to redirect to after authentication. Make sure this URL is under your **Allowed callback URLs**. - KINDE_LOGOUT_REDIRECT_URI - where you want users to be redirected to after logging out. Make sure this URL is under your **Allowed logout redirect URLs**. - KINDE_AUDIENCE (optional)- the intended recipient of an access token. To fetch this value, go to **Settings > Applications > [Your app] > APIs** Below is an example of a `.env` file ```bash KINDE_AUTH_DOMAIN=https://<your_kinde_subdomain>.kinde.com KINDE_AUTH_CLIENT_ID=<your_kinde_client_id> KINDE_LOGIN_REDIRECT_URI=<your_custom_scheme>://kinde_callback KINDE_LOGOUT_REDIRECT_URI=<your_custom_scheme>://kinde_logoutcallback KINDE_AUDIENCE=<your_kinde_audience> ``` **Example:** ```bash KINDE_AUTH_DOMAIN=https://myapp.kinde.com KINDE_AUTH_CLIENT_ID=clientid KINDE_LOGIN_REDIRECT_URI=myapp://kinde_callback KINDE_LOGOUT_REDIRECT_URI=myapp://kinde_logoutcallback KINDE_AUDIENCE=myapp.kinde.com/api ``` **Note:** Be sure to add the .env file in your .gitignore file. See the GitHub link [here](https://github.com/github/gitignore/blob/main/Dart.gitignore). ## Configure your app **Android Setup** Go to the `build.gradle` file in the **Android > App** folder for your Android app. Specify the custom scheme similar to the following, but replace `<your_custom_scheme>` with your own value. ```groovy android { ... defaultConfig { ... manifestPlaceholders += [ 'appAuthRedirectScheme': '<your_custom_scheme>' ] } } ``` **iOS Setup** Go to the `Info.plist` located at **ios > Runner** for your iOS/macOS app. Specify the custom scheme similar to the following but replace `<your_custom_scheme>` with your own value. ```xml <key>CFBundleURLTypes</key> <array> <dict> <key>CFBundleTypeRole</key> <string>Editor</string> <key>CFBundleURLSchemes</key> <array> <string><your_custom_scheme>://</string> </array> </dict> </array> ``` **Note:** `<your_custom_scheme>` has been defined previously as [`myapp`](http://com.kinde.app/) You can define your own custom scheme to correspond to the app name. ## Set callback URLs For your app to work with Kinde, you need to set callback and logout redirect URLs. Replace the values you see in `<code brackets>` with your own values. 1. In Kinde, go to **Settings > Applications.** 2. Select **View details** on your app. 3. Scroll down to the **Callback URLs** section. 4. Add in the callback URLs for your app, which might look something like this: - Allowed callback URLs: `<your_custom_scheme>://kinde_callback` - Allowed logout redirect URLs: `<your_custom_scheme>://kinde_logoutcallback` ```dart loginRedirectUri: myapp://kinde_callback, logoutRedirectUri: myapp://kinde_logoutcallback, ``` 5. Select **Save**. **Tip**: Make sure there are no hidden spaces in URLs and remove the ‘/’ backslash at the end. **Note:** For more details, please visit the link [Set callback and redirect URLs](/get-started/connect/callback-urls/). ## Environments If you would like to use different Environments as part of your development process, you will need to [add them within your Kinde business](/build/environments/environments/) first. You will also need to add the Environment subdomain to the code block above. ## Sign in and **sign up** Kinde supports an easy to implement login / register flow. Use the functions examples below to redirect your users to Kinde, where they authenticate before being redirected back to your app. ### Kinde Client Make sure you’ve already defined **KindeFlutterSDK.instance** variable. ```dart final sdk = KindeFlutterSDK.instance; ``` ### R**edirect after authentication** The Kinde client provides methods for a simple login / register flow which authenticates the user and redirects them back to the app. ```dart ... final String token = await sdk.login(context: context); // or sdk.login(type: AuthFlowType.pkce, context: context) for apply pkce flow ... await sdk.register(context: context); // or sdk.register(type: AuthFlowType.pkce, context: context) for apply pkce flow ... ``` **Note:** Kinde supports the PKCE extension, in which the `code_challenge` and `code_challenge_method` parameters are also required. For More information, visit [Using OAuth Scopes.](/build/tokens/oath-scopes/#authorization-code-flow-with-proof-key-for-code-exchange-pkce) ### Signing out This is implemented in much the same way as logging in or registering. The Kinde SDK client comes with a logout method. ```dart .... await sdk.logout() .... ``` ### Test sign up Register your first user by signing up yourself. You’ll see your newly registered user on the **Users** page in Kinde. ## Get user information To access the user information, call one of the `getUser` or `getUserProfileV2` methods. ```dart sdk.getUser().then((value) { print('User: ${value?.firstName ?? ' '} ${value?.lastName ?? ' '}'); }); ``` ### User profile ```dart final userProfile = await sdk.getUserProfileV2(); print(userProfile); // returns UserProfile { id=kp_12345678910, preferredEmail=dave@smith.com, lastName=smith, firstName=dave, } ``` Both method returns the sub(unique id of user In Kinde Console), `id`, `firstName`, `lastName`, `picture`, and `preferredEmail`, etc. ### Check if user is authenticated We’ve provided a helper to get a boolean value to check if a user is signed in by verifying that the access token is still valid. ```dart final isAuthenticated = await sdk.isAuthenticate(); if (isAuthenticated) { // Need to implement, e.g: call an api, etc... } else { // Need to implement, e.g: redirect user to sign in, etc.. } ``` ### User permissions Once the user has logged in, the JWT token is returned which contains an array of permissions of that user. Read the permissions and implement the functionality in your application accordingly. [Set permissions](/manage-users/roles-and-permissions/user-permissions/) in your Kinde account. Here’s an example set of permissions. ```dart List<String> permissions = [ "create:todos", "update:todos", "read:todos", "delete:todos", "create:tasks", "update:tasks", "read:tasks", "delete:tasks", ]; ``` We provide helper functions to more easily access the permissions claim: ```dart final ClaimPermissions sdkPermissions = sdk.getPermissions(); //to fetch list of permissions final ClaimPermission sdkPermission = sdk.getPermission('permissionName'); //to fetch a single permission ``` ### Examples To fetch a list of permissions, we use the following permission function: ```dart Future<void> getPermissions() async { final ClaimPermissions sdkPermissions = sdk.getPermissions(); print(sdkPermissions.permissions); //list of claim permissions granted to user } ``` To fetch a single permission, we use the following permission function: ```dart Future<void> getPermission() async { final ClaimPermission sdkPermission = sdk.getPermission('permissionName'); print(sdkPermission.isGranted); //Check if permission is granted. print(sdkPermission.orgCode); //orgCode for specific organization. } ``` ## Call Your API (Token storage) After the user has successfully logged in, you will have a JSON Web Token (JWT) and a refresh token securely stored. You can retrieve an access token by utilizing the `getToken` method. ```dart final access_token = await sdk.getToken(); ``` If the `accessToken` has expired, but the `refreshToken` is valid, the `getToken` method will automatically fetch the `newToken` using the built in `refreshToken` interceptor. To implement the methods in your front-end application with encrypted storage using flutter_secure_storage and hive, use the following code: ```dart import 'package:flutter/material.dart'; import 'package:flutter_dotenv/flutter_dotenv.dart'; import 'package:kinde_flutter_sdk/kinde_flutter_sdk.dart'; import 'package:flutter_secure_storage/flutter_secure_storage.dart'; import 'package:hive/hive.dart'; Future<void> initEncryptedHive() async { const FlutterSecureStorage secureStorage = FlutterSecureStorage(); var containsEncryptionKey = await secureStorage.containsKey(key: 'encryptionKey'); if (!containsEncryptionKey) { var key = Hive.generateSecureKey(); await secureStorage.write(key: 'encryptionKey', value: base64UrlEncode(key)); } } void main(){ WidgetsFlutterBinding.ensureInitialized(); await initEncryptedHive(); await dotenv.load(fileName: ".env"); await KindeFlutterSDK.initializeSDK( authDomain: dotenv.env[KINDE_AUTH_DOMAIN]!, authClientId: dotenv.env[KINDE_AUTH_CLIENT_ID]!, loginRedirectUri: dotenv.env[KINDE_LOGIN_REDIRECT_URI]!, logoutRedirectUri: dotenv.env[KINDE_LOGOUT_REDIRECT_URI]!, audience: dotenv.env[KINDE_AUDIENCE], ); } ``` ```dart Future < Box > hiveEncryptedBox() async { // Hive Encrypted Box Added const FlutterSecureStorage secureStorage = FlutterSecureStorage(); String ? key = await secureStorage.read(key: 'encryptionKey'); var encryptionKey = base64Url.decode(key!); var box = await Hive.openBox('myBox', encryptionCipher: HiveAesCipher(encryptionKey)); return box; } Future < String > returnAccessToken() async { final box = await hiveEncryptedBox(); var token = box.get('token', defaultValue: ''); if (token == '') { return await getNewToken(); } else if (token != null) { bool hasExpired = JwtDecoder.isExpired(token); if (hasExpired) { return await getNewToken(); } return token; } else { return getNewToken(); } } Future < String > getNewToken() async { String ? token = await sdk.getToken(); if (token == null) return 'Refresh Token Expired'; // Redirect user to the login page var box = await hiveEncryptedBox(); await box.put('token', token); return token; } ``` **Note:** To setup [hive](https://pub.dev/packages/hive) and [flutter_secure_storage](https://pub.dev/packages/flutter_secure_storage), visit the [pub.dev](http://pub.dev/) . You may also use Android KeyStore or iOS Realm to store tokens. ## **Audience** An `audience` is the intended recipient of an access token - for example the API for your application. The audience argument can be passed to the Kinde client to request an audience be added to the provided token. The audience of a token is the intended recipient of the token. ```dart await KindeFlutterSDK.initializeSDK( ... audience: 'myapp.kinde.com/api', ... ); ``` For details on how to connect, see [Register an API](/developer-tools/your-apis/register-manage-apis/). ## Organizations ### Create an organization To have a new organization created within your application, you will need to set up the following function: ```dart Future<void> createOrg() async { await sdk.createOrg(orgName: string); } ``` ### **Optional type parameter** ```dart Future<void> createOrg() async { await sdk.createOrg(orgName: string,type: AuthFlowType.pkce); } ``` ### Sign up and sign in to organizations The Kinde client provides methods for you easily sign up and sign in users into organizations. ```dart Future < void > loginUser() async { final token = await sdk.login(orgCode: 'orgCode'); // or sdk.login(orgCode:'orgCode', type: AuthFlowType.pkce) for apply pkce flow print(token); } Future < void > registerUser() async { await sdk.register(orgCode: 'orgCode'); // or sdk.register(orgCode:'orgCode', type: AuthFlowType.pkce) for apply pkce flow } ``` Following authentication, Kinde provides a json web token (jwt) to your application. Along with the standard information we also include the `org_code` and the permissions for that organization (this is important as a user can belong to multiple organizations and have different permissions for each). Example of a returned token: ```json { "aud": [], //audience "exp": 1658475930, //token expiry "iat": 1658472329, "iss": "https://your_subdomain.kinde.com", "jti": "123457890", "org_code": "org_1234", //organization codes "permissions": ["read:todos", "create:todos"], //list of permissions "scp": ["openid", "profile", "email", "offline"], //scopes "sub": "kp:123457890" } ``` The `id_token` will also contain an array of organizations that a user belongs to - this is useful if you wanted to build out an organization switcher for example. ```json [ ... "org_codes": ["org_1234", "org_4567"] ... ]; ``` You can also fetch the org_code by: 1. Sign into [kinde.com](https://kinde.com/). 2. In Kinde, go to **Organizations** and fetch the org_code for which you want to register user’s. ### Fetch organizations ```dart sdk.getOrganization(); // ClaimOrganization(code: "org_1234") sdk.getUserOrganizations(); // ClaimOrganizations(orgCodes: [Organization(code: "org_1234"), Organization(code: "org_abcd")]) ``` To shift users between organizations visit [user-management.](/manage-users/about/) ## Scopes ### Default **scopes** By default the KindeSDK requests the following scopes: - **openid:** Perform an OpenID connect sign-in. - **profile:** Retrieve the user’s profile. - **offline:** Retrieve a Refresh Token for offline access from the application. - **email:** Retrieve the user’s email. ### Overriding scopes You can override this by passing scope into the initializeSDK() function ```dart await KindeFlutterSDK.initializeSDK( ... scopes = ["email", "profile"], ... ); ``` ### Getting claims We have provided a helper to grab any claim from your id or access tokens. The helper defaults to access tokens: ```typescript sdk.getClaim(claim:'aud'); // { name: "aud", value: ["local-testing@kinde.com"] } sdk.getClaim(claim:'email',tokenType: TokenType.idToken); // { name: "email", value: "first.last@test.com" } sdk.getClaim(claim:'email',tokenType: TokenType.accessToken); ``` ## Feature Flags We have provided a helper to grab any feature flags from the `access_token`: When a user signs in, the access token your product/application receives contains a custom claim called `feature_flags`, which is an object detailing the feature flags for that user. Here’s an example of how to fetch feature_flags directly from the jwt token. ```dart void getFeatureFlags() async { String ? token = await sdk.getToken(); if (token != null) { Map < String, dynamic > decoded = JwtDecoder.decode(token); print(decoded['feature_flags']); } } ``` Decoding the token using the [jwt.io](http://jwt.io/) website also references the following object that is contained within the token: ```json feature_flags: { theme: { "t": "s", "v": "pink" }, is_dark_mode: { "t": "b", "v": true }, competitions_limit: { "t": "i", "v": 5 } } ``` **Note: Setup** [**JwtDecoder**](https://pub.dev/packages/jwt_decoder) **using this link.** In order to minimize the payload in the token we have used single letter keys / values where possible. The single letters represent the following: `t` = type, `v` = value, `s` = String, `b` = Boolean, `i` = Integer, You can set feature flags in your Kinde account by visiting: [Add Feature Flags](/releases/feature-flags/add-feature-flag/) We also provide helper functions to more easily access feature flags: ```dart sdk.getFlag(code: "featureFlagCode",defaultValue: 'defaultValue',type: FlagType) ``` To fetch `featureFlagCode`, In Kinde, navigate to **Releases** **> Feature Flags.** A practical example in code would look something like: ```dart void getFlagInfo() { final Flag ? info = sdk.getFlag(code: 'featureFlagCode', defaultValue: '', type: FlagType.string); print(info?.code); } ``` ## Wrapper functions We also require wrapper functions by type which should leverage `getFlag` above. Boolean wrapper ```dart /** * Get a boolean flag from the feature_flags claim of the access_token. * @param {String} code - The name of the flag. * @param {Boolean} [defaultValue] - A fallback value if the flag isn't found. * @return {Boolean} */ sdk.getBooleanFlag(code, defaultValue); sdk.getBooleanFlag("is_dark_mode"); // true sdk.getBooleanFlag("is_dark_mode", false); // true sdk.getBooleanFlag("new_feature"); // Error - flag does not exist and no default provided sdk.getBooleanFlag("new_feature", false); // false (flag does not exist so falls back to default) sdk.getBooleanFlag("theme", "blue"); // Error - Flag "theme" is of type string not boolean ``` String wrapper ```dart /** * Get a string flag from the feature_flags claim of the access_token. * @param {String} code - The name of the flag. * @param {String} [defaultValue] - A fallback value if the flag isn't found. * @return {String} */ sdk.getStringFlag(code, defaultValue); /* Example usage */ sdk.getStringFlag("theme"); // pink sdk.getStringFlag("theme", "black"); // true sdk.getStringFlag("cta_color"); // Error - flag does not exist and no default provided sdk.getStringFlag("cta_color", "blue"); // blue (flag does not exist so falls back to default) sdk.getStringFlag("is_dark_mode", false); // Error - Flag "is_dark_mode" is of type boolean not string ``` Integer wrapper ```dart /** * Get an integer flag from the feature_flags claim of the access_token. * @param {String} code - The name of the flag. * @param {Integer} [defaultValue] - A fallback value if the flag isn't found. * @return {Integer} */ sdk.getIntegerFlag(code, defaultValue); sdk.getIntegerFlag("competitions_limit"); // 5 sdk.getIntegerFlag("competitions_limit", 3); // 5 sdk.getIntegerFlag("team_count"); // Error - flag does not exist and no default provided sdk.getIntegerFlag("team_count", 2); // false (flag does not exist so falls back to default) sdk.getIntegerFlag("is_dark_mode", false); // Error - Flag "is_dark_mode" is of type boolean not integer ``` Example of wrapper function: ```dart void getTheme() { final theme = sdk.getStringFlag("theme", "black"); if (theme == "black") { //code to execute when theme is black. } else if (theme == "blue") { //code to execute when theme is blue. } } void isDarkMode() { final isDarkMode = sdk.getBooleanFlag("is_dark_mode", false); if (isDarkMode) { //code to execute in dark mode. } else { // code to execute in light mode. } } int getTeamCount() { final teamCount = sdk.getIntegerFlag("team_count", 2); print(teamCount); return teamCount; } ``` ## SDK API Reference ### `authDomain` Either your Kinde instance url or your custom domain. e.g. `https://yourapp.kinde.com/` Type: `string` Required: Yes --- ### `clientId` The id of your application - get this from the Kinde admin area. Type: `string` Required: Yes --- ### `loginRedirectUri` The url that the user will be returned to after authentication. Type: `string` Required: Yes --- ### `logoutRedirectUri` Where your user will be redirected upon logout. Type: `string` Required: Yes --- ### `audience` The audience claim for the JWT. Type: `string` Required: No --- ### `scope` The scopes to be requested from Kinde. Type: `string` Required: No Default: `openid` `profile` `email` `offline` --- ## **KindeSDK Methods** ### `login` Constructs redirect url and sends user to Kinde to sign in. **Usage:** ```dart sdk.login(); ``` ### `register` Constructs redirect url and sends user to Kinde to sign up. **Usage:** ```dart sdk.register(); ``` ### `logout` Logs the user out of Kinde. **Usage:** ```dart sdk.logout(); ``` ### `isAuthenticated` Check if the user is authenticated. **Usage:** ```dart sdk.isAuthenticated(); ``` **Sample output:** ```dart true or false ``` ### `createOrg` Constructs redirect url and sends user to Kinde to sign up and create a new org for your business. **Arguments:** ```dart options?: CreateOrgURLOptions { org_name?: "string"; org_code?: "string"; state?: "string"; } ``` **Usage:** ```dart sdk.createOrg( org_name: "org_1234" ); ``` ### `getClaim` Extract the provided claim from the provided token type in the current session, the returned object includes the provided claim. **Arguments:** ```dart claim: "string", tokenKey?: TokenType "access_token" | "id_token ``` **Usage:** ```dart sdk.getClaim(claim:"given_name", tokenType: TokenType); ``` ### `getPermission` Returns the state of a given permission. **Arguments:** ```dart key: "string ``` **Usage:** ```dart sdk.getPermission("permission"); ``` **Sample output:** ```dart { orgCode : 'org_1234', isGranted : true} ``` ### `getPermissions` Returns all permissions for the current user for the organization they are logged into. **Usage:** ```dart sdk.getPermissions(); ``` **Sample output:** ```dart { orgCode : 'org_1234', permissions : ['create:todos', 'update:todos', 'read:todos'] } ``` ### `getOrganization` Get details for the organization your user is logged into. **Usage:** ```dart sdk.getOrganization(); ``` **Sample output:** ```dart { orgCode : 'org_1234' } ``` ### `getUserOrganizations` Gets an array of all organizations the user has access to. **Usage:** ```dart sdk.getUserOrganizations(); ``` **Sample output:** ```dart { orgCodes: ['org_7052552de68', 'org_5a5c29381327'] } ``` ### `getUser` Extracts the user details from the Id token obtained post authentication. **Usage:** ```dart sdk.getUser(); ``` **Sample output:** ```dart { "id":"kp_12345678910", "preferredEmail":"dave@smith.com", "lastName":"smith", "firstName":"dave", } ``` ### `getToken` Returns the access token obtained post authentication. **Usage:** ```dart sdk.getToken(); ``` **Sample output:** ```dart eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9 .eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ .SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c; ``` --- ### `getUserProfile` Extracts makes use of the `getToken` method above to fetch user details **Usage:** ```dart sdk.getUserProfile(); ``` **Sample output:** ```dart { given_name: 'Dave', id: 'abcdef', family_name : 'Smith', email : 'mailto:dave@smith.com' } ``` ### `getFlag` Get a flag from the feature_flags claim of the `access_token` **Arguments:** ```dart code : "string" defaultValue? : FlagType[keyof FlagType] flagType? : [key of FlagType] interface FlagType { s: string; b: boolean; i: number; } interface GetFlagType { type?: 'string' | 'boolean' | 'number'; value: FlagType[keyof FlagType]; is_default: boolean; code: "string"; } ``` **Usage:** ```dart sdk.getFlag(code:"theme"); ``` **Sample output:** ```dart { "code": "theme", "type": "string", "value": "pink", "is_default": false } ``` ### `getBooleanFlag` Get a boolean flag from the feature_flags claim of the `access_token` **Arguments:** ```dart code : "string" defaultValue? : boolean ``` **Usage:** ```dart sdk.getBooleanFlag(code:"is_dark_mode"); ``` **Sample output:** ```dart true or false ``` ### `getStringFlag` Get a string flag from the feature_flags claim of the `access_token` **Arguments:** ```dart code : "string" defaultValue? : "string ``` **Usage:** ```dart sdk.getStringFlag(code:"theme"); ``` **Sample output:** ```dart pink ``` ### `getIntegerFlag` Get an integer flag from the feature_flags claim of the `access_token` **Arguments:** ```dart code : "string" defaultValue? : number ``` **Usage:** ```dart sdk.getIntegerFlag(code:"team_count"); ``` **Sample output:** ```dart 2 ``` If you need help connecting to Kinde, contact us at [support@kinde.com](mailto:support@kinde.com).

# Developer tools - Sdks - iOS SDK

> Complete guide for iOS SDK including CocoaPods installation, multiple environment configuration, custom logging, and native iOS authentication integration.

ios sdk, swift, objective-c, cocoapods, appauth, multiple environments, custom logger, url schemes
developer-tools, sdks, ios, native

The Kinde iOS SDK allows developers to quickly and securely integrate a new or existing application into the Kinde platform. You can view the [Kinde iOS SDK](https://github.com/kinde-oss/kinde-sdk-ios) and [iOS starter kit](https://github.com/kinde-starter-kits/ios-starter-kit) in GitHub. ## Before you begin If you haven’t already got a Kinde account, [register for free here](https://app.kinde.com/register) (no credit card required). Registering gives you a Kinde domain, which you need to get started, e.g. `yourapp.kinde.com`. ## **Installation** KindeSDK is available through [CocoaPods](https://cocoapods.org/). To install it, add the following line to your Podfile: ```ruby pod 'KindeSDK' ``` Please note that `KindeSDK` is typically used with CocoaPods dynamic linking (`use_frameworks!`), as it takes a dependency on `AppAuth`. If integrating with other pods that require static linking, follow the instructions provided by CocoaPods. ## **Kinde configuration** ### Callback URLs Here you want to put in the callback URLs for your iOS app: 1. In Kinde, go to **Settings > Applications > [your app] > View details**. 2. Add your callback URLs in the relevant fields. For example: - Allowed callback URLs (also known as redirect URIs): `<your_url_scheme>://kinde_callback` - Allowed logout redirect URLs: `<your_url_scheme>://kinde_logoutcallback` 3. Select **Save**. Note: `your_url_scheme` can be any valid custom URL scheme, such as your app's bundle ID or an abbreviation. It must match the scheme component of the **Allowed callback URLs** (redirect URIs) and **Allowed logout redirect URLs** you configured in the [Application details](/get-started/connect/getting-app-keys/) page for your Kinde application. ### **Environments** If you would like to use our Environments feature as part of your development process. You will need to create them first within your Kinde account. In this case you would use the Environment subdomain in the code block above. ## Configuring your app ### **Environment variables** The Kinde `Auth` service is configured with an instance of the `Config` class. The example uses the bundled `kinde-auth.json` for configuration. To get the details, go to **Settings > Applications > [your app] > View details**. Then scroll to the **App keys** section. - `issuer`: your Kinde domain - `clientId` - you can find this on the **Application details** page - `redirectUri` (**Allowed callback URL**): After the user authenticates we will callback to this address. Make sure this URL is under your allowed callback URLs. - `postLogoutRedirectUri` (**Allowed logout redirect URL**): where you want users to be redirected to after logging out. Make sure this URL is under your allowed logout redirect URLs. ```swift { "issuer": "https://<your-business>.kinde.com", "clientId": "<your-client-id>", "redirectUri": "<your-url-scheme>://kinde_callback", "postLogoutRedirectUri": "<your-url-scheme>://kinde_logoutcallback", "scope": "offline openid email profile" } ``` Replace the values in \<angle brackets> with your own values. For example: ```swift { "issuer": "https://app.kinde.com", "clientId": "abc@live", "redirectUri": "com.example.App://kinde_callback", "postLogoutRedirectUri": "com.example.App://kinde_logoutcallback", "scope": "offline openid email profile" } ``` ## Integrate with your app Before `KindeSDKAPI.auth` can be used, a call to `KindeSDKAPI.configure()` must be made, typically in `AppDelegate` as part of `application(launchOptions)` for a UIKit app, or the `@main` initialization logic for a SwiftUI app. `AppDelegate.swift` ```swift ... import KindeSDK ... class AppDelegate: UIResponder, UIApplicationDelegate { ... func application(...) { ... // The Kinde authentication service must be configured before use KindeSDKAPI.configure(Logger()) ... } ... } ``` ## Multiple environments You may need to test or deploy your app across different environments, such as development, staging, or production. The Kinde iOS SDK now supports configuration for multiple environments, allowing you to easily switch between them. Follow these steps to set up and configure environments in your Kinde account and integrate them into your iOS app. > **Note:** Unless you are on a Kinde Plus or Scale plan, you can only create one additional non-production environment. ### Setting up environments Before you can configure multiple environments in your iOS app, you must first create these environments in your Kinde dashboard. After setting up your environments, create an application under each environment. You will get different App Details (such as issuer, clientId, redirectUri, etc.) for each environment you create. These details will be used to configure your iOS app for the specific environment. - On the Kinde home page, click the **Environment** dropdown in the top-left corner and select **All environments**. - Click **Add environment** and follow the prompts to create each new non-production environment (**deployment, staging, etc**). - For each environment, create a new application under the respective environment. - After creating the app, you'll receive different **App Details** (such as `issuer`, `clientId`, `redirectUri`, etc.) for each environment. ### Configuring multiple environments Once the environments are set up in your Kinde dashboard, you can configure your iOS app to handle multiple environments by using a JSON file for each environment. Create a JSON file for each environment in your project. For example: - `kinde-auth-production.json` - `kinde-auth-development.json` - `kinde-auth-staging.json` (if applicable) Each file should contain the configuration details for that specific environment. Here's an example configuration: ```json { "issuer": "https://<your-business>.kinde.com", "clientId": "<your-client-id>", "redirectUri": "<your-url-scheme>://kinde_callback", "postLogoutRedirectUri": "<your-url-scheme>://kinde_logoutcallback", "scope": "offline openid email profile" } ``` To set up multiple environments in your iOS app, use the `KindeSDKAPI.configure()` method and pass the environment configuration file name. Here's how to do it: #### Example: switch to the production environment ```swift // Use the 'production' environment configuration KindeSDKAPI.configure(fileName: "kinde-auth-production") ``` #### Example: switch to the development environment ```swift // Switch to the 'development' environment KindeSDKAPI.configure(fileName: "kinde-auth-development") ``` To switch to a different environment, simply change the configuration file name in the `KindeSDKAPI.configure()` method. ## Custom Logger (Optional) You can use your own Custom Logger as well by extending `LoggerProtocol`. `CustomLogger.swift` ```swift ... import os.log import KindeSDK ... struct CustomLogger: LoggerProtocol { ..... ..... func log(_ message: String) { print("[INFO]: \(message)") } func log(error: Error) { print("[ERROR]: \(error.localizedDescription)") } } ``` ## Login and register The Kinde client provides methods for an easy to implement login / register flow. You can add buttons in your view as follows: (we’re using UIKit). ```swift ... import KindeSDK ... override func viewDidLoad() { ... view.addSubview(signInButton) view.addSubview(signUpButton) signInButton.addTarget(self, action: #selector(signIn), for: .primaryActionTriggered) signUpButton.addTarget(self, action: #selector(register), for: .primaryActionTriggered) ... } @objc private func signIn(_ target: UIButton) { KindeSDKAPI.auth.login { result in switch result { case let .failure(error): if !KindeSDKAPI.auth.isUserCancellationErrorCode(error) { self.alert("Login failed: \(error.localizedDescription)") } case .success: // Do something here } } } @objc private func register(_ target: UIButton) { KindeSDKAPI.auth.register { result in switch result { case let .failure(error): if !KindeSDKAPI.auth.isUserCancellationErrorCode(error) { self.alert("Registration failed: \(error.localizedDescription)") } case .success: // Do something here } } } ``` ## Handle redirect Once your user is redirected back to your site from Kinde (it means you’ve logged in successfully), use the `getToken` method from `KindeSDKAPI` class to get a user token from Kinde. Let's look at an example of successful login. ```swift KindeSDKAPI.auth.login { result in switch result { case let .failure(error): if !KindeSDKAPI.auth.isUserCancellationErrorCode(error) { self.alert("Login failed: \(error.localizedDescription)") } case .success: self.onLoggedIn() // Calling this function } } func onLoggedIn() { self.isAuthenticated = true self.getToken() } private func getToken() { Task { await asyncGetToken() } } private func asyncGetToken() async -> String { do { let token = try await KindeSDKAPI.auth.getToken() return token } catch { return " } } ``` ## Logout This is implemented in much the same way as logging in or registering. The Kinde SPA client comes with a logout method. ```swift @objc private func logout(_ target: UIButton) { KindeSDKAPI.auth.logout { result in if result { // Do something } } } ``` ## Get user information To access the user information, use the `getUserDetails` helper function: ```swift KindeSDKAPI.auth.getUserDetails() // User(id: 1233, email: "dave@smith.com", given_name: "Dave", family_name: "Smith") ``` ## View users in Kinde Navigate to the **Users** page within Kinde to see your newly registered user. ## User Permissions Once a user has been verified, your application will be returned the JWT token with an array of permissions for that user. You will need to configure your application to read permissions and unlock the respective functions. You set [Permissions](/manage-users/roles-and-permissions/user-permissions/) in your Kinde account, the below is an example set of permissions. ```swift let permissions = [ "create:todos", "update:todos", "read:todos", "delete:todos", "create:tasks", "update:tasks", "read:tasks", "delete:tasks", ]; ``` We provide helper functions to more easily access permissions: ```swift KindeSDKAPI.auth.getPermission(name: "create:todos"); // Permission(organization: Organization(code: "org_1234"), isGranted: true) KindeSDKAPI.auth.getPermissions(); // Permissions(organization: Organization(code: "org_1234"), permissions: ["create:todos", "update:todos", "read:todos"]) ``` A practical example in code might look something like: ```swift let isGranted = KindeSDKAPI.auth.getPermission(name: "create:todos")?.isGranted ?? false if isGranted { // show Create Todo button in UI } ``` ## Audience An `audience` is the intended recipient of an access token - for example the API for your application. The audience argument can be passed to the Kinde client to request an audience be added to the provided token. The audience of a token is the intended recipient of the token. ```swift { "issuer": "https://<your-business>.kinde.com", "clientId": "<your-client-id>", "redirectUri": "<your-url-scheme>://kinde_callback", "postLogoutRedirectUri": "<your-url-scheme>://kinde_logoutcallback", "scope": "offline openid email profile", "audience": "api.yourapp.com" } ``` For details on how to connect, see [Register an API](/developer-tools/your-apis/register-manage-apis/) ## Overriding scope By default the `KindeSDK` requests the following scopes: - `profile` - `email` - `offline` - `openid` You can override this by passing scope into the KindeSDK ```swift { "issuer": "https://<your-business>.kinde.com", "clientId": "<your-client-id>", "redirectUri": "<your-url-scheme>://kinde_callback", "postLogoutRedirectUri": "<your-url-scheme>://kinde_logoutcallback", "scope": "offline openid email profile", "audience": "api.yourapp.com" } ``` ## Getting claims We have provided a helper to grab any claim from your id or access tokens. The helper defaults to access tokens: ```swift KindeSDKAPI.auth.getClaim(key: "aud"); // ["api.yourapp.com"] KindeSDKAPI.auth.getClaim(key: "given_name", token: .idToken); // "David ``` ## Organizations ### Create an organization To create a new organization in your application, you will need to run a similar function to below: ```swift @objc private func createOrg(_ target: UIButton) async { do { try await KindeSDKAPI.auth.createOrg(orgName: "Your Organization") } catch { ... } } ``` ### Sign in and sign up to organizations Kinde has a unique code for every organization. You’ll have to pass this code through when you register a new user. Example function below: ```swift KindeSDKAPI.auth.register(orgCode: "your_org_code"); ``` If you want a user to sign in into a particular organization, pass this code along with the sign in method. ```swift KindeSDKAPI.auth.login(orgCode: "your_org_code"); ``` Following authentication, Kinde provides a `json web token (jwt)` to your application. Along with the standard information we also include the org_code and the permissions for that organization (this is important as a user can belong to multiple organizations and have different permissions for each). Example of a returned token: ```json { "aud": [], "exp": 1658475930, "iat": 1658472329, "iss": "https://your_subdomain.kinde.com", "jti": "123457890", "org_code": "org_1234", "permissions": ["read:todos", "create:todos"], "scp": ["openid", "profile", "email", "offline"], "sub": "kp:123457890" } ``` The `id_token` will also contain an array of organizations that a user belongs to - this is useful if you wanted to build out an organization switcher for example. ```json { ... "org_codes": ["org_1234", "org_4567"] ... } ``` There are two helper functions you can use to extract information: ```swift KindeSDKAPI.auth.getOrganization(); // Organization(code: "org_1234") KindeSDKAPI.auth.getUserOrganizations(); // UserOrganizations(orgCodes: [Organization(code: "org_1234"), Organization(code: "org_abcd")]) ``` For more information about how organizations work in Kinde, see [Kinde organizations for developers](/build/organizations/orgs-for-developers/). ## Feature flags We have provided a helper to return any features flag from the access token: ```swift KindeSDKAPI.auth.getFlag(code: "theme") // returns Flag(code: "theme", type: Optional(KindeSDK.Flag.ValueType.string), value: black, isDefault: false) KindeSDKAPI.auth.getFlag(code: "no-feature-flag") // returns notFound KindeSDKAPI.auth.getFlag(code: "no-feature-flag", defaultValue: "default-value") // returns Flag(code: "no-feature-flag", type: nil, value: "default-value", isDefault: true) KindeSDKAPI.auth.getFlag(code: "no-feature-flag", defaultValue: "default-value", flagType: Flag.ValueType.bool) // returns incorrectType("Flag \"theme\" is type string - requested type boolean") ``` We also require wrapper functions by type which should leverage `getFlag` above. ### **Get boolean flags** ```swift KindeSDKAPI.auth.getBooleanFlag(code: "is_dark_mode") // true KindeSDKAPI.auth.getBooleanFlag(code: "is_dark_mode", defaultValue: false) // true KindeSDKAPI.auth.getBooleanFlag(code: "new_feature") // notFound KindeSDKAPI.auth.getBooleanFlag(code: "new_feature", defaultValue: false) // false KindeSDKAPI.auth.getBooleanFlag(code: "theme") // incorrectType("Flag \"theme\" is type string - requested type boolean") ``` ### **Get string flags** ```swift KindeSDKAPI.auth.getStringFlag(code: "theme") // pink KindeSDKAPI.auth.getStringFlag(code: "theme", defaultValue: "black") // pink KindeSDKAPI.auth.getStringFlag(code: "cta_color") // notFound KindeSDKAPI.auth.getStringFlag(code: "cta_color", defaultValue: "blue") // blue KindeSDKAPI.auth.getStringFlag(code: "is_dark_mode") // incorrectType("Flag \"is_dark_mode\" is type boolean - requested type string") ``` ### **Get integer flags** ```swift KindeSDKAPI.auth.getIntegerFlag(code: "user_limit") // 5 KindeSDKAPI.auth.getIntegerFlag(code: "user_limit", defaultValue: 3) // 5 KindeSDKAPI.auth.getIntegerFlag(code: "team_count") // notFound KindeSDKAPI.auth.getIntegerFlag(code: "team_count", defaultValue: 4) // 4 KindeSDKAPI.auth.getIntegerFlag(code: "is_dark_mode") // incorrectType("Flag \"is_dark_mode\" is type boolean - requested type interger") ``` ### Token Storage Once the user has successfully authenticated, you'll have a JWT and a refresh token and that has been stored securely. ## SDK API Reference ### `issuer` Either your Kinde URL or your custom domain. e.g `https://yourapp.kinde.com`. Type: `string` Required: Yes ### `redirectUri` The URL that the user will be returned to after authentication. Type: `string` Required: Yes ### `clientId` The unique ID of your application in Kinde. Type: `string` Required: Yes ### `postLogoutRedirectUri` Where your user will be redirected when they sign out. Type: `string` Required: No ### `scope` The scopes to be requested from Kinde. Type: `string` Required: No Default: `openid profile email offline` ### `audience` The audience claim for the JWT. Type: `string` Required: No ## **KindeSDK** methods ### `login` Constructs redirect url and sends user to Kinde to sign in. Arguments: ```swift orgCode?: String ``` Usage: ```swift KindeSDKAPI.auth.login(); or KindeSDKAPI.auth.login(orgCode: “your organization code”) // ``` Allow `orgCode` to be provided if a specific org is signed in to. ### `register` Constructs redirect url and sends user to Kinde to sign up. Arguments: ```swift orgCode?: String ``` Usage: ```swift KindeSDKAPI.auth.register(); or KindeSDKAPI.auth.register(orgCode: “your organization code”) // ``` Allow `orgCode` to be provided if a specific org is registered to. ### `enablePrivateAuthSession` Call this method before login/register process to enable or disable message prompt. Usage: ```jsx KindeSDKAPI.auth.enablePrivateAuthSession(true); ``` ### `logout` Logs the user out of Kinde. Usage: ```swift KindeSDKAPI.auth.logout(); ``` ### `getToken` Returns the raw token from URL after logged from Kinde. Usage: ```swift KindeSDKAPI.auth.getToken() ``` Sample output: ```swift eyJhbGciOiJSUzI... ``` ### `createOrg` Constructs a redirect URL and sends the user to Kinde to sign up and create a new organization in your business. Arguments: ```swift orgName: String ``` Usage: ```swift KindeSDKAPI.auth.createOrg(orgName: "Your Organization"); ``` ### `getClaim` Gets a claim from an access or ID token. Arguments: ```swift key: String, token: TokenType = .accessToken ``` Usage: ```swift KindeSDKAPI.auth.getClaim(key: ”given_name”, token: .idToken); ``` Sample output: `"David"` ### `getPermission` Returns the state of a given permission. Arguments: ```swift name: String ``` Usage: ```swift KindeSDKAPI.auth.getPermission(name: ”read:todos”); ``` Sample output: ```swift Permissions (organization: Organization(code: "org_1234"), isGranted: true) ``` ### `getPermissions` Returns all permissions for the current user for the organization they are signed into. Usage: ```swift KindeSDKAPI.auth.getPermissions(); ``` Sample output: ```swift Permissions (organization: Organization(code: "org_1234"), permissions: ["create:todos", "update:todos", "read:todos"]) ``` ### `getOrganization` Get details for the organization your user is signed into. Usage: ```swift KindeSDKAPI.auth.getOrganization(); ``` Sample output: ```swift Organization(code: "org_1234") ``` ### `getUserOrganizations` Gets an array of all organizations the user has access to. Usage: ```swift KindeSDKAPI.auth.getUserOrganizations(); ``` Sample output: ```swift UserOrganizations (orgCodes: [Organization(code: "org_1234"), Organization(code: "org_abcd")]) ``` ### `getUserDetails` Get details for the organization your user is signed into. Usage: ```swift KindeSDKAPI.auth.getOrganization(); ``` Sample output: ```swift User (id: 1233, email: "dave@smith.com", given_name: "Dave", family_name: "Smith") ``` ### `isAuthenticated` Return the boolean to demonstrate whether the user is authenticated or not. Usage: ```swift KindeSDKAPI.auth.isAuthenticated() ``` Sample output: `true` or `false` ### `getFlag` Get a flag from the feature_flags claim of the `access_token` Arguments: ```swift code: String defaultValue?: Any flagType?: Flag.ValueType ``` Usage: ```swift KindeSDKAPI.auth.getFlag(code: "theme") ``` Sample output: ```swift Flag(code: "theme", type: Optional(KindeSDK.Flag.ValueType.string), value: black, isDefault: false) ``` ### **`getBooleanFlag`** Get a boolean flag from the `feature_flags` claim of the access token Arguments: ```swift code: String defaultValue?: String ``` Usage: ```swift KindeSDKAPI.auth.getBooleanFlag(code: "is_dark_mode") ``` Sample output: `true` ### **`getStringFlag`** Get a string flag from the `feature_flags` claim of the access token Arguments: ```swift code: String defaultValue?: String ``` Usage: ```swift KindeSDKAPI.auth.getStringFlag(code: "theme") ``` Sample output: `pink` ### **`getIntegerFlag`** Get a integer flag from the `feature_flags` claim of the access token Arguments: ```swift code: String defaultValue?: String ``` Usage: ```swift KindeSDKAPI.auth.getIntegerFlag(code: "user_limit") ``` Sample output: `5` If you need help connecting to Kinde, contact us at [support@kinde.com](mailto:support@kinde.com).

# Developer tools - Sdks - React Native SDK

> Comprehensive guide for React Native SDK including Android/iOS setup, native linking, Expo compatibility, and mobile authentication integration.

react native sdk, mobile authentication, android setup, ios setup, expo compatibility, native linking, cocoapods
developer-tools, sdks, react-native, native

The Kinde React Native SDK allows developers to quickly and securely integrate a new or an existing React Native application into the Kinde platform. ## Supported versions ### React Native SDK 0.6x **`Kinde React Native SDK 0.6x`** is compatible with React Native versions 0.60 to 0.69. - GitHub: [kinde-react-native-sdk-0-6x](https://github.com/kinde-oss/kinde-react-native-sdk-0-6x) - NPM: [@kinde-oss/react-native-sdk-0-6x](https://www.npmjs.com/package/@kinde-oss/react-native-sdk-0-6x) ### React Native SDK 0.7x **`Kinde React Native SDK 0.7x`** is compatible with React Native versions 0.70 or higher. - GitHub: [kinde-react-native-sdk-0-7x](https://github.com/kinde-oss/kinde-react-native-sdk-0-7x) - NPM: [@kinde-oss/react-native-sdk-0-7x](https://www.npmjs.com/package/@kinde-oss/react-native-sdk-0-7x) ### Expo **`Kinde React Native SDK 0.6x`** and **`Kinde React Native SDK 0.7x`** are designed to work well with Expo. You can easily incorporate them into your Expo projects by following the instructions provided in the [Expo and React Native SDK documentation](/developer-tools/sdks/native/expo/). Compatible versions: - Expo SDK version 46.0.0: Use [Kinde React Native SDK 0.6x](https://www.npmjs.com/package/@kinde-oss/react-native-sdk-0-6x) - Expo SDK version 47.0.0 or higher: Use [Kinde React Native SDK 0.7x](https://www.npmjs.com/package/@kinde-oss/react-native-sdk-0-7x) You can also check out our starter kits on GitHub: - [Starter kit for Kinde React Native SDK 0.6x](https://github.com/kinde-starter-kits/kinde-react-native-starter-kit-0-6x) - [Starter kit for Kinde React Native SDK 0.7x](https://github.com/kinde-starter-kits/kinde-react-native-starter-kit-0-7x) ## Before you begin - If you haven’t already got a Kinde account, [register for free here](https://app.kinde.com/register) (no credit card required). Registering gives you a Kinde domain, which you need to get started, e.g. `yourapp.kinde.com`. - You will also need Node, the React Native command line interface, a JDK, Android Studio (for Android) and Xcode (for iOS). - Follow [the installation instructions for your chosen OS](https://reactnative.dev/docs/environment-setup) to install dependencies. <Aside type="warning" title="Important"> Fundamentally, both SDK versions have equivalent functionality, so there should be no issue integrating either of them. In this guide, we use examples from version 0.7x. But version 0.6x is identical in terms of integration and application. </Aside> ## **Installation** <PackageManagers pkg="@kinde-oss/react-native-sdk-0-7x" /> ### **Android** The SDK requires the `react-native-keychain` and `react-native-inappbrowser-reborn` packages. Sometimes, they may not be automatically linked correctly, resulting in errors when running your app, such as `"Cannot read properties of undefined (reading 'isAvailable')"`. In such cases, you will need to manually link them: 1. Edit `android/settings.gradle` ```java include ':react-native-keychain' project(':react-native-keychain').projectDir = new File(rootProject.projectDir, '../node_modules/react-native-keychain/android') include ':react-native-inappbrowser-reborn' project(':react-native-inappbrowser-reborn').projectDir = new File(rootProject.projectDir, '../node_modules/react-native-inappbrowser-reborn/android') ``` 2. Edit `android/app/build.gradle` ```java apply plugin: 'com.android.application' android { ... } dependencies { ... implementation project(':react-native-keychain') implementation project(':react-native-inappbrowser-reborn') ... } ``` 3. Edit `MainApplication.java` ```java import com.oblador.keychain.KeychainPackage; import com.proyecto26.inappbrowser.RNInAppBrowserPackage; ... public class MainApplication extends Application implements ReactApplication { private final ReactNativeHost mReactNativeHost = new ReactNativeHost(this) { ... @Override protected List<ReactPackage> getPackages() { ... List<ReactPackage> packages = new PackageList(this).getPackages(); packages.add(new KeychainPackage()); packages.add(new RNInAppBrowserPackage()); ... return packages; } ... }; ... } ``` In React Native version 0.73 or above, the `MainApplication.java` file has been replaced with `MainApplication.kt` ```kotlin import com.oblador.keychain.KeychainPackage; import com.proyecto26.inappbrowser.RNInAppBrowserPackage; ... class MainApplication : Application(), ReactApplication { override val reactNativeHost: ReactNativeHost = object : DefaultReactNativeHost(this) { override fun getPackages(): List<ReactPackage> = PackageList(this).packages.apply { // Packages that cannot be autolinked yet can be added manually here, for example: // add(MyReactNativePackage()) add(KeychainPackage()); add(RNInAppBrowserPackage()); } ... } ... } ``` ### **iOS** To update iOS native dependencies, you can use **CocoaPods**. We recommend installing **CocoaPods** using [Homebrew](https://brew.sh/). ```shell brew install cocoapods cd ios && pod install ``` The SDK requires the `react-native-keychain` and `react-native-inappbrowser-reborn` packages. Sometimes, they may not be automatically linked correctly, resulting in errors when running your app, such as `"Cannot read properties of undefined (reading 'isAvailable')"`. In such cases, you will need to manually link them: 1. **Option: With CocoaPods (Highly recommended)** Please add the following lines to your **Podfile**, and then run `pod update`: ```swift pod 'RNKeychain', :path => '../node_modules/react-native-keychain' pod 'RNInAppBrowser', :path => '../node_modules/react-native-inappbrowser-reborn' ``` 2. **Option: Manually link the packages with Xcode** - Go to the **Build Phases** tab and choose **Link Binary With Libraries.** - Select **+** - Add **Other** > **Add Files** > **node_modules/react-native-keychain/RNKeychain.xcodeproj** (similar with **RNInAppBrowser**) - Add **libRNKeychain.a** (similar with **RNInAppBrowser**) - Clean and rebuild. If you encounter any errors during the SDK installation process, you can refer to the General Tips section at the end of this topic. ## K**inde configuration** 1. In Kinde, go to **Settings > Applications.** 2. Select **View details** on the **Front-end app**. 3. Scroll down to the **Callback URLs** section. 4. Add in the callback URLs for your React Native app, which should look something like this: - Allowed callback URLs - `myapp://myhost.kinde.com/kinde_callback` - Allowed logout redirect URLs - `myapp://myhost.kinde.com/kinde_callback` Make sure you press the Save button at the bottom of the page! Note: The `myapp://myhost.kinde.com/kinde_callback` is used as an example of local URL Scheme, change to the local local URL Scheme that you use. ## Environments If you would like to use our Environments feature as part of your development process. You will need to create them first within your Kinde account. In this case you would use the Environment subdomain in the code block above. ## Configure your app ### **Environment variables** Put these variables in your .env file. You can find these variables on the same page as where you set the callback URLs. - `KINDE_ISSUER_URL` - your Kinde domain - `KINDE_POST_CALLBACK_URL` - After the user authenticates we will callback to this address. Make sure this URL is under your allowed callback URLs - `KINDE_POST_LOGOUT_REDIRECT_URL` - where you want users to be redirected to after logging out. Make sure this URL is under your allowed logout redirect URLs - `KINDE_CLIENT_ID` - you can find this on the App Keys page ```typescript KINDE_ISSUER_URL=https://your_kinde_domain.kinde.com KINDE_POST_CALLBACK_URL=myapp://your_kinde_domain.kinde.com/kinde_callback KINDE_POST_LOGOUT_REDIRECT_URL=myapp://your_kinde_domain.kinde.com/kinde_callback KINDE_CLIENT_ID=your_kinde_client_id ``` Configuration example: ```typescript KINDE_ISSUER_URL=https://myhost.kinde.com KINDE_POST_CALLBACK_URL=myapp://myhost.kinde.com/kinde_callback KINDE_POST_LOGOUT_REDIRECT_URL=myapp://myhost.kinde.com/kinde_callback KINDE_CLIENT_ID=myclient@live ``` ## Configuration deep link ### **Android** Open `AndroidManifest.xml` and update your scheme by adding a new block in activity. ```xml <intent-filter> <action android:name="android.intent.action.VIEW" /> <category android:name="android.intent.category.DEFAULT" /> <category android:name="android.intent.category.BROWSABLE" /> <data android:scheme="myapp" android:host="your_kinde_host" /> // Please modify sheme and host to reflect your preferences. </intent-filter> ``` ### **iOS** You need to link `RCTLinking` to your project using the steps below. 1. If you also want to listen to incoming app links during your app's execution, add the following lines to your `AppDelegate.m`. ```swift // iOS 9.x or newer #import <React/RCTLinkingManager.h> - (BOOL)application:(UIApplication *)application openURL:(NSURL *)url options:(NSDictionary<UIApplicationOpenURLOptionsKey,id> *)options { return [RCTLinkingManager application:application openURL:url options:options]; } ``` 2. If you're targeting iOS 8.x or older, use the following code instead. ```swift // iOS 8.x or older #import <React/RCTLinkingManager.h> - (BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(NSString *)sourceApplication annotation:(id)annotation { return [RCTLinkingManager application:application openURL:url sourceApplication:sourceApplication annotation:annotation]; } ``` 3. Make sure you have a configuration URL scheme in `Info.plist`, so the app can be opened by deep link. ```swift <key>CFBundleURLTypes</key> <array> <dict> <key>CFBundleTypeRole</key> <string>Editor</string> <key>CFBundleURLName</key> <string>myapp</string> // you can change it <key>CFBundleURLSchemes</key> <array> <string>myapp</string> // you can change it </array> </dict> </arra ``` ## Integrate with your app To create a new instance of the KindeSDK object, execute the code below. ```typescript import { KindeSDK } from '@kinde-oss/react-native-sdk-0-7x'; ... ... const client = new KindeSDK(YOUR_KINDE_ISSUER, YOUR_KINDE_REDIRECT_URI, YOUR_KINDE_CLIENT_ID, YOUR_KINDE_LOGOUT_REDIRECT_URI); ``` ## Sign in and registration Kinde provides methods for easily implementing a login / register flow. You can add buttons as follows. ```typescript <View> <View> <Button title="Sign In" onPress={handleSignIn} /> </View> <View> <Button title="Sign Up" color="#000" onPress={handleSignUp} /> </View> </View> ``` Then define new functions that match for each button. **Note**: Before proceeding, make sure you’ve defined the **KindeSDK** as a **client** variable. ```typescript ... const handleSignUp = async () => { const token = await client.register(); if (token) { // User was authenticated } }; const handleSignIn = async () => { const token = await client.login(); if (token) { // User was authenticated } }; ... ``` ## **Log out** This is implemented in much the same way as signing in or registering. The Kinde SPA client comes with a logout method: ```typescript const handleLogout = async () => { const loggedOut = await client.logout(); if (loggedOut) { // User was logged out } }; ``` We have also implemented an API for token revocation. Pass `true` as an argument in the `logout` function. This flag will assist in revoking the token without having to open the website within your apps. ```typescript const handleLogout = async () => { const loggedOut = await client.logout(true); if (loggedOut) { // User was logged out } }; ``` **Note: Handle redirects are now deprecated** Starting from version 1.1 of the SDK, the need to handle redirects has been eliminated. Authentication is now performed by launching a web browser within your app instead of relying on an external browser. For a comprehensive example of how to handle authentication, see below. ## **Full code sample for authentication** ```typescript const checkAuthenticate = async () => { // Using `isAuthenticated` to check if the user is authenticated or not if (await client.isAuthenticated) { // Need to implement, e.g: call an api, etc... } else { // Need to implement, e.g: redirect user to sign in, etc.. } }; useEffect(() => { checkAuthenticate(); }, []); const handleSignIn = async () => { const token = await client.login(); if (token) { // Need to implement, e.g: call an api, etc... } }; const handleSignUp = async () => { const token = await client.register(); if (token) { // Need to implement, e.g: call an api, etc... } }; const handleLogout = async () => { // With open web in your apps const isLoggedOut = await client.logout(); if (isLoggedOut) { // Need to implement, e.g: redirect user to login screen, etc... } // Without open web in your apps const isLoggedOut = await client.logout(); if (isLoggedOut) { // Need to implement, e.g: redirect user to login screen, etc... } }; ``` ## **Get user information** To access the user information, use the `getUserDetails` helper function. ```typescript const userProfile = await client.getUserDetails(); console.log(userProfile); // output: {"given_name":"Dave","id":"abcdef","family_name":"Smith","email":"dave@smith.com"} ``` ## View users in Kinde Go to the Users page in Kinde to see your newly registered user. ### User Permissions Once a user has been verified, your product/application will return the JWT token with an array of permissions for that user. You will need to configure your product/application to read permissions and unlock the respective functions. [Set permissions](/manage-users/roles-and-permissions/user-permissions/) in your Kinde account. Here’s an example set of permissions. ```typescript const permissions = [ "create:todos", "update:todos", "read:todos", "delete:todos", "create:tasks", "update:tasks", "read:tasks", "delete:tasks ]; ``` We provide helper functions to more easily access permissions. ```typescript await client.getPermission("create:todos"); // {orgCode: "org_1234", isGranted: true} await client.getPermissions(); // {orgCode: "org_1234", permissions: ["create:todos", "update:todos", "read:todos"]} ``` A practical example in code might look something like. ```typescript if ((await client.getPermission("create:todos")).isGranted) { // show Create Todo button in UI } ``` ## Audience An audience is the intended recipient of an access token - for example the API for your application. The audience argument can be passed to the Kinde client to request an audience be added to the token. The audience of a token is the intended recipient of the token. ```typescript const client = new KindeSDK( YOUR_KINDE_ISSUER, YOUR_KINDE_REDIRECT_URI, YOUR_KINDE_CLIENT_ID, YOUR_KINDE_LOGOUT_REDIRECT_URI, YOUR_SCOPES, { audience: "api.yourapp.com" } ); ``` For details on how to connect, see [Register an API](/developer-tools/your-apis/register-manage-apis/). ## Overriding scope By default the `KindeSDK` requests the following scopes: - profile - email - offline - openid You can override this by passing scope into the KindeSDK. ```typescript const client = new KindeSDK( YOUR_KINDE_ISSUER, YOUR_KINDE_REDIRECT_URI, YOUR_KINDE_CLIENT_ID, YOUR_KINDE_LOGOUT_REDIRECT_URI, "profile email offline openid ); ``` ## Getting claims We have provided a helper to grab any claim from your id or access tokens. The helper defaults to access tokens: ```typescript await client.getClaim("aud"); // { name: "aud", value ["api.yourapp.com"] } await client.getClaim("given_name", "id_token"); // { name: "given_name", value: "David" } ``` ## Organizations ### Create an organization To create a new organization within your application, you will need to run a similar function to this. ```typescript <Button title="Create Organization" onPress={handleCreateOrg} /> ``` Then define the function of the button. Make sure you've already defined `KindeSDK` as the **client** in the state. ```typescript const handleCreateOrg = () => { client.createOrg(); }; // You can also pass `org_name` as your organization client.createOrg({org_name: "Your Organization"}); ``` ### Sign in and sign up to organizations Kinde has a unique code for every organization. You’ll have to pass this code through when you register a new user. Example function below: ```typescript client.register({orgCode: "your_org_code"}); ``` If you want a user to sign in into a particular organization, pass this code along with the sign in method. ```typescript client.login({orgCode: "your_org_code"}); ``` Following authentication, Kinde provides a json web token (jwt) to your application. Along with the standard information we also include the `org_code` and the permissions for that organization (this is important as a user can belong to multiple organizations and have different permissions for each). Example of a returned token: Example of a returned token: ```typescript { "aud": [], "exp": 1658475930, "iat": 1658472329, "iss": "https://your_subdomain.kinde.com", "jti": "123457890", "org_code": "org_1234", "permissions": ["read:todos", "create:todos"], "scp": ["openid", "profile", "email", "offline"], "sub": "kp:123457890" } ``` The `id_token` will also contain an array of organizations that a user belongs to - this is useful if you wanted to build out an organization switcher for example. ```typescript { ... "org_codes": ["org_1234", "org_4567"] ... } ``` There are two helper functions you can use to extract information. ```typescript await client.getOrganization(); // {orgCode: "org_1234"} await client.getUserOrganizations(); // {orgCodes: ["org_1234", "org_abcd"]} ``` For more information about how organizations work in Kinde, see [Kinde organizations for developers](/build/organizations/orgs-for-developers/). ## **Feature Flags** We have provided a helper to return any features flag from the access token: ```typescript client.getFlag('theme') // returns { "is_default": false "value": "pink", "code": "theme", "type": "string", } client.getFlag('no-feature-flag') // Error: This flag 'no-feature-flag' was not found, and no default value has been provided client.getFlag('no-feature-flag', 'default-value') // returns { "is_default": true "code": "no-feature-flag", "value": "default-value", } client.getFlag('theme', 'default-theme', 'b') // Error: Flag 'theme' is type string - requested type boolean ``` We also require wrapper functions by type which should leverage `getFlag` above. ### **Get boolean flags** ```typescript /** * Get a boolean flag from the feature_flags claim of the access_token. * @param {String} code - The name of the flag. * @param {Boolean} [defaultValue] - A fallback value if the flag isn't found. * @return {Boolean} */ kindeClient.getBooleanFlag(code, defaultValue); kindeClient.getBooleanFlag("is_dark_mode"); // true kindeClient.getBooleanFlag("is_dark_mode", false); // true kindeClient.getBooleanFlag("new_feature"); // Error: This flag 'new_feature' was not found, and no default value has been provided kindeClient.getBooleanFlag("new_feature", false); // false (flag does not exist so falls back to default) kindeClient.getBooleanFlag("theme", "blue"); // Error: Flag 'theme' is type string - requested type boolean ``` ### Get string flags ```typescript /** * Get a string flag from the feature_flags claim of the access_token. * @param {String} code - The name of the flag. * @param {String} [defaultValue] - A fallback value if the flag isn't found. * @return {String} */ kindeClient.getStringFlag(code, defaultValue); /* Example usage */ kindeClient.getStringFlag("theme"); // pink kindeClient.getStringFlag("theme", "black"); // true kindeClient.getStringFlag("cta_color"); // Error: This flag 'cta_color' was not found, and no default value has been provided kindeClient.getStringFlag("cta_color", "blue"); // blue (flag does not exist so falls back to default) kindeClient.getStringFlag("is_dark_mode", false); // Error: Flag 'is_dark_mode' is type string - requested type boolean ``` ### **Get integer flags** ```typescript /** * Get an integer flag from the feature_flags claim of the access_token. * @param {String} code - The name of the flag. * @param {Integer} [defaultValue] - A fallback value if the flag isn't found. * @return {Integer} */ kindeClient.getIntegerFlag(code, defaultValue); kindeClient.getIntegerFlag("competitions_limit"); // 5 kindeClient.getIntegerFlag("competitions_limit", 3); // 5 kindeClient.getIntegerFlag("team_count"); // Error: This flag 'team_count' was not found, and no default value has been provided kindeClient.getIntegerFlag("team_count", 2); // 2 (flag does not exist so falls back to default) kindeClient.getIntegerFlag("is_dark_mode", false); // Error: Flag 'is_dark_mode' is type boolean - requested type integer+ ``` ## Token Storage Once the user has successfully authenticated, you'll have a JWT and a refresh token and that has been stored securely. E.g. using the `getAccessToken` method of the `Storage` class to get an access token. ```typescript ... import { Storage } from '@kinde-oss/react-native-sdk-0-7x' ... const accessToken = await Storage.getAccessToken(); console.log('access_token', accessToken); ``` We're using the [react-native-keychain](https://www.npmjs.com/package/react-native-keychain) for `React Native` The storage handler can be found at: [Storage class](https://github.com/kinde-oss/kinde-react-native-sdk-0-7x/blob/main/dist/SDK/Storage/index.d.ts) ## **How to test** Run the test suite using the following command at the root of your React Native. ```shell npm run test ``` Note: Ensure you have already run `npm install`. ## SDK API Reference ### `issuer` Either your Kinde URL or your custom domain. e.g `https://yourapp.kinde.com`. Type: `string` Required: Yes ### `redirectUri` The URL that the user will be returned to after authentication. Type: `string` Required: Yes ### `clientId` The unique ID of your application in Kinde. Type: `string` Required: Yes ### `logoutRedirectUri` Where your user will be redirected when they sign out. Type: `string` Required: Yes ### `scope` The scopes to be requested from Kinde. Type: `boolean` Required: No Default: `openid profile email offline` ### `additionalParameters` Additional parameters that will be passed in the authorization request. Type: `object` Required: No Default: `{}` ### `additionalParameters` `- audience` The audience claim for the JWT. Type: `string` Required: No ### **KindeSDK** methods ### `login` Constructs a redirect URL and sends the user to Kinde to sign in. Arguments: ```typescript { audience?: string; isCreateOrg?: boolean; orgCode?: string; orgName?: string; connectionId?: string; lang?: string; loginHint?: string; } ``` Usage: ```typescript await kinde.login(); // or await kinde.login({orgCode: "your organization code"}); ``` Allow `orgCode` to be provided if a specific organization is being signed into. Sample output: ```typescript { "access_token": "eyJhbGciOiJSUzI...", "expires_in": 86400, "id_token": "eyJhbGciOiJSU...", "refresh_token": "yXI1bFQKbXKLD7AIU...", "scope": "openid profile email offline", "token_type": "bearer" } ``` ### `register` Constructs a redirect URL and sends the user to Kinde to sign up. Arguments: ```typescript { audience?: string; isCreateOrg?: boolean; orgCode?: string; orgName?: string; connectionId?: string; lang?: string; loginHint?: string; } ``` Usage: ```typescript await kinde.register(); // or await kinde.register({orgCode: "your organization code"}); ``` Allow `orgCode` to be provided if a specific organization is being registered to. Sample output: ```typescript { "access_token": "eyJhbGciOiJSUzI...", "expires_in": 86400, "id_token": "eyJhbGciOiJSU...", "refresh_token": "yXI1bFQKbXKLD7AIU...", "scope": "openid profile email offline", "token_type": "bearer" } ``` ### `logout` Logs the user out of Kinde. Arguments: ```typescript isRevoke: boolean; // default is false ``` Usage: ```typescript await kinde.logout(); // or await kinde.logout(true); ``` Sample output: `true` or `false` ### `getToken` Returns the raw Access token from URL after logged from Kinde. Arguments: ```typescript url?: string ``` Usage: ```typescript await kinde.getToken(url); // or await kinde.getToken(); ``` You need to have already authenticated. Otherwise, an error will occur. Sample output: ```typescript { "access_token": "eyJhbGciOiJSUzI...", "expires_in": 86400, "id_token": "eyJhbGciOiJSU...", "refresh_token": "yXI1bFQKbXKLD7AIU...", "scope": "openid profile email offline", "token_type": "bearer" } ``` ### `createOrg` Constructs a redirect URL and sends the user to Kinde to sign up and create a new organization in your business. Arguments: ```typescript { org_name?: string } ``` Usage: ```typescript await kinde.createOrg(); // or await kinde.createOrg({org_name: 'your organization name'}); _**//**_ ``` Allow `org_name` to be provided if you want a specific organization name when you create. Sample output: ```typescript { "access_token": "eyJhbGciOiJSUzI...", "expires_in": 86400, "id_token": "eyJhbGciOiJSU...", "refresh_token": "yXI1bFQKbXKLD7AIU...", "scope": "openid profile email offline", "token_type": "bearer" } ``` ### `getClaim` Gets a claim from an access or ID token. Arguments: ```typescript claim: string; tokenKey?: string ``` Usage: ```typescript await kinde.getClaim("given_name", "id_token"); ``` Sample output: ```typescript { name: "give_name", value: "David"} ``` ### `getPermission` Returns the state of a given permission. Arguments: `key: string` Usage: ```typescript await kinde.getPermission("read:todos"); ``` Sample output: ```typescript { "orgCode": "org_1234", "isGranted": true } ``` ### `getPermissions` Returns all permissions for the current user for the organization they are signed into. Usage: ```typescript await kinde.getPermissions(); ``` Sample output: ```typescript { "orgCode":"org_1234", "permissions": ["create:todos","update:todos","read:todos"] } ``` ### `getOrganization` Get details for the organization your user is signed into. Usage: ```typescript await kinde.getOrganization(); ``` Sample output: ```typescript { "orgCode": "org_1234" } ``` ### `getUserDetails` Returns the profile for the current user. Usage: ```typescript await kinde.getUserDetails(); ``` Sample output: ```typescript { "given_name": "Dave", "id": "abcdef", "family_name": "Smith", "email": "dave@smith.com" } ``` ### `getUserOrganizations` Gets an array of all organizations the user has access to. Usage: ```typescript await kinde.getUserOrganizations(); ``` Sample output: ```typescript { "orgCodes": ["org1234", "org5678"] } ``` ### `isAuthenticated` Return the boolean to demonstrate whether the user is authenticated or not. Usage: ```typescript await kinde.isAuthenticate; ``` Sample output: `true` or `false` ### **`getFlag`** Get a flag from the feature_flags claim of the `access_token`. Arguments: ```typescript flagName : string; options? : OptionalFlag = {} flagType? : FlagType type FlagType = 's' | 'b' | 'i'; type OptionalFlag = { defaultValue?: string | boolean | number } ``` Usage: ```typescript kinde.getFlag("theme"); ``` Sample output: ```typescript { "code": "theme", "type": "string", "value": "pink", "is_default": false } ``` ### **`getBooleanFlag`** Get a boolean flag from the `feature_flags` claim of the access token Arguments: ```typescript flagName: string defaultValue?: boolean ``` Usage: ```typescript kinde.getBooleanFlag("is_dark_mode"); ``` Sample output: `true` ### **`getStringFlag`** Get a string flag from the `feature_flags` claim of the access token Arguments: ```typescript flagName: string defaultValue?: string ``` Usage: ```typescript kinde.getStringFlag("theme"); ``` Sample output: `black` ### **`getIntegerFlag`** Get a integer flag from the `feature_flags` claim of the access token Arguments: ```typescript flagName: string defaultValue?: number ``` Usage: ```typescript kinde.getIntegerFlag("team_count"); ``` Sample output: `2` ## General tips ### **Building issues** **`'value'`** **is unavailable: introduced in iOS 12.0** If you got the error **'value' is unavailable: introduced in iOS 12.0** when trying to build the app, you can follow the below steps to fix that: 1. In your Xcode project navigator, select **Pods.** 2. Under Targets, select **React-Codegen**. 3. Select the **Build Settings** tab. 4. Under **Deployment**, set **iOS Deployment Target** to **12.4.** 5. Clean project and rebuild: **Product > Clean Build Folder, Product > Build.** <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/e441dff0-bc34-40a6-5854-2f390e805300/public" alt="" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" /> 6. Dependency `'androidx.browser:browser:1.6.0-beta01'` requires libraries and applications that depend on it to compile against version 34 or later of the Android APIs The solution is add `androidXBrowser = "1.4.0"` in your project. ```java // android/build.gradle buildscript { ... ext { // ... androidXBrowser = "1.4.0 // .... } ... } ``` 7. Duplicate class **kotlin.collections.jdk8.CollectionsJDK8Kt** found in modules **jetified-kotlin-stdlib-1.8.10** (org.jetbrains.kotlin:kotlin-stdlib:1.8.10) and **jetified-kotlin-stdlib-jdk8-1.7.22** (org.jetbrains.kotlin:kotlin-stdlib-jdk8:1.7.22) The solution is add `org.jetbrains.kotlin:kotlin-bom:1.8.0` dependency in your project. ```java // android/app/build.grade dependencies { ... implementation(platform("org.jetbrains.kotlin:kotlin-bom:1.8.0")) ... } ``` ### **Caching issues** Sometimes there will be issues related to caching when you develop React Native. There are some recommendations for cleaning the cache: 1. Remove `node_modules`, `yarn.lock` or `package-lock.json`. 2. Clean cache: `yarn cache clean` or `npm cache clean --force`. 3. Make sure you have changed values in `.env` file. 4. Trying to install packages again: `yarn install` or `npm install`. 5. Run Metro Bundler: `yarn start --reset-cache` or `npm start --reset-cache`. Assume your StarterKit path is `<StarterKit_PATH>`. **Clean cache for Android** - Run this: ```shell cd <StarterKit_PATH>/android ./gradlew clean ``` **Clean cache for iOS** 1. Run this: ```shell cd <StarterKit_PATH>/ios rm -rf Pods && rm Podfile.lock ``` 2. Clean build folders on **Xcode**. If you need help connecting to Kinde, please contact us at [support@kinde.com](mailto:support@kinde.com).

# Developer tools - Your apis - Give others access to your API

api access, m2m application, third party access, app keys, client credentials, audience
developer-tools, your-apis

There are a number of ways to provide your users with programmatic access to your API and applications via Kinde. You need to [register your API with Kinde](/developer-tools/your-apis/register-manage-apis/) before you begin. ## API access via an M2M application Here’s the process: - Create a machine to machine (M2M) application - Connect the application to your API - Provide access to the user via token or app keys ### Create a M2M application You will want to create a separate M2M application for each user, system, or business who needs to access your API. It is not secure to share access via the same tokens or app keys. 1. Go to **Settings > Applications.** 2. Select **Add Application**. 3. In the dialog that opens, give the application a name, and select **Machine to Machine** as the **Application type**. 4. Select **Save**. App keys - including **Domain** details, **Client ID** and **Client Secret** - are issued for the application. ### Authorize the API to access the application 1. In the application list, find the M2M app you created and select **View details**. 2. Select **APIs** in the menu. A list of all available APIs shows. 3. Select the three dots next to the API you want the application to access, and select **Authorize**. 4. Select **Save**. If you need to cut off access to your API for a user, select the three dots menu and select **Revoke authorization**. ## API access via API keys Allow users to manage their own API keys to access your API, including initializing the request, rotating, and deleting keys. Follow this [quickstart guide](/manage-your-apis/about-api-keys/api-keys-quick-start/). This is much more secure and preferable than manually copying the app keys from the M2M application and providing them to the third-party. ## Provide access via a token A third party can request a token using the relevant `audience` in the claim, for example: ```jsx POST https://yourbusiness.kinde.com/oauth2/token { "client_id": "XXX", "client_secret": "XXX", "grant_type": "client_credentials", "audience": "http://api.example.com/api" } ``` Granting access this way means you don't have to share the Client ID and Secret with anyone. ## Get a test token to test API access Follow this guide to [quickly generate a test token](/developer-tools/your-apis/test-token-from-kinde/) to test access to your API.

# Developer tools - Your apis - Manage API scopes for M2M applications

api scopes, m2m applications, granular access, permissions claim, token customization
developer-tools, your-apis

Kinde allows you to manage API scopes for your M2M applications, providing granular access control and better security between systems. You need to [register your API](/developer-tools/your-apis/register-manage-apis/) and [secure your API](/developer-tools/your-apis/custom-api-scopes/) before you can do this. ## Enable API scopes for an application 1. Go to **Settings > Applications** and select **View details** on the relevant application. 2. Select **APIs** in the side menu. 3. If the application is not yet authorized, select the three dots menu next to the API you’re giving the app access to, and then select **Authorize application**. 4. In the same three dots menu, select **Manage scopes**. 5. In the window that opens, switch on or off the scopes allowed for the application. 6. Select **Save**. ## Include scopes in the permissions claim You can include API scopes in the `permissions` claim and add them as part of the user’s access token. 1. Open the relevant M2M application and select **Tokens** in the menu. 2. Scroll to the **Token customization** section and select **Customize** on the **M2M token**. 3. In the dialog, switch on **Include API scopes in the permissions claim**. 4. Select **Save**.

# Developer tools - Your apis - Secure your API using scopes

custom scopes, api security, granular control, permissions, authorization, scope management
developer-tools, your-apis

<Aside type="upgrade"> You must be on the [Kinde Plus or Scale plan](https://kinde.com/pricing/) to use this feature. </Aside> Kinde lets you add custom scopes to help manage others who access to your APIs. Scopes define token permissions used by your APIs, and provide a reliable way to control access to your API resources. You need to have [registered your APIs](/developer-tools/your-apis/register-manage-apis/) in Kinde to secure them using scopes. <Aside> Note that this topic is NOT about adding custom scopes for the Kinde Management API, it is only related to adding custom scopes to your own APIs. For information about Kinde Management API scopes, see [this topic](/developer-tools/kinde-api/connect-to-kinde-api/). </Aside> ## Benefits of using scopes - **Granular control**: Instead of broad permissions like `read` or `write`, you can create scopes tailored to different levels of access, such as `read:userprofile` or `write:roles`. - **Security**: You only need to grant the permissions necessary for each operation, minimizing the risk of unauthorized access to sensitive data or actions within your system. - **Flexibility**: As your application grows and requirements change, you can easily add, remove, or modify scopes without affecting other parts of your system. - **Better UX**: They simplify the authorization process and improve overall user experience. - **Compliance**: They help you align with regulatory requirements or industry standards by ensuring that access to sensitive data is properly managed and audited. ## Add scopes to an API 1. In Kinde, go to **Settings > APIs**. 2. Select **View details** on the API you want to add scopes for. 3. In the menu, select **Scopes**. 4. Select **Add scope**. 5. In the **Add scope** window, enter a name for the scope. This will be the name you use in your code to recognize the scope. We recommend following a consistent naming convention, such as `read:user_status` or `write:mobilephone`. 6. Add a description that explains what the scope is for and what it does. 7. Select **Save**. 8. Repeat from step 4 for all the scopes you want to add for this API. 9. Repeat from step 1 to add scopes for a different API. ## Authorize and enable scopes for an application 1. Go to **Settings > Applications** and select **View details** on the relevant application. 2. Select **APIs** in the side menu. 3. If the application is not yet authorized, select the three dots menu next to the API you’re giving the app access to, and then select **Authorize application**. 4. In the same three dots menu, select **Manage scopes**. 5. In the window that opens, switch on or off the scopes allowed for the application. 6. Select **Save**. ## Edit and delete scopes <Aside type="warning"> Take care deleting scopes. If a scope is in use, it can cause breaking changes for users and applications that are dependent on them. </Aside> 1. Go to **Settings > APIs** and select **View details** on the relevant API tile. 2. Select **Scopes** in the menu. 3. Find the scope you want to change. 4. Select the dots menu (far right) and select: - **Edit scope.** You can only change the scope description. Select **Save**. - **Delete scope**. Confirm that you want to delete and select **Delete scope**. ## Request a subset of scopes for an authorized application By default token requests for an authorized application will return all the scopes enabled in the section above. However, you can also optionally ask for a subset of enabled scopes to be returned by including them in the body of the access token request. You might do this to add more security to access requests for your API, or because you want your users to be very specific in their requests. Example request ``` curl --request POST \ --url 'https://<your_subdomain>.kinde.com/oauth2/token' \ --header 'content-type: application/x-www-form-urlencoded' \ --data grant_type=client_credentials \ --data 'client_id=<your_m2m_client_id>' \ --data 'client_secret=<your_m2m_client_secret>' \ --data 'audience=<your_api_audience>\ --data 'scope=join:competitions update:competitions' ``` ## API Key scopes If you manage access to your APIs using API keys, you can [set scopes for the API keys](/manage-your-apis/add-manage-api-keys/scopes-for-api-keys/), giving you more granular control over access, depending who has the keys.

# Developer tools - Your apis - Integrate Kinde auth into .NET-based APIs

> Comprehensive guide to integrating Kinde authentication into .NET-based APIs with JWT bearer tokens, authorization policies, and Swagger UI configuration

dotnet, aspnet, jwt bearer, authorization policies, minimal apis, swagger ui, openid connect
developer-tools, your-apis

{/* @case-police-ignore Uri */} {/* @case-police-ignore Jwt */} This article walks through configuring an ASP.NET application to accept and validate an access token from Kinde. Where users are logged into a front end or mobile application, the access token can be passed in a bearer authorization header to secure requests to back end APIs. A complete sample project can be found in the .NET [starter kit](https://github.com/kinde-starter-kits/dotnet-webapi-starter-kit). ## Configure your project 1. Install the packages that handle tokens. ```bash dotnet add package Microsoft.AspNetCore.Authentication.JwtBearer dotnet add package Microsoft.IdentityModel.Protocols.OpenIdConnect ``` 2. Configure application services (typically `Program.cs`) to use the package. ```csharp builder.Services .AddAuthentication(JwtBearerDefaults.AuthenticationScheme) .AddJwtBearer(options => { // These two lines map the Kinde user ID to Identity.Name (optional). options.MapInboundClaims = false; options.TokenValidationParameters.NameClaimType = "sub"; }); ``` 3. Configure `appsettings.json` for your Kinde application. Replace `<your-domain>` with your Kinde domain and `<your-audience>` with the audience associated with your API in Kinde. ```json "Authentication": { "Schemes": { "Bearer": { "Authority": "https://<your-domain>.kinde.com", "ValidAudiences": [ "<your-audience> ] } } } ``` .NET authentication requires an audience. If you don’t already have an audience defined, you will need to do this by [registering your API](/developer-tools/your-apis/register-manage-apis/). ## Manage authorization with policies Access tokens contain information (claims) about what a user is authorized to do when they sign in. You can create policies to manage authorization. ### Via permission claims (recommended) Create a policy that allows only users with certain permission claims, e.g. `read:weather`: ```csharp builder.Services .AddAuthorization(options => { options.AddPolicy("ReadWeatherPermission", policy => policy.RequireAssertion( context => context.User.Claims.Any(c => c.Type == "permissions" && c.Value == "read:weather") )); }); ``` [Set up permissions](/manage-users/roles-and-permissions/user-permissions/) in Kinde. ### Via role claims 1. [Set up Roles](/manage-users/roles-and-permissions/user-permissions/) in Kinde. 2. Add roles to the access token via custom claims, see the [token customization](/build/tokens/token-customization/) procedure. 3. Create a policy for a particular role, for example: ```csharp builder.Services .AddAuthorization(options => { options.AddPolicy("AdminRole", policy => policy.RequireAssertion( context => context.User.Claims.Any(c => c.Type == "roles" && c.Value == "admin") )); }); ``` Note roles defined in Kinde do not map to roles as defined in ASP.NET, so the related functionality, such as `RequireRole()`, cannot be used. ## Secure controller-based APIs To protect routes, add the `[Authorize]` attribute (from the `Microsoft.AspNetCore.Authorization` package) to any controllers or actions required. For example, allow access only to users that satisfy the policy defined in the previous section: ```csharp [Authorize(Policy = "ReadWeatherPermission")] [HttpGet()] public IEnumerable<WeatherForecast> Get() ``` See the [ASP.NET](http://ASP.NET) Core documentation for more details on [authorization](https://learn.microsoft.com/en-us/aspnet/core/security/authorization/simple?view=aspnetcore-8.0#use-the-authorize-attribute). ## Secure minimal APIs To protect routes for minimal APIs, the `RequireAuthorization()` method can be called, and optionally pass in a policy, for example: ```csharp app.MapGet("/protected", () => "Hello") .RequireAuthorization(); app.MapGet("/requires_specific_permission", () => "G'day") .RequireAuthorization("ReadWeatherPermission"); ``` See the ASP.NET Core documentation for more details about [securing minimal APIs](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/minimal-apis/security?view=aspnetcore-8.0). ## Swagger UI Swagger UI provides an easy way to test APIs while in development. For secured APIs, an access token is sent from your front end application with each request. Swagger UI can be configured to initiate auth and populate the token for you. 1. Configure Swagger with the details of Kinde’s OpenID Connect configuration: ```csharp builder.Services.AddSwaggerGen(options => { var authority = builder.Configuration["Authentication:Schemes:Bearer:Authority"]; options.AddSecurityDefinition( "oidc", new OpenApiSecurityScheme { Type = SecuritySchemeType.OpenIdConnect, OpenIdConnectUrl = new Uri(authority + "/.well-known/openid-configuration") } ); options.AddSecurityRequirement( new OpenApiSecurityRequirement { { new OpenApiSecurityScheme { Reference = new OpenApiReference { Type = ReferenceType.SecurityScheme, Id = "oidc" }, }, new string[] { } } } ); }); ``` 2. Configure Swagger UI to pre-populate the relevant parameters: ```csharp app.UseSwaggerUI(c => { c.OAuthClientId("<frontend-app-client-id>"); c.OAuthAdditionalQueryStringParams(new Dictionary<string, string> { { "audience", builder.Configuration["Authentication:Schemes:Bearer:ValidAudiences:0"] ?? "" } }); c.OAuthUsePkce(); }); ``` 3. Swap `<frontend-app-client-id>` with your front end application’s client ID shown in Kinde. 4. Add the callback URL to your front end application’s [allowed callbacks](/get-started/connect/callback-urls/) so that the Swagger UI initiates auth and returns to Swagger UI after auth. For local development, the callback will look like the following, though the port may differ: ```csharp https://localhost:7179/swagger/oauth2-redirect.html ``` 5. Once this is set up, use the `Authorize` button to initiate auth. On return, API requests should be automatically populated with the access token. Note for front end applications, implicit flow is not supported, only PKCE is supported. ## Troubleshooting When mismatched versions of dependent libraries are resolved, requests to the API may fail with HTTP 401 and a token validation error. It will look something like this: ```csharp Bearer error="invalid_token",error_description="The signature key was not found ``` For example, if version 7.4.0 or later of `System.IdentityModel.Tokens.Jwt` is installed with a version of `Microsoft.AspNetCore.Authentication.JwtBearer` that is dependent on an earlier version of `Microsoft.IdentityModel.Protocols.OpenIdConnect`. To fix, you would update the version of `Microsoft.IdentityModel.Protocols.OpenIdConnect` to match your version of `System.IdentityModel.Tokens.Jwt`. E.g. ensure they are both 7.4.0.

# Developer tools - Your apis - Protect your API

> Guide to protecting APIs with Kinde authentication, including frontend setup, backend verification, and JWT handling

api protection, jwt verification, audience, bearer token, jwks, authentication
developer-tools, your-apis

It’s common that front-end UI and back-end APIs are decoupled and that you will want to call your back-end API knowing it is securely authenticated. ## **Set up Kinde** For additional security we recommend you [register your endpoint as an API](/developer-tools/your-apis/register-manage-apis/) in Kinde. ## **Set up front end** ### **Audience** If you have registered your API in Kinde as above, you will need to make sure to pass the `audience` as a parameter in your authentication url. If you are using our [React](/developer-tools/sdks/frontend/react-sdk/#audience) or [JavaScript](/developer-tools/sdks/frontend/javascript-sdk/#audience) SDK this is handled for you. This ensures the access token you receive when the user signs in, will contain the `audience` claim. ### **Calling your API** When you make the call to your API you will want to ensure the access token is sent in the headers. An example in React for a bookstore app might be: ```jsx const { getAccessToken } = useKindeAuth(); const [books, setBooks] = useState([]); const fetchBooks = async () => { try { const accessToken = await getAccessToken(); const res = await fetch(`https://api.myapp.com/books`, { headers: { Authorization: `Bearer ${accessToken}` } }); const {data} = await res.json(); setBooks(data.books); } catch (err) { console.log(err); } }; ``` ## **Setup back end** Now that the token is being passed from the front end you will need to verify it when it hits your API. ### **Libraries** We recommend that you use a library to verify your token. If you are using ExpressJS you can use [our library](/developer-tools/sdks/backend/express-sdk/#verify-jwt) or the OpenID Foundation has [a list of libraries for working with JWT tokens](https://openid.net/developers/jwt/). ### **JSON Web Key** It’s likely the library you decide to use will require the url for your public JSON Web Key (also known as a jwks file). The file can be found here: `https://<your_subdomain>.kinde.com/.well-known/jwks` ### **Audience** If you opted to register your API with Kinde as per the `Setup Kinde` step then you will need to make sure you pass the `audience` you registered on Kinde to whichever library you are using.

# Developer tools - Your apis - Register and manage APIs

> Guide to registering and managing APIs in Kinde, including audience configuration and authorization setup

api registration, audience, aud claim, m2m token, user token, authorization
developer-tools, your-apis

If you manage your application’s data using APIs, you can register them with Kinde. Doing this facilitates authentication between your back-end code framework and front-end application where users sign in. When you register your API with Kinde and link it to a Kinde application, the API can be included in the audience (`aud`) claim of the token. To have it included, your front-end must request the audience by passing it when initializing the SDK or making a token request. Once included, the token can be used to make a request from the front-end to the back-end, which verifies the token and checks the `aud` claim. ## To register an API in Kinde 1. Go to **Settings** > **APIs**. 2. Select **Add API**. 3. Enter an **API name** and **Audience**. The audience (`aud`) is a unique identifier for this API. Often a short code or the URL of the API is used. 4. Select **Save**. The details window for the API opens. You’ll notice that an ID has been created, but it is not editable and neither is the audience. You can copy these details, however. 5. To authorize this API for your apps, select **Applications** in the left menu. 6. Select the three dots menu next to the relevant application, then choose **Authorize application**. ## Request an audience be added to a token ### Audience in a user token Our SDKs accept an `audience` parameter. As an example for the React SDK you would use: ```jsx <KindeProvider audience="api.example.com/v1 clientId="someClientId domain="https://kinde.example.com > <MyApp /> </KindeProvider> ``` When the request is received, Kinde will check that an API with a matching audience has been registered and is enabled for the application with the requested clientId. (In the example above `someClientId`). If there is a match it will return the `aud` claim as part of the Access token. For example: ```jsx { aud: ["api.example.com/v1"]; } ``` When you use this Access token in your product and send it to your product’s API, you can check for the existence of this `aud` claim in the token as part of your verification checks. ### Audience in an M2M token If you are using Postman, you can include the `audience` claim in a token request. If you’re doing it manually, send a POST request to this endpoint: `https://<your_subdomain>.kinde.com/oauth2/token` and include the following in the body. ```jsx { grant_type: "client_credentials", client_id: "<your_M2M_client_id>", client_secret: "<your_M2M_client_secret>", audience: "<your_audience_value>", scope: "read:finance write:accounts" } ``` ## Create API keys If you want, you can also give access to your API via [API keys](/manage-your-apis/add-manage-api-keys/create-an-api-key/). These can be created by you and then managed by your customer via the [self-serve portal](/build/self-service-portal/self-serve-portal-for-orgs/) (optional). You can also [scope API keys to an organization](/manage-your-apis/about-api-keys/organization-api-keys/). ## Authorize or revoke authorization of an app from the API 1. Go to **Settings** > **APIs**. 2. Select **Configure** on the relevant API card. The API detail opens. 3. Select **Applications** in the left. 4. Select the three dots menu next to an application, then choose **Authorize application** or **Revoke authiorization**. ## Delete an API If you no longer need to have an API registered in Kinde, you can delete it. This action cannot be reversed. 1. Go to **Settings** > **APIs**. 2. On the API you want to delete, select the three dots and then select **Delete API**. A confirmation window appears. 3. To confirm, select **Delete API**.

# Developer tools - Your apis - Get a M2M token to test your APIs

> Quick guide to generating M2M test tokens in Kinde for API testing without using external tools

m2m token, test token, api testing, token generation
developer-tools, your-apis

Kinde lets you quickly generate a test token for testing your APIs with Kinde. This can save you time generating a token via Postman or other service. This process assumes you have [registered](/developer-tools/your-apis/register-manage-apis/) your API with Kinde, and have [authorized an M2M application](/developer-tools/your-apis/register-manage-apis/#authorize-or-revoke-authorization-of-an-app-from-the-api) to access it. 1. In Kinde, go to **Settings > APIs**. 2. Select **View details** on your API. 3. Select **Test** in the menu. 4. Select an authorized application to test API access. 5. Select **Get token**. An access token and copyable code snippets are generated. 6. You can copy the token and inspect it. ![image of token generated in Kinde to test your api](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/7149ab96-02f5-4b03-265e-5ffe0e52d900/public) 7. Use the provided token to test your API.

# Developer tools - Your apis - Get a M2M access token to test your APIs (Postman method)

> Step-by-step guide to testing M2M access tokens for APIs using Postman with OAuth2 Client Credentials flow

m2m token, postman, client credentials, oauth2, audience, custom scopes, jwt verification
developer-tools, your-apis

This doc describes how to test the security of token exchange for your API connection and M2M apps, using Postman and Authorization code (with PKCE). You can use this process to request tokens for your own and third-party APIs, and to test custom scopes added to claims. Below are the steps to generate `id` and `access` tokens with Postman. If you are testing user access tokens, see [Get a user access token to test your APIs](/developer-tools/your-apis/test-your-api-user-token/). ## Step 1: Add your API to Kinde If you haven’t already, [register your API with Kinde](/developer-tools/your-apis/register-manage-apis/) and set the audience. ## Step 2: (Optional) Set up custom scopes for API access If you have the relevant Kinde plan, you can add custom scopes to M2M access tokens for added API security. You might want to test these as part of this procedure. - [Secure your API with scopes](/developer-tools/your-apis/custom-api-scopes/) - [Manage API scopes for M2M applications](/developer-tools/your-apis/api-scopes-m2m-applications/) ## Step 3: Send request via Postman To securely connect to Kinde’s API, you need to obtain an access token. This procedure describes how to get the token using [Postman](https://www.postman.com/) - an API platform - but you can follow similar steps in your own app environment. We recommend you do this in a non-production environment first. If you decide to use Postman, we recommended that you set up a Postman **environment.** 1. Add your machine to machine [application keys](/get-started/connect/getting-app-keys/) as environment variables. ![Adding environment variables in Postman](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/69800dc4-2d22-468c-4300-71e4b4ee8b00/public) 2. Set up a new collection or use your existing one. 3. Go to the **Authorization** tab and ensure the **Type** is **OAuth 2.0** and the **Header Prefix** is set to **Bearer**. 4. In the **Configure New Token** section, set the **Grant Type** to **Client Credentials**. This is the grant type for hitting your API. 5. Enter the **Access Token URL**, using the domain variable you created above. For example, `https://yourbusiness.kinde.com/oauth2/token`. Note that even if you use a custom subdomain domain, the access token URL needs to include the `kinde.com` domain. ![Entering the access token URL](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/8149baf6-e3b7-406d-7447-390fe4bc2100/public) 6. Enter the **Client ID** and **Client Secret** for the M2M application you created in Kinde. 7. Set the **audience** to match the `audience` value for the API you registered in Kinde. To do this: 1. Scroll down and expand the **Advanced** section. 2. Add `audience` as the **key** and paste the URL as the **value**. 3. Set **Send in** to `Request body` 8. In the **Authorization** section, select **Get New Access Token**. If it works, you should see a confirmation message. ![Access Token in Postman](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/b736bc91-3f30-4d48-62c6-37f131e88300/public) 9. Select **Use Token**. You should now have the access token. ## Step 4: Validate the token in your API Check that the token contains the required information and is valid. Testing methods may vary depending on your framework, here’s a general topic for [verifying JWTs](/build/tokens/verifying-json-web-tokens/) and some [recommended libraries](https://openid.net/developers/jwt-jws-jwe-jwk-and-jwa-implementations/). Things to check, include: - Audience - Lifetime / validity - Scopes

# Developer tools - Your apis - Get a user access token to test your APIs (Postman method)

> Step-by-step guide to testing user access tokens for APIs using Postman with OAuth2 Authorization Code flow and PKCE

user access token, postman, oauth2, pkce, authorization code, audience, custom scopes, jwt verification
developer-tools, your-apis

This doc describes how to test user access tokens for your API connection, using Postman and Authorization code (with PKCE). You can use this process to request tokens for your own and third-party APIs, and to test custom scopes added to claims. Below are the steps to generate `id` and `access` tokens with Postman. See the instructions on [how to test M2M tokens](/developer-tools/your-apis/test-your-api-m2m-token/). ## Before you begin ### Register your API (recommended) If you use audiences in your application, we recommend you register your API with Kinde so that you can include `audience` in the token request. An `audience` defines the recipient of the token and ensures the token can only be used by the intended system. You can trust the token as is, but we would recommend you to use the API authentication using `audience`. If you haven’t already, [register your API with Kinde](/developer-tools/your-apis/register-manage-apis/) and set the audience. ### Add custom scopes to the access token If you have the relevant Kinde plan, and your API is registered, you can add custom scopes to user access tokens for added API security. You might want to test these as part of this procedure. - [Secure your API with scopes](/developer-tools/your-apis/custom-api-scopes/) - [Manage API scopes for users](/developer-tools/your-apis/user-api-scopes/) ## Step 1: Add callback URLs to your application in Kinde 1. In Kinde, go to **Settings > Applications**. 2. Select **View details** on the tile for the application you’re testing. 3. In the **Allowed callback URLs** section, add this Postman callback URL, `https://oauth.pstmn.io/v1/callback` as a separate entry on a new line. 4. Select **Save**. ## Step 2: Send request via Postman If you are using audiences in your application, we recommend you 1. In Postman, create a new GET request. 2. Go to the **Authorization** tab. 3. In the **Type** field, select **OAuth 2.0**. 4. Scroll down to the **Configure New Token** section and set the **Grant Type** as **Authorization Code (With PKCE)**. 5. Select the **Authorize using browser** checkbox. 6. Set the **Auth URL**. For example: ```jsx https://yourbusiness.kinde.com/oauth2/auth?prompt=login ``` Where: - `yourbusiness.kinde.com` is the domain - `prompt=login` forces asking for user credentials every login to disable SSO. 7. (If you’ve registered your API and use `audience` claims in your product) Add the `audience` key to the token request, with a value of `https://yourproduct.com/api`. Note that Kinde supports multiple audiences. <Aside> **Older versions of Postman** Add the `audience` parameter to the request url, e.g. `https://yourbusiness.kinde.com/oauth2/auth?prompt=login&audience=https://yourproduct.com/api` </Aside> 8. In the **Access Token URL** field enter your Kinde domain URL, e.g. `https://yourbusiness.kinde.com/oauth2/token`. 9. In the **Client ID** field, add the **Client ID** listed in the application the API is authorized for. You can find this in Kinde by going to **Settings > Applications > View details > App keys** section. 10. If you are testing a back-end app, Enter the **Client Secret**. This can be left blank for front-end apps. 11. Set the **Code Challenge Method** to **SHA-256**. 12. Leave the **Code verifier** field blank. 13. Set the value of **Scope** to **openid email offline**. 14. Enter a random value in the **State** field. It must be at least 8 characters long. 15. Select **Get New Access Token**. This should be the result: - The **ID token** contains an `aud` claim for two audiences, one for the application ID, one for the issuing party. - The **Access token** contains the `aud` claim for the requested (intended) audience to authenticate the API. - The `azp` claim represents the application `client_id` you are using to issue the token. 16. The access token you received can now be used to test and secure your APIs. ![Access token in Postman](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/1fc6f61c-a544-4cce-83c6-7d691f785700/public) ## Step 3: Validate the token in your API Check that the token contains the required information and is valid for accessing your application or site. Test may vary depending on your framework, here’s a general topic for [verifying JWTs](/build/tokens/verifying-json-web-tokens/) and some [recommended libraries](https://openid.net/developers/jwt-jws-jwe-jwk-and-jwa-implementations/). Things to check, include: - Audience - Lifetime / validity - Scopes

# Developer tools - Your apis - Manage API scopes for users

> Guide to managing API scopes for users through roles, additional scopes, and permissions claims

api scopes, user permissions, role management, permissions claim, audience, token customization
developer-tools, your-apis

There are two ways to manage user API scopes. - Include API scopes in roles and assign the role to the user - Add additional API scopes to the user (in addition to role) You also have the option to add API scopes for users through the `permissions` claim. ## Before you begin - Make sure the scopes already exist for your API. See [Create and manage API scopes](/developer-tools/your-apis/custom-api-scopes/) - Add your API as an `audience` in the .env file of your SDK. For example, request multiple audiences by providing a white space separated list: ``` KINDE_AUDIENCE=<your-api-1> <your-api-2> ``` ## Apply API scopes via user role 1. In Kinde, go to **Settings > Roles**. 2. Add a new role or edit an existing role. 3. In the dialog that appears, switch on **API scopes** at the bottom of the window. 4. Select **Save**. 5. Go back to the home page in Kinde. 6. Select **Users**. 7. Find and open the record for the user you want. 8. Select **Roles** in the menu. 9. [Assign the role with the relevant scopes to the user](/manage-users/roles-and-permissions/apply-roles-and-permissions-to-users/). ## Apply additional API scopes for a user 1. In Kinde, go to **Settings > Users**. 2. Find and open the record for the user you want. 3. Select **API scopes** in the side menu. 4. In the **Additional API scopes** section, select **Add scopes**. 5. In the dialog, switch on the scopes you want. 6. Select **Save**. ## View API scopes for a user 1. In Kinde, go to **Settings > Users**. 2. Find and open the record for the user you want. 3. Select **API scopes** in the side menu. All the scopes applied to the user - via role and additional - are shown. ## Include API scopes in the permissions claim You can include API scopes in the `permissions` claim if you want them included as part of the user’s Access token. 1. Go to **Settings > Applications** and select **View details** on the relevant application for the permissions. 2. Select **Tokens** in the side menu. 3. Scroll to the **Token customization** section and select **Customize** on the **Access token** tile. 4. In the dialog, switch on **Include API scopes in the `permissions` claim.** 5. Select **Save**.

# Get started - Apis and sdks - About Kinde APIs

> Overview of Kinde APIs including Management API access via M2M applications and registering custom APIs for secure integration.

kinde apis, management api, m2m applications, api registration, integration
get-started, apis-and-sdks

At Kinde we want to empower founders to build their product their way, and integrate with us in a way that suits them. That’s why we’re building out the Kinde Management API and allowing Kinde users to register their API with us as well. ## Access the Kinde Management API You can only access Kinde's API via machine to machine (M2M) applications. Once connected, you can use our API to integrate Kinde functionality in your app without the admin interface layer. [Check out the API docs](/kinde-apis/management/). ## Integrate by registering your own API If your product has its own APIs, you can register them with Kinde to ensure access requests to your endpoints are secure and authorized. See [Register an API](/developer-tools/your-apis/register-manage-apis/).

# Get started - Connect - Set callback and redirect URLs

> Guide to setting up callback and redirect URLs for Kinde authentication including troubleshooting, wildcard usage, and security considerations.

callback urls, redirect urls, logout redirect, wildcards, security, troubleshooting, management api
get-started, connect

For authentication to work, you need to add callback URLs into your app. - An **Allowed callback URL** (also known as a redirect URI) is the web address where a user is sent after they authenticate. - An **Allowed logout redirect URL** is where the user is redirected when they sign out - sometimes these are the same as the allowed callback URLs. ## Set callback URLs 1. In Kinde, go to **Settings** > **Applications**. 2. View the details of an application. 3. In the **Allowed callback URLs** section, enter a callback URL. For example `https://[YOUR_SERVER_URL]/kinde_callback`. Make sure the callback URL does not have a trailing space. 4. In the **Allowed logout redirect URLs** field, enter a redirect URL. For example, enter your website address or the URL for a custom logout screen. Make sure you also register the redirect URL in your application settings. ## Troubleshoot ‘Invalid callback URL’ A common error reported by new users is that they receive an ‘invalid callback URL’ message when testing their connection. If you get this error, check the following: - Make sure there are no spaces before or after the callback URL in your Kinde application. - Ensure the callback URL in your code exactly matches the callback URL in your Kinde application. - The Client ID in your code must exactly match the Client ID in your Kinde application. - If you’re testing with a cloud hosting solution, such as Vercel, redeploy your application each time you update the environment variables. ## Wildcards in callback URLs You can use wildcards in the Kinde callback URLs. This is helpful if you have multiple subdomains, for example. Just replace the subdomain with an asterisk `*` — for example `https://*.mybusiness.com/callback`. <Aside type="warning"> We recommend using wildcards only for non-production purposes, as they present increased security risk. </Aside> ### Wildcard limitations - Root level domains are **not** allowed (`*.com` is not allowed). - Only a single wildcard is allowed per callback (`https://*.*.hello.com` is not allowed). - Wildcards are only allowed with `http` or `https` URL protocols (`*.hello.com`, `service:jmx:rmi://[host[:port]][urlPath]` are **not** allowed). - Wildcard has to be in the leftmost subdomain (`https://*.hello.com` is allowed, `https://hello.*.com` is **not** allowed). - Wildcards with prefixes and suffixes are allowed (`https://prefix-*-suffix.hello.com`) - A URL with a valid wildcard **will not** match a URL with more than one subdomain level in place of the wildcard. (`https://*.hello.com` will **not** work with `https://sub1.sub2.hello.com`) - Certain well-known shared hosting domains require a suffix or prefix for the wildcard (`*.vercel.app` is **not** allowed as this opens up anyone to authenticate on the Vercel platform, but `*something.vercel.app` is allowed as this will lock callbacks to your team or personal account). - Wildcards are not supported as part of a URL path (`https://sub1.sub2.hello.com/*` is not allowed). You can use the post-login redirect (available in several SDKs) to achieve dynamic navigation after authentication. ## Alternative methods of securing dynamic callbacks A more secure way of managing dynamic wildcards is to integrate with the Kinde Management API and manage them via API calls. This way you can be sure only allowed callbacks are authenticating against your Kinde instance. If your application lives in a [GitHub](https://github.com/) repository connected to [Vercel](https://vercel.com/), refer to [this section](/developer-tools/sdks/backend/nextjs-sdk/#working-with-preview-urls) on how to add wildcard callback URLs via the Kinde API. You can also use our [callbacks endpoint](/kinde-apis/management#tag/callbacks) in our Management API to add specific callbacks at the relevant point in your deployment. ## Distinguishing callback activity as sign in or sign up Kinde does not currently provide the ability to distinguish between a sign in and new registration, when the user lands on the callback URL. We recommend that you map the Kinde user IDs to your internal users. Then when the token from Kinde gets verified, - if the user doesn't exist: continues with **sign up** flow - if the user does exist: continues with **sign in** flow We don't include this information in the token because it's possible to create a user via an API, or in the admin UI (via custom import).

# Get started - Connect - Customize email sender

> Guide to customizing email sender configuration in Kinde including SMTP setup, email provider integration, and troubleshooting common issues.

email sender, smtp, email provider, deliverability, sendgrid, mailgun, postmark, troubleshooting
get-started, connect

You can configure Kinde to send emails from your own preferred email provider. This means your users will receive communications from your business’s email address, and not Kinde’s. There are also other benefits, such as better control of email deliverability, analytics and tracking, scalability, email compliance, etc. ## Emails that will be sent from you When you set your own email provider details, the following emails will be sent from your preferred email address: - Sign up and sign in emails - One-time passcode (OTP) emails - Password reset codes Emails will come from `no-reply@kinde.com` if you choose not to set this up. ## Emails sent from Kinde Even if you enter custom sender details, these emails will still be sent from Kinde. - Invitation to join business team - triggered by manual or API addition of team member - Warnings and notifications of data export ## Requirements and recommendations - You can only have one email sender set up in Kinde - You need to set up provider details before making your environment live - The provider must support user/password sign in and TLS - Check the limitations of your provider (e.g. Microsoft O365 has daily send limits). We recommend using bulk email service providers such as SendGrid, Mailgun, Mailchimp, Postmark, etc. ## Add email sender SMTP details <Aside> Users who are in the process of signing in to your application when you enable this setting will not receive emails from the new address until they start a new authenticated session. </Aside> If you are setting this up and your production environment is already live, we recommend testing this in a staging or test environment first. 1. In Kinde, go to **Settings > Email**. 2. Enter a **Sender name**. This is usually your business name, but might be a specific person. 3. Enable the **Use custom sender** switch. The SMTP details section opens. <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/d4c4b57d-9f1a-4b1c-638c-0a770c4fe400/public" alt="" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" /> 4. Enter the **Sender email**. This is the address your users will receive emails from. 5. Enter the SMTP details of your email provider: - Server name - this will be something like `yourbusiness.smtp.providername.com` - Port - use the one recommended by your email provider - Sign-in details - Username and password 6. Select **Send test email**. This sends a test email to the email address you are logged into Kinde with. 7. If the test is successful, select **Save**. 8. If the test is not successful, check the SMTP details (step 5) and try sending a test email again. If this does not work, see the troubleshooting section below. ## Edit email sender We recommend testing any changes to SMTP details in a non-production environment first. 1. In Kinde, go to **Settings > Email**. 2. Change any of the details that you want. 3. Select **Send test email**. This sends a test email to the email address you are logged into Kinde with. 4. If the test is successful, select **Save**. ## Reset email sender You should only do this if your environment is not live. 1. In Kinde, go to **Settings > Email**. 2. Disable the **Use custom sender** switch. This reverts back to use the default Kinde email address and removes SMTP details. 3. Select **Save**. ## Troubleshoot the SMTP provider connection Sometimes things go wrong with server connections and external provider configuration. There’s only so much we can assist with on our side, but if you get an SMTP error, check your provider documentation. Here’s a [list of errors](https://datatracker.ietf.org/doc/html/rfc2821#section-4.2.3) you might see (from the IETF), and here’s link to SMTP docs from some common providers. - [SendGrid](https://sendgrid.com/en-us/blog/smtp-server-response-codes-explained) - [Mailchimp](https://mailchimp.com/developer/transactional/docs/smtp-integration/) - [Postmark](https://postmarkapp.com/support/article/1114-what-are-smtp-codes-and-how-can-i-troubleshoot-them) - [MailerSend](https://www.mailersend.com/blog/smtp-codes) - [Mailgun](https://documentation.mailgun.com/docs/mailgun/user-manual/sending-messages)

# Get started - Connect - Get application keys

> Guide to obtaining and managing Kinde application keys including client ID, client secret, and security best practices for credential management.

app keys, client id, client secret, credentials, environment variables, security
get-started, connect

Application keys - or app keys - are credentials that you need to connect your project to Kinde. There are unique app keys for each application you have. This includes each machine to machine, front-end, back-end, or single-page application, etc. For more information about Kinde apps, see [Applications in Kinde](/build/applications/about-applications/). ## About app keys In the App keys section of your application in Kinde, you’ll find these details: - **Custom domain** - if you have opted to use one - **Domain** - this is the domain issued by Kinde - **Client ID** - unique for this app - **Client secret** - unique for this app (only back-end and M2M apps have client secrets) <Aside title="Rotating client secrets in Kinde"> You can only rotate client secrets for M2M applications. For backend applications, follow [these token security principles](/build/tokens/refresh-tokens/#token-security-recommendations). </Aside> ## View and copy app keys 1. Go to **Settings > Environment > Applications**. 2. Find the application you want to connect. 3. On the application tile, select **View details**. 4. Scroll to the **App keys** section. 5. Select **Copy** to copy the keys. 6. Make sure you securely store and manage your client secret as it provides access to your Kinde account for your product. <Aside> Note that front-end (client-side) applications do not have a client secret because they run in insecure environments, typically a browser. </Aside> 7. Add the app key details to the .env file in your code base or starter kit. Follow the instructions in the relevant [SDK](/developer-tools/about/our-sdks/) or the README file in the starter kit. 8. Do this for each application you want to connect.

# Get started - Guides - Connect existing code base to Kinde

> Guide for connecting existing codebases to Kinde including SDK selection, app configuration, callback URLs, and environment setup.

existing codebase, sdk documentation, app keys, callback urls, environment variables, user registration, setup tasks
get-started, guides

Once you’ve got a [Kinde business and domain](https://app.kinde.com/register), you’re ready to get started. You’ve got a couple of options: - **Fast and easy** - Access the guided **Quick start** via the application tile on the Kinde home page, and follow the in-app instructions for using your own codebase. - **DIY** - Follow the instructions below. ## 1: Get your SDK Browse [our SDK documentation](/developer-tools/about/our-sdks/) for the one you want. SDK documentation contains language-specific instructions for connecting to Kinde. The steps in this document provide an overview of what you need to do. If we don’t have the language or framework you’re looking for, and you’re an experienced developer, try [using Kinde without an SDK](/developer-tools/about/using-kinde-without-an-sdk/). You can also [request an SDK](https://kinde-21631392.hs-sites.com/en-au/feature-request). ## 2: Add your application in Kinde Next, you’ll want to connect your code base to the application you set up in Kinde. Follow these steps to [add a new application to Kinde](/build/applications/add-and-manage-applications/). Kinde also comes with a couple of pre-built applications and you can use those ones if they suit. Sign in to Kinde and go to **Settings > Applications**. <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/98b14309-1d1d-406d-e9c0-c57003f24c00/public" alt="" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" /> ## 3: Get app keys View details of your application in Kinde and scroll down to [copy the App keys](/get-started/connect/getting-app-keys/). You’ll need to add these to your project’s `.env` file. <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/708e61e2-0738-4c51-e376-b675fac52300/public" alt="" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" /> ## 4: Add callback URLs to your Kinde application While you are viewing the application details, set the callback and redirect URLs for your app. These define where a user goes when they sign in to you app. You need to set these in order to enable users to sign up. Enter default localhost details, such as below. Note that `http://localhost:3000` is an example of a commonly used local development URL. It should be replaced with the URL where your app is running. <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/39a075f3-ab58-448b-037e-ed154c4a1300/public" alt="" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" /> You can add other URLs later, when your production environment is ready to go live or you set up a custom domain. ## 5: Add app keys to the .env file Your code base will include an .env file (or something similar) for storing configuration information. Add the Kinde app details you copied at step 3 to your .env file Here’s an example from the Next.js app router SDK. You replace `<your_kinde_client_id>`, `<your_kinde_client_secret>`, and `<your_kinde_subdomain>` with the Kinde app details. ```bash KINDE_CLIENT_ID=<your_kinde_client_id> KINDE_CLIENT_SECRET=<your_kinde_client_secret> KINDE_ISSUER_URL=https://<your_kinde_subdomain>.kinde.com KINDE_SITE_URL=http://localhost:3000 KINDE_POST_LOGOUT_REDIRECT_URL=http://localhost:3000 KINDE_POST_LOGIN_REDIRECT_URL=http://localhost:3000/dashboard ``` ## 6: Test user registration After you complete the previous steps, you should be able to register your first user. Register your first user by signing up yourself. To view the user, go to the main **Users** page in Kinde. Continue through the SDK to complete other configuration tasks. Then follow the link in step 7 below for a list of other set up tasks. ## 7: Set up Kinde to work how you want it Start configuring Kinde to work the way you want by exploring [common set up tasks](/get-started/guides/set-up-tasks/) and customizations. That’s when you’ll really start to build your business on Kinde.

# Get started - Guides - Common errors and codes

> Comprehensive troubleshooting guide for common Kinde error codes including authentication, SAML, OAuth, and verification issues.

error codes, troubleshooting, authentication errors, saml errors, oauth errors, verification codes, token errors
get-started, guides

Depending on the complexity of your authentication setup, you or your users may occasionally encounter errors. Here are some common error codes and troubleshooting steps. ## Sorry we don't see way to authenticate you This error message typically appears when there's an issue with your authentication configuration or token handling. A few common causes include: - Expired or invalid tokens - Misconfigured authentication settings - Session management issues - Incorrect callback URLs ## State not found The `State not found` error typically occurs when there's a mismatch between your environment variables and the domain you're using during authentication. There may be a trailing space or incorrect syntax. ## Verification code not received (email) Verification codes are sent almost immediately when triggered. If a code is not received, it might be because: - Junk/spam folders​ - Email providers and devices may treat OTPs from unknown providers like Kinde as spam. Check your own spam folder, or ask your IT team if emails from Kinde are quarantined by firewalls or other IT defence systems. - Gmail delays​ - Google Workspace addresses can experience ~4 minute delays due to pre-delivery scanning - Microsoft Defender filters​ - Aggressive anti-spam filters sometimes quarantine verification emails for Outlook/Hotmail users If none of the above help troubleshoot the issue, contact Kinde support. ## Verification code not received (mobile device) Verification codes are sent almost immediately when triggered. If a code is not received, it might be because: - Network connectivity problems or poor signal strength - Carrier-level spam filtering blocking OTP messages - SMS delivery delays during peak usage times - Full storage preventing new messages from being received - Phone numbers in certain countries do sometimes experience issues. Contact us if you think this might be the case. We recommend using [Twilio](/authenticate/authentication-methods/phone-authentication/), a third-party SMS provider instead of Kinde's default service. This makes troubleshooting issues and accessing logs much easier. ## Error code 578 Description - Error coming back to Kinde while validating SAML response Troubleshooting - Check that the Assertion Consumer Service (ACS) URL is correct on the identity provider ## Error code 780 Description - The OAuth 2.0 response failed - The token is valid, but the redirect is null ## Error code 928 Description - Error getting or reading the connected app configuration ## Error code 1004 Description - Error getting custom SAML config while initializing SAML redirect ## Error code 1656 Description - Error with authorization response - The request is missing a required parameter, includes an invalid parameter value, includes a parameter more than once, or is otherwise malformed Troubleshooting - Missing nonce on implicit flow - Redirect URI might not be with an https - Only a localhost suffix can be used with http - Error with workflow ## Error code 1829 Description - Error exchanging token on connected app callback Troubleshooting - Check the redirect URLs for a mismatch - Check the client credentials ## Error code 1959 Description - Error decoding SAML response - Response contains invalid characters for Base64 response ## Error code 3005 Description - Cannot handle SAML callback - The userProfile contains invalid values ## Error code 3420 Description - OAuth 2.0 response failed because token is invalid and redirect ID is null ## Error code 4179 Description - Handle Social OAuth 2.0 callback - error exchanging token - Expired secrets for social provider Troubleshooting - Check the secret being used with your social provider and ensure that it hasn't expired ## Error code 4617 Description - Error reading config on OAuth 2.0 callback Troubleshooting - Check that the client credentials in both Kinde and IDP are correct - Check that the redirect and callback URLs in both Kinde and IDP are correct ## Error code 5716 Description - OAuth 2.0 response failed due to an invalid token - Redirection was successful ## Error code 6722 Description - Error configuring SAML provider This error also appears if a user tries to sign in to your app via their identity provider setup (IdP-initiated) and not the sign in via the enterprise connection in your app, which is supported by Kinde as service provider (SP-initiated). Troubleshooting - Check that the settings in the Kinde enterprise connection are correct - Check enterprise connection metadata URL, entity ID, certificate ## Error code 7558 Description - SAML callback tokenInfo returned invalid data ## Error code 8030 Description - Error configuring SAML provider on redirect Troubleshooting - Check the enterprise connection metadata URL - Check that the IDP has the correct ACS URL ## Error code 8809 Description: - Received browser trust token is different from the one stored in the login session Troubleshooting - Start the auth flow again from the sign in or log in button - The user is trying to start a session in a new tab, browser, or device when there's already a partially completed session in progress - The user may have bookmarked the auth page when it's partially completed, instead of bookmarking the initial sign in or log in page ## Error code 9055 Description - Error getting custom SAML provider configuration - RelayState is invalid or doesn't exist Troubleshooting - Check the SAML callback URL - Check the entity ID - Check that the SAML IDP is returning a valid RelayState ## Error code 9364 Description - Error getting authentication request while initializing SAML redirect Troubleshooting - Check the enterprise connection private key, certificate, and signature method ## Error code 9697 Description - Disposable email detected while authenticating a user on sign up in a workflow ## Error code 9881 Description - Error storing tokens with connected app Troubleshooting - Check the refresh token is valid

# Get started - Guides - Where to start with Kinde

> Essential guide for getting started with Kinde including business setup, quick start options, and onboarding process for new users.

getting started, quick start, onboarding, business setup, tech stack, social authentication
get-started, guides

First, [sign up for a business and get a Kinde domain](https://app.kinde.com/register). ## Choose your own business adventure When you sign up for a new business, you’ll be guided through a few decisions about how you want to set up your business, including the tech stack you use, the social authentication methods you want, and whether you are bringing your own code, or are starting from scratch. Then you’ll be asked if you want to use the Quick Start method to get your app connected. ![quickstart example](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/52d876f0-afc1-4f56-0c05-992c7f7a2800/public) ## Take the Quick Start path Follow our **Quick Start** guide to get connected fast. You can jump straight in there from the onboarding, or you might have breezed through these steps so you can look around. Either way, here’s how to find your way back. 1. On the Kinde home page, select **View details** on your app tile. 2. Select **Quick start** in the menu. 3. Select the relevant tab: **Starter kit** or **Existing codebase.** ![Tab selection options](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/31311feb-d809-4d04-ab91-6986f4b1b000/public) 4. Follow the steps to get connected! If you need to, you can also change the technology you selected. <Aside> You can access the **Quick start** guide for any of your applications. Go to **Settings** > **Applications** > **View details** (on the application tile) > **Quick start.** </Aside> ## Resources for getting to know us Check out the [website](https://kinde.com/product-demo/), the [docs](/), the [blog](https://kinde.com/blog/), [videos](https://www.youtube.com/@heykinde), and hit up the [Slack community](https://join.slack.com/t/thekindecommunity/shared_invite/zt-1vyq8qilj-jFH5V27jfFnHk~BuBSU0ZA) to talk to other Kinde users. If you need help setting up, there’s a **#support** channel in the Slack community or you can contact us at [support@kinde.com](mailto:support@kinde.com) ## More starter docs - [Our SDKs](/developer-tools/about/our-sdks/) - Alternative guide for [connecting to Kinde from a blank slate](/get-started/guides/start-with-starter-kit/) - Alternative guide for [connecting your own codebase](/get-started/guides/byo-code/)

# Get started - Guides - Common set up tasks

> Comprehensive guide to common Kinde setup tasks including business settings, applications, authentication, user management, and integrations.

setup tasks, business settings, applications, authentication, user management, integrations, organizations, branding
get-started, guides

The whole idea of Kinde is you can set it up the way you want, without too much fuss. Here are some common set up tasks. Depending on your business structure and how you want to do things, you may do some or all. ## Business settings - [Use your own domain](/build/domains/pointing-your-domain/) for sign up and sign in - Add links to [privacy policy and terms of service](/manage-your-account/business-information/policies-terms/) - [Invite team members](/get-started/team-and-account/add-team-members/) to help you set up - [Create another environment](/build/environments/environments/), such as a local development environment ## Applications - Set [callback and redirect URLs](/get-started/connect/callback-urls/) in your applications, and ensure they match the URLs in your code. - Switch on [authentication options](/authenticate/manage-authentication/user-auth-applications/) for your applications. ## Appearance and user experience - Set up the [request access](/design/pages/set-up-the-request-access-page/) page (if your app is not yet in the market) - Add your [email provider details](/get-started/connect/customize-email-sender/) so emails come from you and not Kinde - Set your global brand theme for [emails and pages](/design/brand/global-brand-defaults/), including sign up and sign in pages - [Create a form](/design/pages/subscription-form/) to collect emails from mailing list subscribers ## Authentication - Select and [set up authentication](/authenticate/authentication-methods/set-up-user-authentication/) for your apps (Email + passwordless is set up by default in your first app when you add a new business) - Enable [social sign up options](/authenticate/social-sign-in/add-social-sign-in/) - Set up [multi-factor authentication](/authenticate/multi-factor-auth/enable-multi-factor-authentication/) - Add [MS Entra ID](/authenticate/enterprise-connections/azure/) or [SAML](/authenticate/enterprise-connections/custom-saml/) enterprise authentication (if you have enterprise customers) - Manage the [authentication experience](/authenticate/custom-configurations/authentication-experience/), including error handling, sign up fields, marketing consent, etc. ## Users - [Import users](/manage-users/add-and-edit/import-users-in-bulk/) into Kinde, or [add them manually](/manage-users/add-and-edit/add-and-edit-users/) - Add [user permissions](/manage-users/roles-and-permissions/user-permissions/) - Add and assign [user roles](/manage-users/roles-and-permissions/user-roles/) ## Integrations - [Register your APIs](/developer-tools/your-apis/register-manage-apis/) on Kinde - Connect to [Kinde’s Management API](/developer-tools/kinde-api/connect-to-kinde-api/) - Add [Google Analytics](/manage-users/view-activity/track-user-sign-in-with-google-analytics/) to track user sign ups and sign ins ## Organizations (B2B/+ businesses) - Learn how [multi-tenancy and organizations](/build/organizations/multi-tenancy-using-organizations/) works in Kinde - Add or [import organizations](/build/organizations/import-organizations/) - Allow [organization creation](/build/organizations/allow-org-create-on-signup/) on sign up - [Apply branding for organizations](/design/brand/apply-branding-for-an-organization/)

# Get started - Guides - Start with a Kinde starter kit

> Step-by-step guide for using Kinde starter kits including GitHub setup, app configuration, callback URLs, and user registration testing.

starter kit, github, app keys, callback urls, environment variables, user registration, setup tasks
get-started, guides

Once you’ve got a [Kinde business and domain](https://app.kinde.com/register), you’re ready to get started. You’ve got a couple of options: - **Fast and easy** - Access the guided **Quick start** via the application tile on the Kinde home page, and follow the in-app instructions for using a starter kit. - **DIY** - Follow the instructions below. ## 1: Get a starter kit If you’re starting a brand new project or you just want to have a play around, using one of our starter kits gives you a ready-to-use project with Kinde already integrated with your tech of choice. [Grab a starter kit from GitHub](https://github.com/kinde-starter-kits) Open the README file in the starter kit for instructions on how to use it to connect to Kinde. Or follow the steps below. ## 2: Add an application in Kinde Kinde works by linking the application you set up in Kinde, with the app you’re creating yourself - or in this case, it will probably be an app that comes with the starter kit you chose. If you know what type of application you’re building, [add it to Kinde](/build/applications/add-and-manage-applications/). Kinde also comes with a couple of pre-built applications and you can use those ones if they suit. Go to **Settings > Applications**. <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/98b14309-1d1d-406d-e9c0-c57003f24c00/public" alt="" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" /> ## 3: Get app keys View details of the application in Kinde and scroll down to [copy the App keys](/get-started/connect/getting-app-keys/). You’ll need to add these to the .env file that came with the starter kit. <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/708e61e2-0738-4c51-e376-b675fac52300/public" alt="" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" /> ## 4: Add app keys to the .env file Your starter kit came with a file called `.env-sample` (or something close to that). You will want to rename it `.env`. The .env file contains configuration information for linking with Kinde. Follow the README instructions in your starter kit to add your app keys to the .env file. Here’s an example from the Next.js app router starter kit. You replace `<your_kinde_client_id>`, `<your_kinde_client_secret>`, and `<your_kinde_subdomain>` with details from Kinde. ```bash KINDE_CLIENT_ID=<your_kinde_client_id> KINDE_CLIENT_SECRET=<your_kinde_client_secret> KINDE_ISSUER_URL=https://<your_kinde_subdomain>.kinde.com KINDE_SITE_URL=http://localhost:3000 KINDE_POST_LOGOUT_REDIRECT_URL=http://localhost:3000 KINDE_POST_LOGIN_REDIRECT_URL=http://localhost:3000/dashboard ``` ## 5: Add callback URLs to your Kinde app Callback and redirect URLs define where a user goes when they sign in to you app. You need to set these in order to enable users to sign up. Go to **Settings > Applications** and select **View details** on your application in Kinde. Enter the URL details as per your starter pack README file. For now, it will be a localhost URL. But you can add other URLs later, when your production environment is live or you set up a custom domain. <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/39a075f3-ab58-448b-037e-ed154c4a1300/public" alt="" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" /> ## 6: Test user registration After you complete the previous steps, you should be able to register your first user. 1. Open a terminal window where your project is running. 2. View the README file in your starter kit to get the command to start your local server and view your project in a browser. For example, the command for Next.js is `npm run dev`. 3. Once your project is running in the browser, select **Sign up** to register your first user. 4. When you’re done, view the user in the main **Users** page in Kinde. Now you’re ready to take on the rest of the Kinde set up tasks. ## 7: Set up Kinde to work how you want it Start configuring Kinde to work the way you want by exploring [common set up tasks](/get-started/guides/set-up-tasks/) and customizations. That’s when you’ll really start to build your business on Kinde.

# Get started - Learn about kinde - Kinde product security information

> Comprehensive overview of Kinde's security practices including XSS protection, CSRF prevention, bot detection, password standards, and TLS enforcement.

security, xss protection, csrf protection, bot detection, credential stuffing, clickjacking, password security, tls, waf, rate limiting
get-started, learn-about-kinde

Here’s some of the practices, standards, and methods we use to keep your data, and user’s data secure. ## Auth pages require known origins in the callback URL To help prevent [XSS attacks](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html), all authentication pages require a [callback URL](/get-started/connect/callback-urls/) to be set in Kinde. Authentication does not work correctly without them. Our application will check the callback URLs and parse out the domain for an origin check. ## Bot detection Native bot detection is on the roadmap, which will allow customers to bring their own Cloudflare integration key to apply bot detection and protections directly to their Kinde hosted auth pages. This will allow customers to adjust the level of protection based on their own risk profile. Please see our [roadmap](https://updates.kinde.com/board) for updates. To protect against bot driven volumetric attacks, we use AWS WAF to block traffic that matches OWASP threat rules, known malicious IP addresses, and AWS managed rules. Alternatively, customers can implement bot detection and CAPTCHA if your DNS is hosted via Cloudflare. Kinde's hosted pages, with a custom domain, can be proxied through Cloudflare to incorporate their advanced web attack protection features, including bot detection and Cloudflare's Turnstile (Cloudflare's equivalent to CAPTCHA). Please see [Proxy your Kinde auth pages through Cloudflare](/authenticate/custom-configurations/proxy-your-kinde-auth-pages-through-cloudflare/) for more information. ## Credential stuffing protection Kinde protects from credential stuffing attacks with a combination of techniques. To protect against volumetric attacks, we use AWS WAF to block traffic that matches OWASP threat rules and also use our own application throttling. To protect against password brute forcing, we will automatically lock out accounts after 5 consecutive failed attempts of the password or passwordless code (OTP, password, or multi-factor authentication) for a short period of time. Admins can manually unlock accounts if necessary. Bot detection (see previous section) can be used to provide additional protection. ## CSRF protections via `state` parameter Kinde protects against [CSRF](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html) attacks by using and recommending the `state` parameter as part of an auth token. All state changing requests generate a CSRF tokens server side, which are validated on the backed, and cookies are set to sameSite `strict`. ## Hosted auth pages prevent clickjacking To prevent [clickjacking](https://cheatsheetseries.owasp.org/cheatsheets/Clickjacking_Defense_Cheat_Sheet.html) attacks where a user’s personal information or credentials may be stolen by hidden iFrames, use Kinde’s hosted pages for authentication. Hosted pages have protections in place such as such as strict CSP and security headers to prevent itself from being embedded as an iFrame. Kinde controls and hosts the authentication pages, so the risk for protecting pages is assumed by Kinde rather than you. ## Enforced password standards Kinde provides a baseline password protection policy for any customer who wants to include password authentication in their product. - 8 character minimum - No complexity requirements - Blocking of 1,000,000 most common passwords - 5 incorrect attempts locks account out for 5 minutes Note that Kinde recommends, where possible, not using passwords for authentication and instead using [passwordless](/authenticate/about-auth/authentication-methods/#passwordless) or [social](/authenticate/social-sign-in/add-social-sign-in/) integrations. If using passwords for authentication, we recommend adding [multi-factor authentication](/authenticate/multi-factor-auth/about-multi-factor-authentication/) as an option for users. ## Password security If your business is set up so users sign in with passwords, you can be assured that Kinde uses a hashing algorithm and never stores passwords as text. Specifically, we use bcrypt for hashing of passwords in our database. ## Denial of service mitigation via rate limits and throttles Kinde has implemented an application level rate limit and throttle. This helps protect our shared infrastructure and our customers from excessive network traffic that could lead to an outage. Our rate limits are tuned based on the type of traffic, such as API, admin pages, or general auth usage, and will limit the number of connections from an IP in a short space of time. This generally covers all interactions for our service. ## Device fingerprinting prevents session hijacking Kinde implements a method of device fingerprinting during the authentication flow to block the transfer of sessions between different browsers or devices that could lead to [session hijacking](https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html). ## Enforcement of TLS version and ciphers Kinde enforces strict [TLS versions](https://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Security_Cheat_Sheet.html) and ciphers across it’s public facing websites and API endpoints. TLS 1.3 - TLS_AES_128_GCM_SHA256 - TLS_AES_256_GCM_SHA384 - TLS_CHACHA20_POLY1305_SHA256 TLS 1.2 - TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 - TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256 - TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 - TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384 ## Preventing third-party script injections with XSS and CSP Kinde uses various techniques to help prevent the execution of unknown third party scripts and the injection of malicious third party scripts by using XSS protection and CSP. Kinde’s server rendered application encodes output by default, which prevents most opportunities to inject HTML. The Content Security Policy configured across our webpages prevents the execution of inline and third party scripts. ## Blocking malicious traffic with our WAF Kinde has implemented a web application firewall ([WAF](https://cheatsheetseries.owasp.org/cheatsheets/Secure_Cloud_Architecture_Cheat_Sheet.html#web-application-firewall)) across all of our public-facing websites and API endpoints. We use AWS WAF to block traffic that matches OWASP threat rules, known malicious IP addresses, and AWS managed rules.

# Get started - Learn about kinde - Supported browsers

> Information about Kinde's supported browsers including desktop and mobile browsers, Browserslist configuration, and browser compatibility requirements.

browser support, browserslist, chrome, safari, firefox, edge, ios, mobile browsers
get-started, learn-about-kinde

For Kinde admin and authentication flow, Kinde uses [Browserslist’s](https://github.com/browserslist/browserslist) recommended query of `defaults`, which matches recent versions of popular and supported browsers worldwide. This means we support the typical stack of desktop and mobile browsers: - Chrome - Chrome for Android - Safari - Safari on iOS - Edge - Firefox - Opera In addition to the `defaults` query, we add the `iOS >= 15.4` query to extend iOS Safari support to version 15.4. **Note:** Kinde does not support any Internet Explorer (IE) version, including IE 11. ## See all targeted browsers [View all targeted browsers](https://browsersl.ist/?results=#q=defaults%2C+iOS+%3E%3D+15.4), and filter by region, e.g. - [Australia](https://browsersl.ist/?results=#q=defaults%2C+iOS+%3E%3D+15.4&region=AU) - [United States](https://browsersl.ist/?results=#q=defaults%2C+iOS+%3E%3D+15.4&region=US) - [Europe](https://browsersl.ist/?results=#q=defaults%2C+iOS+%3E%3D+15.4&region=alt-eu) ## Query breakdown Kinde’s Browserslist query: `defaults, iOS >= 15.4` breaks down to: - `> 0.5%` all versions with > 0.5% of the audience worldwide - `last 2 versions` last 2 versions of each browser - `Firefox ESR` the latest Firefox Extended Support Release - `not dead` excludes dead browsers, i.e., browsers without official support or updates for more than 24 months - `iOS >= 15.4` all iOS Safari versions newer than `15.3` **Note:** Regarding the `not dead` query, this includes IE 11, IE Mobile 11, BlackBerry 10, BlackBerry 7, Samsung 4, Opera Mobile 12.1, and all versions of Baidu. ## Staying up-to-date Browserslist queries like `last 2 versions` or `> 0.5%` depend on actual data. Therefore, Kinde regularly updates the Browserslist DB via the [update-db tool](https://github.com/browserslist/update-db). ## How to report issues If you find any issues, please report them via email to [support@kinde.com](mailto:support@kinde.com), the support chat in the Kinde admin, or the #support channels in [Slack](https://join.slack.com/t/thekindecommunity/shared_invite/zt-2k5i0aeet-d6Z_2qYphcNCpj0bFa4oCg) or [Discord](https://discord.gg/KdkCXRNTFn).

# Get started - Learn about kinde - Supported data regions

> Information about Kinde's supported data regions for data storage, compliance requirements, and performance optimization recommendations.

data regions, data storage, compliance, performance, australia, usa, canada, europe, uk
get-started, learn-about-kinde

When you first sign up to Kinde, you will be given the option to choose your data region. Regions define where Kinde stores data for your customers and business. You may need to select a specific region to meet your regulatory requirements. To ensure optimal performance, we also strongly recommend choosing a region that is closest to your customers and where your app, site, or project is hosted. For example, if you are in Canada, choose the US region; if you are in North Africa, choose Ireland (Europe); for Southeast Asia and Oceania, choose Australia. Currently, we support these regions (with more to follow): - Asia Pacific - Sydney, Australia - North America - Oregon, USA - North America - Quebec, Canada - Europe - Dublin, Ireland - UK - London, England Once selected, you cannot change the data region of your business within Kinde. ## Failover support within regions We currently have failover support within regions. But we do not have cross-regional failover support. This ensures that data stays in the selected region. Email [support@kinde.com](mailto:support@kinde.com) if you have any questions about how your data is stored. You can also read [our privacy policy](/trust-center/privacy-and-compliance/privacy-policy/).

# Get started - Learn about kinde - What does Kinde do?

> Overview of Kinde's dev-acceleration infrastructure platform including authentication, user management, feature flags, and SDK support for SaaS teams.

kinde platform, authentication, user management, feature flags, webhooks, sdk, saas infrastructure
get-started, learn-about-kinde

Kinde builds beautifully simple dev-acceleration infrastructure for SaaS teams. We provide an easy-to-use platform and code support for building: - [Authentication and access](/authenticate/about-auth/about-authentication/) - [Environment management](/build/environments/environments/) - [Feature flags](/releases/about/about-feature-flags/) - [User management](/manage-users/about/) - [B2B/B2B2C infrastructure](/build/organizations/add-and-manage-organizations/) - [Webhooks](/integrate/webhooks/about-webhooks/) and [connections](/integrate/connected-apps/add-connected-apps/) - Custom [data](/properties/work-with-properties/manage-properties/), [tokens](/properties/work-with-properties/properties-in-tokens/), [brand](/design/brand/global-brand-defaults/), and [domains](/build/domains/pointing-your-domain/) - Customer billing (coming soon) Supported by [SDKs](/developer-tools/about/our-sdks/) in more than 20 different language frameworks, your engineers can focus on building your core product, without also having to build the essential functions that allow your business scale and grow. <Aside> **Kinde exists to do everything possible to propel founders and their teams forward.** Check out some of our features in action on [YouTube](https://www.youtube.com/@heykinde/videos). </Aside> ## Get started If you already have a project and we have an SDK using your framework, you can get up and running in minutes. See [Where to start with Kinde](/get-started/guides/first-things-first/). ## Join the community If you sign up to Kinde, you’ll be among thousands of like-minded colleagues who are bringing their own ideas to life. Join them via [Discord](https://discord.gg/KdkCXRNTFn) or [Slack](https://join.slack.com/t/thekindecommunity/shared_invite/zt-2k5i0aeet-d6Z_2qYphcNCpj0bFa4oCg). ## Find out what’s coming We have a long exciting road of plans ahead. Keep an eye on [the Kinde roadmap](https://updates.kinde.com/board) to see where we’re headed next.

# Get started - Switch to kinde - Migrate to Kinde from Auth0

> Comprehensive guide to migrating from Auth0 to Kinde including user data export, password migration, social identities, and organizational setup.

auth0 migration, user import, password migration, oauth2, oidc, social identities, organizations, roles, permissions
get-started, switch-to-kinde

This guide is designed to help you migrate from Auth0 to Kinde. Switching between providers for any service can be daunting, and especially where user data is involved. We’ll walk you through the process or migrating, to take some of the pain away. If you’ve got a lot of users (your export file is over 20MB) or are concerned about file size limits, you can contact us to ensure the import goes smoothly. ## Still not sure about moving to Kinde? If you want to compare Kinde with Auth0, [this page](https://kinde.com/comparisons/auth0-alternative/) has some useful information. A key point to note is that Kinde is OAuth2/OIDC compatible, issuing similar tokens to Auth0. You only need to update the token claims when you migrate. ## Step 1: Prepare your Kinde business for migration If you haven’t already got a Kinde account, [register for free here](https://app.kinde.com/register) (no credit card required). - Set up the [authentication methods](/authenticate/about-auth/about-authentication/) in Kinde. You can replicate the auth methods you currently use with Auth0, or [set up new methods for users](/authenticate/authentication-methods/set-up-user-authentication/), e.g. passwordless. - If your users sign in with passwords, be sure to enable [password authentication](/authenticate/authentication-methods/password-authentication/). - [Create organizations in Kinde](/build/organizations/add-and-manage-organizations/) - only if you use this function to support multi-tenancy (for example, in a B2B structure) or if you manage separate user groups this way. - Add [roles](/manage-users/roles-and-permissions/user-roles/) and [permissions](/manage-users/roles-and-permissions/user-permissions/) in Kinde, if you intend to import these details with users. - Review the [Migrating other objects](/get-started/switch-to-kinde/auth0-to-kinde/#other-objects-you-may-want-to-bring-from-auth0) topic below. ## Step 2: Get the Auth0 extension to export users Auth0 doesn’t have an export option by default, so you’ll need to install an export extension. 1. Go to [Auth0 Dashboard > Extensions](https://manage.auth0.com/#/extensions), and select **User Import / Export**. 2. When prompted, select **Install**. ![Auth0 extension screen shot](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/2a8f1e39-2050-4c14-146a-338ecb57bb00/public) You'll now see it in your list of installed extensions. The first time you launch it, you'll be asked to grant permission for the extension to access your Auth0 account. ## Step 3: Export user data from Auth0 File format guidelines: - User details and passwords must be in NDJSON (Newline Delimited JSON) format - Import file size limit is 20MB. You may need to split the file if the exported size exceeds this. ### Supported auth methods Kinde supports migrating the following authentication methods from Auth0: Usernames, Email, Phone, Google, Apple, Microsoft, Facebook, GitHub, Twitch, Bitbucket. If you need to migrate another authentication type from Auth0 please get in touch with support. Auth methods are shown in the `connection` attribute. These are represented as follows in the identity array: - Username-Password-Authentication - email - sms - google-oauth2 - github - twitch - facebook - bitbucket - windowslive ### Can’t get the passwords from Auth0? Some Auth0 plans don’t allow password exports, or you might not want to wait 2 weeks for the file. If this is the case, import the user data you’re able to, and Kinde will ask users to set a new password the next time they sign in. ### Export Auth0 data 1. Launch the extension by selecting **Import / Export Extension.** 2. Export your existing Auth0 users associated with database connections, select **Export**. ![Auth0 export selections screen shot](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/0748f464-d46f-4455-20dc-8f1c677fbb00/public) 3. Select **Add default fields** and add the **identities** field to the import list. **Identities** data distinguishes the type of identity, e.g. username, phone, GitHub, Google, etc. 4. Change the **Export Format** to **.json**. 5. When you're ready, click **Export [X] Users.** (**X** is the number of users you're exporting). 6. Once the export is complete, select **Download** to get the file containing your user’s information. This is the main file you’ll need to migrate your users; the other file is the password hashes. ## Step 4: Import user data into Kinde 1. In Kinde, go to **Users**, then select **Import users**. 2. Select **Auth0.** ![Import from Kinde tool screen shot](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/10090edb-3f26-405d-898d-2dfedd155100/public) 3. You’ll be presented with 2 options: 1. **Import users only** - import users first and passwords after. You can also use this method if you want to allow users to reset their password or sign in another way. 2. **Import passwords only** - only choose this if you have already imported users. 4. Follow the on-screen prompts to import the data. 5. If there are any [errors with the import](/manage-users/add-and-edit/troubleshoot-user-import-errors/), you will be able to view them afterwards. 6. Most import errors can be fixed by editing the json file and then re-importing into Kinde. Once the password hashes have been imported, your users will be able to sign in to Kinde with their existing password. ### How Auth0 user identities are treated on import Social identities without an email can be imported and are identified by the `connection` attribute. You can also import users with multiple identities; these will be listed under the user’s profile. ## After the migration ### **Communication to users after import** Kinde does not send any notifications or invitations to users when they are added to Kinde via import. The idea is that your users have a seamless experience that feels (almost) like it always has in your app. Similarly, if you add users via API, Kinde does not send an email or notification to the user. If you’ve made changes to their sign in experience — for example adding multi-factor authentication — then consider contacting your users to let them know their sign in experience will be changed. ### Additional consequences of migration Importing all your existing users and passwords following the above process should mean that your users won’t notice anything when they next sign in. This is the optimal experience. However: - If a user changes their password after the user export and while the migration is in progress, they will need to reset their password to sign in. - If you have set up a new authentication method as part of the user migration (for instance, going password-less) your users will be prompted to use the new method on sign in. - If you add or remove roles or permissions, users may gain/lose access to parts of your system. During and following the migration, we recommend checking for these issues. ### There is no check for weak passwords When you import passwords, Kinde does not check for password strength. You’ll want to enforce your own password policies for users. ### Other objects you may want to bring from Auth0 If you have important objects that need to be migrated, such as organizations or roles outside the basic user information, you can import them, or add them via the [Kinde management API](/kinde-apis/management/). Before you migrate, however, be aware that the functionality of these objects may differ between Auth0 and Kinde. Here’s some similarities and differences to note: - Auth0 has the concept of [Tenants](https://auth0.com/docs/get-started/learn-the-basics) which group other objects such as users and applications together. Kinde calls these [Businesses](/build/set-up-options/run-multiple-businesses/) and is set up to allow you to run multiple businesses with a single Kinde account. - Both Kinde and Auth0 have [Organizations](/build/organizations/multi-tenancy-using-organizations/) to allow you to build multi-tenant applications. The main difference being that Kinde treats organizations as a first class citizen. - Each business Kinde allows you to have multiple [Environments](/build/environments/environments/) and these contain organizations, users and applications. - In Auth0, [Applications](https://auth0.com/docs/applications/set-up-an-application) are what your users can sign in to. They are also called [Applications](/build/applications/add-and-manage-applications/) in Kinde and work in essentially the same way. - In Auth0, [Identity Providers](https://auth0.com/docs/identityproviders) are a source of data for users. Kinde calls these connections or authentication providers. - In Auth0, [Roles and Permissions](https://auth0.com/docs/authorization/rbac/roles) provide information about what your users can do in your applications. Kinde also has [Roles](/manage-users/roles-and-permissions/user-roles/) and [Permissions](/manage-users/roles-and-permissions/user-permissions/) and they are assigned on a per user, per organization basis, meaning the same user can have different permissions in different organizations. For the Auth0 equivalent of user-level roles/permissions, use the [default organization](/build/organizations/orgs-for-developers/). - Kinde’s hosted sign-up pages are a very similar concept to [Auth0’s Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login). ## Help is here We’ve tried to make onboarding to Kinde as easy as possible, because we know it’s a pain to break up with your old provider. We’re here to help and can assist with your migration. Contact us via: [Slack](https://thekindecommunity.slack.com/join/shared_invite/zt-26hdaavyc-CfOa06vP23guSwK~~OpFMQ#/shared-invite/email), [Discord](https://discord.com/invite/wHX6j7wG5d), [Email](mailto:support@kinde.com), [Chat](https://chat.kinde.com) Book a call for: - [General or account questions](https://meetings.hubspot.com/kinde/kinde-demo) - [Technical questions](https://meetings.hubspot.com/kinde/kinde-demo) (we will make sure we have engineers on the call to help) - [Security and compliance questions](https://meetings.hubspot.com/kinde/kinde-demo)

# Get started - Switch to kinde - Migrate to Kinde for user authentication

> Comprehensive guide to migrating user authentication to Kinde including CSV import, password migration, authentication setup, and organizational configuration.

user migration, csv import, password migration, authentication methods, organizations, roles, permissions, hashing methods
get-started, switch-to-kinde

If you are currently using a different authentication tool to manage users, you can switch to Kinde pretty quickly. The method described here involves importing user details from CSV files into Kinde. [Follow this other guide](/get-started/switch-to-kinde/auth0-to-kinde/) if you are switching from Auth0. If you’ve got a lot of users (your export file is over 5MB) or are concerned about file size limits, you can contact us to ensure the import goes smoothly. ## Before you import users - [Create organizations in Kinde](/build/organizations/add-and-manage-organizations/) - only if you use this function to support multi-tenancy (for example, in a B2B structure) or if you manage separate user groups this way. - Add [roles](/manage-users/roles-and-permissions/user-roles/) and [permissions](/manage-users/roles-and-permissions/user-permissions/) in Kinde, if you intend to import these details with users. ### Set up user authentication We recommend setting up user authentication in Kinde before importing. For example, set up: - Passwords - switch this option on before importing user passwords - Passwordless - users will be sent a one-time code to sign in - Social sign-on - users can sign up and in using Google, Apple, etc. - Enterprise - SAML or Entra ID. **Note: Importing users from Azure** Set up the [MS Entra ID connection in Kinde](/authenticate/enterprise-connections/azure/) before you import your users. Then when you import, Kinde will match users to the relevant connection based on their email address. For more details, see [Authentication methods](/authenticate/authentication-methods/set-up-user-authentication/). ## Step 1: Prepare user data You can export user details and data fairly easily from most auth providers. However, some providers require you to separately request password details for users and this can take a little while. If you’re using your own auth system, prepare data as described below. ### File format User data can only be imported from a CSV file. Depending on what you currently use for auth, you will need to export or prepare data in a CSV file. Kinde can import files up to 5MB. You may need to split the import into batches if you have a lot of users. ### Export data from other systems or your own system When exporting data from another auth system or your own system, the CSV file you export may need to be edited to ensure data is formatted in rows with some of these column headings. ### Required **data** - `email` - minimum required information - `external_organization_id` - Only required if you are importing roles and permissions <Aside> The more data that you include for import, the easier we can set up your users in Kinde. Kinde will not duplicate users with existing email addresses. </Aside> ### **Other user data** - `first_name` and `last_name` - `id` (also referred to as `provided id`) - unique to the auth provider and helps us match records as they are imported. - `phone` - including the international code with no spaces and no leading ‘0’, for example. +61555111555. Required for phone authentication. ([beta feature](https://kinde-21631392.hs-sites.com/en-au/beta-feature-interest)) - `phone_verified` - phone number verification status: TRUE or FALSE ([beta feature](https://kinde-21631392.hs-sites.com/en-au/beta-feature-interest)) - `email` - the user’s email address - `email_verified` - email verification status: TRUE or FALSE - `role_key` - the role key for the role a user will be assigned on import. If the user is to be assigned more than one role, use a comma separated list. - `permission_key` - the permissions key for the permission a user will be assigned (that is not included in their role). If the user is to be assigned more than one permission, use a comma separated list. - `external_organization_id` - the ID of the organizations you want the user to be imported into (if applicable). Only required if you are importing roles and permissions with user data. If the user belongs to more than one organization, use a comma separated list. <Aside> Note that this is NOT the same as the **Organization code** in Kinde, which is a Kinde-supplied ID. </Aside> ### Password data (optional) - `hashed_password` - the user’s password encrypted using a hashing method or algorithm. - `hashing_method` - the name of the algorithm used to encrypt the user’s password. Currently **crypt**, **bcrypt**, **sha256**, **md5**, and **wordpress** are supported. [Contact us](https://kinde-21631392.hs-sites.com/en-au/feature-request) if you need a different method. - `salt` - extra characters added to passwords to make them stronger - `salt_position` - position of salt in password string. E.g. prefix (before) or suffix (after). - `salt_format` - format of the salt, e.g. hex, string, etc. <Aside title="bcrypt $2b variant support:"> Please note if you are importing bcrypt hashes with the $2b variant, Kinde will substitute this for the $2a variant. These are interchangeable as long as you were not running OpenBSD at the time the hashes were generated. </Aside> <Aside title="sha256 support:"> Provide the hash in hex format. Import the salt using the `salt` column. For the `salt_format`, specify how the salt should be interpreted: e.g. **hex** for a hex-encoded string (68656c6c6f for hello). By default, the salt is treated as a plain string, and escape sequences (like \n or \v) are treated as literal characters. </Aside> | Hashing method | Salt | Salt position | | -------------- | -------- | ------------------------- | | md5 | Optional | required if salt included | | bcrypt | | | | crypt | Optional | | | wordpress | Optional | | | sha256 | Optional | required if salt included | ### Example CSV ```text email,first_name,last_name,email_verified,hashed_password,hashing_method,external_organization_id bills@company.com,bill,smith,TRUE,#########,md5,abc001 carlosg@company.com,carlos,garcia,TRUE,#########,md5,abc001 lliu@company.com,lee,liu,FALSE,#########,md5,xyz002 ``` ### Check for errors Before importing, check the CSV for missing information or duplication. Kinde will check for some errors during import, and report these back to you. ### Passwords If you want your users to have an uninterrupted sign in experience as you change providers, you will need to bring their password data from your auth provider. Passwords are usually ‘hashed’ or encrypted so they cannot be read and they may be ‘salted’ as well (see above). If you decide not to import passwords, however, it’s not a big deal. Users will be prompted to reset their password or sign in using whatever authentication methods you have chosen to set up in Kinde. ## Step 2: Import users Once you have your user details, you’re ready to import them. 1. In Kinde, go to **Users**, then select **Import users**. 2. Select the **Import users** tab and then select **Import from a CSV** 3. Follow the on-screen prompts to upload the user data. 4. If there are any errors with the import, you will be able to view them afterwards. 5. Most import errors can be fixed by editing the CSV file and then re-importing into Kinde. Any records that have already been imported and have not been edited, will be ignored. For full instructions, see [Import or update users in bulk](/manage-users/add-and-edit/import-users-in-bulk/). ## After the migration ### **Communication to users after import** Kinde does not send any notifications or invitations to users when they are added to Kinde via import. The idea is that your users have a seamless experience that feels (almost) like it always has in your app. Similarly, if you add users via API, Kinde does not send an email or notification to the user. If you’ve made changes to their sign in experience — for example adding multi-factor authentication — then consider contacting your users to let them know their sign in experience will be changed. ### Additional consequences of migration Importing all your existing users and passwords following the above process should mean that your users won’t notice anything when they next sign in. This is the optimal experience. However: - If a user changes their password after the user export and while the migration is in progress, they will need to reset their password to sign in. - If you have set up a new authentication method as part of the user migration (for instance, going password-less) your users will be prompted to use the new method on sign in. - If you add or remove roles or permissions, users may gain/lose access to parts of your system. During and following the migration, we recommend checking for these issues. ### There is no check for weak passwords When you import passwords, Kinde does not check for password strength. You’ll want to enforce your own password policies for users.

# Get started - Team and account - Add team members

> Guide to adding team members to Kinde including role management, invitations, and access control for business owners and admins.

team members, member roles, owner, admin, invitations, access control
get-started, team-and-account

You can invite other team members and give them access to your business on Kinde. When you add new people, you can [add roles](/get-started/team-and-account/team-member-roles/) for them as well. Paid plans come with [multiple pre-defined roles](/get-started/team-and-account/team-member-roles/). Free accounts come with an Owner and Admin role only. ## How team member roles work - Team members can have any mix of roles, such as Customer success / Engineer / Finance / Marketing / Security specialist. Although it may be easier to give admin rights if broad access is needed. - Only Owners can promote other team members to Owners - Any combo of roles can be assigned to team members when they are invited to Kinde - Roles are gated to prevent being changed by users without sufficient permissions. i.e a read-only person can’t make someone an Owner ## Add a new member You need sufficient permissions to be able to add team members. 1. On the Kinde home page, select the avatar menu on the bottom left, and then select **Team members**. A list of your current team is shown. 2. Select **Add member**. 3. In the window that appears, enter the team member’s details. 4. Select the roles they will have in the business. This can be more than one. 5. Select **Save**. Your team member will receive an email with an invitation to join your business on Kinde. They can set up an account or sign in to an existing account. ## Change the role of a team member You need sufficient permissions to be able to change member roles. An owner can make any changes. An Admin can make any changes (except to the Owner role). 1. On the Kinde home page, select the avatar menu on the bottom left, and then select **Team members**. A list of your current team is shown. 2. Select the three dots next to the team member who's role you want to change. 3. In the menu that appears, select **Edit roles**. 4. Using the toggles, change the roles they will have in the business. This can be more than one. Note you are restricted by your own role as to your ability to change roles for others. 5. Select **Save**. The team member's roles have been changed. ## **Revoke an invitation** 1. On the Kinde home page, select the avatar menu on the bottom left, and then select **Business settings**. 2. Select **Members** in the side menu. 3. Find the team member in the list, they will have a tage showing 'invited' next to their name. 4. Select the three dots, then select **Revoke invitation**. ## Delete **team member** Owners and Admins can delete other Admins. Only Kinde can delete Owners, and only on request and verification. 1. On the Kinde home page, select the avatar menu on the bottom left and then select **Business settings**. 2. Select **Members** in the side menu. 3. Find the team member in the list, select the three dots, then select **Delete team member**. 4. Confirm the deletion when prompted.

# Get started - Team and account - Access Kinde via an enterprise connection

> Guide to setting up enterprise access to Kinde using SAML connections for team member authentication via Identity Provider.

enterprise access, saml, identity provider, idp, entity id, metadata url, acs url
get-started, team-and-account

If you want your team members to sign in to the Kinde dashboard using an enterprise connection (such as SAML) instead of via our default sign up flow, you can contact us to request it. You must be on a Kinde Scale or Enterprise plan to request this. Email your business name and email ID to support@kinde.com and provide the following from your Identity Provider (IdP): - Entity ID - IdP metadata URL - Email key attribute - First name key attribute - Last name key attribute - Home realm domains Once we have these, we can set up the connection and send you an ACS url (also known as a **reply url**), for example: `https://app.kinde.com/login/saml/callback`, to complete the setup with your IdP.

# Get started - Team and account - Claim credits with Kinde perk code

> Guide to claiming Kinde perk codes and credits from community partners for account billing.

perk code, credits, billing, community partner
get-started, team-and-account

If you’ve received a Kinde perk code from a Kinde Community Partner, send us the code, along with details of who you got it from so we can credit your account. Email us at support@kinde.com with the subject 'Claiming Kinde perk credit' Once we verify the code, we will apply credits to your account. Expect the credit to be deducted from your normal billing until the credit runs out.

# Get started - Team and account - Get a referral code for sharing Kinde

> Guide to Kinde's referral program including how to get referral codes, earn commissions, and share with friends and colleagues.

referral program, referral code, commission, rewards, sharing
get-started, team-and-account

Kinde's referral program rewards existing businesses for referring new business to Kinde. Referring a friend could earn you 20% of what they spend with us in a year, if they join up. They also get a $50 credit. ## How it works - Grab your personal referral code (see below) - Share it with a friend or colleague - They sign up using the link and that’s it! ## Get your Kinde referral link 1. On the Kinde home page, select the avatar menu at the bottom left and choose **Account**. 2. Go to your profile and scroll to the **Kinde referral code** section. 3. Generate your unique code (you only need to do this once). 4. Copy the code and re-use it to refer as many friends as you want. ## How to use the code - Share directly with friends and colleagues electronically - Post on your socials - Share at events and in tech forums People who use your code must sign up via the referral link. We can't honor verbal referrals or referrals who sign up via our normal sign-up page. ## How and when do you get paid? At the end of each calendar month, you’ll be notified if any of your referrals signed up to a paid plan. We will reach out to you on the email address associated with your Kinde account, requesting your bank details, and GST registration status (if applicable). We will generate a recipient generated tax invoice, and pay the relevant commission within 30 days of receiving your bank details. We will disclose the total amount of commission available relating to all of your referrals but due to privacy considerations, we cannot disclose the identity of your referrals or the revenue that we receive from them. ## More information Visit our [website](https://kinde.com/refer/) for detailed information about the referral program. Or contact us via support@kinde.com with other questions.

# Get started - Team and account - Add MFA for accessing Kinde

> Guide to setting up multi-factor authentication for team access to Kinde including role-based MFA and authentication factors.

mfa, multi-factor authentication, team security, role-based mfa, authenticator app, sms code, email code
get-started, team-and-account

<Aside> For paid Kinde plans only. Not available on the free plan. </Aside> If you want your team members to use multi-factor authentication (MFA) when they sign in to Kinde, you can contact us to request this. We can set MFA so that it applies to everyone in your team, or only applies to certain roles, e.g. Owners within the business. ## What to ask for when you request MFA Send your MFA request to support@kinde.com, and include: - The name of each business that MFA should apply to - The MFA factors that you want your team to have available to them, e.g. one or more of these factors: email code, SMA code, Authenticator app. - If you want MFA to be applied only to certain roles, such as **Owner** Feel free to send any questions you have along with the request.

# Get started - Team and account - Team member roles in Kinde

> Guide to managing roles and permissions for team members in Kinde.

team members, member roles, owner, admin, invitations, access control

You can invite other team members and give them access to your business on Kinde. To simplify access control, Kinde has provided a number of pre-defined roles. ## Team member roles (Paid plans) On Kinde paid plans, there are a range of specific roles that can be assigned to team members. This allows you to restrict actions that you may want limited to certain people in your business. **Owner** - The person who creates the business in Kinde is automatically the Owner. They have the highest access level in the Kinde business and can assign any role to anyone. Only an owner can approve data export from Kinde. **Admin** - Comprehensive access to manage all aspects of the system, excluding the ability to assign or modify the Owner role. **Customer success** - Manage user accounts, subscriptions, and organization settings to support customer onboarding and retention. **Engineer** - Configure applications, APIs, environments, feature flags, and integrations. Access audit logs for debugging and monitoring. **Finance** - Oversee your business’s subscription to Kinde, including plan type and payment details. **Marketing** - Manage branding elements, email templates, and content-related settings to ensure a consistent user experience. **Read-only** - Read-only access across all system areas for monitoring and review purposes without the ability to make changes. **Security specialist** - Manage authentication methods, multi-factor authentication (MFA), and security policies for your business. ## Team member roles (Free plan) The Kinde free plan comes with just the Owner and Admin roles. **Owner** - The person who creates the business in Kinde is automatically the Owner. They have the highest access level in the Kinde business. Only an owner can approve data export from Kinde. **Admin** - All other team members in Kinde are created as Admins. They have access to all Kinde features, except data export approval and the ability to change the Owner role. ## How team member roles work - Team members can have any mix of roles, such as Customer success / Engineer / Finance / Marketing / Security specialist. Although it may be easier to give admin rights if broad access is needed. - Only Owners can promote other team members to Owners - Any combo of roles can be assigned to team members when they are invited to Kinde - Roles are gated to prevent being changed by users without sufficient permissions. i.e a read-only person can’t make someone an Owner ## Change the role of a team member You need sufficient role permissions to be able to change member roles. An owner can make any changes. An Admin can make any changes (except to the Owner role). 1. On the Kinde home page, select the avatar menu on the bottom left, and then select **Team members**. A list of your current team is shown. 2. Select the three dots next to the team member who's role you want to change. 3. In the menu that appears, select **Edit roles**. 4. Using the toggles, change the roles they will have in the business. This can be more than one. Note you are restricted by your own role as to your ability to change roles for others. 5. Select **Save**.

# Integrate - Connected apps - Add connected apps

> Comprehensive guide to adding and configuring connected apps in Kinde including OAuth setup, scope management, and access token retrieval for third-party integrations

connected apps, third party integration, oauth, access tokens, scopes, client id, client secret, callback urls, management api
integrate, connected-apps

Connected apps let your users access third party tools and services through Kinde. When you add a connection, you’ll need to define which features (or scopes) that you want to be made available. To get the connection up and running, you’ll need to do some steps in Kinde and some in the app you are connecting. ## **Before you add a connected app** - Set up a [machine to machine application](/developer-tools/kinde-api/connect-to-kinde-api/) - Ensure you have at least one [end-user created](/manage-users/add-and-edit/add-and-edit-users/) ## **Step 1: Add the connected app in Kinde** 1. In Kinde, go to **Settings > Connected apps**. 2. Select **Connect an app**. A dialog opens. 3. Select the connected app you want from the available apps. 4. Select **Save**. The app will appear in the list of your connected apps. 5. Select **Configure** on the tile and copy the **Provider to Kinde** callback URL. 6. Next: Set up the app. See instructions for setting up apps below. ## **Step 2: Set up the app you want to connect** - [Google Drive](/integrate/connected-apps/google-drive-connected-app/) - [GitHub](/integrate/connected-apps/github-connected-app/) - [GitLab](/integrate/connected-apps/gitlab-connected-app/) - [Patreon](/integrate/connected-apps/patreon-connected-app/) - [Discord](/integrate/connected-apps/discord-connected-app/) - [Microsoft 365](/integrate/connected-apps/microsoft-365-connected-app/) ## **Step 3: Configure the connected app in Kinde** To complete this procedure, you need to have set up the app. See relevant instructions below. 1. In Kinde, go to **Settings > Connected apps**. 2. On the app tile, select **Configure**. 3. On the Details tab: 1. Enter a name. 2. Enter the **Client ID** and **Client secret** from the app, e.g. Google Drive. 3. Enter a reference key that will be used in your app’s code. 4. Enter the callback URL for your app. 5. Select **Save**. 4. In the **Permissions** tab, select the permissions (scopes) that you want to access via the connection. 5. Select **Save**. The next time a user signs in, they will be prompted to allow the above permissions. ## **Step 4: Get an access token via the Kinde Management API** This final step needs to be performed in your own app, using that app’s language. The steps below simulate the process in Postman. 1. Get the user ID of one of your users by calling the following API in Postman: `https://yourdomain.kinde.com/api/v1/users`. In the below example, the `id` of the only user in the business is `kp:xxxxx...` <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/4226353f-43a6-4fbd-381c-5f6817e32800/public" alt="" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" /> Note: The user’s endpoint is a Kinde management API endpoint, therefore you will need a token to call this API. 2. Using Postman, call the auth url endpoint to get a URL that will allow you to connect, e.g. to Google. The URL is: `https://<KINDE_URL>/api/v1/connected_apps/auth_url?key_code_ref=<KEY>&user_id=<USER_ID>` 3. Replace: - `<KINDE_URL>` with your Kinde business url, e.g. `mybiz.kinde.com` - `<KEY>` with the unique key you gave your connected app - `<USER_ID>` with the user id you got in step 1 Note: The `auth_url` endpoint is a Kinde management API endpoint, therefore you will need a token to call this API. You will get back a URL and session_id in the response if the call was successful: <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/040b6860-0774-4128-fbb9-95dd24774300/public" alt="Getting session_id in Postman" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" /> 4. Copy the URL from the call to `url` and paste it in a browser’s address bar. This should redirect you to get authenticated. 5. Authorize the requested scopes for the application. You will be redirected to the URL defined in the `Kinde to application` . 6. Use Postman to call the `connected_apps/token` API to get an access token that has been granted the scopes you have defined previously. The URL is: `https://<KINDE_URL>/api/v1/connected_apps/token?session_id=<SESSION_ID>` 7. Replace: - `<KINDE_URL>` with your Kinde business url, e.g. `mybiz.kinde.com` - `<SESSION_ID>` with the session_id that was returned when calling the `auth_url` endpoint Note: The `connected_apps/token` endpoint is a Kinde management API endpoint, therefore you will need a token. You will get an access token back from the call. This token can be used to call the connected services. 8. You’re ready to use the connection. Below is an example API call to Google Drive. ### **Example connected app access - Google Drive** 1. In your code or using Postman, call the Google Drive API to list files. The URL is `https://www.googleapis.com/drive/v3/files` . 2. You will need to use the access token you obtained earlier, and pass it as a bearer token in the Authorization header. Here’s what the call and return looks like. <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/c76b98f4-828e-4147-4ff1-32fa489e1400/public" alt="Calling Google Drive API in Postman" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" /> ## **Disconnect a connected app** You can disconnect a connected app from Kinde, however this does not revoke permissions. To revoke permissions you need to call the `/connected apps/revoke` endpoint. 1. Go to **Settings > Connected Apps**. 2. Select the three dots menu on the tile for the connected app, then select **Disconnect**. A confirmation window pops up. 3. Select **Disconnect**.

# Integrate - Connected apps - Discord connected app

> Guide to setting up Discord as a connected app in Kinde including OAuth2 configuration, client credentials, and redirect URI setup

discord, oauth2, client id, client secret, redirect uri, callback url, discord developer
integrate, connected-apps

Before you can add Discord as a connected app in Kinde, you need to [set up a machine to machine application](/developer-tools/kinde-api/connect-to-kinde-api/) to connect to Kinde’s API. This is Step 2 of the [Kinde Connected apps setup](/integrate/connected-apps/add-connected-apps/#step-2-set-up-the-app-you-want-to-connect) topic. You first need to have [added the connected app](/integrate/connected-apps/add-connected-apps/#step-1-add-the-connected-app-in-kinde) in Kinde. ## What you need The Provider to Kinde callback URL from the Kinde connected app. ## Set up the Discord app 1. Sign in to your [Discord developer account](https://discord.com/developers/applications). 2. In the **Applications** section, select **New application**. 3. Give your application a name and agree to Discord’s terms, then select **Create**. 4. Copy the **Client ID** and **Client secret**. These correspond to the Client ID and Client secret in your Kinde M2M application. ![screen shot of discord add application screen](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/9b43cdbe-70fd-4c61-beee-155efadfde00/public) 5. In the menu, select **OAuth2**. ![screen shot of redirects field in discord app](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/b7fa03fd-f67c-433a-f603-8607f1df4a00/public) 6. If the Redirect URI field is not blank, select **Add Another**. 7. Paste the **Provider to Kinde callback URL** that you copied when you set up the connection in Kinde. 8. Next: Finish setting up the connection in the Kinde application. See [Configure the connected app in Kinde](/integrate/connected-apps/add-connected-apps/#step-3-configure-the-connected-app-in-kinde).

# Integrate - Connected apps - GitHub connected app

> Step-by-step guide to setting up GitHub as a connected app in Kinde including OAuth app creation, permissions configuration, and callback URL setup

github, github app, oauth, permissions, scopes, client id, client secret, webhooks, developer settings
integrate, connected-apps

Before you can add GitHub as a connected app in Kinde, you need [set up a machine to machine application](/developer-tools/kinde-api/connect-to-kinde-api/) for connecting to the Kinde API. This is Step 2 of the [Kinde Connected apps setup](/integrate/connected-apps/add-connected-apps/#step-2-set-up-the-app-you-want-to-connect) topic. 1. Sign in to your GitHub account and open the **Developer settings:** 1. If this is a personal account, select your avatar and select **Settings**. 2. If this is an organization account, select your avatar, select **Your Organizations**, then select **Settings**. 2. Select **Developer Settings** in the left menu. The **GitHub apps** page opens. 3. Select **New GitHub App**. 4. Enter a name for the app and add a **Homepage URL**. 5. Add the callback URL copied from Kinde's GitHub connected app. It should be something like `https://<yourdomain>.com/connected_apps/callback`. 6. In the **Webhook** section, make webhooks inactive if they are not being used. 7. In the **Permissions** section, for each permission group (Repository, Organization, Account), open the group and select the access level for each permission - **No access**, **Read-only,** or **Read and write**. For a permission (scope) to be available in Kinde, it needs to be made accessible here. Note that not every permission visible here will also be available in Kinde. Some scopes have been excluded for security and data protection reasons. <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/eb5b9196-bbdc-47ba-947d-68923092ed00/public" alt="" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" /> 8. Based on the permissions you have selected, choose which events you want to subscribe to in the **Subscribe to events** section. 9. When you have finished, select **Create GitHub app**. Details for the app are created. <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/20cfa2af-06c5-4e21-3e10-003e40d8cb00/public" alt="" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" /> 10. Copy the **Client ID** and **Generate a new client secret** to copy into your Kinde GitHub connected app. 11. Note that you can **Revoke all user tokens** in the same area you set up your app (see the screen shot at step 9 above). It is better to revoke tokens in your app set up, rather than through Kinde. 12. Finish setting up the connection in Kinde by following [Step 3: Configure the connected app in Kinde](/integrate/connected-apps/add-connected-apps/#step-3-configure-the-connected-app-in-kinde).

# Integrate - Connected apps - GitLab connected app

> Guide to setting up GitLab as a connected app in Kinde including OAuth provider configuration, scope selection, and application credentials setup

gitlab, oauth provider, scopes, application id, secret, redirect uri, callback url
integrate, connected-apps

Before you can add GitHub as a connected app in Kinde, you need to [set up a machine to machine application](/developer-tools/kinde-api/connect-to-kinde-api/) to connect to Kinde’s API. This is Step 2 of the [Kinde Connected apps setup](/integrate/connected-apps/add-connected-apps/#step-2-set-up-the-app-you-want-to-connect) topic. 1. Sign in to your GitLab account and follow steps 1 to 3 of [these instructions](https://docs.gitlab.com/ee/integration/oauth_provider.html) for adding a group-owned or user-owned application. 2. Name the application. 3. Select the scopes you want to be available in your application. For example, `api`, `read_api`, `read_user`, etc. For a scope to be available in Kinde, it needs to be selected here. Note that not every scope visible here will also be available in Kinde. Some scopes have been excluded for security and data protection reasons. <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/dcf1eb8b-e83e-4e23-323f-4aac3289a400/public" alt="" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" /> 4. Paste the Kinde callback URL in the **Redirect URI** field. 5. Select **Save**. 6. Copy the **Application ID** and **Secret**, and paste them where you can access them later. <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/f3ceadff-02b5-467d-4ade-e22480e87400/public" alt="" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" /> 7. Next: Finish setting up the connection in Kinde. See [Configure the connected app in Kinde](/integrate/connected-apps/add-connected-apps/#step-3-configure-the-connected-app-in-kinde).

# Integrate - Connected apps - Google Drive connected app

> Comprehensive guide to setting up Google Drive as a connected app in Kinde including Google Cloud Console configuration, OAuth setup, and API enablement

google drive, google cloud console, oauth client id, consent screen, scopes, client id, client secret, redirect uris, google drive api
integrate, connected-apps

Before you can add Google Drive as a connected app in Kinde, you need to set up the API connection by following all these steps. This is Step 2 of the [Kinde Connected apps setup](/integrate/connected-apps/add-connected-apps/#step-2-set-up-the-app-you-want-to-connect) topic. ### **Create a project** 1. Sign in to Google and go to the Google Cloud Console [https://console.cloud.google.com/apis](https://console.cloud.google.com/apis). 2. In the **Enabled APIs and services** section, select **Create project.** 3. Give the project a name and location (optional). 4. Select **Save**. You’ll be redirected to the project dashboard. ### **Configure consent and add scopes** You need to configure consent to update scopes before creating the OAuth client ID. 1. Select **Configure Consent Screen**. 2. Select the **User type**: Internal or External. This will usually be **Internal** for Google Workspaces. 3. Select **Create**. You’ll be prompted to follow the app registration process. <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/a8c7c8ea-ca67-4c54-ad5c-bf31d8e36d00/public" alt="Configuring consent in Google Cloud" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" /> 4. Enter the app information, including: 1. **App name** 2. **User support email** 3. **App domain** information, including privacy links and terms. If prompted, add **Authorized domains**. 4. **Developer contact** information 5. Select **Save and continue**. 6. Select **Add or remove scopes**. A panel slides out on the right. <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/abef19e0-fd75-4a5f-7bb0-9fa6c7f21f00/public" alt="Updating scopes in Google Cloud" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" /> 7. Browse the list and select scopes you want to include by selecting the checkbox. You can also filter the list or add scopes manually. See the [full list of available scopes](https://developers.google.com/identity/protocols/oauth2/scopes). For a scope to be accessed by Kinde, it needs to be selected in this list. 8. When you have finished selecting scopes, select **Update**. 9. Select **Save and continue**. 10. If you want, you can add test users, but you don’t have to. ### **Create OAuth Client ID** 1. Select **Credentials** in the left hand menu. 2. Select **+ create credentials > OAuth client ID.** 3. Select the application type and enter a name. 4. If you want, add **Authorized JavaScript origins** 5. Add **Authorized redirect URIs**. Enter your Kinde callback URL. E.g. `https://yourdomain.kinde.com/connected_apps/callback` 6. Select **Create**. A modal appears with your Client ID and Client Secret. <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/39a36b61-b554-4156-a8b0-4b49e3e26e00/public" alt="Creating OAuth client in Google Cloud" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" /> 7. Copy these details immediately somewhere you can access them later for entering in Kinde. You can also download them as a JSON file. ### **Enable the API in the project** 1. On the API and Services page (where you have setup your Google client), in the **Enable APIs and Services** section, select **Enable APIs and Services.** <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/f1b88701-9cbc-419d-1ea6-9e84e8d22a00/public" alt="Enabling the API in Google Cloud" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" /> 2. Search for Drive, then select the search result for **Google Drive API.** 3. Click **Enable**. This can take a few seconds to enable. 4. Finish setting up the connection in Kinde by following Step 3: [Configure the connected app in Kinde](/integrate/connected-apps/add-connected-apps/#step-3-configure-the-connected-app-in-kinde).

# Integrate - Connected apps - Microsoft 365 connected app

> Guide to setting up Microsoft 365 as a connected app in Kinde including Azure app registration, calendar permissions, and client secret generation

microsoft 365, microsoft azure, entra id, app registration, calendar scopes, client id, client secret, redirect uri, microsoft graph
integrate, connected-apps

You can now set up a connection between Kinde and Microsoft 365. You might do this, for example, to request Microsoft 365-related permissions from users during auth. The procedure below covers the case for adding calendar permissions. ## Before you begin - Set up a [machine to machine application](/developer-tools/kinde-api/connect-to-kinde-api/) - Ensure you have at least one [end-user created](/manage-users/add-and-edit/add-and-edit-users/) - Complete [Step 1: Add a connected app to Kinde](/integrate/connected-apps/add-connected-apps/#step-1-add-the-connected-app-in-kinde) You also need a [Microsoft Azure account](https://portal.azure.com/#home) for creating MS Entra ID apps. ## Register a Microsoft app This is Step 2 of [Add a connected app to Kinde](/integrate/connected-apps/add-connected-apps/#step-1-add-the-connected-app-in-kinde). 1. Sign in to your [Microsoft Azure account](https://portal.azure.com/). 2. Navigate to **Entra ID**. You can do this from links on the main screen or in the left side menu. 3. Select **Add+ > App registration** or go to **Manage > App registrations > New registration**. 4. Enter a name for the app. 5. Select a **Supported account types option**. For testing purposes, we selected **Accounts in any organizational directory and personal Microsoft accounts**. 6. In the **Redirect URI (optional)** section, select **Web** in the **Select a platform** dropdown. 7. Enter the **Provider to Kinde callback URL** from the Kinde connected app. For example, `https://app.<yourdomain>/connected_apps/callback`. 8. Select **Register**. Details of your new app appear. 9. Copy the **Application (client) ID** and paste it in a text file or somewhere you can easily access it again. You’ll use this as the **Client ID** for the connected app in Kinde. ## Add calendar scopes and generate a secret <Aside type="warning"> While it may be possible to add other scopes, we have currently only tested the inclusion of calendar scopes. </Aside> 1. Add scopes to the Microsoft app. 1. Go to **API permissions**. 2. Select **+ Add a permission**. 3. In the pop-out, select **Microsoft Graph** and then **Application permissions**. 4. Search for ‘calendar’, then select only `Calendars.Read` and `Calendars.ReadWrite`. ![Entra app Permissions for calendar](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/1fa72783-a7e0-45d1-08ee-ba6df5106300/public) 5. Select **Add permissions**. These permissions can now be selected as scopes in the Kinde connected app. 2. Generate a secret. 1. Select **Certificates and secrets** from the left menu, select + **New client secret.** 2. Enter a name and give it an expiry date (or accept the default), then select **Add**. Details of the secret are generated. 3. Copy the value in the **Value** column and paste it in a text file or somewhere you can easily access it again. Make sure you copy from the **Value** column, not the **Secret ID** column. ![Entra app secret value not secret ID](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/56dd1ace-8646-44c9-9add-982528e4a800/public) ## Finish configuring the connection in Kinde You’ll need the **Application (Client) ID** and **Secret** that you copied above. You’ll also need your Kinde app callback URL. See [Step 3: Configure the connected app in Kinde](/integrate/connected-apps/add-connected-apps/#step-3-configure-the-connected-app-in-kinde).

# Integrate - Connected apps - Patreon connected app

> Guide to setting up Patreon as a connected app in Kinde including creator platform registration, OAuth client creation, and API version configuration

patreon, creator platform, oauth, client id, client secret, redirect uri, api version, scopes
integrate, connected-apps

You can connect Patreon to your Kinde account so you can manage Patreon members and campaigns. Before you can add Patreon as a connected app in Kinde, you need to [set up a machine to machine application](/developer-tools/kinde-api/connect-to-kinde-api/) to connect to Kinde’s API. This is Step 2 of the [Kinde Connected apps setup](/integrate/connected-apps/add-connected-apps/#step-2-set-up-the-app-you-want-to-connect) topic. 1. Sign up as a creator at [patreon.com](http://patreon.com/). 2. Go to the [Patreon Platform (developer area)](https://www.patreon.com/portal/registration/register-clients) and sign in if you are not already. 3. Select **Create new client**. <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/a35a8351-ed96-41ea-2adb-4e2339adb400/public" alt="" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" /> 4. In the window that appears, complete all the required and other fields. 1. In the **Redirect URI** field, enter the callback URL from your app in Kinde. 2. In the **Client API Version** field select **2**. This selection defines the included scopes, which are detailed in the [Patreon docs](https://docs.patreon.com/#scopes). 5. When you’re finished, select **Create New Client**. Your new client is shown in the dashboard of the Patreon Portal. 6. Select the down arrow on the client tile. The app details and other client information is shown. Copy the **Client ID and Client Secret**. 7. Next: Finish setting up the connection in Kinde. See [Configure the connected app in Kinde](/integrate/connected-apps/add-connected-apps/#step-3-configure-the-connected-app-in-kinde).

# Integrate - Third party tools - Kinde as identity provider with Cloudflare Zero Trust

> Guide to configuring Kinde as an identity provider with Cloudflare Zero Trust using OpenID Connect for secure authentication across systems

cloudflare zero trust, openid connect, identity provider, oauth, jwks, token endpoint, authorization endpoint, callback urls
integrate, third-party-tools

If you use Cloudflare to manage authentication across your systems, you can use Kinde as an third-party identity provider. This topic explains how to set up Cloudflare Zero Trust to use Kinde as an auth identity provider through OpenID Connect. You need to already have a backend [web application set up](/build/applications/add-and-manage-applications/) in Kinde to follow this procedure. ## Get your Cloudflare team domain 1. [Sign into Cloudflare](https://dash.cloudflare.com/) and navigate to **Zero Trust**. 2. Go to **Settings > Custom Pages**. <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/9b73e4d9-5478-44f7-a917-8324c529d100/public" alt="" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" /> 3. Copy your **Team domain**. ## Set up your Kinde app 1. In Kinde, go to **Settings > Applications**. 2. Select **View details** on the relevant backend/web application. 3. Copy the **Client ID** and **Client secret** and add them somewhere you can access later. 4. Scroll to the **Callback URLs** section and enter the Zero Trust Team domain in the **Allowed callback URLs** field. (Copied in the procedure above) In this example, we would paste: `mirosaurus.cloudflareaccess.com/cdn-cgi/access/callback` 5. Select **Save**. ## Get your OpenID config info 1. In your browser, go to the OpenID configuration URL of your Kinde business. This will be `https://<your_kinde_subdomain>.kinde.com/.well-known/openid-configuration` Our example shows details for `mirosaurus.kinde.com/.well-known/openid-configuration` <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/8e82dc48-a516-42c7-2a41-0bfea682a600/public" alt="" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" /> 2. Copy the following information somewhere you can access it later. - jwks_uri - e.g. `https://mirosaurus.kinde.com/.well-known/jwks` - token_endpoint - e.g. `https://mirosaurus.kinde.com/oauth2/token` - authorization_endpoint - e.g. `https://mirosaurus.kinde.com/oauth2/auth` ## Add Kinde as a provider in Cloudflare Zero Trust 1. Back in the Cloudflare Zero Trust dashboard, go to **Settings > Authentication**. <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/eb59f014-9fbb-4ef2-6291-ec1d946a7f00/public" alt="" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" /> 2. In the **Login methods** section, select **Add new**. The **Add a login method** screen opens. 3. Select **OpenID Connect** as the identity provider. <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/eb21ed9c-150a-47cd-510d-0a0e5dc15500/public" alt="" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" /> 4. Follow the page guide and enter the following details: - Name - Whatever you want - App ID - this is the Client ID you copied from your Kinde app - Client Secret - this is the Client secret you copied from your Kinde app - Auth URL - the `authorization_endpoint` copied in the previous procedure - Token URL - the `token_endpoint` copied in the previous procedure - Certificate URL - the `jwks_uri` copied in the previous procedure <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/e5cffb1e-e316-473d-d51a-3dac205b1a00/public" alt="" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" /> 5. Select **Save**. ## Enable Cloudflare to use Kinde as an auth provider 1. In the **Zero Trust** dashboard, go to **Access > Applications**. 2. In the **Authentication** tab, select the newly created **Open ID Connect** method. <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/7e72598a-d4a6-48ae-7948-c8face8d0200/public" alt="" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" /> 3. Select **Save application**. When an authentication event is triggered, Cloudflare will offload to Kinde to complete the authentication.

# Integrate - Third party tools - Use Kinde auth in an Electron app

> Step-by-step guide to integrating Kinde authentication with an Electron app, incorporating configuration via SDK, along with login, logout, and user profile access.

electron, OAuth, express, desktop app, authentication, callback urls, client id, client secret
integrate, third-party-tools

## What you need - Latest version of Node.js installed on your computer - A [Kinde](https://kinde.com/) account (Sign up for free) ## Step 1: Create a Kinde application 1. On the Kinde home page, select **Add application.** 1. Enter a name for your application. 2. Select **Front-end and mobile** as the type. 3. Select **Save**, the Quickstart page opens. 2. In the **Quick Start** section, select **Other native**, and then select **Save** to continue. 3. Go to **Details** and make a copy of the **Domain** and **Client ID**. 4. Scroll down, enter the following in the **Allowed callback URLs,** and select **Save** ``` http://127.0.0.1:53180/callback ``` ## Step 2: Initialize an Electron app 1. Open a terminal and run the following commands to create a new folder for your Electron app, and then navigate into it. ```bash mkdir electron-kinde-auth cd electron-kinde-auth ``` 2. Create a new `package.json` file: ```bash touch package.json ``` 3. Open the newly created `package.json` file with your code editor and add the following: ```json { "name": "electron-kinde-auth", "description": "A simple Electron app to authenticate with Kinde using OAuth", "productName": "Electron Kinde Auth", "version": "1.0.0", "main": "main.js", "scripts": { "start": "electron .", "dev": "electron ." }, "dependencies": { "dotenv": "^17.2.2", "express": "^4.19.2", "keytar": "^7.9.0", "node-fetch": "^3.3.2" }, "devDependencies": { "electron": "^31.3.0" } } ``` 4. Run the following command to install the required packages: ```bash npm install ``` 5. Create a `.env` file for environment variables: ```bash touch .env ``` 6. Open it in your editor and paste the Kinde credentials copied from the **Details** page. ```bash KINDE_ISSUER_URL=https://<KINDE_DOMAIN>.kinde.com KINDE_CLIENT_ID=<CLIENT_ID> KINDE_SCOPES=openid profile email offline ``` 7. Create a new `helpers.js` file: ```bash touch helpers.js ``` 8. Add the following code to the `helpers.js` file: ```jsx const crypto = require("crypto") function base64urlencode(buf) { return buf .toString("base64") .replace(/\+/g, "-") .replace(/\//g, "_") .replace(/=+$/, "") } function generateVerifier() { return base64urlencode(crypto.randomBytes(32)) } function challengeFromVerifier(v) { return base64urlencode(crypto.createHash("sha256").update(v).digest()) } function randomState(len = 12) { return crypto .randomBytes(Math.ceil((len * 3) / 4)) .toString("base64url") .slice(0, len) } // Minimal JWT decode (no signature verification) function decodeIdToken(idToken) { try { const [, payload] = idToken.split(".") const pad = (s) => s + "=".repeat((4 - (s.length % 4)) % 4) const json = Buffer.from( pad(payload).replace(/-/g, "+").replace(/_/g, "/"), "base64" ).toString("utf8") return JSON.parse(json) } catch { return null } } function createTokenStore(storage, { serviceName, accountName, logger }) { const safeParse = (s) => { try { return JSON.parse(s) } catch { return null } } return { async load() { const s = await storage.getPassword(serviceName, accountName) const t = s ? safeParse(s) : null if (!t || typeof t.access_token !== "string") return null return t }, async save(tokens) { await storage.setPassword( serviceName, accountName, JSON.stringify({ ...tokens }) ) }, async clear() { try { await storage.deletePassword(serviceName, accountName) } catch (e) { logger?.warn?.(e) } }, async exists() { return (await this.load()) !== null }, } } module.exports = { generateVerifier, challengeFromVerifier, randomState, decodeIdToken, createTokenStore, } ``` ### Code explanation for `helpers.js` **PKCE helpers** - `base64urlencode(buf)` converts raw bytes to URL-safe Base64 (no `+`, `/`, or `=`), which OAuth endpoints expect. - `generateVerifier()` returns a high-entropy, URL-safe PKCE **code_verifier** (32 random bytes → Base64URL). - `challengeFromVerifier(v)` derives the **code_challenge** by SHA-256 hashing the verifier and Base64URL-encoding the digest (`S256` method). Together these implement the PKCE half of the authorization flow. **Random state** - `randomState(len = 12)` generates a short, URL-safe random string for the OAuth `state` parameter (CSRF protection). It uses cryptographic randomness and trims the Base64URL output to your requested length. **ID token decoding** - `decodeIdToken(idToken)` decodes the JWT payload so you can read claims (e.g., `name`, `picture`) without verifying the signature. *Note:* This is for **display/convenience only**—don’t make trust decisions on the decoded payload without verifying the signature remotely (which you typically don’t do in a desktop main process). **Token storage (factory + DI)** - `createTokenStore(storage, { serviceName, accountName, logger })` returns a tiny persistence API: - `load()` → parses the secret and ensures there’s an `access_token`, else `null`. - `save(tokens)` → stores the token blob as JSON. - `clear()` → deletes the secret (logs a warning on failure if a `logger` is provided). - `exists()` → convenience check built on `load()`. - It’s dependency-injected: pass a `storage` that looks like **keytar** (`getPassword`, `setPassword`, `deletePassword`). This makes it trivial to test by swapping in an in-memory mock. **Error handling & resilience** - Safe JSON parsing prevents crashes on corrupt secrets and simply returns `null`. - The store doesn’t encrypt itself; it relies on the OS credential vault (e.g., Keychain, Credential Manager) provided by your `storage` implementation. 9. Create a new `main.js` file: ```bash touch main.js ``` 10. Add the following code to the `main.js` file: ```jsx require("dotenv").config() const { app, BrowserWindow, ipcMain, shell } = require("electron") const path = require("path") const os = require("os") const express = require("express") const keytar = require("keytar") const { generateVerifier, challengeFromVerifier, randomState, decodeIdToken, createTokenStore, } = require("./helpers") // ---------- Config ---------- const CALLBACK_HOST = "127.0.0.1" const CALLBACK_PORT = 53180 const REDIRECT_URI = `http://${CALLBACK_HOST}:${CALLBACK_PORT}/callback` const ISSUER = process.env.KINDE_ISSUER_URL const CLIENT_ID = process.env.KINDE_CLIENT_ID const AUDIENCE = process.env.KINDE_AUDIENCE || "" const SCOPES = ( process.env.KINDE_SCOPES || "openid profile email offline" ).trim() if (!ISSUER || !CLIENT_ID) { console.error("Please configure KINDE_ISSUER_URL and KINDE_CLIENT_ID in .env") } const tokenStore = createTokenStore(keytar, { serviceName: "electron-kinde-pkce-sample", accountName: os.userInfo().username, // or 'default' }) // Ensure we have a fetch impl (Electron/Node 18+ has global fetch) const fetchFn = global.fetch || ((...args) => import("node-fetch").then(({ default: f }) => f(...args))) // ---------- Small helpers ---------- function stampIssued(tokens) { const t = { ...tokens } t.issued_at = Date.now() if (typeof t.expires_in === "number") t.expires_at = t.issued_at + t.expires_in * 1000 return t } async function postForm(url, data) { const body = new URLSearchParams(data) const res = await fetchFn(url, { method: "POST", headers: { "Content-Type": "application/x-www-form-urlencoded" }, body, }) const text = await res.text() if (!res.ok) throw new Error(`${res.status} ${text}`) return JSON.parse(text) } // ---------- OAuth helpers ---------- async function exchangeCodeForTokens({ code, codeVerifier, redirectUri }) { const tokenUrl = new URL("/oauth2/token", ISSUER).toString() const json = await postForm(tokenUrl, { grant_type: "authorization_code", code, client_id: CLIENT_ID, redirect_uri: redirectUri, code_verifier: codeVerifier, }) return stampIssued(json) } async function refreshTokens(refreshToken) { const tokenUrl = new URL("/oauth2/token", ISSUER).toString() const json = await postForm(tokenUrl, { grant_type: "refresh_token", refresh_token: refreshToken, client_id: CLIENT_ID, }) // Some providers omit refresh_token on refresh → keep the old one if (!json.refresh_token) json.refresh_token = refreshToken return stampIssued(json) } async function getValidAccessToken() { const tokens = await tokenStore.load() if (!tokens) return null const expiresAt = tokens.expires_at ?? (tokens.issued_at || 0) + (tokens.expires_in || 0) * 1000 const aboutToExpire = !expiresAt || Date.now() + 60_000 >= expiresAt // refresh when <60s left if (!aboutToExpire) return tokens.access_token if (!tokens.refresh_token) return null const refreshed = await refreshTokens(tokens.refresh_token) await tokenStore.save(refreshed) return refreshed.access_token } // ---------- Callback server (single fixed port) ---------- function listenForCallback(expectedState) { const appx = express() let server // Promise we resolve/reject from inside the route let resolveLogin, rejectLogin const waitForCode = new Promise((resolve, reject) => { resolveLogin = resolve rejectLogin = reject }) appx.get("/callback", (req, res) => { const { code, state, error, error_description } = req.query // Validate state if (state !== expectedState) { res .status(400) .send("<h1>Invalid state</h1><p>Please try signing in again.</p>") try { server?.close() } catch {} return rejectLogin(new Error("Invalid OAuth state")) } if (error) { res .status(400) .send(`<h1>Login error</h1><p>${error}: ${error_description || ""}</p>`) try { server?.close() } catch {} return rejectLogin(new Error(`${error}: ${error_description || ""}`)) } res.send( "<h1>Login successful</h1><p>You can close this window and return to the app.</p>" ) try { server?.close() } catch {} return resolveLogin({ code: String(code), redirectUri: REDIRECT_URI }) }) server = appx.listen(CALLBACK_PORT, CALLBACK_HOST) server.on("error", (err) => { const msg = err && err.code === "EADDRINUSE" ? `Callback port ${CALLBACK_PORT} is already in use. Close the other process or change the port.` : String(err) try { server?.close() } catch {} rejectLogin(new Error(msg)) }) return { waitForCode } } // ---------- Login flow ---------- async function startLogin() { const codeVerifier = generateVerifier() const codeChallenge = challengeFromVerifier(codeVerifier) const state = randomState() // Start fixed-port server (closes itself on success/error) const { waitForCode } = listenForCallback(state) const auth = new URL("/oauth2/auth", ISSUER) auth.searchParams.set("client_id", CLIENT_ID) auth.searchParams.set("response_type", "code") auth.searchParams.set("redirect_uri", REDIRECT_URI) auth.searchParams.set("scope", SCOPES) auth.searchParams.set("code_challenge_method", "S256") auth.searchParams.set("code_challenge", codeChallenge) auth.searchParams.set("state", state) if (AUDIENCE) auth.searchParams.set("audience", AUDIENCE) await shell.openExternal(auth.toString()) // Exchange the code for tokens const { code } = await waitForCode const tokens = await exchangeCodeForTokens({ code, codeVerifier, redirectUri: REDIRECT_URI, }) await tokenStore.save(tokens) const claims = decodeIdToken(tokens.id_token) return { tokens, claims } } async function doLogout() { await tokenStore.clear() try { const url = new URL("/logout", ISSUER) url.searchParams.set("client_id", CLIENT_ID) await shell.openExternal(url.toString()) } catch {} } // ---------- Electron window ---------- let win function createWindow() { win = new BrowserWindow({ width: 1000, height: 700, webPreferences: { preload: path.join(__dirname, "preload.js"), // CommonJS preload contextIsolation: true, nodeIntegration: false, sandbox: true, }, }) win.loadFile(path.join(__dirname, "renderer", "index.html")) } app.whenReady().then(() => { createWindow() app.on("activate", () => { if (BrowserWindow.getAllWindows().length === 0) createWindow() }) }) app.on("window-all-closed", () => { if (process.platform !== "darwin") app.quit() }) // ---------- IPC ---------- ipcMain.handle("auth:login", async () => { try { const { claims } = await startLogin() return { ok: true, claims } } catch (e) { return { ok: false, error: String(e) } } }) ipcMain.handle("auth:getAccessToken", async () => { try { const token = await getValidAccessToken() return { ok: true, access_token: token } } catch (e) { return { ok: false, error: String(e) } } }) ipcMain.handle("auth:logout", async () => { try { await doLogout() return { ok: true } } catch (e) { return { ok: false, error: String(e) } } }) ipcMain.handle("auth:getSession", async () => { try { const tokens = await tokenStore.load() if (!tokens) return { ok: true, signedIn: false } // Optional: ensures token freshness (ignore failure for UI) try { await getValidAccessToken() } catch {} const claims = decodeIdToken(tokens.id_token) return { ok: true, signedIn: true, claims } } catch (e) { return { ok: false, error: String(e) } } }) ``` ### Code explanation for `main.js` **Bootstrapping & configuration** - Loads env vars with `dotenv` and pulls Kinde settings (`ISSUER`, `CLIENT_ID`, optional `AUDIENCE`, `SCOPES`). - Defines a **fixed loopback redirect** (`http://127.0.0.1:53180/callback`) so you can whitelist a single URL in Kinde. - Sets up a secure token store backed by **keytar** (`createTokenStore`), namespaced per OS user. Safe networking & utilities - Ensures a `fetch` implementation: uses Node/Electron’s global `fetch` when available, otherwise lazy-loads `node-fetch`. - Provides two tiny helpers: - `postForm(url, data)`: POSTs `application/x-www-form-urlencoded`, throws on non-2xx, returns JSON. - `stampIssued(tokens)`: annotates tokens with `issued_at` and `expires_at` for easier expiry checks. **OAuth (Authorization Code + PKCE)** - **PKCE bits** come from `helpers`: generates a `code_verifier`, derives `code_challenge`, and creates a random `state`. - **Exchange/refresh**: - `exchangeCodeForTokens(...)` hits `/oauth2/token` with `authorization_code` grant and returns stamped tokens. - `refreshTokens(refreshToken)` refreshes access tokens; if the server omits a new `refresh_token`, it keeps the old one. - `getValidAccessToken()` loads tokens, checks expiry with a 60s buffer, and refreshes if needed; returns a valid access token or `null`. **Local callback server (loopback)** - `listenForCallback(expectedState)` spins up a one-route **Express** server on `127.0.0.1:53180`. - When `/callback` is hit: - Validates the `state` to prevent CSRF. - On error: returns a friendly HTML message and rejects. - On success: replies “Login successful” and resolves with the `code`. - The server is **closed** on success or error; startup errors (e.g., `EADDRINUSE`) are handled gracefully. **Login & logout flows** - `startLogin()`: - Builds the Kinde `/oauth2/auth` URL with PKCE and `state`. - Opens the system browser (`shell.openExternal`) to authenticate (more secure than embedding). - Waits for the loopback callback, exchanges the code for tokens, **persists** them via `tokenStore`, decodes the ID token for UI claims, and returns `{ tokens, claims }`. - `doLogout()`: - Clears local credentials and opens Kinde’s `/logout` URL (best-effort). **Electron window & security** - Creates the main `BrowserWindow` and loads `renderer/index.html`. - Uses a **preload** script with: - `contextIsolation: true` - `nodeIntegration: false` - `sandbox: true` (These keep the renderer locked down and expose only the APIs you allow via preload.) **IPC surface (renderer ↔ main)** Exposes four IPC handlers the renderer can call: - `auth:login` → runs the full PKCE flow and returns ID token **claims**. - `auth:getAccessToken` → returns a fresh access token (refreshing if needed). - `auth:logout` → clears local tokens and calls the provider’s logout. - `auth:getSession` → checks keytar for existing tokens, tries to freshen silently, and returns `{ signedIn, claims }`. 11. Create a new `preload.js` file: ```bash touch preload.js ``` 12. Add the following code to the file and save changes: ```jsx const { contextBridge, ipcRenderer } = require("electron") contextBridge.exposeInMainWorld("kindeAuth", { login: () => ipcRenderer.invoke("auth:login"), getAccessToken: () => ipcRenderer.invoke("auth:getAccessToken"), logout: () => ipcRenderer.invoke("auth:logout"), getSession: () => ipcRenderer.invoke("auth:getSession"), }) ``` 13. Run the following to set up your project structure: ```bash mkdir renderer touch renderer/index.html renderer/style.css renderer/renderer.js ``` 14. Add the following code to `index.html` file to create the UI: ```html <!DOCTYPE html> <html lang="en"> <head> <meta charset="utf-8" /> <title>Kinde Auth App</title> <meta name="viewport" content="width=device-width, initial-scale=1" /> <!-- CSP allows local file + external HTTPS connects for token/API calls --> <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline'; img-src 'self' https: data:; connect-src 'self' https: http:;" /> <link rel="stylesheet" href="./style.css" /> <style> .hidden { display: none !important; } </style> </head> <body> <!-- Header / Nav --> <header> <nav class="nav container"> <h1 class="text-display-3">KindeAuth</h1> <!-- Signed-out nav --> <div id="nav-guest"> <button class="btn btn-ghost sign-in-btn" id="signInBtn"> Sign in </button> <button class="btn btn-dark" id="signUpBtn">Sign up</button> </div> <!-- Signed-in nav --> <div id="nav-authed" class="profile-blob hidden"> <img id="avatar" class="avatar" src="" alt="User avatar" /> <div> <p class="text-heading-2" id="fullName">—</p> <a class="text-subtle" href="#" id="signOutLink">Sign out</a> </div> </div> </nav> </header> <!-- Main --> <main> <div class="container"> <!-- Guest hero --> <section id="guest-hero" class="card hero"> <p class="text-display-2 hero-title"> Let&rsquo;s start authenticating </p> <p class="text-display-2 hero-title">with KindeAuth</p> <p class="text-body-1 hero-tagline">Configure your app</p> <a class="btn btn-light btn-big" href="https://docs.kinde.com" target="_blank" rel="noreferrer" > Go to docs </a> </section> <!-- Authed hero --> <section id="authed-hero" class="card start-hero hidden"> <p class="text-body-2 start-hero-intro">Woohoo!</p> <p class="text-display-2">Your authentication is all sorted.</p> <p class="text-display-2">Build the important stuff.</p> </section> <!-- Next steps --> <section id="next-steps" class="next-steps-section hidden"> <h2 class="text-heading-1">Next steps for you</h2> <ul class="next-steps-list"> <li class="text-body-3"> Call your API using a fresh access token </li> <li class="text-body-3"> Use ID token claims to personalize the UI </li> <li class="text-body-3">Wire billing/entitlements as needed</li> </ul> </section> </div> </main> <!-- Footer --> <footer class="footer"> <div class="container"> <strong class="text-heading-2">KindeAuth</strong> <p class="footer-tagline text-body-3"> Visit our <a class="link" href="https://kinde.com/docs">help center</a> </p> <small class="text-subtle" >&copy; 2025 KindeAuth, Inc. All rights reserved</small > </div> </footer> <script src="./renderer.js"></script> </body> </html> ``` 15. Add the following code to `style.css` file to style the UI. ```css :root { --g-color-black: #000; --g-color-white: #fff; --g-color-grey-50: #f6f6f6; --g-color-grey-600: #636363; --g-color-grey-700: #4d4d4d; --g-color-grey-900: #0f0f0f; --g-box-shadow: 0px 6px 12px rgba(18, 20, 23, 0.06), 0px 15px 24px rgba(18, 20, 23, 0.07), 0px -4px 12px rgba(18, 20, 23, 0.05); --g-font-family: Helvetica, sans-serif; --g-font-size-x-small: 0.75rem; /* 12px */ --g-font-size-small: 0.875rem; /* 14px */ --g-font-size-base: 1rem; /* 16px */ --g-font-size-large: 1.25rem; /* 20x */ --g-font-size-x-large: 1.5rem; /* 24px */ --g-font-size-2x-large: 2rem; /* 32px */ --g-font-size-3x-large: 2.5rem; /* 40px */ --g-font-size-4x-large: 4rem; /* 64px */ --g-font-weight-base: 400; --g-font-weight-semi-bold: 500; --g-font-weight-bold: 600; --g-font-weight-black: 700; --g-border-radius-small: 0.5rem; --g-border-radius-base: 1rem; --g-border-radius-large: 1.5rem; --g-spacing-small: 0.5rem; /* 8px */ --g-spacing-base: 1rem; /* 16px */ --g-spacing-large: 1.5rem; /* 24px */ --g-spacing-x-large: 2rem; /* 32px */ --g-spacing-2x-large: 2.5rem; /* 40px */ --g-spacing-3x-large: 3rem; /* 48px */ --g-spacing-6x-large: 6rem; /* 96px */ } * { padding: 0; margin: 0; box-sizing: border-box; } html, body { font-family: var(--g-font-family); } a { color: inherit; text-decoration: none; } .text-subtle { color: var(--g-color-grey-600); font-size: var(--g-font-size-x-small); font-weight: var(--g-font-weight-base); } .text-body-1 { font-size: var(--g-font-size-2x-large); font-weight: var(--g-font-weight-base); } .text-body-2 { font-size: var(--g-font-size-x-large); font-weight: var(--g-font-weight-base); } .text-body-3 { color: var(--g-color-grey-900); font-size: var(--g-font-size-small); font-weight: var(--g-font-weight-base); } .text-display-1 { font-size: var(--g-font-size-4x-large); font-weight: var(--g-font-weight-black); line-height: 1.2; } .text-display-2 { font-size: var(--g-font-size-3x-large); font-weight: var(--g-font-weight-black); line-height: 1.4; } .text-display-3 { font-size: var(--g-font-size-x-large); font-weight: var(--g-font-weight-black); } .text-heading-1 { font-size: var(--g-font-size-large); font-weight: var(--g-font-weight-semi-bold); } .text-heading-2 { font-size: var(--g-font-size-base); font-weight: var(--g-font-weight-semi-bold); } .container { padding: 0 var(--g-spacing-6x-large); margin: auto; } .nav { align-items: center; display: flex; justify-content: space-between; padding-bottom: var(--g-spacing-x-large); padding-top: var(--g-spacing-x-large); width: 100%; } .sign-in-btn { margin-right: var(--g-spacing-small); } .btn { border-radius: var(--g-border-radius-small); display: inline-block; font-weight: var(--g-font-weight-bold); padding: var(--g-spacing-base); cursor: pointer; border: none; } .btn-ghost { color: var(--g-color-grey-700); } .btn-dark { background-color: var(--g-color-black); color: var(--g-color-white); } .btn-light { background: var(--g-color-white); color: var(--g-color-black); font-weight: 600; } .btn-big { font-size: var(--g-font-size-large); padding: var(--g-font-size-large) var(--g-font-size-x-large); } .hero { align-items: center; display: flex; flex-direction: column; height: 30rem; justify-content: center; text-align: center; } .hero-title { margin-bottom: var(--g-spacing-x-large); } .hero-tagline { margin-bottom: var(--g-spacing-x-large); } .card { background: var(--g-color-black); border-radius: var(--g-border-radius-large); box-shadow: var(--g-box-shadow); color: var(--g-color-white); } .link { text-decoration: underline; text-underline-offset: 0.2rem; } .link:hover, .link:focus { background: #f1f2f4; } .footer { padding-bottom: var(--g-spacing-x-large); padding-top: var(--g-spacing-x-large); } .footer-tagline { margin-bottom: var(--g-font-size-x-small); margin-top: var(--g-font-size-x-small); } .start-hero { padding: var(--g-spacing-2x-large); text-align: center; } .start-hero-intro { margin-bottom: var(--g-spacing-base); } .avatar { align-items: center; background-color: var(--g-color-grey-50); border-radius: var(--g-border-radius-large); display: flex; height: var(--g-spacing-3x-large); justify-content: center; text-align: center; width: var(--g-spacing-3x-large); } .profile-blob { align-items: center; display: grid; gap: var(--g-spacing-base); grid-template-columns: auto 1fr; } .next-steps-section { margin-top: var(--g-spacing-2x-large); } ``` 16. Add the following code to `renderer.js` file to make everything work. ```jsx const els = { navGuest: document.getElementById("nav-guest"), navAuthed: document.getElementById("nav-authed"), guestHero: document.getElementById("guest-hero"), authedHero: document.getElementById("authed-hero"), nextSteps: document.getElementById("next-steps"), claimsPre: document.getElementById("claims"), tokenPre: document.getElementById("token"), signInBtn: document.getElementById("signInBtn"), signUpBtn: document.getElementById("signUpBtn"), signOutLink: document.getElementById("signOutLink"), avatar: document.getElementById("avatar"), fullName: document.getElementById("fullName"), getTokenBtn: document.getElementById("getTokenBtn"), } function safeSetText(el, text) { if (el) el.textContent = text } function safeSetSrc(el, src, alt = "") { if (!el) return if (src) { el.src = src el.alt = alt || "" } else { el.removeAttribute("src") } } function setAuthedUI(on, claims) { // guard everything with optional chaining to avoid null errors if (on) { els.navGuest?.classList.add("hidden") els.navAuthed?.classList.remove("hidden") els.guestHero?.classList.add("hidden") els.authedHero?.classList.remove("hidden") els.nextSteps?.classList.remove("hidden") const name = [claims?.given_name, claims?.family_name].filter(Boolean).join(" ") || claims?.name || "Signed in" safeSetText(els.fullName, name) safeSetSrc(els.avatar, claims?.picture, name) } else { els.navGuest?.classList.remove("hidden") els.navAuthed?.classList.add("hidden") els.guestHero?.classList.remove("hidden") els.authedHero?.classList.add("hidden") els.nextSteps?.classList.add("hidden") safeSetText(els.claimsPre, "{}") safeSetText(els.tokenPre, '(click "Get access token")') } } // --- Startup: restore session if present --- async function bootstrap() { try { const res = await window.kindeAuth.getSession() if (res?.ok && res.signedIn) { if (els.claimsPre) els.claimsPre.textContent = JSON.stringify(res.claims || {}, null, 2) setAuthedUI(true, res.claims) } else { setAuthedUI(false) } } catch { setAuthedUI(false) } } // Wire buttons (unchanged, but safe to keep) els.signInBtn?.addEventListener("click", async () => { safeSetText(els.claimsPre, "...") const res = await window.kindeAuth.login() if (!res.ok) { safeSetText(els.claimsPre, "Login failed: " + res.error) setAuthedUI(false) } else { if (els.claimsPre) els.claimsPre.textContent = JSON.stringify(res.claims, null, 2) setAuthedUI(true, res.claims) } }) els.signUpBtn?.addEventListener("click", async () => { els.signInBtn?.click() }) els.getTokenBtn?.addEventListener("click", async () => { safeSetText(els.tokenPre, "...") const res = await window.kindeAuth.getAccessToken() safeSetText( els.tokenPre, res.ok ? res.access_token || "(no token)" : "Error: " + res.error ) }) els.signOutLink?.addEventListener("click", async (e) => { e.preventDefault() await window.kindeAuth.logout() setAuthedUI(false) }) // Ensure DOM is ready, then bootstrap if (document.readyState === "loading") { document.addEventListener("DOMContentLoaded", bootstrap) } else { bootstrap() } ``` ## Step 3: Run and test the Electron app 1. To start your Electron application and Express server, run the following command in your terminal: ```bash npm start ``` The Kinde app sign up screen opens. ![Electron app with kinde auth](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/ca9076c5-3193-48f9-78bb-80ca2bc43b00/public) 2. Sign in or sign up for a new account and test the auth flow. You should be able to see your admin area, for example: ![Signed in to electron app](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/4da712af-5ac0-4798-7260-3f5d9deb5f00/public) ## Next steps - [Call your API](/developer-tools/your-apis/register-manage-apis/) using a fresh access token - [Set up your brand experience](/design/brand/global-brand-defaults/) - [Get started with billing](/billing/about-billing/about-billing/) ## Finished! You’ve successfully built a full-stack Electron app with an Express.js backend, including user authentication and an admin area. This setup serves as a solid foundation for further development, allowing you to expand features, improve the user interface, or enhance security. You can now continue adding functionality or explore packaging the app for distribution.

# Integrate - Third party tools - Kinde and Bravo Studio

> Step-by-step guide to integrating Kinde authentication with Bravo Studio for mobile app development including OAuth 2.0 setup and Figma integration

bravo studio, figma, oauth 2.0, mobile app, authentication, callback urls, client id, client secret, bravo vision
integrate, third-party-tools

Adding authentication to your Bravo Studio app is easier than you think! With **Kinde**, you can let users securely sign up, log in, and access their profile data. This guide will walk you through connecting **Kinde** with **Bravo Studio** so you can build apps that authenticate users seamlessly. ## What you need - A [Figma account](http://figma.com/) (Sign up for free) - A [Kinde account](https://kinde.com/) (Sign up for free) - A [Bravo Studio account](https://www.bravostudio.app/) paid plan (minimum Solo plan) ## Step 1: Set up your Kinde application 1. Sign in to Kinde and select **Add application**. 2. In the dialog that opens, enter a name for the application (we’ve used ‘Bravo Studio app’). 3. Choose **Back-end web** as the application type, and select **Save**. 4. On the **Quickstart** page, select **Other back end**, and select **Save**. ![SDK choices](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/a5d21fe1-266e-4dc7-e311-54e787757400/public) 5. Go to **Authentication** and switch on each authentication method you want to be available. (e.g. Google, passwordless, etc.) For these to work, you need to [set up the selected auth methods](https://docs.kinde.com/authenticate/about-auth/authentication-methods/) in Kinde. 6. Select **Save**. 7. Go to **Details** and note your **Client ID** and **Client secret**. You’ll need these later. ![App keys in kinde](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/d7cd88fb-2724-415a-d31f-c9f100ab4600/public) ## Step 2: Connect Bravo Studio with Kinde 1. Sign in to your [Figma account](http://figma.com/) on the web or desktop. 2. Open the [Bravo Sample: Kinde Auth Starter Kit](https://www.figma.com/community/file/1470830408542459372). 3. Select **Open in Figma**. This will create a copy in your account. 4. Select **Share** in the top-right corner, then select **Copy link** to copy the public Figma file URL. ![figma share dialog](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/fd4a0c30-8d72-496c-ef2b-ca1aa2be4600/public) 5. Sign in to your [Bravo Studio dashboard](https://projects.bravostudio.app/apps), and select **Create a new app**. 6. Paste the Figma file URL and select **Connect Bravoized Figma file.** ![Convert figma to bravo](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/0abac93d-0f34-48f8-85a5-cc4a545b7100/public) 7. In the **App** tab, open the **Home page** screen. - Select the **Your Name** text element. - Select the **database icon** to configure dynamic data. - Choose **Static** and enter `${user.name}`. - Bravo supports built-in variables like `${user.id}`, `${user.name}`, and `${user.email}`. [View all built-in variables](https://docs.bravostudio.app/connect-api/request-url-variables/built-in-variables) ![Shows bravo view of figma](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/36ffe4dc-3e3c-4b2c-ed40-946f4319b900/public) ![Shows Bravo view of figma continued](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/8de14b7f-ac7b-474c-e6d5-0aae8422cd00/public) 8. Go to the **Integrations** tab and enable **OAuth 2.0 code flow**. ![Bravo login](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/36a186ab-047f-40a9-89eb-b3becfcbc100/public) 9. Select **Show** to view your Bravo **callback URLs.** 10. Copy the URLs. ![bravo callback urls.png](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/d0228081-a535-47cd-a9e3-a04fd0d41000/public) 11. In your **Kinde app > Details** page, paste the **callback URLs** (without trailing `/`) into **Allowed callback URLs** and select **Save**. ![kinde allowed callback urls.png](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/8760257c-92ed-4f71-91c6-4c26f9b90000/public) 12. Build your **Authorize URI:** - Find your **OAuth 2.0 URL** in **Kinde > Quick Start** (e.g., `https://<YOUR_BUSINESS>.kinde.com/oauth2/auth`). - Find your **Bravo project URI** in the **callback URLs** section. - Set **state** to any random 8+ characters. - Combine them into the following format. ``` https://<YOUR_BUSINESS>.kinde.com/oauth2/auth?response_type=code&client_id=<YOUR_KINDE_CLIENT_ID>&redirect_uri=https://<YOUR_BRAVO_APP_ID>.callbacks.bravostudio.app&scope=openid+profile+email+offline&state=abcxyz123 ``` 13. Go back to **Bravo > Integrations** and fill in the following. - Client ID: `<YOUR_KINDE_CLIENT_ID>` - Client Secret: `<YOUR_KINDE_CLIENT_SECRET>` - Authorize URI: The URL you just built - Token URI: `https://<YOUR_BUSINESS>.kinde.com/oauth2/token` - UserInfo URI: `https://<YOUR_BUSINESS>.kinde.com/oauth2/v2/user_profile` - Scope: `openid profile email offline` ![bravo oauth.png](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/3998a039-7bb0-4dda-424e-f92350323b00/public) 14. Select **Save**. You can find all Kinde endpoints in your business’s OpenID configuration page. (e.g., `https://<YOUR_BUSINESS>.kinde.com/.well-known/openid-configuration`). ## Step 3: Test your Bravo application 1. Download [the Bravo Vision app](https://www.bravostudio.app/download-bravo-vision) on your smartphone. 2. Open **Bravo Vision** and log in with your Bravo account. Your projects will appear. 3. Select **Bravo Sample: Kinde Auth Starter Kit** to open the app preview. ![sign in entry screen](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/4491108e-d668-45fb-fada-b02760681e00/public) 4. Select **Sign in** to register or log in with your Kinde account. Follow the authentication steps. ![sign in screen](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/e7beda48-18dd-4fa0-18fb-3516804f8d00/public) 5. Once authenticated, you’ll be redirected to the app’s homepage. You should see your profile name displayed. ![enter username](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/8fe71e60-19a5-4a8d-4560-33ac6d0af900/public) That’s it! You’ve successfully connected Kinde authentication with Bravo Studio and tested it on your mobile app. <Aside title="Troubleshooting"> If a deployment error occurs, trying changing the Bravo callback URLs in Kinde to be lowercase. See step 11 of **Connect Bravo Studio with Kinde** above. E.g. change `https://a01JMF34GB3VYX7Z5GVQXSGYFP0.callbacks.bravostudio.app` to `https://a01jmf34gb3vyx7z5gvqxsgyfp0.callbacks.bravostudio.app`. It's odd but it has fixed an issue previously. </Aside> ## You did it! Your app can now securely sign in users and display their profile data. This is a huge step towards building production-ready apps with authentication powered by Kinde. What’s next? - Explore [Bravo’s API features](https://docs.bravostudio.app/connect-api) to connect your app to live data. - Dive deeper into Kinde’s [documentation](https://docs.kinde.com/) to unlock more authentication capabilities. - Start customizing your app’s design and logic in Bravo to make it your own. Happy building!

# Integrate - Third party tools - Kinde and edge worker services

> Guide to integrating Kinde with edge worker services including Cloudflare Workers, Vercel, Next.js Edge Runtime, and Deno Deploy with JWT handling

edge workers, cloudflare workers, vercel, nextjs, nuxt, deno deploy, jwt, wrangler
integrate, third-party-tools

Kinde works with edge worker services and providers. We have tested the following: - [Nuxt on Vercel](https://vercel.com/docs/frameworks/nuxt#edge-functions) - [Next.js Edge Runtime](https://nextjs.org/docs/pages/api-reference/edge) - [Deno Deploy](https://deno.com/deploy) - [Cloudflare Workers](https://workers.cloudflare.com/) You will need to follow the edge worker service instructions linked above, to get things running. Here’s an example of how we set up Cloudflare Workers. ## Example Cloudflare Workers integration <Aside> With server-side SDKs, you'll need to handle JWT implementation (generate & validate JWT tokens) without relying on external libraries, so it is suitable to deploy within the Cloudflare environment. [Here’s some docs to help](https://github.com/tsndr/cloudflare-worker-jwt). </Aside> 1. Set up a Cloudflare account. 2. Install Wrangler. This is Cloudflare’s CLI. ```bash brew install wrangler ``` 3. Run the Wrangler login to authenticate into your Cloudflare account: ```bash wrangler login ``` 4. Create a repository to install dependencies using the below command. During this process, answer any questions best suited to your app: ```bash wrangler init ``` 5. Combine the folder created for Cloudflare + kinde sdk/starter kit. 1. Sort out any conflicts in the code (including your package.json / package-lock.json files), such as conflicting scripts, commands, dependencies, etc. 2. Merge into the one file. 6. Install Kinde dependencies if required. Here’s an example for React: ```bash npm install @kinde-oss/kinde-auth-react ``` 7. Deploy your project. We suggest you deploy to your local environment for testing. ```bash npm run pages\:deploy ``` You’ll get a link to see the changes.

# Integrate - Third party tools - Kinde and Resend for custom SMTP

> Guide to configuring Kinde with Resend for custom SMTP email delivery including API key setup, domain verification, and SMTP configuration

resend, smtp, email, api key, domain verification, email deliverability, troubleshooting
integrate, third-party-tools

You can configure Kinde to send emails using your existing Resend account. This means your users will receive communications from your business’s email address, and not Kinde’s. Other benefits include better control of email deliverability, analytics and tracking, scalability, email compliance, etc. Please review the documentation at [Customize email sender](/get-started/connect/customize-email-sender/) for details about how custom SMTP works with Kinde and third party providers. ## Generate an API key from Resend You'll need an API key from Resend to use as the password for authenticating with their SMTP server. You can use an existing API key from Resend if you have one already. Or you can create a new API key from the Resend dashboard by going to the API keys section and clicking `Create API Key`. See Resend's [API Keys](https://resend.com/docs/dashboard/api-keys/introduction) documentation for more details. ## Whitelist domain Resend also requires you to verify the domain being used for the emails. See Resend's [Managing Domains](https://resend.com/docs/dashboard/domains/introduction) documentation for verifying your domain. ## Add email sender SMTP details If you are setting this up and your production environment is already live, we recommend testing this in a staging or test environment first. 1. In Kinde, go to **Settings > Email**. 2. Enter a **Sender name**. This is usually your business name, but might be a specific person. 3. Enable the **Use custom sender** switch. The SMTP details section opens. <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/d4c4b57d-9f1a-4b1c-638c-0a770c4fe400/public" alt="" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" /> 4. Enter the **Sender email**. This is the address your users will receive emails from and should be one of the verified domains from your Resend account. 5. Enter the SMTP details of your email provider: - Server name - `smtp.resend.com` - Port - `465` - User - `resend` - Password - Use the API key generated from your Resend account 6. Select **Send test email**. This sends a test email to the email address you are logged into Kinde with. 7. If the test is successful, select **Save**. 8. If the test is not successful, check the SMTP details (step 5) and try sending a test email again. If this does not work, see the troubleshooting section below. ## Troubleshooting If sending a test email fails: - Verify network connectivity to smtp.resend.com. - Confirm the port, user, and API key are correct. - Review error messages on the Resend dashboard. For more details, see Resend's troubleshooting guide: https://resend.com/docs/dashboard/api-keys/troubleshooting

# Integrate - Third party tools - Create a to-do app with Kinde and Supabase

> A walkthough example on how to create a to-do list app using Kinde and Supabase, as previously set up.

supabase, postgresql, row level security, rls, nextjs, jwt, authentication, database, todo app
integrate, third-party-tools

User authentication and secure data access are critical components of modern web applications. Kinde simplifies the process by handling user authentication, managing session tokens, and offering robust user management features. When combined with Supabase's powerful database management and PostgreSQL’s Row-Level Security (RLS) policies, you can create a secure, scalable application that ensures user-specific data access. In this guide, we will walk through building a personalized and secure to-do application. We’ll use Next.js as the application framework. ### What you need - A Kinde & Supabase project built [using this guide](/integrate/third-party-tools/kinde-supabase/) ## Step 1: Create to-do table in Supabase 1. Sign in to your Supabase dashboard and go to **SQL Editor.** 2. Select the **plus “+” icon**, and then **Create a new snippet**. ![Create Snippet in Supabase](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/ee3d1db7-9029-4ea1-9d76-f573af311b00/public) 3. Paste the following SQL code into the command window and select **Run**: ```sql -- Create the table CREATE TABLE todos ( id BIGINT PRIMARY KEY GENERATED ALWAYS AS IDENTITY, task TEXT NOT NULL, user_id TEXT NOT NULL, completed_state BOOLEAN DEFAULT FALSE ); -- Insert some sample data into the table INSERT INTO todos (task, user_id, completed_state) VALUES ('Finish writing blog post', 'kp_123', FALSE), ('Buy groceries', 'kp_456', TRUE), ('Work out at the gym', 'kp_789', FALSE), ('Read 10 pages of a book', 'kp_101', TRUE); -- Enable row-level security ALTER TABLE todos ENABLE ROW LEVEL SECURITY; ``` This command creates a `todos` table with the following columns: - **`task`**: with a type of **text**. - **`user_id`**: with a type of **text**. - **`completed_state`**: with a type of **boolean**. We use boolean because the completed state of each item is either true or false. It also inserts four sample todo items. We will need this for later. 4. Create another new snippet and run the following SQL statement to enable the row-level policy. ```sql create policy "users can read only their todos" on public.todos for select to public using (get_user_id() = user_id); ``` Your database policy is now set up to ensure that only the authenticated user's to-do items are displayed. In the next step, you'll update your table rows to include user IDs. ## **Step 2: Build a simple to-do app** 1. Open the `/components/hero.tsx` file with your favorite code editor. 2. Add the following code to `hero.tsx` which is a basic to-do list table: ```tsx import { createClient } from "@/lib/supabase/server" export async function Hero() { const supabase = await createClient() const { data: todos } = await supabase.from("todos").select() return ( <div className="flex flex-col gap-16 items-center"> <table style={{ width: "100%", borderCollapse: "collapse" }}> <thead> <tr> <th style={{ border: "1px solid #ddd", padding: "8px", textAlign: "left", backgroundColor: "#f2f2f2", }} > ID </th> <th style={{ border: "1px solid #ddd", padding: "8px", textAlign: "left", backgroundColor: "#f2f2f2", }} > Task </th> <th style={{ border: "1px solid #ddd", padding: "8px", textAlign: "left", backgroundColor: "#f2f2f2", }} > Is Complete </th> </tr> </thead> <tbody> {todos?.map((row) => ( <tr key={row.id}> <td style={{ border: "1px solid #ddd", padding: "8px" }}> {row.id} </td> <td style={{ border: "1px solid #ddd", padding: "8px" }}> {row.task} </td> <td style={{ border: "1px solid #ddd", padding: "8px" }}> {String(row.completed_state)} </td> </tr> ))} </tbody> </table> </div> ) } ``` 3. Run the project with the following terminal command: ```bash npm run dev ``` 4. Go to [http://localhost:3000](http://localhost:3000/), sign in/sign up, and preview the page. You won’t see any to-do items because we haven’t set any user ID yet. ![Empty to do list](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/a7a2213e-a5db-43cd-7d12-b33bb2cc6100/public) ## **Step 3: Link Kinde ID to to-do items** 1. Sign in to your Kinde dashboard and select **Users** to view the user list. 2. Locate the user registered with your Supabase to-do app (e.g: Tamal Chowdhury) and select their name to view their profile. [List of Kinde users](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/9a063bd4-4aaf-4f7d-d4d2-2e9425a06f00/public) 3. Copy the unique **Kinde profile ID** displayed on their profile page. [Kinde profile ID](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/8ca5c4de-0a28-4f1a-8baa-e960d79c3e00/public) 4. Go to **Table Editor** in your Supabase project, and open the **todos** table. 5. Locate the rows corresponding to your to-do items and update the `user_id` column with the Kinde ID you copied. Save your changes. ![to-do items](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/bf7a1ea7-0cb8-4512-3935-55b5d03f1e00/public) 6. In the Kinde project, log in with the same user you signed up with. Verify that the to-do items linked to this user are now visible on the **to-do page** of your app. ![to-do list finished](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/fc135833-78c1-4277-e3d1-6f92cfcad600/public) This step links the Kinde user ID to specific to-do items, enabling the app to filter and display tasks based on the authenticated users. ## Excellent work! You’ve successfully built a secure and personalized to-do app using Kinde for authentication and Supabase for database management. With this foundation, your app is now equipped to manage user authentication and personalized data securely. You can extend this project further by adding features like task creation, deletion, updates, or even real-time collaboration.

# Integrate - Third party tools - Kinde and Supabase

> Comprehensive guide to integrating Kinde authentication with Supabase database including PostgreSQL RLS policies, Next.js setup, and secure user-specific data access

supabase, postgresql, row level security, rls, nextjs, jwt, authentication, database, todo app
integrate, third-party-tools

User authentication and secure data access are critical components of modern web applications. Kinde simplifies the process by handling user authentication, managing session tokens, and offering robust user management features. When combined with Supabase's powerful database management and PostgreSQL’s Row-Level Security (RLS) policies, you can create a secure, scalable application that ensures user-specific data access. In this guide, we will walk through integrating Kinde and Supabase. We’ll use Next.js as the application framework. You can then go on to build a to-do app following [this doc](/integrate/third-party-tools/kinde-supabase-todo-app/). ## What you need - A [Supabase](https://supabase.com/) account (sign up for free) - A [Kinde](https://kinde.com/) account (sign up for free) ## Step 1: Set up your Kinde application 1. [Sign in to Kinde](https://kinde.com/) and on the front page, select **Add application**. 2. Enter a name for the application and select **Back-end web** as the application type. 3. Select **Save**. The **Quick start** page opens. 4. Select **Next.js** from the list of back-end SDKs, then select **Save**. 5. On the **Quick Start** page, select either **Starter Kit** or **Existing codebase** and follow the setup steps. For either path: 1. Select **Set** for each default callback URL to configure your application's callback settings. ![Callback URLs in Kinde](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/e3452f72-18ad-4647-3f6f-20a7a7c43300/bloglarge) 2. Copy the environment variables. We will use these later. ![Env variables from Kinde](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/e748137c-2db9-4f84-54fa-349d28245d00/public) 6. Select **Authentication** in the menu. 7. Enable the authentication types you want your users to sign in with (e.g. Email and Google), and select **Save**. ![Select auth options screen](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/6b0c12ba-6aec-4317-47c5-93b78a8afd00/public) ## Step 2: Set up a Supabase project 1. Sign in to your [Supabase dashboard](https://supabase.com/). 2. Select or add a new organization to add the project to. 3. Select **New Project.** 1. Enter a project name. 2. Set a secure password for your database. 3. Select a database region that best suits your application. 4. Select **Create new project**. ![Create new project in supabase](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/2c69ee62-35cc-4ebe-4a5b-a50ee30cf900/public) 4. In the **Project settings**, go to **API Keys** and select **Create new API keys**. ![Supabase API keys page](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/2df82b9c-6bea-4254-3167-548a199c3e00/public) 5. Copy the **Publishable key**, we will need it in the upcoming steps. 6. Go to **JWT Keys > JWT Signing Keys**. 7. Select **Migrate JWT secret**. ![Supabase migrate JWT secret](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/be3c2870-b253-4067-78d7-a080c884b700/public) ![Start using new JWT keys dialog](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/a6e04626-98c0-4bf7-c4a7-2ab21b2cea00/public) You will see a pair of JWT keys in the page. The CURRENT KEY (Legacy HS256) and the STANDBY KEY (ECC P-256). We will mint our own JWT key with a shared secret. ![Supabase JWT Keys](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/b25a37ad-74cf-413f-f04c-095b43905e00/public) 8. Select the **three dots** next to the `STANDBY KEY` and select **Move to previously used**. This will enable you to create a new standby key. 9. Select **Create Standby Key**. ![Supabase new JWT standby keys](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/0b4ceff8-3b6b-4412-220a-0f5937bbfb00/public) 10. From the dropdown of algorithm selection, choose **HS256 (Shared Secret)**. 1. Select the **Import an existing secret** option. 2. Paste in the Kinde client secret from your application. To find it, go to **Kinde > Applications > Your application > Details >** **Client Secret.** 3. Select **Create standby key**. Your new key is listed as a `STANDBY KEY` ![Supabase new standby key window](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/08f09e3c-1711-4a3e-45dd-b8a856ebdd00/public) ![Supabase rotate keys window](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/38b9ece2-8f68-4e5c-21c6-18fa1d07d100/public) 11. Select **Rotate keys**. 12. Check both confirmation boxes and select **Rotate signing key**. You will have your shared secret key set as your `CURRENT KEY`. ![Rotate JWT signing key dialog](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/9e5e96ed-108f-448d-62d3-6fdd17ad9a00/public) ![standby keys](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/6c012dee-38c4-43d3-087d-321af5ba8000/public) 13. Navigate to **SQL Editor** and select **New SQL Snippet**. ![New SQL Snippet](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/24671391-0aa5-466a-8860-887468ac6200/public) 14. Paste the following SQL code into the command window and select **Run**: ```sql create or replace function get_user_id() returns text language sql stable as $$ select nullif(current_setting('request.jwt.claims', true)::json->>'sub', '')::text; $$; ``` This function extracts the `sub` field from the JSON Web Token (JWT) sent by Kinde auth. The `sub` field contains the Kinde user ID, which allows Supabase to authenticate the correct Kinde user. ## Step 3: Setup a Next.js project with Supabase and Kinde 1. Run the following command in your terminal window to start a new project with Next.js and Supabase. Follow the on-screen instructions. ```bash npx create-next-app -e with-supabase ``` 2. Set a name for your project (e.g: `kinde-with-supabase`) 3. Go into the project directory: ```bash cd kinde-with-supabase ``` 4. Install the Kinde dependency with this command: ```bash npm install @kinde-oss/kinde-auth-nextjs jsonwebtoken npm install --save-dev @types/jsonwebtoken ``` 5. Create the Kinde auth endpoint in this path **app/api/auth/[kindeAuth]**: ```bash mkdir -p "app/api/auth/[kindeAuth]" touch "app/api/auth/[kindeAuth]/route.js" ``` 6. Open the newly created `route.js` file, enter the following code, and save the file: ```bash import { handleAuth } from "@kinde-oss/kinde-auth-nextjs/server" export const GET = handleAuth() ``` 7. Create an environment variables file `.env.local` by typing: ```bash touch .env.local ``` 8. Add the following to your `.env.local` file: - The Kinde environment vars details you copied earlier. You can get these again from your Kinde application Quick start page. - The Supabase Project URL from **Supabase > Project Settings > Data API > Project URL.** - The Publishable key from **Supabase > Project Settings > API Keys > API Keys** tab **→ Publishable key** ``` KINDE_CLIENT_ID=<kinde_client_id> KINDE_CLIENT_SECRET=<kinde_client_secret> KINDE_ISSUER_URL=https://<your_kinde_business>.kinde.com KINDE_SITE_URL=http://localhost:3000 KINDE_POST_LOGOUT_REDIRECT_URL=http://localhost:3000 KINDE_POST_LOGIN_REDIRECT_URL=http://localhost:3000 NEXT_PUBLIC_SUPABASE_URL=https://<supabase_project_id>.supabase.co NEXT_PUBLIC_SUPABASE_PUBLISHABLE_OR_ANON_KEY=<supabase_publishable_key> ``` 9. To ensure the user is redirected to the homepage after they sign in, update the `KINDE_POST_LOGIN_REDIRECT_URL` in your `.env.local` file to: ``` KINDE_POST_LOGIN_REDIRECT_URL=http://localhost:3000 ``` 10. Open the `components/auth-button.tsx` file and replace the entire content with the following. This code will replace Supabase Auth functions with Kinde Auth. ```tsx import { RegisterLink, LoginLink, LogoutLink, } from "@kinde-oss/kinde-auth-nextjs/components" import { getKindeServerSession } from "@kinde-oss/kinde-auth-nextjs/server" import { Button } from "./ui/button" export async function AuthButton() { const { getUser } = getKindeServerSession() const user = await getUser() return user ? ( <div className="flex items-center gap-4"> Hey, {user.email}!<LogoutLink className="text-subtle">Log out</LogoutLink> </div> ) : ( <div className="flex gap-2"> <Button asChild size="sm" variant={"outline"}> <LoginLink className="btn btn-ghost sign-in-btn">Sign in</LoginLink> </Button> <Button asChild size="sm" variant={"default"}> <RegisterLink className="btn btn-dark">Sign up</RegisterLink> </Button> </div> ) } ``` 11. Replace `lib/supabase/server.ts` with the following code: ```tsx import { getKindeServerSession } from "@kinde-oss/kinde-auth-nextjs/server" import { createServerClient } from "@supabase/ssr" import { cookies } from "next/headers" import jwt from "jsonwebtoken" export const createClient = async () => { const cookieStore = await cookies() const { getIdToken } = getKindeServerSession() const idToken = await getIdToken() let token: string if (idToken) { token = jwt.sign(idToken, process.env.KINDE_CLIENT_SECRET!) } else { token = process.env.NEXT_PUBLIC_SUPABASE_PUBLISHABLE_OR_ANON_KEY! } return createServerClient( process.env.NEXT_PUBLIC_SUPABASE_URL!, process.env.NEXT_PUBLIC_SUPABASE_PUBLISHABLE_OR_ANON_KEY!, { global: { headers: { Authorization: `Bearer ${token}`, }, }, cookies: { getAll() { return cookieStore.getAll() }, setAll(cookiesToSet) { try { cookiesToSet.forEach(({ name, value, options }) => { cookieStore.set(name, value, options) }) } catch (error) { // The `set` method was called from a Server Component. // This can be ignored if you have middleware refreshing // user sessions. } }, }, } ) } ``` 12. Replace `lib/supabase/middleware.ts` with the following code: ```tsx import { NextResponse, type NextRequest } from "next/server" import { hasEnvVars } from "../utils" export async function updateSession(request: NextRequest) { const supabaseResponse = NextResponse.next({ request, }) // If the env vars are not set, skip middleware check. You can remove this once you setup the project. if (!hasEnvVars) { return supabaseResponse } // Do not run code between createServerClient and // supabase.auth.getUser(). A simple mistake could make it very hard to debug // issues with users being randomly logged out. // IMPORTANT: DO NOT REMOVE auth.getUser() // IMPORTANT: You *must* return the supabaseResponse object as it is. // If you're creating a new response object with NextResponse.next() make sure to: // 1. Pass the request in it, like so: // const myNewResponse = NextResponse.next({ request }) // 2. Copy over the cookies, like so: // myNewResponse.cookies.setAll(supabaseResponse.cookies.getAll()) // 3. Change the myNewResponse object to fit your needs, but avoid changing // the cookies! // 4. Finally: // return myNewResponse // If this is not done, you may be causing the browser and server to go out // of sync and terminate the user's session prematurely! return supabaseResponse } ``` 13. Start the development environment by typing the following in your terminal: ```bash npm run dev ``` 14. Go to [http://localhost:3000](http://localhost:3000/) and sign up/sign in to your Kinde application to test the integration. ![Your local app showing supabase readiness](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/115c087b-d820-444e-7809-a059c37fa400/public) ## Well done! You've successfully integrated Kinde for authentication with Supabase for database management, creating a secure foundation for user-specific data access. With this integration in place, your application is now equipped to handle user authentication and manage personalized data securely. You can extend this foundation by adding various features and functionalities specific to your application's requirements, all while maintaining the security and scalability provided by this Kinde-Supabase integration. Take this one step further by creating a [to-do list application following the next guide](/integrate/third-party-tools/kinde-supabase-todo-app/).

# Integrate - Third party tools - Connect Kinde and WordPress

> Guide to integrating Kinde with WordPress using the OpenID Connect Generic Client plugin including plugin installation and OAuth configuration

wordpress, openid connect, plugin, oauth, client id, client secret, callback urls, endpoints
integrate, third-party-tools

This topic describes how to set up Kinde with WordPress using the `OpenID Connect - Generic Client` plugin. <Aside> This topic includes only basic steps. Depending on your exact setup, additional configuration might be required. </Aside> ## Step 1: Install the Plugin 1. In the WordPress admin area, go to **Plugins** and select **Add New**. 2. Search for `OpenID Connect - Generic Client` and select **Install Now**. 3. Once installed, select **Activate**. ## Step 2: Set up Kinde 1. Sign in to your Kinde dashboard. 2. Go to **Settings > Applications > [Your App Name] > View Details**. 3. In the **Allowed callback URLs** field, enter: `https://[your_wordpress_domain]/wp-admin/admin-ajax.php?action=openid-connect-authorize` 4. In the **Allowed logout redirect URLs** field, enter: `https://[your_wordpress_domain]/` 5. Select **Save**. ## Step 3: Configure the Plugin 1. In WordPress, go to the **Settings** page for the plugin. 2. Set the **Scope** to **openid**. 3. Enter the following details: - **Client ID**: Client ID from your Kinde application - **Client Secret:** Client secret from your Kinde application - **Login Endpoint URL:** `https://[your_kinde_domain].kinde.com/oauth2/auth` - **Userinfo Endpoint URL:** `https://[your_kinde_domain].kinde.com/oauth2/v2/user_profile` - **Token Validation Endpoint URL:** `https://[your_kinde_domain].kinde.com/oauth2/token` - **End Session Endpoint URL:** `https://[your_kinde_domain].kinde.com/logout` - **Identity Key:** sub - **Nickname Key:** sub ## Step 4: Test the configuration Finally, you should test your configuration to ensure that everything is set up correctly. 1. Sign in to your WordPress site. This should redirect to Kinde pages. 2. If everything is set up correctly, you should be able to sign in successfully.

# Integrate - Third party tools - Marketing campaign tracking with Kinde

> Guide to marketing campaign tracking with Kinde including Google Analytics integration and state parameter usage for UTM code correlation

marketing campaigns, google analytics, tracking, state parameter, utm codes, analytics, sign up tracking
integrate, third-party-tools

Kinde gives you several options for extracting your data, while we work toward providing a more comprehensive analytics feature. ## Google analytics Kinde lets you integrate with [Google Analytics](/manage-users/view-activity/track-user-sign-in-with-google-analytics/), so you can track sign up patterns, rates, frequency, etc. To start using it, enter your Google UA or G-tag in **Settings > Environment > Details > Tracking**. ## The state parameter If GA does not give you the specific information you need, you might be able to use the `state` parameter as a solution. The `state` parameter is used to store a unique code for each sign up flow, adding security to the authentication experience. But It can also be harnessed to correlate unique marketing IDs (such as UTM codes) along with it. Here’s how it works: 1. Your campaign ad carries a unique ID for the campaign. 2. A user clicks through the campaign to sign up to your app or product. 3. A unique event code is generated and the unique ID from the ad is picked up and passed through the Kinde auth process in the `state` parameter. 4. A token is issued for the user by Kinde, then Kinde redirects your user back, passing the same `state` parameter. The value of the `state` can then be used to correlate back any ad-specific information or call the advertiser’s API. Any information you need after the authentication flow, can be correlated with the passed through `state` parameter value. See the [definition of State in Using Kinde without an SDK](/developer-tools/about/using-kinde-without-an-sdk/#state).

# Integrate - Third party tools - Kinde and Shopify Multipass

> Guide to integrating Kinde with Shopify Multipass for seamless user authentication and customer data passing between applications

shopify, multipass, shopify plus, jwt decoder, customer data, redirect, api endpoint
integrate, third-party-tools

[Shopify Multipass](https://shopify.dev/docs/api/multipass) lets you seamlessly log your users from your application to Shopify, passing over related metadata about your user via a token. ## What you need - A Kinde account, this will work on all Kinde plans. - [Shopify Plus plan](https://www.shopify.com/au/pricing/) and [Multipass enabled.](https://shopify.dev/docs/api/multipass/) ## Configure Multipass in your project The following example uses [Next.js](https://nextjs.org/), however this can also be configured in other languages and frameworks. ### Add new environment variables Add Shopify and Multipass settings to your .env file. ```shell title=".env SHOPIFY_MULTIPASS_SECRET = "[Your Mulitpass secret]"; SHOPIFY_STORE_URL = "[yourshopify].myshopify.com"; ``` ### Set up API endpoint Create an endpoint file, e.g. `/api/multipass` that contains the following. Make sure to replace the generic information with your specific domain and secret information. ```tsx import {NextResponse} from "next/server"; import {jwtDecoder, type JWTDecoded} from "@kinde/jwt-decoder"; import {cookies} from "next/headers"; import {Multipass} from "multipass-js"; export async function GET() { const decodedToken = jwtDecoder<JWTDecoded & {email: string}>(cookies().get("id_token")?.value); if (decodedToken) { const multipass = new Multipass(process.env.SHOPIFY_MULTIPASS_SECRET as string); const customerData = { // Required email: decodedToken?.email, created_at: decodedToken?.iat // add additional fields here }; const url = multipass .withCustomerData(customerData) .withDomain(process.env.SHOPIFY_STORE_URL as string) .url(); return NextResponse.redirect(url, 302); } else { const params = new URLSearchParams(); params.append("post_login_redirect_url", `${process.env.KINDE_SITE_URL}/api/multipass`); return NextResponse.redirect( `${process.env.KINDE_SITE_URL}/api/auth/login?${params.toString()}`, 302 ); } } ``` Shopify Multipass is now configured with Kinde. When you redirect the user to the endpoint `/api/multipass`, this will generate the Multipass token and redirect the user logged in to your Shopify site.

# Integrate - Third party tools - Integrate fraud detection with TrustPath

> Comprehensive guide to integrating TrustPath fraud detection with Kinde workflows including risk assessment, threat detection rules, and API integration for secure authentication

trustpath, fraud detection, workflows, risk assessment, threat detection, api integration, security, m2m application
integrate, third-party-tools

This guide shows you how to build a Fraud Detection Workflow that runs after user authentication in **Kinde**, and uses **TrustPath** to detect and block potentially fraudulent sign-ins and sign-ups. The core idea: **whenever a user signs in or registers**, Kinde sends data to TrustPath. Based on the risk score it returns, Kinde allows or denies access. TrustPath works with Kinde workflows to trigger certain actions at key points in the authentication journey, using your own code. ## What you need Here’s what you need to get started. - **Kinde account** - [Create one](https://app.kinde.com/register) for free if you haven’t already. You’ll also need to set up an application in Kinde. - **Kinde M2M application** - Create a [dedicated M2M app](https://docs.kinde.com/developer-tools/kinde-api/connect-to-kinde-api/) for accessing the Kinde Management API - **TrustPath account** - [Sign up](https://console.trustpath.io/login) here if you don’t have one. A free account does not require any payment information. - **TrustPath API access** - Grab an API key from the [TrustPath console](https://console.trustpath.io). - **Git repo for storing your code** - clone [this repository](https://github.com/trust-path/kinde-trustpath-integration-example). It contains integration code that is already prepared for use with this guide. ## Step 1: Set up the workflow and connect your repo For a workflow to function in Kinde, the workflow files need to be structured and set up in a specific way. Refer to the docs to get this part right. 1. [Create a new workflow](/workflows/getting-started/workflow-files/) or [clone a template workflow](https://github.com/trust-path/kinde-trustpath-integration-example). 2. [Connect your GitHub repo](/workflows/getting-started/connect-repo-for-workflows/) to execute the workflow. ## Step 2: Define the workflow entry point The workflow starts with a simple async function triggered after user authentication: ```js export default async function FraudDetectionWorkflow(event: onPostAuthenticationEvent) { } ``` The event parameter gives us initial context—such as the user ID, IP address, and whether this is a new user. But we need to enrich this data before we can send it to TrustPath. We’ll do this in the next step. ## Step 3: Fetch full user data from Kinde To make an informed decision, TrustPath. needs more than a user ID—it also needs the user's email, first name, and last name. To get this data from Kinde, do the following. 1. [Set up an M2M application](/developer-tools/kinde-api/connect-to-kinde-api/) to access the Kinde Management API and switch on the `read:users` scope. 2. Copy the Client ID and Client secret from the above application. 3. Create two new [environment variables](/workflows/configuration/environment-variables-and-secrets/) in Kinde. Go to **Settings > Data management > Env variables**. 4. Add the following variables: | Key | Value | Sensitive | | --- | --- | --- | | KINDE_WF_M2M_CLIENT_ID | Copy from M2M application | No | | KINDE_WF_M2M_CLIENT_SECRET | Copy from M2M application | Yes | Once these are set up, you can retrieve the additional data you need, using the `createKindeAPI` helper from [@kinde/infrastructure](https://github.com/kinde-oss/infrastructure), which allows us to call the Kinde Management API: ```js const kindeAPI = await createKindeAPI(event); const user = await getUserData(kindeAPI, event.context.user.id); async function getUserData(kindeAPI: any, userId: string) { const { data: user } = await kindeAPI.get({ endpoint: `user?id=${userId}` }); return user; } ``` ## Step 4: Set up your TrustPath API key **TrustPath** requires an API key to authenticate your requests, in this case a request that originates from the Kinde workflow. To get your API Key: 1. Log in to the [TrustPath Console](https://console.trustpath.io). 2. On the left-hand menu, go to **[Your Name] > API Keys**. 3. Copy either one of the API keys provided there. (Recommended) Store the API key securely as an [environment variable](/workflows/configuration/environment-variables-and-secrets/) in **Kinde**, just like the other variables mentioned above. ```js const trustPathAPIKey = getEnvironmentVariable("TRUSTPATH_API_KEY")?.value; ``` This ensures you’re not hardcoding sensitive credentials, and it keeps your app secure and maintainable. ## Step 5: Determine the event type TrustPath evaluates risk differently based on the event type. For example, account creation versus account sign in. ```js const isNewUser = event.context.auth.isNewUserRecordCreated; const eventType = isNewUser ? "account_register" : "account_login"; ``` We check whether the user is new and set the event type accordingly: - `account_register`: Used for new sign-ups - typically includes more rigorous fraud checks. - `account_login`: Used for existing users - can focus on things like account takeover detection. By classifying the event properly, you can take advantage of TrustPath's specialized rule sets. ## Step 6: Define TrustPath threat detection rules TrustPath threat detection rules are individual risk assessment criteria designed to identify fraudulent activities. Each rule analyzes specific signals to detect suspicious behavior and assigns a risk score to the event. Each risk detected then contributes to the total risk score, which ranges from 0 to 100. - A score of 0 means no risk (approve) - A score of 100 means very risky (decline) You need to set up separate rules for `account_register` and `account_login` events. Select **Threat Rules** from the menu and choose the card labeled **Account Register** to configure it. TrustPath offers the flexibility to add your own rules, but it also provides default rules tailored to each event type. ![Threat rules in TrustPath dashboard](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/eada27f8-80b4-4c2b-0f3f-a379fda7b800/public) ![TrustPath Rules library](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/2b574b60-336c-4a2b-7585-e1f575537800/public) Here’s an example of how to add a rule for the account register event. 1. Select **Add Rule From Library** in the top right corner. 2. From the list, select the following rules by clicking on each rule: - Email addresses are disposable. - IP Address is a Tor exit node. - Email server IP addresses have abuse reports. This will enable any new account registration on Kinde to perform IP and email threat signal checks. Next, configure rules for the account log in event. For this, we want to prevent users from entering the system with disposable email addresses, as well as detect rapid IP changes, which can be a sign of unusual behavior. Here’s where you configure rules for the `account_login` event. ![Event type rules in TrustPath](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/5902e60b-45b8-470d-8ec1-4fd46e6ec100/public) You can see we have some rules switched on, and each rule has a score. The example above detects rapid IP changes and blocks users by assigning a high risk score, which signals potential issues. ### Advanced rule configuration The above rule can be strengthened by adding browser fingerprinting to IP change detection. For instance, the rule might be: “*if the same user email sees more than three different IP addresses within five minutes **and** also has a new browser fingerprint”*, it’s a stronger signal of suspicious activity. When set up, this detects a user logging in from multiple locations or while traveling—where the IP may change, but the browser fingerprint typically remains consistent if they’re using the same device. TrustPath supports many advanced configurations like this. You can contact their team to help you set up any complex rules you want. ## Step 7: Build the request body Now that we have the user info and event type, we can build the payload to send to TrustPath when the workflow is triggered. ```js const requestBody = { ip: event.request.ip.split(",")[0].trim(), // Handles cases where multiple IPs are forwarded email: user.preferred_email, user: { user_id: event.context.user.id, first_name: user.first_name, last_name: user.last_name, }, event_type: eventType, }; ``` This information passed in the request body allows TrustPath to cross-reference behavioral history, analyze IP risk, and more. ## Step 8: Call the TrustPath Risk API Once the connection is set up between APIs, data is ready to be sent to TrustPath via a standard HTTP POST request. Here’s an example: ```js const response = await kinde.fetch( "https://api.trustpath.io/v1/risk/evaluate", { method: "POST", responseFormat: "json", headers: { Authorization: `Bearer ${trustPathAPIKey}`, "Content-Type": "application/json", }, body: JSON.stringify(requestBody), } ); ``` This request is made using `kinde.fetch`, which handles outbound API calls securely within the workflow context. ## Step 9: Evaluate the response and take action When the API call to TrustPath comes back, the response will include a state field showing one of three values: - **approve** - let the user through - **review** - optionally flags cases for manual review - **decline** - block access Here's how to enforce a block for declined requests: ```js const state = response.json.data.score.state; if (state === "decline") { denyAccess( "You are not allowed to access this resource. Request declined by TrustPath.io ); } ``` You can adapt this to handle review flags differently, or to just mark it for review. ## Step 10: Test your fraud detection setup Now that everything is set up, we can test the entire flow. Starting with the `account_register event`, select a disposable email address (choosing any from your favorite search engine should be sufficient) and try to create a new account on Kinde. Once everything is set up and deployed: 1. Log in or register using your test account 2. Check TrustPath's Event History to see the result 3. By default, new accounts will return **approve** until you define threat rules in TrustPath. You can also test the `account_login` event by simulating logins from different IP addresses—using a VPN is a simple way to do this. ## Support If you need extra support, here’s where to get it. - **TrustPath support:** For questions related to fraud detection rules, API integration, or threat analysis, visit **TrustPath**, [contact the TrustPath team](https://trustpath.io/contact), or view the TrustPath [API docs](https://docs.trustpath.io/). - **Kinde support:** For help with authentication workflows, triggers, or general setup, refer to the [Kinde docs](https://docs.kinde.com/) or reach out to [our support team](https://kinde.com/support/). TrustPath is a German-based company. Their team wrote this guide to help Kinde users.

# Integrate - Webhooks - About webhooks

> Comprehensive guide to Kinde webhooks including event monitoring, security best practices, JWT handling, and retry policies for real-time notifications

webhooks, event monitoring, jwt, idempotency, replay attacks, security, retry policy, endpoints
integrate, webhooks

<Aside type="warning"> If you are experiencing issues with webhooks, it could be because the webhooks request content-type header has changed from `application/json` to `application/jwt`. Read the full details [here](https://kinde.notion.site/Important-notice-for-webhooks-users-7fcf184faece41368603e513267dffc6). We apologize for any inconvenience. </Aside> Webhooks are a way of monitoring events in Kinde, so that you can be notified and take action when something you’re monitoring happens. <Aside type="upgrade"> Depending which Kinde plan you’re on, the number of webhooks you can create might be limited. [View plans](https://kinde.com/pricing/). </Aside> ## How webhooks work When you create a webhook, you register your own URL endpoints in Kinde and associate them with a Kinde event (e.g. when a user is created). When an endpoint is triggered, Kinde sends data about the event, so that you can initiate an action in your application or store the data. A simple example would be setting up a webhook for when a new user is created in Kinde. This event can be set up to trigger an update to your database, enabling your system to automatically send a welcome email. ## Webhooks flow 1. Webhook endpoints are registered in Kinde. 2. An event occurs in your account, e.g. `user.created`. 3. Your endpoint will be called with a JWT containing the data object about that event, and details about the webhook. 1. If a `200` response is received, the workflow is complete. 2. If it fails to receive a response, it will retry using a back-off policy (see **Webhooks responses and retry policy** below). 4. In your application you should verify the authenticity of the webhook request, and decode the JWT (see **Webhooks security** below). 5. Logic is triggered in your application using the event data. ## Webhooks identifiers There are a number of unique IDs you will come across with webhooks. - **Webhook ID**: prefixed with `webhook_`, this refers to the webhooks that you create in Kinde. Webhook IDs are exposed via the Kinde Management API webhook endpoints. You can get a list of webhooks via the endpoint `GET /api/v1/webhooks` - **Event ID**: prefixed with `event_`, this is the ID of an event that has occurred in your account, and is included as `event_id` in webhook request payloads. You can use this ID to retrieve an event from Kinde’s API using `GET /api/v1/events/{event_id}` - **Webhook Request ID**: found in the webhook headers as `webhook-id`, this is unique to a webhook and event, and will not change between attempts. You can use this as the idempotency key (see Webhooks security below). ## Webhooks decoder Kinde provides a [webhooks decoder](https://github.com/kinde-oss/webhook) to help you decode and validate webhook tokens, for an easier implementation. ## Webhooks security ### Idempotency key Each webhook has a webhook-id header that can be used to avoid reprocessing the same webhook request. This is referred to as the ‘idempotency key’ meaning that multiple requests will result in the same outcome. ### Prevent Replay Attacks A replay attack occurs when a payload is intercepted, potentially modified and re-transmitted. Kinde webhooks contain a ‘timestamp’ attribute in the payload, and the payload is a signed JSON Web Token (JWT). This allows you to verify that the request came from Kinde, and check the timestamp to prevent replay attacks. ### Verify an event You can request events by their event_id using the Kinde management api via `/api/v1/events/{event_id}`. The event_id is provided in all webhook requests. ## Webhooks best practices Ensure webhooks are secure and optimized. - Handle duplicate request attempts by checking that the webhook-id header has not already been received and processed, making your processing idempotent - Verify the JWT to ensure that the request came from Kinde using your public JWKS file - Only add the events to your endpoint that your implementation requires, listening for all events creates unnecessary load on your server - Endpoints must use HTTPS - Return a 200 from your endpoint to indicate it has received the request ## Webhooks responses and retry policy If we fail to receive a 200 response from your endpoint, Kinde operates a back-off retry policy, this roughly equates to the following attempts: - Immediately - After 5 seconds - After 30 seconds - After 2 minutes - After 10 minutes - After 1 hour - After 4 hours - Every 12 hours until 36 hours ## Webhooks terminology You’ll come across these terms when you start using webhooks. **Endpoint** - the URL called when an event occurs. **Event type** - something that happens in Kinde, e.g. a user is created. **Event** - an instance of an event type that happens in Kinde, e.g. Jane Doe just signed up. **Request** - the request object sent to your endpoint that contains a JSON Web Token (JWT) with the event data and details about the event. **Attempt** - an instance of a request making an http request, multiple request attempts may be made if we do not receive a 200 response.

# Integrate - Webhooks - Add and manage webhooks

> Guide to adding and managing webhooks in Kinde including security setup, trigger configuration, API management, and local testing with proxy tools

webhook management, webhook triggers, authentication webhooks, user management webhooks, billing webhooks, jwt validation, local testing, ngrok, localtunnel
integrate, webhooks

<Aside type="warning"> If you are experiencing issues with webhooks, it could be because the webhook request content-type header has changed from `application/json` to `application/jwt`. Read the full details [here](https://kinde.notion.site/Important-notice-for-webhooks-users-7fcf184faece41368603e513267dffc6). We apologize for any inconvenience. </Aside> Webhooks are outbound calls that are sent from Kinde when a specified events occurs. Calls are sent using HTTPS REST calls to a verified external URL you specify. Use Kinde’s webhooks to create triggers and push event data to your other systems and applications. <Aside type="upgrade"> Webhook limits apply if you are on the Kinde free plan. [See all plans](https://kinde.com/pricing/). </Aside> ## Webhook security Webhook request payloads are signed and sent as a JSON Web Token (JWT) from Kinde. You’re probably using a library to validate your JWTs and they will require the url for your public JSON Web Key (also known as a `jwks` file). The jwks file can be found at `https://<your_subdomain>.kinde.com/.well-known/jwks` ## Add a webhook 1. Go to **Settings > Environment > Webhooks**. 2. Select **Add webhook**. 3. Give the webhook a name and enter a description so it’s clear what it’s for. 4. Enter the external URL. 5. Select the event triggers. You can choose from a number of triggers and categories. See below for definitions. ## Edit a webhook 1. Go to **Settings > Environment > Webhooks**. 2. Select the webhook name to open the details window. 3. Update events and triggers. 4. Select **Save**. ## Delete a webhook 1. Go to **Settings > Environment > Webhooks**. 2. Select the three dots menu next to the webhook you want to delete. 3. Select **Delete webhook**. A confirmation message appears. 4. Confirm you want to delete the webhook. ## Manage webhooks via the Kinde API Everything you can do in Kinde’s UI with webhooks, you can also do through the Kinde API using these endpoints. - `POST api/v1/webhooks` - create a webhook - `PATCH api/v1/webhook/{webhook_id}` - update a webhook - `DELETE api/v1/webhook/{webhook_id}` - delete a webhook - `GET api/v1/webhooks` - list of available webhooks Events can also be retrieved using: - `GET /api/v1/events/{event_id}` - get an event by the event_id provided in a webhook - `GET /api/v1/event_types` - list the available event types ## Webhook triggers ### Authentication webhooks ```jsx organization.created; user.created; user.authentication_failed; user.authenticated; subscriber.created; access_request.created; ``` ### User management webhooks ```jsx role.created; role.updated; role.deleted; permission.created; permission.updated; permission.deleted; organization.updated; organization.deleted; user.updated; user.deleted; ``` ### Billing webhooks ```jsx customer.agreement_cancelled; customer.agreement_created; customer.invoice_overdue; customer.meter_usage_updated; customer.payment_failed; customer.payment_succeeded; customer.plan_created; customer.plan_assigned; customer.plan_changed; ``` <Aside> The `user.created` trigger does not create a call when you import users </Aside> ## Testing webhooks locally In order to use webhooks, you need a publicly available URL. To test locally you need to use a proxy to expose your local instance on the internet. Here are a couple of free tools to help you to do this. - [localtunnel](https://theboroer.github.io/localtunnel-www/) - fast and easy, we recommend using the `—subdomain` attribute to fix the issued subdomain. - [Ngrok](https://ngrok.com/) - for intermediate users, requires some dev experience to get set up. Each of these services exposes a local port though a public URL that can be set as your web socket.

# Integrate - Webhooks - Set up webhooks using Next.js

> Step-by-step guide to implementing Kinde webhooks in Next.js including JWT verification, API route setup, and local development testing

nextjs webhooks, jwt verification, jwks-rsa, jsonwebtoken, api routes, local development, ngrok, localtunnel
integrate, webhooks

While webhooks will work with any Next.js setup, this guide uses [Next.js 14 with app router](/developer-tools/sdks/backend/nextjs-sdk/) and the `app` directory. You may need to alter some code samples if you have a different setup, but the core instructions remain the same. ## Set up local development In order to use webhooks, you need a publicly available URL. To test locally you need to use a proxy to expose your local instance on the internet. Here are a couple of free tools to help you to do this. - [localtunnel](https://theboroer.github.io/localtunnel-www/) - fast and easy, we recommend using the `—subdomain` attribute to fix the issued subdomain. - [Ngrok](https://ngrok.com/) - for intermediate users, requires some dev experience to get set up. Each of these services expose a local port though a public URL that can be set as your web socket. Follow their instructions to run your local Next.js application and you will receive a URL that you need later in this guide. ## Create the Kinde webhook route Kinde sends webhooks as JWT’s to make them both easy and secure. In this example we will leverage 2 libraries to parse the JWT and verify the signature. 1. Create the file `app/api/kinde-webhook/route.ts`. The `route.ts` file is a specific file convention in Next.js that marks the route as an API route, rather than a page. ```jsx // app/api/kinde-webhook/route.ts import { NextResponse } from "next/server"; export async function POST(req: Request) { return NextResponse.json({ status: 200, statusText: "success" }); } ``` Whenever an event occurs in Kinde, a POST request is sent via this route to the specified endpoint, so that your project can react to the event. For example, refreshing a token or updating data in your database. Note that the endpoint needs to be publicly available, with no route protection. 2. Install the dependencies. <PackageManagers pkg="jwks-rsa jsonwebtoken" /> 3. Update your file as follows: ```jsx // app/api/kinde-webhook/route.ts import { NextResponse } from "next/server"; import jwksClient from "jwks-rsa"; import jwt from "jsonwebtoken"; // The Kinde issuer URL should already be in your `.env` file // from when you initially set up Kinde. This will fetch your // public JSON web keys file const client = jwksClient({ jwksUri: `${process.env.KINDE_ISSUER_URL}/.well-known/jwks.json`, }); export async function POST(req: Request) { try { // Get the token from the request const token = await req.text(); // Decode the token const { header } = jwt.decode(token, { complete: true }); const { kid } = header; // Verify the token const key = await client.getSigningKey(kid); const signingKey = key.getPublicKey(); const event = await jwt.verify(token, signingKey); // Handle various events switch (event?.type) { case "user.updated": // handle user updated event // e.g update database with event.data console.log(event.data); break; case "user.created": // handle user created event // e.g add user to database with event.data console.log(event.data); break; default: // other events that we don't handle break; } } catch (err) { if (err instanceof Error) { console.error(err.message); return NextResponse.json({ message: err.message }, { status: 400 }); } } return NextResponse.json({ status: 200, statusText: "success" }); } ``` As per the sample above, the JWKs file is fetched from Kinde, the token is decoded, and the signature is compared against your keys file. This is how you know you can trust the request has come from Kinde. <Aside title="Handling different event types"> In the example above, we used a switch statement. But you could also set up an endpoint per event type, group them into related endpoints, use a map, or any other method for splitting and managing the events. </Aside> 4. Start your server so it’s ready and listening out for the next step. With most Next.js applications, run `npm run dev` in the terminal. ## Set up the webhook in Kinde 1. In the Kinde, go to **Settings > Environment > Webhooks**. 2. Select **Add webhook**. 3. Give the webhook a name and description. 4. Enter the Next.js endpoint we set up earlier in your project. For example `<your_app_url>/api/kinde-webhook`. If you are using an external tool to test the endpoint locally, enter the endpoint URL specified in the tool. <Aside type="warning" title="Make sure URLs match"> Testing will fail if the endpoint URL in Kinde does not match the site URL where you are testing the webhook. </Aside> 5. Select **Add events.** 6. In the dialog that opens, select the events you want. For example, user events, organization events, etc. 7. Select **Save**. 8. In the webhook window, select **Save**. ## Test the webhook 1. Either create a new user or update an existing one in Kinde. 2. Switch back to where your server is running and you should see the data in your server console. 3. Done! Have a tasty beverage.

# Integrate - Webhooks - Connect Zapier to Kinde

> Guide to connecting Zapier with Kinde for automation and event-driven workflows using webhooks and event hooks

zapier, event hooks, automation, integration, webhooks
integrate, webhooks

When we first introduced a Zapier connection, it was to offer approximate webhooks functionality, until we had [actual webhooks](/integrate/webhooks/about-webhooks/). Now that we have webhooks, you can still integrate with Zapier, it just works a bit different. Here’s how: <YoutubeVideo videoId={"2C0GNM0t-sY"} />

# Machine to machine applications - About m2m - Authenticate with M2M applications

> Guide to authenticating with M2M applications using OAuth 2.0 client credentials flow including token requests, API authorization, and Bearer token usage

m2m authentication, oauth 2.0, client credentials, access tokens, api authorization, bearer token, jwt, audience, scopes
machine-to-machine-applications, about-m2m

You can use a Machine-to-Machine (M2M) application in Kinde to request access tokens using the OAuth 2.0 client credentials flow. These tokens can be used to call Kinde’s APIs or your own APIs with no user interaction required. ## Authorize your application Before an M2M app can request a token for a specific API audience, it must be authorized for that API. If the app is not authorized for the given audience, the token request will fail. 1. Open the M2M application in Kinde. 2. Select **APIs**. 3. Select the three dots menu and authorize each API the app is allowed to call. 4. Select **Save**. You can also [authorize apps programmatically](https://docs.kinde.com/kinde-apis/management/#tag/apis/patch/api/v1/apis/{api_id}/applications) using the Kinde Management API. ## Get an access token Your M2M application will be provided with a `client_id` and `client_secret` which can be used to request a token. To get a token, make a `POST` request to your Kinde environment’s token endpoint: ```http POST https://<your-subdomain>.kinde.com/oauth2/token ``` ### Required parameters The request body must include: ```text grant_type=client_credentials &client_id=<your-client-id> &client_secret=<your-client-secret> &audience=<your-api-audience> ``` If your app has scopes assigned, you can optionally request them: ```text &scope=read:users write:flags ``` **Note**: The `audience` parameter tells Kinde which API the token is intended for. Use `https://<your-subdomain>.kinde.com/api/v1` when calling Kinde’s management API. If you're protecting your own custom API, the audience should match the identifier you registered for that API in Kinde. ### Example (cURL) ```bash curl --request POST 'https://your-subdomain.kinde.com/oauth2/token' \ --header 'Content-Type: application/x-www-form-urlencoded' \ --data-urlencode 'grant_type=client_credentials' \ --data-urlencode 'client_id=your-client-id' \ --data-urlencode 'client_secret=your-client-secret' \ --data-urlencode 'audience=your-api-audience' \ --data-urlencode 'scope=read:users write:flags' ``` ### Successful response A successful request returns a JSON response with an access token: ```json { "access_token": "<token>", "token_type": "Bearer", "expires_in": 3600 } ``` ## Use the token Once you have a token, include it as a Bearer token in the `Authorization` header when making API calls: ```http Authorization: Bearer <token> ``` ## Example usage Calling a Kinde API: ```bash curl https://your-subdomain.kinde.com/api/v1/organizations \ -H "Authorization: Bearer <token> ``` ## Important information about tokens, audience, claims, and M2M apps - Access tokens are valid for 1 hour by default. - The `audience` must match the intended API — tokens are only valid for the audience they’re issued for. - You can request multiple audiences - If your M2M app is scoped to an organization, the token will include the `org_code` trusted claim. - Tokens are JWTs and can be decoded to inspect claims using standard libraries or tools like [Kinde's JWT decoder](https://kinde.com/tools/online-jwt-decoder/). ## Test your M2M app in Kinde You can also generate a token to help with testing. 1. Open your M2M app in Kinde. 2. Select *APIs* in the menu, then open the API you want to test with the app. 3. Select the **Test** tab 4. Select **Get token** 5. Copy the access token and use it in your API requests. This is useful for debugging or verifying scopes and claims without writing code.

# Machine to machine applications - About m2m - M2M overview

> Overview of machine-to-machine applications in Kinde including OAuth 2.0 client credentials flow, use cases, types, and best practices for secure API authentication

m2m, machine to machine, oauth 2.0, client credentials, access tokens, api authentication, automation, ci/cd, ai agents
machine-to-machine-applications, about-m2m

Machine-to-machine (M2M) applications allow you to authenticate backend services, scripts, or automation tools that need to call your APIs without a user being involved. M2M apps in Kinde use the OAuth 2.0 client credentials flow to obtain access tokens. These tokens can then be used to securely interact with Kinde APIs or your own APIs. You can create M2M applications for general use across your business, or [scope them to a specific organization](/machine-to-machine-applications/organization-scoped-m2m-apps/m2m-applications-for-organizations/) for tighter access control. ## Use cases Common scenarios where M2M apps are useful: - Internal automation scripts that manage users, flags, or orgs - CI/CD pipelines that update configuration or deploy features - AI agents that need to interact with your product on behalf of a customer - Customer-facing API keys that are tied to a specific tenant ## Types of M2M apps in Kinde ### Global (unscoped) M2M apps These are not linked to any one organization and can be used to call APIs across multiple orgs. Typically used for admin-level automation or infrastructure integration. ### Org-scoped M2M apps These are tied to a single organization. Tokens issued to these apps include trusted claims like `org_code`, ensuring that any access is isolated to that organization’s context. ## How M2M authentication works 1. Create an M2M app in Kinde. 2. Use the provided `client_id` and `client_secret` in a client credentials request. 3. Receive an access token in response. 4. Use the token to call Kinde APIs or your own backend. Tokens can include scopes to limit access and, if scoped to an org, will include the `org_code` trusted claim. ## Best practices for M2M apps - Use separate M2M apps for different scopes or services. - Limit the [scopes](https://docs.kinde.com/developer-tools/your-apis/custom-api-scopes/) assigned to each M2M app to the minimum required for its function. - [Rotate client secrets](/build/applications/rotate-client-secret/) periodically using the UI. - Avoid including any personally identifiable information (PII) in token claims.

# Machine to machine applications - About m2m - Top questions about M2M applications

> A set of popular questions about machine-to-machine applications in Kinde, including OAuth 2.0 client credentials flow, use cases, types, and best practices.

m2m, machine to machine, oauth 2.0, client credentials, access tokens, api authentication, automation, ci/cd, ai agents
machine-to-machine-applications, about-m2m

Here are short answers to the most common M2M questions. Click any question to expand the answer. <Aside title="Ask the docs"> Type **@kindeAI** to access 24/7 global support in the **#ask-kinde-ai** channel in the Kinde [Slack](https://join.slack.com/t/thekindecommunity/shared_invite/zt-1vyq8qilj-jFH5V27jfFnHk~BuBSU0ZA) or [Discord](https://discord.gg/KdkCXRNTFn) communities. </Aside> ## Core concepts and setup <details> <summary><strong>What's the difference between machine-to-machine and regular user authentication in Kinde?</strong></summary> M2M authentication is designed for servers, APIs, and automated systems that need to communicate securely without human intervention. Unlike regular user auth where someone signs in with a password or social login, M2M uses the client credentials flow - your application authenticates using a client ID and secret to get an access token. Think of it like having a service account that can access your APIs 24/7 without anyone needing to sign in. This is perfect for microservices, background jobs, or third-party integrations that need to access your Kinde-protected resources. [About machine-to-machine applications](/machine-to-machine-applications/about-m2m/) </details> <details> <summary><strong>How do I create and configure a machine-to-machine application in Kinde?</strong></summary> Setting up M2M is straightforward - create a new application in your Kinde dashboard and select "Machine to machine" as the type. You'll get a client ID and client secret (treat secrets as highly sensitive). The key difference from regular apps is that M2M applications don't need callback URLs since there's no user redirect flow. You will need to specify which APIs this M2M app can access and what scopes it needs. Start with minimal permissions and expand as needed - it's easier to add permissions than to figure out why something has too much access. [Create machine-to-machine application](/machine-to-machine-applications/m2m-application-setup/create-an-m2m-application/) </details> <details> <summary><strong>What are the security best practices for storing Kinde M2M credentials?</strong></summary> Never, ever put M2M credentials directly in your code or version control - that's like posting your house keys on social media. Use environment variables and a secrets manager (AWS Secrets Manager, Azure Key Vault, Google Secret Manager) or your platform’s secure configuration system. Rotate your client secrets regularly, especially if you suspect they might have been exposed. Consider using different M2M applications for different environments (development, staging, production) so a compromise in one doesn't affect others. [Machine-to-machine token structure](/machine-to-machine-applications/about-m2m/token-structure-and-claims-for-m2m-applications/) </details> <details> <summary><strong>When should I use multiple M2M applications versus one application with broad permissions?</strong></summary> Follow the principle of least privilege - create separate M2M applications for different services or use cases. Your email service might only need read access to user profiles, while your analytics service needs broader access to usage data. This compartmentalization means if one service gets compromised, the blast radius is limited. It also makes debugging easier when you can trace API calls back to specific applications. The slight overhead of managing multiple M2M apps is worth the security and operational benefits. [Create machine-to-machine application](/machine-to-machine-applications/m2m-application-setup/create-an-m2m-application/) </details> <details> <summary><strong>How do I handle Kinde M2M token expiration in production systems?</strong></summary> M2M access tokens expire (usually after an hour), so your application needs to handle token refresh gracefully. Most Kinde SDKs handle this automatically, but if you're doing it manually, implement retry logic that gets a fresh token when you receive 401 responses. Cache tokens in memory and refresh proactively before expiry. For high-traffic systems, use a short-lived, in-memory cache per host/process to reduce token requests. Do not share tokens across services or persist them. [About machine-to-machine applications](/machine-to-machine-applications/about-m2m/token-structure-and-claims-for-m2m-applications/) </details> ## API access and scopes <details> <summary><strong>What Kinde API scopes do I need for different M2M use cases?</strong></summary> It depends on what your M2M application needs to do. For basic user management, you might need `read:users` and `write:users`. For organization management, add `read:organizations` and `write:organizations`. If you're syncing billing data, include relevant billing scopes. Here's the thing - start narrow and expand permissions as needed. It's much easier to debug "permission denied" errors than to figure out why an M2M app has access to everything. Check the Kinde Management API docs for the complete scope list and map them to your actual business needs. [Add APIs to machine-to-machine applications](/developer-tools/your-apis/api-scopes-m2m-applications/) </details> <details> <summary><strong>How do I call Kinde APIs from my M2M application without getting rate limited?</strong></summary> Respect the rate limits and implement exponential backoff when you hit them. Batch your API calls when possible instead of making hundreds of individual requests. For high-volume operations like user imports, use bulk endpoints if available or spread the work over time. Cache data that doesn't change frequently - you probably don't need to fetch the same user profile 50 times per minute. If you're consistently hitting limits, it might be time to optimize your integration or contact Kinde about higher limits. [Authenticate with M2M](/machine-to-machine-applications/about-m2m/authenticate-with-m2m/) </details> <details> <summary><strong>What's the best way to handle Kinde Management API responses in M2M applications?</strong></summary> Always check HTTP status codes before processing response data – a 200 means success, anything else needs error handling. Parse the JSON response carefully and handle cases where expected fields might be missing. For paginated responses, implement proper pagination logic rather than just grabbing the first page. Log API responses (but never log credentials or tokens) for debugging purposes, and implement idempotent operations where possible so retrying failed requests doesn't cause duplicate data. [Troubleshoot M2M token errors](/machine-to-machine-applications/troubleshooting-m2m/troubleshoot-m2m-token-errors/) </details> <details> <summary><strong>How do I test Kinde M2M integrations safely without affecting production data?</strong></summary> Use separate M2M applications for development and production environments - this keeps your test data completely isolated. Create test organizations and users that you can safely experiment with. Set up your CI/CD pipeline to use development M2M credentials for automated testing. Mock the Kinde API responses in your unit tests rather than making real API calls every time. And please, test your error handling scenarios - what happens when the API is down or returns unexpected responses? [Create machine-to-machine application](/machine-to-machine-applications/m2m-application-setup/create-an-m2m-application/) </details> ## Integration patterns <details> <summary><strong>How should I structure Kinde M2M calls for microservices architecture?</strong></summary> Each microservice should have its own M2M application with only the permissions it needs - this follows the principle of least privilege and makes security auditing much easier. Consider creating a shared authentication service that handles token management for all your microservices, or use a service mesh that can inject tokens automatically. Don't pass M2M tokens between services - each service should authenticate directly with Kinde. This prevents token leakage and makes it easier to track which service is making which API calls. [About machine-to-machine applications](/machine-to-machine-applications/about-m2m/) </details> <details> <summary><strong>What's the best way to sync user data between Kinde and my application using M2M?</strong></summary> Use webhooks for real-time updates when users change their profiles or organizations, then use M2M API calls to fetch detailed data when needed. Don't try to keep a complete mirror of Kinde data in your system - it's better to cache frequently accessed information and fetch fresh data for important operations. Implement proper error handling for sync operations, and consider implementing eventual consistency patterns where slight delays are acceptable. [Sync data in Kinde](/authenticate/manage-authentication/sync-with-kinde/) </details> <details> <summary><strong>How do I handle Kinde organization management through M2M applications for multi-tenant SaaS?</strong></summary> M2M is perfect for automated organization provisioning when new customers sign up. You can create organizations, set up initial users, configure permissions, and even assign billing plans all through the Management API. Use consistent naming conventions for organizations (maybe map them to your internal customer IDs) and store the Kinde organization ID in your customer records for easy lookup. This automation means new customers can start using your product immediately without manual setup steps. [M2M apps for organizations](/machine-to-machine-applications/organization-scoped-m2m-apps/m2m-applications-for-organizations/) </details> <details> <summary><strong>How can I use Kinde M2M applications to automate user provisioning workflows?</strong></summary> Set up M2M applications that can create users, assign them to organizations, and configure their initial permissions based on your business logic. This is particularly useful for enterprise customers who need automated onboarding from their HR systems or directory services. You can trigger these workflows from webhooks, scheduled jobs, or API events from other systems. Just make sure to handle edge cases like duplicate email addresses or organization limits gracefully. [Machine-to-machine auth flow](/machine-to-machine-applications/about-m2m/authenticate-with-m2m/) </details> ## Troubleshooting and monitoring <details> <summary><strong>Why is my Kinde M2M application getting authentication errors in production?</strong></summary> Check the obvious stuff first - are you using the right client ID and secret for your production environment? M2M credentials are environment-specific, so development credentials won't work in production. Look at the exact error message: "invalid_client" usually means wrong credentials, while "insufficient_scope" means you're trying to access APIs without the right permissions. If tokens were working before but suddenly stopped, check if credentials were rotated or if API scopes changed. [M2M API scopes](/machine-to-machine-applications/m2m-application-setup/scopes-for-m2m-applications/) </details> <details> <summary><strong>How do I monitor and debug Kinde M2M API performance issues?</strong></summary> Implement proper logging that captures request/response times, error rates, and token refresh patterns. Monitor for increasing latency or higher error rates - these often signal capacity issues or misconfigurations. Use correlation IDs in your logs so you can trace requests across multiple services. Set up alerts for authentication failures or unusual API usage patterns. The Kinde dashboard shows some usage metrics, but you'll want your own monitoring for production applications. [Test API with M2M tokens](/developer-tools/your-apis/test-token-from-kinde/) </details> <details> <summary><strong>What should I do when my Kinde M2M application needs higher rate limits?</strong></summary> First, optimize your current usage - are you making unnecessary API calls or missing opportunities to batch requests? Cache data that doesn't change frequently and implement proper pagination for large datasets. If you've optimized everything and still need higher limits, document your use case and expected traffic patterns when contacting Kinde support. They'll want to understand your business needs and ensure the higher limits won't impact system performance for other customers. [API rate limits](/developer-tools/kinde-api/api-rate-limits/) </details> <details> <summary><strong>How do I handle intermittent failures when calling Kinde APIs from M2M applications?</strong></summary> Network issues happen, so build resilience into your M2M integrations. Implement exponential backoff with jitter for retries, set reasonable timeouts on API calls, and have circuit breaker patterns for critical paths. Log failures with enough context to debug later, but don't spam your logs with retry attempts. For non-critical operations, consider using message queues so failed operations can be retried later without blocking your main application flow. [Troubleshoot M2M](/machine-to-machine-applications/troubleshooting-m2m/troubleshoot-m2m-token-errors/) </details> ## Advanced use cases <details> <summary><strong>How can I use Kinde M2M applications for automated user lifecycle management?</strong></summary> M2M is perfect for automating the boring stuff - creating accounts when customers sign up through your sales process, deactivating users when they leave companies, or updating permissions based on role changes. Set up webhooks to trigger these workflows, then use M2M API calls to make the actual changes in Kinde. You can even automate organization setup for enterprise customers, complete with custom authentication requirements and user provisioning. Just make sure you have proper audit logging for compliance purposes. [Management API integration](/developer-tools/kinde-api/connect-to-kinde-api/) </details> <details> <summary><strong>What's the best approach for using Kinde M2M in serverless functions and background jobs?</strong></summary> Serverless functions are actually perfect for M2M since you don't need to worry about long-lived token storage. Get a fresh token at the start of each function execution - the overhead is minimal and it's more secure than trying to cache tokens across function invocations. For background jobs, implement token caching with proper expiration handling. Remember that cold starts might affect initial authentication performance, so consider warming up critical functions if latency matters. [Example of using M2M for AI](/machine-to-machine-applications/organization-scoped-m2m-apps/using-m2m-apps-for-ai-applications/) </details> <details> <summary><strong>How do I implement Kinde M2M for data synchronization between multiple systems?</strong></summary> Design your sync jobs to be idempotent - running them multiple times should produce the same result without creating duplicates. Use the Management API to query for changes since your last sync, then update your systems accordingly. Implement proper error handling and retry logic since network issues happen. Consider using message queues or event streams for real-time sync requirements. And always, always test your sync logic with large datasets before going live - edge cases love to hide in bulk operations. [Data sync in Kinde](/authenticate/manage-authentication/sync-with-kinde/) </details> <details> <summary><strong>How can I leverage Kinde M2M applications for compliance and audit requirements?</strong></summary> M2M applications are excellent for automated compliance workflows - you can programmatically generate user access reports, audit permission changes, or automatically revoke access for inactive accounts. Use the Management API to query user activities and organization changes, then format this data for compliance reporting. Set up scheduled jobs that check for policy violations or unusual access patterns. Remember to log all M2M operations for your own audit trail - knowing which automated system made which changes is crucial for compliance. [Management API overview](/developer-tools/kinde-api/connect-to-kinde-api/) </details>

# Machine to machine applications - About m2m - M2M quick start

> Step-by-step quick start guide for creating and using M2M applications in Kinde including API authorization, scope assignment, and token generation

m2m quick start, machine to machine, api authorization, client credentials, scopes, access tokens, bearer token, curl
machine-to-machine-applications, about-m2m

This guide shows you how to create a Machine-to-Machine (M2M) application in Kinde, authorize it for an API, and use the client credentials flow to get a token and make a secure API request. ## Step 1: Create a machine-to-machine app 1. On the Kinde home page, select **Add application**. 2. Enter a name for the application. 3. Choose **Machine-to-machine (M2M)**. 4. Select **Save**. ## Step 2: Create an API in Kinde (if you don't have one) You can skip this step if you already have an API registered in Kinde. 1. Go to **Settings > APIs**. 2. Select **Add API**. 3. Enter a name for the API. 4. Select **Save**. For details on the full API setup, see [Register and manage APIs](/developer-tools/your-apis/register-manage-apis/). ## Step 3: Authorize the app to access an API 1. Open the newly created M2M app. 2. Go to **APIs** in the menu. 3. Find the API you want to authorize in the list. 4. Select the three dots on the far right and select **Authorize**. ## Step 4: (Optional) Add scopes to define permissions 1. Go to **Settings > APIs**. 2. Choose the API you want to protect. 3. Select **Scopes** in the menu and add scopes (e.g. `read:users`, `write:flags`). 4. Once you are finished, open the M2M app and assign the scopes. See [Define and manage API scopes](/developer-tools/your-apis/api-scopes-m2m-applications/). ## Step 5: Get a token to test your M2M app You can test the app in one of two ways: ### Option A - Use the **Test** details in Kinde 1. Open your M2M app. 2. Go to **Test** in the menu. 3. Select the API (audience). 4. Copy the generated token. ### Option B - Use the client credentials flow directly ```bash curl --request POST 'https://<your-subdomain>.kinde.com/oauth2/token' \ --header 'Content-Type: application/x-www-form-urlencoded' \ --data-urlencode 'grant_type=client_credentials' \ --data-urlencode 'client_id=your-client-id' \ --data-urlencode 'client_secret=your-client-secret' \ --data-urlencode 'audience=<your-api-audience>' \ --data-urlencode 'scope=read:users write:flags' ``` The response will include a bearer token you can use in requests: ```json { "access_token": "<token>", "token_type": "Bearer", "expires_in": 3600 } ``` ## Step 6: Use the token in an API call Include the token in the `Authorization` header: ```bash curl https://your-subdomain.kinde.com/v1/organizations \ -H "Authorization: Bearer <token> ```

# Machine to machine applications - About m2m - Token structure and claims

> Reference guide to M2M token structure and claims including JWT payload examples, standard claims, and validation best practices for secure API access

token structure, jwt claims, m2m tokens, org_code, audience, scopes, token validation, openid configuration
machine-to-machine-applications, about-m2m

Access tokens issued by Kinde to Machine-to-Machine (M2M) applications are JSON Web Tokens (JWTs)that include trusted claims about the app, scopes, and (if applicable) the organization. This reference explains what those claims are and how to use them securely in your APIs or services. ## How to view M2M token claims Tokens returned from the client credentials flow can be decoded using any standard JWT library, or online tools like [Kinde's JWT decoder](https://kinde.com/tools/online-jwt-decoder/). You do **not** need to validate the signature unless you're verifying tokens on your own backend (outside of Kinde-hosted APIs). For most use cases, Kinde validates the token for you when you call our APIs. ## Example M2M token payloads ### Global M2M app ```json { "aud": [ "your-api-audience ], "azp": "d4d3c5b74e064badb9625a4aa6241bcc", "exp": 1751237068, "gty": [ "client_credentials ], "iat": 1751150668, "iss": "https://<your-subdomain>.kinde.com", "jti": "f95ed3e0-cc4d-40c4-b95a-9971729b0ae5", "scope": "read:users write:flags", "scp": [ "read:users", "write:flags ], "v": "2" } ``` ### Org-scoped M2M app ```json { "aud": [ "your-api-audience ], "azp": "d4d3c5b74e064badb9625a4aa6241bcc", "exp": 1751237068, "gty": [ "client_credentials ], "iat": 1751150668, "iss": "https://<your-subdomain>.kinde.com", "jti": "f95ed3e0-cc4d-40c4-b95a-9971729b0ae5", "org_code": "org_ba4a2311eb1", "scope": "read:users write:flags", "scp": [ "read:users", "write:flags ], "v": "2" } ``` ## Standard M2M token claims | Claim | Description | |-------|-------------| | `aud` | The audience for the token. This is the API that the token is intended for. | | `azp` | The client ID of the M2M app that requested the token. | | `exp` | The expiration time of the token. | | `gty` | The grant type for the token. This is always `client_credentials`. | | `iat` | The issuance time of the token. | | `iss` | The issuer of the token. This is the Kinde environment URL. | | `jti` | The unique identifier for the token. | | `scope` | The scopes granted to the token. | | `scp` | The list of scopes initially requested | | `v` | The version of the token. | ## Additional M2M claims for org-scoped apps | Claim | Description | |-------|-------------| | `org_code` | The organization code for the token. | ## Validating and using claims for M2M apps In your API or backend service, you can use these claims to enforce access: - Confirm the `aud` matches the expected audience for your API - If your endpoint is organization-specific (e.g. `/orgs/:org_code/...`), ensure that `org_code` from the token matches the route parameter - Use `scopes` to implement scope-based access control (e.g. `write:flags` required to enable a feature flag) ## Important information about M2M tokens, audiences, and scopes - Tokens are signed using asymmetric keys (RS256) - You can retrieve your Kinde environment’s public keys from the [OpenID configuration endpoint](https://your-subdomain.kinde.com/.well-known/openid-configuration) - Token claims are added by Kinde based on the M2M app’s configuration and assigned scopes — they cannot be overridden in the token request - You can request multiple audiences - You can request specific scopes to limit the permissions of the token

# Machine to machine applications - M2m application setup - Assign feature flags for use in M2M tokens

> Guide to assigning feature flags to M2M tokens including environment-level flag definition, token customization, and common use cases for conditional functionality

feature flags, m2m tokens, environment flags, token customization, boolean flags, string flags, json flags, ai agents
machine-to-machine-applications, m2m-application-setup

You can include feature flags in the tokens issued to machine-to-machine (M2M) applications in Kinde. This is helpful for enabling or disabling functionality in downstream systems based on feature access. <Aside> At this time, only **environment-level feature flags** can be included in M2M tokens. Support for organization-assigned flag values may be added in future releases. </Aside> ## Define environment-level feature flags Before including a flag in a token, you need to define it in your environment. This is the quick procedure (below), here's the [detailed procedure for adding feature flags](/releases/feature-flags/add-feature-flag/). 1. In Kinde, go to **Releases**. 2. Select **Add feature flag**. 3. Give the flag a key and (optionally) a description. 4. Choose the flag type (boolean, string, integer, JSON). 5. (Optional) Add a default value. 6. (Optional) Decide if the feature flag value can be overridden. 7. Select **Save**. Once defined, this flag will be available for inclusion in any M2M token issued in the same environment. ## Include a flag in an M2M token 1. Go to **Settings > Applications > Your M2M app**. 2. Select **Tokens** in the menu. 3. Under **Feature flags**, toggle on the flags you want included in the token. These flags will be embedded in the token under the `feature_flags` claim: ```json { "feature_flags": { "new-ai-agent": { "t": "b", "v": true }, "access-level": { "t": "s", "v": "beta" } } } ``` The `t` and `v` are short codes for the type and value of the feature flag. - `t` = `type` (boolean, string, number) - `v` = `value` (true | false, "beta", 1, etc.) Only the feature flags you explicitly toggle on will be included. ## Common use cases - Enable or disable AI models or endpoints - Drive conditional logic in APIs or job runners - Gate functionality in distributed workers ## Notes - Flags are set at the **environment** level - they are global, not org-specific - Token customization is configured per-app in the **Tokens** tab - Tokens remain small: only enabled flags are included - Flag values are read-only for the recipient - you must update them via the dashboard or API

# Machine to machine applications - M2m application setup - Add metadata to an M2M app using properties

> Guide to adding metadata to M2M applications using properties including property definition, assignment, and token customization for configuration management

properties, metadata, m2m applications, token customization, application properties, configuration, ai agents, structured data
machine-to-machine-applications, m2m-application-setup

You can use **Properties** in Kinde to add structured metadata to a Machine-to-Machine (M2M) application. These properties can store configuration or contextual data, such as `region`, `tier`, or `model_version`. While properties can be applied to users and orgs, only properties scoped to **Applications** are relevant for M2M apps. This feature is useful for: - Customizing tokens - Driving logic in downstream systems - Managing AI agent behavior - Setting up per-customer configuration without hardcoding or external storage If you're looking to include properties inside tokens, see [Customize the claims of an M2M token with properties](/machine-to-machine-applications/m2m-application-setup/add-metadata-to-an-m2m-application-with-properties/). ## Step 1: Define the property for the M2M application Before you can assign a property to an app, you need to define it. 1. In Kinde, go to **Settings > Data Management > Properties**. 2. Select **Add property**. 3. Give the property a name. 4. Add a description and key (e.g. `tier`, `region`, `model_version`). 5. If you want a property to be included in tokens, switch off the **Private** option. 6. Choose **Applications** for where the property is to be used. 7. Select **Save**. The property is now available across all M2M applications. ## Step 2: Assign the property to an M2M application 1. Open the relevant M2M application in Kinde. 2. Go to the **Properties** menu. 3. Add or edit values for the available properties. For example: | Property | Value | | ------------- | ----- | | region | eu | | model_version | v2 | | tier | pro | These values are stored with the app but are not included in tokens unless explicitly enabled. ## Step 3: Include a property in an M2M token 1. Open the relevant M2M application in Kinde. 2. Select **Tokens** in the menu. 3. Scroll to the **Token customization** section and select **Customize** on the **M2M token** tile. 4. Under **Properties**, toggle on the properties you want included in the token. 5. Select **Save**. The selected properties are embedded in the token under the `application_properties` claim: ```json { "application_properties": { "region": { "v": "eu" }, "tier": { "v": "pro" } } } ```

# Machine to machine applications - M2m application setup - Create an M2M application

> Guide to creating M2M applications in Kinde including general and organization-scoped applications with app key generation

create m2m application, machine to machine, organization scoped, app keys, client id, client secret, domain details
machine-to-machine-applications, m2m-application-setup

This guide shows you how to create a Machine-to-Machine (M2M) application in Kinde. They are either general or organization-scoped (Organization scoped M2M apps are available on Plus and Scale plans only). ## Create a general M2M application You will want to create a separate M2M application for each user, system, or business who needs to access your APIs. It is not secure to share access via the same tokens or app keys. 1. Go to **Settings > Applications.** 2. Select **Add Application**. 3. In the dialog that opens, give the application a name, and select **Machine to Machine** as the **Application type**. 4. Select **Save**. App keys - including **Domain** details, **Client ID** and **Client Secret** - are issued for the application. ## Create an organization-scoped M2M application 1. Go to **Organizations > [Organization] > M2M apps.** 2. Select **Add M2M application**. 3. In the dialog that opens, give the application a name, and select **Machine to Machine** as the **Application type**. 4. Select **Save**. App keys - including **Domain** details, **Client ID** and **Client Secret** - are issued for the application.

# Machine to machine applications - M2m application setup - M2M application API scopes

> Overview of M2M application API scopes for controlling token permissions and access control in Kinde applications

m2m scopes, api scopes, custom scopes, read:users, write:flags, token permissions, access control
machine-to-machine-applications, m2m-application-setup

Scopes define what actions a token is allowed to perform when calling an API. For example, you might create scopes like `read:users` or `write:flags` to control how each machine-to-machine (M2M) app can interact with your services. To learn how to create custom scopes and assign them to APIs and applications, see [Custom API scopes in Kinde](https://docs.kinde.com/developer-tools/your-apis/custom-api-scopes/). For information about API scopes for M2M apps, see [Manage API scopes for M2M applications](/developer-tools/your-apis/api-scopes-m2m-applications/).

# Machine to machine applications - M2m token customization - Customize the claims of an M2M token

> Guide to customizing M2M token claims including properties, feature flags, and custom metadata for enhanced token functionality and configuration

token customization, m2m tokens, properties, feature flags, custom claims, jwt, metadata, ai agents
machine-to-machine-applications, m2m-token-customization

You can customize the claims of tokens issued to Machine-to-Machine (M2M) applications in Kinde by including selected **Properties** and **Feature Flags**. This allows you to inject structured metadata and configuration directly into the token, without requiring an additional lookup at runtime. This is useful for: - Routing or behavior changes based on metadata - Feature gating in backend systems - Configuring AI agents or other automation tools Tokens remain signed JWTs and can be verified like any other Kinde-issued token. See [Token customization](/build/tokens/token-customization/) for detailed procedures. ## Include feature flags in the token If your M2M app is scoped to an organization, you can also include feature flags that are enabled for that org. See [Add feature flags to M2M applications](/machine-to-machine-applications/m2m-application-setup/add-feature-flags-to-m2m-applications/) ## Important info about customizing M2M tokens - [Properties must be defined and assigned](/properties/work-with-properties/manage-properties/) before they can be included in a token. - Only [environment level feature flags](/releases/feature-flags/add-feature-flag/) are available for M2M apps. - Only toggled flags and properties are included - so the token stays lean and secure. ## Complete control over the token For complete control over the token, you can use the [Kinde M2M token generation workflow](/machine-to-machine-applications/m2m-workflow-automation/m2m-workflow/) to customize the token further. For example, you can: - Add custom claims to the token - Add custom scopes to the token - Add custom metadata to the token

# Machine to machine applications - M2m workflow automation - Trigger workflows when an M2M token is generated

> Guide to triggering workflows when M2M tokens are generated including real-time token usage tracking, custom validation, and dynamic service configuration

m2m workflows, token generation, workflow triggers, audit logging, custom validation, dynamic configuration, rate limiting, usage tracking
machine-to-machine-applications, m2m-workflow-automation

Kinde lets you run your own code via the [M2M token generation workflow](/workflows/example-workflows/m2m-token-generation-workflow/) whenever a machine-to-machine (M2M) token is generated. This gives you a powerful way to react to token usage in real time. Use this to: - Audit or log token usage - Apply custom validation - Configure downstream services dynamically - Enforce limits or rate-based rules > This trigger runs **server-side** on Kinde infrastructure. You don’t need to deploy or host anything yourself. ## Real-world use cases Here are some examples of how teams are using this workflow trigger: ### 1. Track token usage by region Log a metric to your analytics system based on metadata in the token (e.g. `region: eu`). Helps track activity across territories. ### 2. Enforce internal token policies Prevent token generation if a certain property or flag is missing (e.g. `model_version` not assigned). ### 3. Apply dynamic configuration Trigger a downstream webhook or set a cache flag when a token is generated, allowing dependent services to fetch relevant settings. ### 4. Alert on suspicious usage Send an alert or log entry if a token is requested more than X times within a short period. ## Set up the M2M token generation workflow The full setup process and code example is documented in the [Token generated workflow trigger](/workflows/example-workflows/m2m-token-generation-workflow/) page, and includes: - Example JavaScript handler - Event payload shape - Deployment instructions

# Machine to machine applications - Organization scoped m2m apps - Enforce org access in your API using M2M tokens

> Guide to enforcing organization access control in APIs using M2M tokens including org_code validation, Express middleware examples, and multi-tenant security best practices

org access enforcement, m2m tokens, org_code validation, tenant-specific apis, access control, express middleware, jwt verification, multi-tenancy
machine-to-machine-applications, organization-scoped-m2m-apps

If you're using [org-scoped machine-to-machine (M2M) apps](/machine-to-machine-applications/organization-scoped-m2m-apps/m2m-applications-for-organizations/), Kinde will automatically include a trusted `org_code` claim in the token. You can then enforce access control in your own APIs using this claim. ## When to enforce org context You should validate `org_code` in any API route or resource that is **tenant-specific**, such as: - `/orgs/:org_code/users` - `/reports/:org_code/usage` - Backend functions or queues scoped to a customer’s data If the token’s org doesn’t match the route or request context, you should reject the request. ## What to check When you receive a token, decode it and check the following. 1. The token is valid and not expired. 2. The token contains `org_code`. 3. The `org_code` in the token matches the organization being accessed. ## Example in Node.js (Express) ```js const jwt = require("jsonwebtoken"); function verifyOrgAccess(req, res, next) { const authHeader = req.headers.authorization; const token = authHeader?.split(" ")[1]; if (!token) return res.status(401).send("Missing token"); // If Kinde is **not** validating the token for you, // verify the signature instead of a raw decode. // const PUBLIC_KEY = ... // fetch from /.well-known/openid-configuration const decoded = jwt.verify(token, PUBLIC_KEY, {algorithms: ["RS256"]}); // Check for required claims if (!decoded?.org_code) return res.status(403).send("Token not scoped to an organization"); const orgFromRoute = req.params.org_code; if (decoded.org_code !== orgFromRoute) { return res.status(403).send("Token does not match organization"); } next(); } ``` Then apply the middleware: ```js app.get("/orgs/:org_code/users", verifyOrgAccess, (req, res) => { // safe to fetch users for this org }); ``` ## Tips for working with org scoped M2M apps accessing your API - You don’t need to verify the token signature if Kinde is validating the token on the backend (e.g. if you’re using our hosted APIs). - If you’re validating the token yourself, use the public key from your environment’s OpenID configuration: `https://<your-subdomain>.kinde.com/.well-known/openid-configuration` - Always treat `org_code` as a **binding contract** — never override it with user input ## How to treat global tokens If the token has no `org_code`, treat it as **not authorized** to access org-specific resources unless explicitly allowed. You may choose to: - Reject the request - Allow access only to system-level endpoints - Prompt developers to use org-scoped apps instead

# Machine to machine applications - Organization scoped m2m apps - M2M apps scoped to organizations

> Guide to organization-scoped M2M applications including tenant isolation, token structure with org_code claims, and best practices for multi-tenant environments

org-scoped m2m, organization scoped, tenant isolation, org_code, client credentials, multi-tenancy, access control, audit trails
machine-to-machine-applications, organization-scoped-m2m-apps

<Aside type="upgrade"> This feature is available on the [Kinde Plus and Kinde Scale plans](https://kinde.com/pricing/) </Aside> You can create machine-to-machine (M2M) applications in Kinde that are scoped to a specific organization. These applications are used to issue access tokens that are automatically restricted to that organization’s context, ensuring strong tenant isolation when calling Kinde’s APIs or your own. Org-scoped apps use the same client credentials flow as other M2M apps, but the tokens they generate include the `org_code` claim. ## When to use an org-scoped M2M application Use an org-scoped app when: - You're building automation or AI tools that act on behalf of a specific customer or tenant - You want to issue per-organization API access keys with enforced access boundaries - You need to simplify your API logic by trusting `org_code` directly from the token - You want tighter auditability and control across multiple customer environments ## Token structure Tokens issued to an org-scoped app include trusted claims such as: - `org_code`: the organization the token is scoped to - `scope`: the permissions granted to the token ```json { "org_code": "org_123", "scope": "read:users write:flags" } ``` These claims are enforced at token issuance time and cannot be modified by the caller. ## Create an org-scoped M2M app 1. In Kinde, go to **Organizations**, then view an organization. 2. Select **M2M apps**. 3. Enter a name for the application. 4. Select **M2M application** as the type. 5. Select **Save**. Kinde generates a `client_id` and `client_secret` tied to the selected organization. Use the credentials in a standard client credentials flow to request a token. Use the credentials to authenticate using the [client credentials flow](/machine-to-machine-applications/about-m2m/authenticate-with-m2m/). The resulting token will include the organization context automatically. These claims can be used by your backend services to authorize access to specific APIs or resources. ## Org-scoped vs global M2M applications | Feature | Global M2M app | Org-scoped M2M app | | --------------------- | ---------------------------------- | ------------------------------ | | Org context in token | No | Yes | | Tenant data isolation | Manual | Enforced | | Use case | Admin scripts, internal automation | Per-tenant agents, scoped APIs | | Token restrictions | None | Scoped to one org | | Token claims | Basic | Includes `org_code` | ## Best practices for org-scoped M2M apps - Use separate M2M apps for different scopes or services. - Limit the [scopes](https://docs.kinde.com/developer-tools/your-apis/custom-api-scopes/) assigned to each M2M app to the minimum required for its function. - [Rotate client secrets](/build/applications/rotate-client-secret/) periodically using the UI. - Audit token usage by tracking `client_id` and `org_code` in logs. - Avoid including any personally identifiable information (PII) in token claims.

# Machine to machine applications - Organization scoped m2m apps - Using M2M apps for AI applications

> Guide to using M2M applications for AI tools and agents including organization-scoped authentication, custom properties, feature flags, and best practices for AI service security

ai applications, m2m apps, ai assistants, ai agents, organization scoped, properties, feature flags, token customization, org isolation
machine-to-machine-applications, organization-scoped-m2m-apps

If you're building AI-powered tools or agents that act on behalf of your customers, machine-to-machine (M2M) applications in Kinde offer a simple, secure way to authenticate them. M2M apps are ideal for: - Long-running background jobs - Headless tools or scheduled workers - AI assistants, agents, or orchestration layers By scoping M2M apps to specific organizations, you ensure each token can only access the data and functionality appropriate to that customer. ## Example: AI assistant per organization You’ve built a support assistant that uses a customer’s internal knowledge base to generate responses. Each org gets their own agent instance. With Kinde, you can: - Create one M2M app per organization - Assign custom metadata (e.g. model version, language preference) - Include feature flags in the token (e.g. `enable_agent_v2`) - Enforce `org_code` in your API to isolate access Your backend APIs validate the incoming token and respond accordingly — no need for separate credential logic or inline configuration. ## Example: Shared agent with dynamic tokens If you deploy a shared service that rotates between customer workspaces, you can: - Store the appropriate client credentials per org - Request tokens using the client credentials flow - Receive a token scoped to a single org, with configuration claims This keeps your infrastructure lightweight while maintaining strict org isolation. ## Best practices - Use [Properties](/machine-to-machine-applications/m2m-application-setup/add-metadata-to-an-m2m-application-with-properties/) to define custom configuration like `model_version` or `max_tokens` - Use [Token customization](/machine-to-machine-applications/m2m-token-customization/customize-m2m-tokens/) to inject only the claims your AI service needs - Enforce `org_code` and `scopes` server-side to prevent token misuse - Rotate credentials regularly and assign minimal scopes per app - Include feature flags to roll out new AI capabilities safely ## Sample token contents ```json { "org_code": "org_123456789", "application_properties": { "model_version": { "v": "gpt-4" }, "region": { "v": "eu" } }, "feature_flags": { "agent-v2": { "t": "b", "v": true }, "beta-tools": { "t": "b", "v": false } } } ``` The `t` and `v` are short codes for the type and value of the feature flag. - `t` = `type` (boolean, string, number) - `v` = `value` (true | false, "beta", 1, etc.) Only the feature flags you explicitly toggle on will be included.

# Machine to machine applications - Troubleshooting m2m - Troubleshoot M2M token errors

> Comprehensive troubleshooting guide for M2M token errors including common error codes, causes, fixes, and debugging techniques for machine-to-machine authentication issues

m2m troubleshooting, token errors, invalid_client, unauthorized_client, invalid_scope, invalid_request, 401 unauthorized, 403 forbidden, org_code, jwt decoder
machine-to-machine-applications, troubleshooting-m2m

If you're using a machine-to-machine (M2M) application to request tokens or call APIs, you may encounter errors related to token generation or usage. This guide covers the most common issues and how to resolve them. ## Token request errors These errors occur when calling the token endpoint (`/oauth2/token`). ### `invalid_client` **Cause:** - The `client_id` or `client_secret` is incorrect - The app has been deleted or had its secret rotated **Fix:** - Double check your credentials in the Kinde dashboard - If you recently rotated the secret, make sure you're using the new one ### `unauthorized_client` **Cause:** - The app hasn’t been authorized to access the requested API (audience) **Fix:** - Go to the **APIs** tab on your M2M app in Kinde - Make sure the app is authorized to access the audience you're requesting ### `invalid_scope` **Cause:** - You requested a scope the app isn’t allowed to use - The scope wasn’t defined on the API or wasn't assigned to the app **Fix:** - Go to the **API** in the Kinde dashboard and verify that the scope exists - Go to the **Scopes** tab on your M2M app and assign the correct ones ### `invalid_request` **Cause:** - Missing or malformed parameters in the request - Common issues: missing `audience`, unsupported `grant_type` **Fix:** - Make sure your request includes: - `grant_type=client_credentials` - `client_id`, `client_secret`, and `audience` - Check your content type: must be `application/x-www-form-urlencoded` ## Token usage errors These occur when using the token to call Kinde or your own API. ### `401 Unauthorized` **Cause:** - Missing or expired token - Malformed `Authorization` header **Fix:** - Make sure you're including the token in the request: ```http Authorization: Bearer <token> ``` - Check that the token hasn’t expired (`exp` claim) ### `403 Forbidden` **Cause:** - The token is valid, but doesn’t have access to the resource - For org-scoped tokens: the `org_code` doesn’t match the route or resource - Required scopes are missing **Fix:** - Check the token’s `org_code` and compare to the resource being accessed - Check the token’s `scopes` and ensure the required permission is present ### Token doesn't include `org_code` **Cause:** - You’re using a global M2M app instead of an org-scoped one **Fix:** - If you're expecting a token with `org_code`, create an [org-scoped M2M app](/machine-to-machine-applications/organization-scoped-m2m-apps/m2m-applications-for-organizations/) ## How to debug - Use tools like the [Kinde JWT decoder](https://kinde.com/tools/online-jwt-decoder/) to decode the token and inspect claims - Check your M2M app configuration in Kinde - Use the **Test** tab in the Kinde dashboard to generate a valid token and compare

# Manage users - About - About user management

> Overview of user management in Kinde including user lifecycle, organization management, and access control features for comprehensive user administration.

user management, organizations, user profiles, user identities, permissions, roles, self sign up, profile sync, enterprise connections
manage-users, about

User management is about managing user records, and controlling what users can do and access within your product. You can set this up to be simple or complex, depending on your company’s needs. ## **Default user settings** ### **Users and organizations** Whether or not you [manage multiple organizations](/build/organizations/add-and-manage-organizations/) in Kinde, all users need to belong to at least one organization. You can specify which organization users are added to, or else they are added to the default organization. You can add users to other organizations or [change the organizations](/manage-users/about/manage-users-across-organizations/) they belong to at any time. If a user belongs to multiple organizations, they will be prompted to select an organization when they sign in. ### **Users can sign themselves up** By default, users will be allowed to sign up to your applications without being invited. If you would prefer your users to be invitation only, go to **Settings > Environment > Policies** and switch off the **Allow self-sign up** option. Tip: If users can sign themselves up, you might want to also [set a default role](/manage-users/roles-and-permissions/default-user-roles/) for new users. ### **User profiles are synced to Kinde** When a user signs in, some of their basic profile details (email, name, picture, etc.) from the external provider (MS Entra ID, Google, etc.) are passed to Kinde as well. For example, if you manage user access via a SAML connection, then their profile stored with the external identity provider is synced to Kinde each time they sign in. You should leave this switched on if you are using [enterprise connections](/authenticate/enterprise-connections/about-enterprise-connections/) for authenticating users. If you want, you can disable it in **Settings > Environment > Policies** by de-seleting the **Sync user profiles on sign in** option. ## User identities are different to profiles User profiles are not quite the same as [user identities](/manage-users/add-and-edit/add-manage-user-identities/), which can also include contact information, access rights, and sign in credentials. User may have just one, or multiple identities (e.g. a username+password, and a Google SSO identity). Manage user identities via the dashboard or via API. ## **Options for adding users** You can [add users manually](/manage-users/add-and-edit/add-and-edit-users/), [import them from a CSV file](/manage-users/add-and-edit/import-users-in-bulk/), or add them [via API](/kinde-apis/management#tag/users/post/api/v1/user). If you are transferring user details from another service, such as Auth0, you need to obtain the details from the service before you can import. ## **Permissions and roles** Permissions and roles are defined at the ‘Business’ level in your Kinde account - which is the global level; but they are applied per user at an ‘organization’ level. This means you just have to create them once and they are made available across your whole business structure. Kinde provides the ability to set individual [permissions](/manage-users/roles-and-permissions/user-permissions/) at a user level, and to create [roles](/manage-users/roles-and-permissions/user-roles/) (sets of permissions) for easier user management. A user can be assigned multiple roles, and assigned permissions on top of these. We recommend you work out a model for managing this, starting with basic permissions. You can [include user roles in access tokens](/manage-users/roles-and-permissions/user-roles/#add-roles-to-the-access-token). **Recommended approach** While everyone’s needs are different, we recommend you write your code based on permissions, not roles, as it gives you more control and will scale better when you are managing a lot of users.

# Manage users - About - Manage users across organizations

> Guide to managing users across multiple organizations including moving users between organizations, bulk operations, and sign-in experience for multi-org users.

multi-organization, user management, organization switching, bulk import, external_organization_id, roles and permissions, sign in experience, enterprise authentication
manage-users, about

If you have [multiple organizations](/build/organizations/multi-tenancy-using-organizations/) set up, you can easily switch the organization a user belongs to and add them to other organizations. - to do this per user, following the procedure below. - to add users to an organization in bulk, [re-import the users](/manage-users/add-and-edit/import-users-in-bulk/) and include the external_organization_id with the CSV. ## **Move a user between organizations** 1. In Kinde, go to **Users**. A list of all your organization’s users shows. 2. Find the user in the list. 3. Select their name to open their profile. 4. Check and uncheck the boxes to add and remove them from an organization. 5. Select **Save**. 6. You will need to [separately add roles and permissions](/manage-users/roles-and-permissions/apply-roles-and-permissions-to-users/) for this user in the organization. If a user belongs to multiple organizations, they will be prompted to select the organization they want to access when they sign in. ## Sign in experience for users in multiple organizations If a user belongs to multiple organizations, they will be prompted to select an organization when they sign in. If you use enterprise authentication, users will be recognized by their email domain and will be forwarded to the correct identity provider.

# Manage users - Access control - Accept policies at signup

> Guide to configuring policy acceptance at user signup in Kinde including terms of service, privacy policy, and legal compliance requirements.

policy acceptance, terms of use, privacy policy, clickwrap agreement, explicit acceptance, sign up flow, third party signup, acceptance tracking, compliance
manage-users, access-control

When a user signs up to your app, site, or platform via Kinde, their acceptance of product terms and privacy policy is implied (see the left image). However, some businesses want to record explicit acceptance and track who has accepted, this is also known as a clickwrap agreement, click-accept, click-to-sign, or clickthrough agreement (see the right image). <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/7933c9f0-7285-431c-b702-3607a0a98100/public" alt="" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" /> ## Switch on explicit acceptance of policies When you switch on explicit acceptance, it is set at the business level and will apply to all environments and organizations in your business. 1. Go to **Settings > Business details**. 2. Add the URL location of the **Terms of use URL** or **Privacy policy URL**, or both. Both are not required. You may have already added these when you set up authentication. 3. In the **Global display settings** section, switch on the **Show a policy acceptance checkbox on sign up** toggle. 4. Select **Save**. ## Acceptance experience for users The next time a user signs up, they will be prompted to select the acceptance checkbox before they are allowed to sign up to your service. - If they sign up with email, the acceptance box appears inline, on the sign up page (see image above). - If they sign up using a third party service like Google or GitHub, a dialog will appear, prompting them to accept (see image below). <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/4bf1e7ff-ed53-445b-206b-6c1fe2121000/public" alt="" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" /> ## Check if a user has accepted You can see in a user’s profile when they accepted the policies, terms and conditions. 1. In Kinde, go to **Users**. 2. Filter the list and select the user you want to view. 3. In the **Activity** section for the user, the dates of acceptance are shown in the **Log** list, with **Terms of use accepted on** and **Privacy policy accepted on** shown in the description. These are shown as a log activity because when one of the policies is updated and new acceptance is recorded, the accepted date will also change.

# Manage users - Access control - Delete or suspend users

> Guide to deleting or suspending users in Kinde including user deactivation, permanent deletion, and access control management.

delete users, suspend users, user suspension, user deletion, access control, user restoration, admin permissions, user management, self sign up
manage-users, access-control

If you want to prevent access by a user, you can suspend or delete them. You need to be a Kinde Owner or Admin to do this. ## **Suspend a user** 1. On the Kinde home page, select **Users**. 2. Find the user you want to suspend. 3. Select the three dots menu, then select **Suspend user.** A ‘suspended’ badge appears next to their name on the user list. When the user tries to sign in, they will receive an error and will not be able to sign in. ## **Restore a suspended user** 1. On the Kinde home page, select **Users**. 2. Find the suspended user you want to restore. 3. Select the three dots menu, then select **Restore user**. This reinstates their access. When the user tries to sign in, their access will be restored. ## **Delete a user** 1. On the Kinde home page, select **Users**. 2. Find the user you want to delete. 3. Select the three dots menu, then select **Delete user**. A confirmation window opens. 4. Select the extent to which you want to delete the user: 1. Select the first option to remove the user’s access and ability to sign in to all organizations, but leave their profile in Kinde. 2. Select the second option to completely remove the user record from Kinde, including access and all subscriber lists. 5. Select **Delete user**. When the user tries to sign in, they will be prompted to sign up (if self-sign-up is allowed in your business).

# Manage users - Access control - Reset multi-factor authentication for a user

> Guide to resetting multi-factor authentication for users in Kinde including MFA bypass, re-enrollment, and security management.

mfa reset, multi-factor authentication, authenticator app, recovery codes, mfa setup, organization mfa, environment mfa, mfa methods, access control
manage-users, access-control

You can reset multi-factor authentication (MFA) for individual users. You might do this because: - they can’t access their authenticator app. - they need to reset or re-install an authenticator app. - they have previously opted out of MFA but now want to enable it. They should be able to use their recovery codes to get in to the system in the meantime. ## **To reset MFA for a user** 1. In Kinde, go to the **Users** page. 2. Select the user’s name to view their details. 3. Select **Multi-factor auth** in the menu. Depending on how MFA is set up in the environment and how many organizations the user belongs to, you will see: - a section for the default MFA (environment-level settings), if this applies. - a section for MFA for each organization the user belongs to. 4. Select the three dots next to the relevant MFA method and then select **Reset multi-factor auth**. A confirmation message opens. 5. Select **Reset**. 6. If a user has multiple MFA methods set up, you need to remove each method to fully reset MFA for the environment or organization. Repeat from step 4. The next time the user signs in to the environment or organization they will be prompted to set up their MFA. If the user has previously opted out of MFA, they will be prompted to opt-in again before setting up MFA.

# Manage users - Access control - Reset a user's password

> Guide to resetting user passwords in Kinde including password reset workflows, temporary passwords, and user authentication management.

password reset, user password, admin reset, api reset, password change, authentication, admin permissions, user management
manage-users, access-control

If your user’s authenticate using passwords, you can reset their password through the Kinde admin (instructions below), or [through our API](/kinde-apis/management#tag/users/patch/api/v1/user) using `{"is_password_reset_requested": true}` in the body of a request. Note that you need to be a Kinde admin or have sufficient permissions to reset a user’s password. 1. In Kinde, go to **Users**. The list of all your users is displayed. 2. Filter, browse, or search the list for the user who’s password needs to be reset. 3. Select their name to open their profile, then scroll down the **Profile** window and select **Reset Password**. 4. Select **Reset** in the confirmation message that appears. The next time the user signs in, they will be prompted to change their password.

# Manage users - Access control - Set temporary password

> Guide to setting temporary passwords for users in Kinde including password expiration, forced password changes, and security best practices.

temporary password, single-use password, password authentication, hashed password, bcrypt, md5, sha256, salt, security warning, api password

If you have set up [password authentication](/authenticate/authentication-methods/password-authentication/) for your users, you might want to set or update their password. Kinde lets you set a single-use, temporary password to enable authentication. There are a number of reasons why you might need to do this, for example: - You don’t allow self-sign-up, so you provide sign in and password details to all new users - You don’t have a valid email for the user - The user cannot access their email or phone, to receive a reset password code When you set a temporary password, you’ll need to communicate it to the user via your own method. Kinde cannot send a temporary password via email or SMS. ## Security warning Setting a temporary password is not a very secure way of helping a user sign in. The password might be overheard or intercepted after you send it, and it could be misused and make your systems vulnerable. If you have an email for the user, we recommend triggering a [password reset](/manage-users/access-control/reset-user-password/) instead. ## Signing in with a temporary password To use a temporary password, the user signs in with their email, or other identity credential, and uses the temporary password. They will be immediately prompted to set a new password of their own creation. Once used, the temporary password becomes invalid. ## Set a temporary password in Kinde 1. In Kinde, go to **Users**, then open the profile of the user. 2. Scroll to the bottom of the page to the **Admin actions** section. 3. In the **Manage passwords** area, select **Set temporary password**. 4. In the window that appears, enter a password. <Aside> The password must be more than 8 characters, not common or guessable (e.g. not `Password123`). We recommend a mix of alphanumeric characters in upper and lowercase. Special characters are optional. </Aside> 5. To view the password, select the ‘eye’ icon. 6. Select **Set temporary password**. 7. Communicate the password to the user. ## Set or update a password via Kinde API The [Set user password API](/kinde-apis/management#tag/users/put/api/v1/users/{user_id}/password) allows you to supply a hashed password for a user. If you pass the `is_temporary_password: true` to the API it will set a password as being single-use. <Aside type="warning"> We only accept password hashes and will never allow plain text passwords </Aside> Include the following information for the password API: - `hashed_password` - the user’s password encrypted using a hashing method or algorithm - `hashing_method` - the name of the algorithm used to encrypt the user’s password. Currently **crypt**, **bcrypt**, **md5**, **SHA256**, and **wordpress** are supported. <Aside title="bcrypt $2b variant support"> If you are importing bcrypt hashes with the $2b variant, Kinde will substitute this for the $2a variant. These are interchangeable as long as you were not running OpenBSD at the time the hashes were generated. </Aside> <Aside title="sha256 support:"> Provide the hash in hex format. For the `salt_format`, specify how the salt should be interpreted: e.g. **hex** for a hex-encoded string (68656c6c6f for hello). By default, the salt is treated as a plain string, and escape sequences (like \n or \v) are treated as literal characters. </Aside> - `salt` - extra characters added to passwords to make them stronger - `salt_position` - position of salt in password string. Prefix (before) or suffix (after). | Hashing method | Salt | Salt position | | -------------- | -------- | ------------------------- | | md5 | Optional | required if salt included | | bcrypt | | | | crypt | Optional | | | wordpress | Optional | | | SHA256 | Optional | required if salt included | - `is_temporary_password` - indicates a single use password, the user will be prompted to set a new password after the first time they use it.

# Manage users - Add and edit - Manually add and edit users

> Guide to manually adding and editing users in Kinde including user creation, editing details, and organization assignment.

add users, edit users, user management, manual user creation, user details, organizations, bulk import
manage-users, add-and-edit

You can manually add and edit users in Kinde. You can also import users in bulk from CSV. See [Import users in bulk](/manage-users/add-and-edit/import-users-in-bulk/). ## **Add a user** 1. Go to **Users**. A list of users across all your organizations is shown. 2. Select **Add user**. 3. In the window that appears, enter the user details including name, email, and other relevant details. 4. Select the **Organizations** you want to add them to. Your business’s default organization is selected by default. 5. Select **Save**. ## **Edit user details** 1. Go to **Users**. A list of users across all your organizations is shown. 2. Find the user whose details you want to edit. 3. Open the user’s record. 4. Use the side menu to navigate the pages and make the changes you want. Select **Save** on each page as you go.

# Manage users - Add and edit - Add and manage user identities

> Guide to adding and managing user identities in Kinde including email addresses, phone numbers, and social login connections for multi-identity support.

user identities, identity management, profile identities, contact information, sign in identity, primary identity, enterprise identities, username case sensitivity, api management

You can add and manage a user’s identity in Kinde. This includes their Kinde profile, contact, and sign in identity information. [Learn more about identities in Kinde](/authenticate/about-auth/identity-and-verification/). This topic explains how to add profile identities manually in Kinde - you might do it this way as a one-off task. You can also add identities via [the Kinde Management API](/kinde-apis/management/). You might do it this way for bulk processes. <Aside> Users with enterprise identities in Kinde can't also have other identity types in Kinde. E.g. a user can have an email identity and a social identity. But if a user has an enterprise identity, they cannot have other identities. </Aside> ## Add an identity 1. In Kinde, go to **Users**. 2. Search or browse for the user you want to update. 3. In the **Profile** page for the user, in the **Identities** section, select **Add identity**. 4. In the dialog, choose the identity type and enter the details. 5. Select **Save**. Create a username, email or phone identity via API: `POST /users/{user_id}/identities` ## Delete an identity You can’t edit an identity record as it can break authentication for a user. Instead, add a new identity before you delete the old one. 1. In Kinde, go to **Users**. 2. Search or browse for the user you want to update. 3. In the **Profile** page for the user, in the **Identities** section, locate the identity you want to delete. 4. Select the three dots menu and select **Delete identity**. Delete a username, email or phone identity via API: `DELETE /identities/{identity_id}` ## Make a contact identity primary Primary contact information gets passed in the ID token for the user. You can change the primary identity. 1. In Kinde, go to **Users**. 2. Search or browse for the user you want to update. 3. In the **Profile** page for the user, in the **Identities** section, locate the identity you want to make primary. 4. Select the three dots menu and select **Make primary**. Make an identity the primary one (`is_primary`) via API: `PATCH /identities/{identity_id}` ## Update a user identity You can’t directly edit identities in Kinde. You need to add a new identity and delete the old one to update identity records. ## Cases in usernames Kinde treats usernames as case-insensitive. In other words, we ignore case. We do this because it eliminates the possibility of auth issues and fraud when two usernames are identical in every aspect except the case of one of their letters. We are happy to support users choosing an aesthetically pleasing username combination, like `RosyRose` or `BuilderBob`. We just don't also support separate identities for `rosYrosE` and `BUilderbob`. Before adding users, we recommend checking that all usernames are unique in more than just case.

# Manage users - Add and edit - Import users in bulk from Auth0

> Comprehensive guide to importing users in bulk to Kinde from Auth0 using the JSON format, validation rules, and error handling for large-scale user management.

auth0 migration, user migration, password import, roles and permissions, hashed passwords, external_organization_id, username case sensitivity
manage-users, add-and-edit

This topic is for people who want to import users in bulk to Kinde from Auth0. For other formats, see [import users via JSON or CSV](/manage-users/add-and-edit/import-users-in-bulk/). ## File requirements - Auth0 data - User details and passwords need to be in NDJSON (Newline Delimited JSON) format - File size up to 20MB supported If you’ve got large user sets (over 20MB) or are concerned about file size limits, you might consider importing in batches, or contact us for import support. ## Before you import users - [Create organizations in Kinde](/build/organizations/add-and-manage-organizations/) - only if you use this function to support multi-tenancy (for example, in a B2B structure) or if you manage separate user groups this way. - Add [roles](/manage-users/roles-and-permissions/user-roles/) and [permissions](/manage-users/roles-and-permissions/user-permissions/) in Kinde, if you intend to import these details with users. - If your users sign on with passwords, make sure you [Enable password authentication](/authenticate/authentication-methods/set-up-user-authentication/) before importing them ## Cases in usernames Kinde treats usernames as case-insensitive. In other words, we ignore case. We do this because it eliminates the possibility of auth issues and fraud when two usernames are identical in every aspect except the case of one of their letters. We are happy to support users choosing an aesthetically pleasing username combination, like `RosyRose` or `BuilderBob`. We just don't also support separate identities for `rosYrosE` and `BUilderbob`. Before importing users, we recommend checking that all usernames are unique in more than just case. ## Prepare Auth0 data When you export user details from Auth0: - select all the default fields and add the `identities` field to the import list. - select the JSON file format for export. `Identities` data distinguishes the type of identity, specifically the `connection` attribute. e.g. username, phone, GitHub, Google, etc. ### How Auth0 user identities are treated on import Social identities without an email can be imported, and are identified by the connection type. You can import users with multiple identities, these will be listed under the user’s profile. Kinde supports migrating the following authentication methods from Auth0: Usernames, Email, Phone, Google, Apple, Microsoft, Facebook, GitHub, Twitch, Bitbucket. Auth methods are shown in the `connection` attribute. These are represented as follows in the identity data: - Username-Password-Authentication - email - sms - google-oauth2 - apple - microsoft - github - twitch - facebook - bitbucket - windowslive ### Import options When importing users from Auth0, you have two options: 1. **Import users only** - choose this method if you want to allow users to reset their password or sign in another way. 2. **Import passwords only** - only choose this if you have already imported users. ## How to import users 1. In Kinde, go to **Users**, then select **Import users**. 2. Select **From Auth0**. 3. Follow the on-screen prompts to import the data. 4. If there are any [errors with the import](/manage-users/add-and-edit/troubleshoot-user-import-errors/), you will be able to view them afterwards. 5. Most import errors can be fixed by editing the JSON file and then re-importing into Kinde. Any records that have already been imported and are unchanged, will be ignored. ## Impact on end-users Importing all your existing users and passwords should mean that your end users won’t notice anything when they next sign in. This is the optimal experience. However: - If a user changes their password after the user export and while the migration is in progress, they will be prompted to reset their password on the next sign in. - If you have set up a new authentication method as part of the user migration (for instance, going passwordless) your users will be prompted to use the new method on sign in. - If you add or remove roles or permissions, they may gain/lose access to parts of your system. ## Weak passwords are not rejected on import When you import passwords, Kinde does not check for password strength. However, if you do not also include a `TRUE` in the `password_verified` column of the CSV, Kinde will send a one-time password to the user the first time they try to sign in, in order to verify their identity. In future, we may add the ability to check password strength and initiate a password change if it's deemed to weak by standard password criteria. ## Re-importing can update user info If you add a user via import and they start authenticating via Kinde, and then you import their records again with changes - for example, you import name and email, but with a new permission - that information will be updated Kinde. We do not recommend making user updates via import, instead, manage updates via the Kinde admin, or via API. ## Communication to users Kinde does not send any notifications or invitations to users when they are added to Kinde via import. The idea is that your users have a seamless experience that feels (almost) like it always has in your app. If you’ve made changes to their sign in experience — for example adding multi-factor authentication — then consider contacting your users to let them know their sign in experience will be changed.

# Manage users - Add and edit - Import users via CSV or JSON

> Comprehensive guide to importing users in bulk to Kinde including custom CSV and NDJSON format requirements, validation rules, and error handling for large-scale user management.

bulk import, csv import, auth0 migration, user migration, password import, organization assignment, roles and permissions, hashed passwords, external_organization_id, username case sensitivity
manage-users, add-and-edit

You can import users in bulk, from CSV or JSON. If you are moving to Kinde from Auth0, see [this guide](/manage-users/add-and-edit/import-users-from-auth0/) instead. ## File requirements - CSV - User details and passwords need to be in UTF-8 encoded CSV format - JSON - User details and passwords need to be in NDJSON (Newline Delimited JSON) format - File size up to 20MB supported If you’ve got large user sets (over 20MB) or are concerned about file size limits, you might consider importing in batches, or contact us for import support. ## Before you import users - [Enable password authentication](/authenticate/authentication-methods/set-up-user-authentication/) before importing passwords - [Create organizations in Kinde](/build/organizations/add-and-manage-organizations/) - only if you use this function to support multi-tenancy (for example, in a B2B structure) or if you manage separate user groups this way. - Add [roles](/manage-users/roles-and-permissions/user-roles/) and [permissions](/manage-users/roles-and-permissions/user-permissions/) in Kinde, if you intend to import these details with users. **Note: Importing users from Entra ID (formerly Azure)** Set up the [MS Entra ID connection in Kinde](/authenticate/enterprise-connections/azure/) before you import your users. Then when you import, Kinde will match users to the relevant connection based on their email address. ## Cases in usernames Kinde treats usernames as case-insensitive. In other words, we ignore case. We do this because it eliminates the possibility of auth issues and fraud when two usernames are identical in every aspect except the case of one of their letters. We are happy to support users choosing an aesthetically pleasing username combination, like `RosyRose` or `BuilderBob`. We just don't also support separate identities for `rosYrosE` and `BUilderbob`. Before importing users, we recommend checking that all usernames are unique in more than just case. ## Prepare NDJSON data Before importing, make sure that you set up data that you want user records to be linked to, e.g. roles, permissions, organizations. Organizations are linked based on the 'external_organization_id' field , the value of which needs to be added against the organization object with 'external_id' in your import file. Using the NDJSON format you can import users with the following user data: - Permissions - Roles - Property values - Identities - Feature flags - Scopes - Profiles NDJSON files are line separated JSON objects with each JSON object representing a user. The following schema can be used for importing NDJSON files, note this schema represents one line within the file. ```json { "$schema": "http://json-schema.org/draft-07/schema#", "title": "User", "description": "A user object for importing", "type": "object", "properties": { "id": { "type": "string", "description": "A unique external identifier for the user (e.g., 'your_external_user_id_001')." }, "password": { "type": "object", "description": "Password metadata including salt, hash, and algorithm used.", "properties": { "salt": { "type": ["string", "null"], "description": "The salt value used when hashing the password, if applicable." }, "salt_format": { "type": ["string", "null"], "enum": ["hex", "string", null], "description": "Format of the salt value. Can be 'hex', 'string', or null if not used." }, "salt_position": { "type": ["string", "null"], "enum": ["prefix", "suffix", null], "description": "Position of the salt relative to the password. Can be 'prefix', 'suffix', or null." }, "hashed_password": { "type": "string", "description": "The resulting hashed password string." }, "hashing_algorithm": { "type": "string", "enum": ["crypt", "bcrypt", "sha256", "md5", "wordpress"], "description": "The algorithm used to hash the password." } } }, "first_name": { "type": "string", "description": "The user's first name." }, "last_name": { "type": "string", "description": "The user's last name." }, "identities": { "type": "array", "description": "A list of identity records such as email, username, or social.", "items": { "type": "object", "description": "An identity record associated with the user.", "properties": { "type": { "type": "string", "description": "The type of identity.", "enum": [ "email", "phone", "username", "oauth2:slack", "oauth2:apple", "oauth2:github", "oauth2:facebook", "oauth2:twitter", "oauth2:twitch", "oauth2:gitlab", "oauth2:xero", "oauth2:linkedin", "oauth2:discord", "oauth2:bitbucket", "oauth2:stripe", "oauth2:microsoft", "oauth2:clever", "oauth2:roblox" ] }, "identity": { "type": "string", "description": "The actual identifier value (e.g., email address, username, or provider user ID)." }, "is_verified": { "type": "boolean", "description": "Whether this identity has been verified." }, "provider": { "type": "string", "description": "The name of the provider (e.g., 'google') for OAuth identities." }, "profile": { "type": "object", "description": "Optional key/value pairs returned from the provider.", "additionalProperties": true } } } }, "properties": { "type": "array", "description": "Custom metadata key-value pairs associated with the user.", "items": { "type": "object", "properties": { "key": { "type": "string", "description": "The name of the property." }, "value": { "type": "string", "description": "The value of the property." } } } }, "feature_flags": { "type": "array", "description": "A list of feature flags for the user.", "items": { "type": "object", "properties": { "key": { "type": "string", "description": "The name of the feature flag." }, "value": { "type": "string", "description": "The value of the flag." } } } }, "organizations": { "type": "array", "description": "Organizations this user is associated with, including roles, permissions and api scopes.", "items": { "type": "object", "properties": { "external_id": { "type": "string", "description": "An external identifier for the organization (e.g., 'your_external_org_id_001')." }, "roles": { "type": "array", "description": "List of roles assigned to the user within the organization.", "items": { "type": "string" } }, "permissions": { "type": "array", "description": "List of specific permissions granted to the user within the organization.", "items": { "type": "string" } }, "scopes": { "type": "array", "description": "API scopes assigned to the user for this organization.", "items": { "type": "object", "properties": { "audience": { "type": "string", "format": "uri", "description": "The audience or API this scope applies to (e.g., 'https://your-api.com')." }, "scope": { "type": "string", "description": "The name of the scope (e.g., 'scope_1')." } } } } } } } } } ``` Here's an single-line example: ```txt {"id":"your_external_user_id_001","password":{"salt":null,"salt_format":null,"salt_position":null,"hashed_password":"$2a$10$t8Jz3hJCCTFk/Acja7bw3OpamB3xuLPhpJlRHb31bXIjfzeTfn8rq","hashing_algorithm":"bcrypt"},"last_name":"One","first_name":"User","identities":[{"type":"username","identity":"userone"},{"type":"email","identity":"userone@example.com","is_verified":true},{"type":"oauth2:google","profile":{"custom_provider_fields":"custom key/values from google"},"identity":"123456","provider":"google","is_verified":true}],"properties":[{"key":"property_1","value":"false"}],"feature_flags":[{"key":"feature_flag_1","value":"true"}],"organizations":[{"external_id":"your_external_org_id_001","roles":["admin","member"],"permissions":["read","write"],"scopes":[{"audience":"https://your-api.com","scope":"scope_1"}]}]} ``` Example, but a bit easier to read. ```jsx { "id": "your_external_user_id_001", "password": { "salt": null, "salt_format": null, "salt_position": null, "hashed_password": "$2a$10$t8Jz3hJCCTFk/Acja7bw3OpamB3xuLPhpJlRHb31bXIjfzeTfn8rq", "hashing_algorithm": "bcrypt" }, "last_name": "One", "first_name": "User", "identities": [ { "type": "username", "identity": "userone" }, { "type": "email", "identity": "userone@example.com", "is_verified": true }, { "type": "oauth2:google", "profile": { "custom_provider_fields": "custom key/values from google" }, "identity": "123456", "provider": "google", "is_verified": true } ], "properties": [{ "key": "property_1", "value": "false" }], "feature_flags": [{ "key": "feature_flag_1", "value": "true" }], "organizations": [ { "external_id": "your_external_org_id_001", "roles": ["admin", "member"], "permissions": ["read", "write"], "scopes": [{ "audience": "https://your-api.com", "scope": "scope_1" }] } ] } ``` ## Prepare CSV files When exporting data from another auth system or your own system via CSV, the file needs to be set up with specific headings and formats for the data you are importing. These are detailed below. If you are migrating from Auth0, see the **Prepare JSON data (for Auth0 imports)** section. ### Required **data** - `email` or `phone` - minimum required identity information - `external_organization_id` - assign users to organizations, optional unless you are importing roles and permissions <Aside> There are special considerations if you are importing users who will share a phone number to authenticate via a mobile device. Contact support@kinde.com for advice on the best way to import users where the phone is the primary identity and numbers are shared. </Aside> ### Other user data <Aside> The more data that you include for import, the easier we can set up your users in Kinde. Kinde will not duplicate users with existing email addresses. </Aside> - `first_name` and `last_name` - `id` (also referred to as `provided_id`) - unique to the auth provider and helps us match records as they are imported. - `username` - if usernames are part of a user’s identity - `phone` - in the [E.164](https://en.wikipedia.org/wiki/E.164) format [+][country code][number]. For example, +6155511555. Required for phone authentication. - `phone_verified` - phone number verification status: TRUE or FALSE - `email` - the user’s email address - `email_verified` - email verification status: `TRUE` or `FALSE`. TRUE only applies if you are also importing the user's password. If they have not set a password and you set this to `TRUE`, they will be prompted to set one using a one-time code the first time they sign in. This verifies their identity. - `role_key` - the role key for the role a user will be assigned on import. If the user is to be assigned more than one role, use a comma separated list. - `permission_key` - the permissions key for the permission a user will be assigned (that is not included in their role). If the user is to be assigned more than one permission, use a comma separated list. - `external_organization_id` - your supplied 'external_id' for the organization that you want the user to be imported into. Optional unless you are importing roles and permissions with user data. If the user belongs to more than one organization, use a comma separated list wrapped in double quotes. If left empty the user will be assigned to the default organization, if the 'Add users to this organization if no organization is specified' policy is enabled. <Aside> Note that this is NOT the same as the **Organization code** in Kinde, which is a Kinde-supplied ID. You can define your ID in the organization 'external_id' field. </Aside> ### Password data (optional) - `hashed_password` - the user’s password encrypted using a hashing method or algorithm. - `hashing_method` - the name of the algorithm used to encrypt the user’s password. Currently **crypt**, **bcrypt**, **sha256**, **md5**, and **wordpress** are supported. [Contact us](https://kinde-21631392.hs-sites.com/en-au/feature-request) if you need a different method. - `salt` - extra characters added to passwords to make them stronger - `salt_position` - position of salt in password string. E.g. prefix (before) or suffix (after). - `salt_format` - format of the salt, e.g. hex, string, etc. <Aside title="bcrypt $2b variant support:"> Please note if you are importing bcrypt hashes with the $2b variant, Kinde will substitute this for the $2a variant. These are interchangeable as long as you were not running OpenBSD at the time the hashes were generated. </Aside> <Aside title="sha256 support:"> Provide the hash in hex format. Import the salt using the `salt` column. For the `salt_format`, specify how the salt should be interpreted: e.g. **hex** for a hex-encoded string (68656c6c6f for hello). By default, the salt is treated as a plain string, and escape sequences (like \n or \v) are treated as literal characters. </Aside> | Hashing method | Salt | Salt position | | -------------- | -------- | ------------------------- | | md5 | Optional | required if salt included | | bcrypt | | | | crypt | Optional | | | wordpress | Optional | | | sha256 | Optional | required if salt included | ### **Example simple csv import** ```text email,id,first_name,last_name,roles,permissions,external_organization_id jen@kinde.com,0001,"Jen","Smith","role_1","permission_1","ext_org_id_1,ext_org_id_2 elmo@kinde.com,0002,"Elmo","Smith","role_1","permission_2","ext_org_id_1,ext_org_id_2 ``` ### Users with multiple orgs and multiple roles If you’re importing users who belong to multiple organizations and they have different roles in those organizations, you can set up the CSV to duplicate the user on a separate line for each organization they belong to, with the relevant roles to match. For example: ```text email,id,first_name,last_name,roles,permissions,external_organization_id jen@kinde.com,0001,"Jen","Smith","role_1,role_2","permission_1,permission_2","ext_org_id_1 jen@kinde.com,0001,"Jen","Smith","role_3","permission_3,permission_4","ext_org_id_2,ext_org_id_3 ``` Alternatively, you can import your users first, then import their roles and organizations in a separate file: ```text File 1 email,id,first_name,last_name jen@kinde.com,0001,"Jen","Smith ``` ```text File 2 id,roles,permissions,external_organization_id 0001,"role_1,role_2","permission_1,permission_2","ext_org_id_1 0001,"role_3,role_4","permission_3,permission_4","ext_org_id_2 ``` ## How to import users 1. In Kinde, go to **Users**, then select **Import users**. 2. Select the option for your situation: - Custom CSV - Custom NDJSON 3. Follow the on-screen prompts to import the data. 4. If there are any [errors with the import](/manage-users/add-and-edit/troubleshoot-user-import-errors/), you will be able to view them afterwards. 5. Most import errors can be fixed by editing the CSV or NDJSON file and then re-importing into Kinde. Any records that have already been successfully imported, will be ignored. ## Impact on end-users Importing all your existing users and passwords should mean that your end users won’t notice anything when they next sign in. This is the optimal experience. However: - If a user changes their password after the user export and while the migration is in progress, they will be prompted to reset their password on the next sign in. - If you have set up a new authentication method as part of the user migration (for instance, going passwordless) your users will be prompted to use the new method on sign in. - If you add or remove roles or permissions, they may gain/lose access to parts of your system. ## Weak passwords are not rejected on import When you import passwords via CSV, Kinde does not check for password strength. However, if you do not also include a `TRUE` in the `password_verified` column of the CSV, Kinde will send a one-time password to the user the first time they try to sign in, in order to verify their identity. In future, we may add the ability to check password strength and initiate a password change if it's deemed to weak by standard password criteria. ## Re-importing does not update user info If you add a user via import and they start authenticating via Kinde, and then you import their records again with changes - for example, a name change or a new email - that information will not be updated in Kinde. Similarly, if a user has changed the spelling of their name or has new permissions, and you import data from a CSV containing outdated information, the older data will NOT override their current record in Kinde. We recommend managing updates to user information via the Kinde admin, or via API. ## Communication to users Kinde does not send any notifications or invitations to users when they are added to Kinde via import. The idea is that your users have a seamless experience that feels (almost) like it always has in your app. Similarly, if you add users via API, Kinde does not send an email or notification to the user. If you’ve made changes to their sign in experience — for example adding multi-factor authentication — then consider contacting your users to let them know their sign in experience will be changed.

# Manage users - Add and edit - Manage subscribers

> Guide to managing subscribers in Kinde including subscriber status, billing integration, and subscription lifecycle management for SaaS applications.

subscribers, subscriber management, lead generation, newsletters, campaigns, subscription form, convert to user, contact management, access requests
manage-users, add-and-edit

In Kinde, you can build a list of subscribers so you can communicate to them about your business, products, and services. For example, you might use the subscriber form for: - lead generation - newsletters - campaigns - product or feature communication Once a contact is in your subscriber list, they can be easily converted to users later. This list is different to your [Access request contacts](/build/set-up-options/manage-access-requests/), who’s details you collected when they registered interest in your product. ## Set up a subscription form Kinde allows you to design the page where customers can go to subscribe to your newsletter or other product updates. See [Set up a subscription form](/design/pages/subscription-form/). ## View subscriber details 1. In Kinde, go to **Users > Subscribers**. A list of contacts is shown. 2. To see when a person subscribed, find them in the list, select the three dots menu and select **View details**. A panel slides out showing added information. ## Add a subscriber 1. Go to **Users > Subscribers** and select **Add subscriber**. 2. In the window that appears, enter their name and email address. 3. Select **Save**. ## Convert a subscriber to a user 1. Go to **Users > Subscribers** and find the contact you want to convert to a user. 2. Select the three dots menu and select **Convert to user**. A window appears, prompting you to select the organization the user will belong to. You can only select one. 3. Select **Convert**. The contact will now appear on the **All users** list, but will also remain a subscriber. See [Manage users across organizations](/manage-users/about/manage-users-across-organizations/) if you want to assign the user to other organizations. ## Delete a subscriber 1. Go to **Users > Subscribers** and find the contact you want to delete. 2. Select the three dots menu and select **Delete subscriber**. A confirmation message appears. 3. Confirm you want to delete the subscriber and select **Delete subscriber**. The person is permanently removed from the subscriber list.

# Manage users - Add and edit - Move users between Kinde environments and businesses

> You can move users between Kinde environments or businesses by exporting and importing them.

transfer users, bulk import, organization assignment, roles and permissions, hashed passwords
manage-users, add-and-edit

If you need to move users between Kinde environments or Kinde businesses, you can do this using a JSON export and import routine. ## File requirements - User details and passwords need to be in NDJSON (Newline Delimited JSON) format, with a file size up to 20MB supported. - If you’ve got large user sets (over 20MB) or are concerned about file size limits, you might consider importing in batches. ## Data that can be transferred Using the NDJSON format you can export/import users with the following data: - First name, last name - Permissions - Roles - Property values - Identities - Feature flags - Scopes - Profiles - Passwords ## Set up the business or environment First, set up the business or environment you are moving users to. For example: - [Enable password authentication](/authenticate/authentication-methods/set-up-user-authentication/) before importing passwords - [Create organizations in Kinde](/build/organizations/add-and-manage-organizations/) if relevant - Add [roles](/manage-users/roles-and-permissions/user-roles/) and [permissions](/manage-users/roles-and-permissions/user-permissions/) in Kinde, if you intend to import these details with users. ## Export users from Kinde environment In the business or environment you want to export users from - follow this [export procedure](/manage-your-account/your-data/exporting-data/). ## Import users to a Kinde environment In the environment you want to import users into - follow this [JSON import procedure](/manage-users/add-and-edit/import-users-in-bulk/). ## About the NDJSON format NDJSON files are line separated JSON objects, with each JSON object representing a user. The following schema can be used for importing NDJSON files, note this schema represents one line within the file. ```json { "$schema": "http://json-schema.org/draft-07/schema#", "title": "User", "description": "A user object for importing", "type": "object", "properties": { "id": { "type": "string", "description": "A unique external identifier for the user (e.g., 'your_external_user_id_001')." }, "password": { "type": "object", "description": "Password metadata including salt, hash, and algorithm used.", "properties": { "salt": { "type": ["string", "null"], "description": "The salt value used when hashing the password, if applicable." }, "salt_format": { "type": ["string", "null"], "enum": ["hex", "string", null], "description": "Format of the salt value. Can be 'hex', 'string', or null if not used." }, "salt_position": { "type": ["string", "null"], "enum": ["prefix", "suffix", null], "description": "Position of the salt relative to the password. Can be 'prefix', 'suffix', or null." }, "hashed_password": { "type": "string", "description": "The resulting hashed password string." }, "hashing_algorithm": { "type": "string", "enum": ["crypt", "bcrypt", "sha256", "md5", "wordpress"], "description": "The algorithm used to hash the password." } } }, "first_name": { "type": "string", "description": "The user's first name." }, "last_name": { "type": "string", "description": "The user's last name." }, "identities": { "type": "array", "description": "A list of identity records such as email, username, or social.", "items": { "type": "object", "description": "An identity record associated with the user.", "properties": { "type": { "type": "string", "description": "The type of identity.", "enum": [ "email", "phone", "username", "oauth2:slack", "oauth2:apple", "oauth2:github", "oauth2:facebook", "oauth2:twitter", "oauth2:twitch", "oauth2:gitlab", "oauth2:xero", "oauth2:linkedin", "oauth2:discord", "oauth2:bitbucket", "oauth2:stripe", "oauth2:microsoft", "oauth2:clever", "oauth2:roblox", "oauth2:google" ] }, "identity": { "type": "string", "description": "The actual identifier value (e.g., email address, username, or provider user ID)." }, "is_verified": { "type": "boolean", "description": "Whether this identity has been verified." }, "provider": { "type": "string", "description": "The name of the provider (e.g., 'google') for OAuth identities." }, "profile": { "type": "object", "description": "Optional key/value pairs returned from the provider.", "additionalProperties": true } } } }, "properties": { "type": "array", "description": "Custom metadata key-value pairs associated with the user.", "items": { "type": "object", "properties": { "key": { "type": "string", "description": "The name of the property." }, "value": { "type": "string", "description": "The value of the property." } } } }, "feature_flags": { "type": "array", "description": "A list of feature flags for the user.", "items": { "type": "object", "properties": { "key": { "type": "string", "description": "The name of the feature flag." }, "value": { "type": "string", "description": "The value of the flag." } } } }, "organizations": { "type": "array", "description": "Organizations this user is associated with, including roles, permissions and api scopes.", "items": { "type": "object", "properties": { "external_id": { "type": "string", "description": "An external identifier for the organization (e.g., 'your_external_org_id_001')." }, "roles": { "type": "array", "description": "List of roles assigned to the user within the organization.", "items": { "type": "string" } }, "permissions": { "type": "array", "description": "List of specific permissions granted to the user within the organization.", "items": { "type": "string" } }, "scopes": { "type": "array", "description": "API scopes assigned to the user for this organization.", "items": { "type": "object", "properties": { "audience": { "type": "string", "format": "uri", "description": "The audience or API this scope applies to (e.g., 'https://your-api.com')." }, "scope": { "type": "string", "description": "The name of the scope (e.g., 'scope_1')." } } } } } } } } } ``` Here's an single-line example: ```txt {"id":"your_external_user_id_001","password":{"salt":null,"salt_format":null,"salt_position":null,"hashed_password":"$2a$10$t8Jz3hJCCTFk/Acja7bw3OpamB3xuLPhpJlRHb31bXIjfzeTfn8rq","hashing_algorithm":"bcrypt"},"last_name":"One","first_name":"User","identities":[{"type":"username","identity":"userone"},{"type":"email","identity":"userone@example.com","is_verified":true},{"type":"oauth2:google","profile":{"custom_provider_fields":"custom key/values from google"},"identity":"123456","provider":"google","is_verified":true}],"properties":[{"key":"property_1","value":"false"}],"feature_flags":[{"key":"feature_flag_1","value":"true"}],"organizations":[{"external_id":"your_external_org_id_001","roles":["admin","member"],"permissions":["read","write"],"scopes":[{"audience":"https://your-api.com","scope":"scope_1"}]}]} ``` Example, but a bit easier to read. ```jsx { "id": "your_external_user_id_001", "password": { "salt": null, "salt_format": null, "salt_position": null, "hashed_password": "$2a$10$t8Jz3hJCCTFk/Acja7bw3OpamB3xuLPhpJlRHb31bXIjfzeTfn8rq", "hashing_algorithm": "bcrypt" }, "last_name": "One", "first_name": "User", "identities": [ { "type": "username", "identity": "userone" }, { "type": "email", "identity": "userone@example.com", "is_verified": true }, { "type": "oauth2:google", "profile": { "custom_provider_fields": "custom key/values from google" }, "identity": "123456", "provider": "google", "is_verified": true } ], "properties": [{ "key": "property_1", "value": "false" }], "feature_flags": [{ "key": "feature_flag_1", "value": "true" }], "organizations": [ { "external_id": "your_external_org_id_001", "roles": ["admin", "member"], "permissions": ["read", "write"], "scopes": [{ "audience": "https://your-api.com", "scope": "scope_1" }] } ] } ```

# Manage users - Add and edit - Send user invitations with webhooks

> Describes several methods for sending invitations to end users, including from one organization member to another.

users, user invitations, add users, invite users, welcome email

If you add users to your Kinde business manually or via API, you can send them a welcome or invitation email using a webhook. ## Use webhooks to send an invitation or welcome email 1. Go to **Settings > Webhooks** and select **Add webhook**. 2. Fill in the name and details, and select an endpoint for receiving the hook. This might be in your product. 3. Choose the `user.created` event trigger. 4. Select **Save**. ## Prepare to receive the webhook - Set up the email template you want to send via the webhook. The email should be sent from your email server and contain a link to the sign-in screen. - Verify the webhook signature before processing to ensure the request is authentic. - Respond with a 2xx quickly after queuing work; use retries and make processing idempotent (e.g., de-duplicate by event ID). - Filter the webhook payload to determine whether the user was created manually or via API. The `source` field is `admin` or `api`. Treat these differently if needed. Payload example: ```json { "type": "user.created", "id": "evt_123", "data": { "user_id": "usr_abc", "email": "new.user@example.com", "source": "admin" } } ``` ## Test the webhook 1. Add a fake user to an organization either manually or via the Kinde Management API using an email address you can access. 2. Check that the hook works and the email is sent. 3. When the user goes to sign in for the first time with the same email address, they should automatically be synced by Kinde with the invited profile.

# Manage users - Add and edit - Troubleshoot user import errors

> Guide to troubleshooting user import errors in Kinde including common validation issues, error messages, and solutions for bulk user import problems.

import errors, troubleshooting, duplicate records, invalid email, missing information, organization errors, role errors, permission errors, password errors, csv validation
manage-users, add-and-edit

When you import users in bulk from a file, Kinde checks to see if there are errors that will prevent a new user record from being created or updated. Common errors include: - Duplicate records (based on the ID or email) - Invalid email - Missing or invalid information - An organization, role, or permission does not exist in Kinde. You can view the error log immediately after you import to review any errors. ## To view errors After the import, you have the option to view the error list. This will tell you which items are in error. 1. In the file, find the error and correct it. 2. Re-import the file. 3. If you cannot correct an error, you may want to [add the user manually](/manage-users/add-and-edit/add-and-edit-users/), which will trigger a password reset the next time they sign in. If you find any errors you cannot resolve, [contact our support team](mailto:support@kinde.com). ## Fixing errors The best appraoch is to fix errors in the file and then [import the users](/manage-users/add-and-edit/import-users-in-bulk/) again. For JSON format imports, we recommend using a JSON validator tool to check for errors. - You can re-import as many times as you need to. - You don’t need to delete records that have already been imported. - Kinde ignores any information that exists already, unless you made any changes to it. ### Password errors When importing JSON passwords, Kinde will look for a user matching the ID or email address in the user details file. We will let you know if a match is not found, if the hashing algorithm is not supported, or related columns are incorrect. User’s whose passwords cannot be imported will be prompted to reset their password once you switch on the connection. ### Bad data from previous provider If there are a lot of errors, you may need to go back to your old auth provider to get a new file. ### Importing users with organization IDs, roles, or permissions Organizations, roles, and permissions need to exist in Kinde before you bring these details in as part of a user import. If an organization match is not found in Kinde, the user will be added to the default organization. To correct this, you may need to [add them to others manually,](/manage-users/about/manage-users-across-organizations/) or re-import. Similarly, if the role or permission key does not exist in Kinde _exactly_ the way you referenced in the CSV, then the user might not be assigned the role or permission.

# Manage users - Roles and permissions - Apply roles and permissions to users

> Guide to applying roles and permissions to users in Kinde including manual assignment, bulk operations, and organization-specific role management.

apply roles, apply permissions, user assignment, organization roles, multi-organization, role management, permission management, bulk assignment, access control
manage-users, roles-and-permissions

Roles and permissions are defined at the business level, but set at the level of an **Organization**. So if you have users who belong to multiple organizations, you’ll need to set their roles and permissions separately. <Aside> Users must belong to an organization before you can assign them roles or permissions. </Aside> You can add and remove roles and permissions for users in an organization. If you can’t find a role or permission, you may need to add it. See [Define user permissions](/manage-users/roles-and-permissions/user-permissions/) and [Define user roles](/manage-users/roles-and-permissions/user-roles/). You can also assign roles and permissions to users by [updating their profiles in bulk](/manage-users/add-and-edit/import-users-in-bulk/). ## **Apply and edit roles and permissions** <Aside type="warning"> Roles and permissions cannot be assigned to a user unless they belong to an organization. </Aside> 1. Go to **Users** and click on the user you want to edit to view their details. 2. To add or edit roles: 1. Select **Roles**. 2. If the user belongs to multiple organizations, select one from the dropdown menu. The list of roles for the organization is listed. 3. Use the switches next to each role to turn them on and off for the user. 4. Select **Save**. 5. Repeat from step b for each organization they belong to. 3. To add or edit permissions: 1. Select **Permissions**. 2. If the user belongs to multiple organizations, select one from the dropdown menu. The list of available permissions is listed. 3. Use the switches next to each permission to turn them on and off for the user. 4. Select **Save**. 5. Repeat from step b for each organization they belong to. 4. Repeat for each user who’s permissions you want to change.

# Manage users - Roles and permissions - Set default user roles

> Guide to setting default user roles in Kinde including automatic role assignment for new users and organization-specific default configurations.

default roles, new user signup, automatic assignment, organization roles, scale plan, advanced features, role creation, access control, user onboarding

When users first sign up to your app or service, you can automatically assign them roles and permissions. This means users are able to interact with your application immediately - in the way you define - without waiting for additional access. For example, you might assign everyone a role for basic access permissions, and assign more advanced functions on request. You can also set up default roles in organizations if you are on the Kinde [Scale plan](https://kinde.com/pricing/). This topic covers default roles for applications and for organizations. [permissions](/manage-users/roles-and-permissions/user-permissions/) [roles](/manage-users/roles-and-permissions/user-roles/) ## Create a new role and enable it as default 1. Go to **Settings** > **Roles**. If you already have roles set up, these are shown here. 2. Select **Add role**. The **Add role** window opens. ![Addrole window in Kinde](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/7030c2ab-6b59-4e99-b5d1-5f4d0c204700/public) 3. Give the role a **Name**. Keep it short and descriptive, so you can easily understand what it is for. For example, ‘Basic access’. 4. Enter a **Description**. Describe what a user with this role can do. For example ‘Allows anyone assigned this role basic system access.’ 5. Enter a **Key**. The key is how your code references the role in Kinde. Ideally, it’s a word that is easy to reference in code and match in your product. You should also follow a naming convention to help maintain your code. E.g. `basic-system-access`. 6. Select the **Assign to new users** option. 7. Select the permissions that are included in the role by switching them on. 8. Select **Save**. All new users who sign up to your application will be assigned this role. 9. If you want to make this a default role in an organization, see the procedure below. ## Make an existing role a default role This procedure assumes you have roles and permissions set up already. 1. Go to **Settings > User management > Roles**. 2. Find the role you want to make default, select the three dots menu then **Edit role**. 3. In the dialog that opens, switch on the **Assign to new users** option. 4. Select **Save**. ## Enable default roles in an organization This procedure assumes you have roles and permissions set up already, that you are on a [Scale](https://kinde.com/pricing/) plan, and have activated the [advanced features](/authenticate/custom-configurations/advanced-organization/) for the target organization. 1. Go to **Organizations** and view the details of the organization you want to edit. 2. Select **Policies**. 3. In the **Default roles** section, switch on the roles you want to be assigned by default when users join the organization. ![Default roles in org screen shot](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/6fc3e960-8bfe-427e-1e34-051b515aa600/public) 4. Select **Save**.

# Manage users - Roles and permissions - Define user permissions

> Guide to defining user permissions in Kinde including permission creation, management, and integration with roles for granular access control.

user permissions, permission management, access control, permission keys, naming conventions, role grouping, dynamic permissions, token refresh, permission deletion
manage-users, roles-and-permissions

It’s easy to manage and control user access with permissions. Once you set up permissions, they can be grouped into [roles](/manage-users/roles-and-permissions/user-roles/), to make assigning them managing access easier. ## **First time creating permissions?** For each permission you create on Kinde, you need to assign a unique ‘key’ that your product code will reference to apply the permission. We suggest you create permissions first, and then if you want, create roles to group sets of permissions to apply to users. ## **Add a new user permission** 1. Go to **Settings** **> User Management >** **Permissions**. If you already have permissions added, you’ll see a list of them. 2. Select **Add permission**. 3. Give the permission a **Name**. Keep it short and descriptive, so you can easily understand what it is for. For example, ‘View financial reports’. 4. Enter a **Description**. Provide additional context to help users understand this permission and the effect it will have. For example ‘Allows users to view, but not update, financial reports for the business.’ 5. Enter a **Key**. The key is how your code references the permission in Kinde. It should be a word that is easy to reference in code and match in your product. For example `read-reports`. It’s a good idea to follow a naming convention pattern to help maintain your code. Here’s what it might look like: `[action_type]:[functional_area]` e.g `read:reports` 6. Select if you want this permission to be automatically added when a new role is created. You might do this for example, if the permission is something all users need to be allowed to do. 7. Select **Save**. ## **Edit permission** User permissions are dynamic and refreshed via the issued token. This means that any changes you make will be applied to users, the next time they sign in. We don’t recommend editing permission keys, once a permission is in use. It will break the code link between your product and the defined permission. 1. Go to **Settings** **> User Management > Permissions**. If you already have permissions, you’ll see a list of them. 2. Select the three dots next to the permission you want to edit and choose **Edit permission**. 3. Make the changes you want and select **Save**. ## Delete user permissions When you delete a permission, you remove the permission access from all users who are assigned that permission, and from all users who have that permission as part of a role. This can’t be reversed. 1. Go to **Settings > User Management > Permissions**. Your list of permissions is shown. 2. Select the three dots next to the permission and choose **Delete**. A confirmation / warning message appears. 3. Select **Delete permission**. The permission is permanently deleted.

# Manage users - Roles and permissions - Manage user roles

> Comprehensive guide to managing user roles in Kinde including role creation, editing, deletion, API integration, and token customization for access control.

user roles, role management, permissions, access control, organization roles, role keys, default roles, token claims, api management, role assignment
manage-users, roles-and-permissions

Roles allow you to group [permissions](/manage-users/roles-and-permissions/user-permissions/) into buckets. A role in Kinde could represent a collection of permissions available to an `owner`, an `administrator`, a `member` or whatever role structure is relevant to your business. This topic covers how to manage roles in the Kinde platform and [via the Kinde Management API](/kinde-apis/management#tag/roles). ## Important things to know about Kinde roles - User roles are defined at the business level, but applied to users at an [organization](/build/organizations/orgs-for-developers/) level - A user can have multiple roles per organization - The same user can have [different roles in different organizations](/manage-users/about/manage-users-across-organizations/). They could have the `admin` and `owner` role in Org A and a `member` role in Org B - We recommend you use permissions for controlling access to features within your application, then use roles to group the permissions. - Roles (and permissions) cannot be assigned to a user unless they belong to an organization. <Aside> Tip: [Set default roles when a user signs up to an organization](/manage-users/roles-and-permissions/default-user-roles/) </Aside> ## Add user roles in Kinde 1. In Kinde, go to **Settings > User Management > Roles**. The **User roles** page opens showing any user roles already defined. 2. Select **Add role**. The **Add role** window opens. 3. Give the role a **Name**. Keep it short and descriptive, so you can easily understand what it is for. For example, ‘Accounts management’. 4. Enter a **Description**. Describe what a user with this role can do. For example ‘Allows users to perform all basic accounts functions.’ 5. Enter a **Key**. The key is how your code references the role in Kinde. It should be a word that is easy to reference in code and match in your product. You should also follow a naming convention for all roles to help maintain your code. 6. Select if the role should be assigned to all new users by default when they sign up. 7. Select the permissions that are included in the role by switching them on. See also [Define user permissions](/manage-users/roles-and-permissions/user-permissions/). 8. Select **Save**. ## **Edit user roles** You can [update user roles via the Kinde Management API](/kinde-apis/management#tag/roles/patch/api/v1/roles/{role_id}) or using the procedure below. User roles are dynamic and refreshed via the issued token. This means that any changes you make will be applied to all users assigned that role, the next time they sign in. We don’t recommend editing role keys, once a role is in use. It will break the code link between your product and the defined role. 1. Go to **Settings > User Management > Roles**. If you already have roles, you’ll see a list of them. 2. Select the three dots next to the role you want to edit and choose **Edit**. 3. Make the changes you want and select **Save**. ## Delete user roles You can [delete user roles via the Kinde Management API](/kinde-apis/management#tag/roles/delete/api/v1/roles/{role_id}) or using the procedure below. When you delete a user role, you will remove the role as well as all the associated permissions from all users who are assigned that role. This can’t be reversed. 1. Go to **Settings > User Management > Roles**. Your list of roles is shown. 2. Select the three dots next to the role and choose **Delete**. A confirmation / warning message appears. 3. Select **Delete role**. The role is deleted permanently. ## **Add user roles via API** You can add user roles via the Kinde API. Use the [Add Organization User Role](/kinde-apis/management#tag/organizations/post/api/v1/organizations/{org_code}/users/{user_id}/roles) end point to assign a role to a user, and get the role IDs from the [Roles](/kinde-apis/management#tag/roles) endpoint. ## Add roles to the access token When a user authorizes against an organization in Kinde, you can enable their roles to be returned as an array of IDs in the `roles` claim of the `access_token`. This is part of an additional claim. ### To add roles to tokens 1. Go to **Settings > Applications > [Your application] > Tokens**. 2. Scroll to the **Token Customization** section. 3. Select **Customize** on the **Access tokens** card. 4. Switch on **Roles (array**) in the **Additional claims** section. Our SDKs commonly ship with a `getClaim` method to help with this. For example in React you could use something like: ```jsx getClaim("roles"); // {name: "roles", value: ["admin", "owner"]} ``` ## Other role-related functions in the Kinde Management API - [View a list of roles](/kinde-apis/management#tag/roles/get/api/v1/roles) - [View a list of permissions for a role](/kinde-apis/management#tag/roles/get/api/v1/roles/{role_id}/permissions) - [Edit permissions for a role](/kinde-apis/management#tag/roles/patch/api/v1/roles/{role_id}/permissions) - [Remove permissions from a role](/kinde-apis/management#tag/roles/delete/api/v1/roles/{role_id}/permissions/{permission_id})

# Manage users - View activity - Track user sign-in with Hotjar

> Guide to integrating Hotjar with Kinde for tracking user sign-in events and user behavior analytics.

hotjar, user tracking, behavior analytics, user insights, privacy, security, site id, authentication flow, session recording

If you use Hotjar to track user behaviour on your site, you can now add it to Kinde. <Aside> You need your own [Hotjar](https://www.hotjar.com/) account to use this feature. </Aside> Hotjar is a tool for recording and tracking user behavior. It is designed to give you insights about how users interact with your site or app. ## Privacy and security with Hotjar Kinde adds Hotjar’s tracking script to the initial sign up and sign in screens. We do not add it to any screens that include sensitive data entry such as password / OTP entry or MFA details. In Hotjar recordings, you’ll see the user redirecting to Kinde and select an authentication option. The rest of the auth flow will not be captured. Hotjar then stitches together the session by recording your application, and gives you a single recording with the sensitive parts of the auth flow omitted. ## Add your Hotjar credentials in Kinde 1. Go to **Settings > Environment > Details**. 2. Scroll down to the **Tracking** section. 3. Add your **Hotjar Site ID**. 4. Select **Save**. You can now track user interactions with Hotjar. <Aside> Note that Kinde does not allow Hotjar to record a user’s personal auth details, such as passwords. </Aside>

# Manage users - View activity - Track user sign-in with Google Analytics

> Guide to integrating Google Analytics with Kinde for tracking user sign-in events and authentication analytics.

google analytics, user tracking, sign in events, g-code, ua-code, measurement id, tracking id, google tag manager, security principles
manage-users, view-activity

If you use Google Analytics to track activity on your app or website, you can now add these in Kinde to track user sign in events. No activity in Kinde is tracked, but you will be able to see where a user’s journey ended in signing in or signing up via our platform. ## **Set up Google Analytics in Kinde** 1. In Kinde, go to **Settings > Environment > Details**. 2. Scroll to the **Tracking** section and enter your G- or UA- code in the **Google Analytics** field. 3. Select **Save**. ## **Find your Google codes** ### **G- code** Sign in to your GA account, select **Admin** and then **Data Streams**. Select the data stream you want. The G-Code appears under the **Measurement ID** field. ### **UA- code** If you use Universal Analytics (UA) for a website, sign in to your GA account and select **Admin**. Locate the **Property** you have set up for UA. The UA- code can be found in the **Tracking ID** field. ## **Google tag manager** We know some people really wanted us to add functionality for Google Tag Manager, but we looked into it and there’s a security concern that could introduce a vulnerability that contravenes our [guiding security principles](/trust-center/security/security-at-kinde/).

# Manage users - View activity - View audit log

> Guide to viewing audit logs in Kinde including system-wide activity monitoring, filtering options, and detailed activity tracking.

audit log, user activity log, activity tracking, authentication events, access tokens, policy acceptance, event details, ip address, location tracking, environment specific
manage-users, view-activity

You can keep track of user activity and actions through the Kinde Audit log. You can also view individual user activity in their user profile. Audit logs are environment-specific, so you’ll need to choose your environment first to view the relevant logs. ### To view the Audit log Open an environment, then go to **Settings > Audit log**. ## Events logged Kinde currently records the following events. If you need us to track other events, [let us know](https://kinde-21631392.hs-sites.com/en-au/feature-request). - Self-serve sign up events - Authentication events - Access tokens granted - Acceptance of policies ## Event details When an event is logged, the following details are captured. - User - Email - User ID - Organizations - Date and time of event - Event details - IP address - Application - Location

# Manage users - View activity - Audit log

> Guide to viewing individual user activity logs including activity history, sign-in methods, and detailed activity monitoring in Kinde.

audit log, user activity, activity history, sign in methods, sign in activity, user monitoring, activity logs, user details
manage-users, view-activity

You can view activities for individual end users in their user profile. To get a view of activities across organizations and users, [view the audit log](/manage-users/view-activity/view-audit-log/). ## Check the user activity log 1. Go to **Users** and click on the user name to view their details. 2. In the left menu, select **Activity**. A summary of the user’s activity shows at the top of the page. 3. Check the **Logs** list to see a full activity history. 4. To view an activity in detail, select the three dots next to the activity and select **View details**. A panel slides out showing full details of the activity. ## View sign-in methods and sign-in activity 1. Go to **Users** and click on the user name to view their details. 2. On their **Profile** page, scroll to the **Identities** section. You can see: - the email or identity method they used to sign in - how many times they have signed in with each method - when they last signed in with the method

# Manage your account - Business information - Change the Owner of your Kinde business

> Find out how to change the Owner of a business in Kinde.

business owner, team member, roles
manage-your-account, business-information

A business Owner in Kinde has full power in the business, including setting any role for any member, and being able to assign the role of 'Owner' to others. You might need to change the owner of a business to reflect a new org structure or when someone leaves. [Read more about the roles in a Kinde business and how to assign them to members](/get-started/team-and-account/add-team-members/). There can be multiple Owners in a business. ## Promote a team member to Owner or demote a team member from Owner You need to be a current Owner to perform this procedure. 1. On the Kinde home page, select the avatar menu on the bottom left, and then select **Team members**. A list of your current team is shown. 2. Select the three dots next to the team member who's role you want to change. 3. In the menu that appears, select **Edit roles**. 4. Using the toggles, change the roles they will have in the business to include or exclude Owner. 5. Select **Save**. The team member's role has been changed. ## Delete an Owner from a business If an owner moves on or is replaced, you can [delete them from the business](/get-started/team-and-account/add-team-members/). First, make sure you have another Owner in place. Only an Owner can delete another Owner.

# Manage your account - Business information - Your business data region and timezone

> Guide to checking data regions and changing business timezone settings in Kinde for proper date display in logs and user history.

data region, timezone, business settings, audit logs, user history, date display, business profile, regional settings
manage-your-account, business-information

## Check the data region of your business 1. On the Kinde home page at the top of the window, select the dropdown next to your business name. 2. Select **Switch business**. Your business data region is shown on the relevant tile representing your business. ## Change your business timezone If you want, you can change the timezone that is used in your Kinde business account. The time zone that you select is reflected in areas that show dates, such as user history, audit logs, etc. 1. Go to **Settings > Business > Profile**. 2. In the **Time zone** field, make a selection. 3. At the bottom of the page, select **Save**.

# Manage your account - Business information - Add and update policies and terms

> Guide to adding and updating privacy policies and terms of use URLs in Kinde for user agreement and legal compliance.

policies, terms of use, privacy policy, business settings, user agreement, legal compliance, policy urls, business details
manage-your-account, business-information

When your users sign up or sign in to your business via the Kinde platform, they implicitly agree to your Privacy policy and Terms of use (or licence terms). You can add and update these so they apply across your business. 1. In Kinde, go to **Settings > Business > Details**. 2. Scroll to the **Terms of use and privacy** section. 3. Enter the relevant URLs for each policy and select **Save**.

# Manage your account - Business information - Update your business details

> Guide to updating business details in Kinde including sign-in name changes, email management, and business information updates.

business details, sign in name, email change, team invitation, owner role, business name, business url, account management
manage-your-account, business-information

You can change some business details in Kinde, but you may need to contact support for help with other changes. ## Change your sign in name 1. On the Kinde home page, select the avatar menu at the bottom left. 2. In the menu that opens, select **Account**. 3. Make the changes you want and select **Save**. ## Change the email you sign in to Kinde with You cannot edit the email you sign in to Kinde with, but you can invite a new team member (new email) to join you on Kinde and make them an Owner in the business. 1. Send a [team invitation](/get-started/team-and-account/add-team-members/) to the new email address. 2. Accept the invitation to join Kinde. 3. (If applicable) Contact support@kinde.com (from the original Owner email) and request that the new team member be promoted to the role of Owner. 4. (If applicable) Once that is done, you can request via support@kinde.com that the original Owner (Old email) be deleted from your business. Owners cannot delete other Owners. ## Change business details 1. On the Kinde home page, select the avatar menu at the bottom left. 2. In the menu that opens, select **Business settings**. 3. Select **Business Details**. You can only change your business name, this will not impact your kinde business URL that was already created. 4. Select **Save**.

# Manage your account - Profile and plan - Changing your Kinde plan

> Comprehensive guide to changing Kinde plans including upgrade/downgrade processes, billing details, refund policies, and custom plan options.

plan change, plan upgrade, plan downgrade, subscription charges, metered usage, unit costs, stripe payment, custom invoicing, refunds, plan cancellation
manage-your-account, profile-and-plan

Kinde offers multiple plans, including a free plan. When you decide to upgrade to a higher plan, charges apply, including: - a base subscription price - metered usage charges (e.g. for MAU) - unit costs for expanding feature capacity (e.g. for adding more environments) - other recurring costs You can upgrade or downgrade plans at any time. ## How plan charges work When you buy a plan or upgrade, you will be immediately charged the base subscription price for the month ahead. On the following invoice (after the first monthly billing cycle), you will be charged for any metered and unit costs for the previous month, plus the monthly base subscription price for the next month. We currently accept credit cards as a means of payment, and use Stripe to process and secure transactions. Custom invoicing arrangements (e.g. by bank transfer, annual, currency) are available to enterprise customers. ## How to change your plan You’ll see multiple upgrade prompts throughout the Kinde interface, with a button for upgrading and choosing a plan. Click any of these prompts and you will be shown the plan selector and guided through the sign-up process. Or you can do the following: 1. On the Kinde home page, select the avatar menu at the bottom left, and then select **Business settings**. 2. In the window that opens, select **Plan**. 3. At the top of the window, select **Change plan**. The plan selector opens. 4. Select the plan you want to change to. - If you upgrade, you will be immediately charged the full subscription price. Upgrade features are available immediately. - If you downgrade, you can still use Kinde until the end of your billing period. Remember to [export your data](https://docs.kinde.com/manage-your-account/your-data/exporting-data/) You’ll be asked to confirm credit card details each time you upgrade, even if it’s from a paid plan to a paid plan. ## Refunds for downgrade If you downgrade, we can partially refund the monthly base subscription price for unused days. You will still need to pay for anything metered that you use. ## Cancelling your Kinde plan We don't have self-serve for cancelling plans, but you can downgrade to the free plan to avoid further charges, then also delete your business if you want. We want your experience at Kinde to be great, even if you decide to leave us. You can be assured that we will err on the side of crediting back any costs that you should not be charged for. To discuss any concerns, contact support@kinde.com and we will sort it out. ## Speak to an advisor about a custom plan We know some businesses are more complex than others. If you feel you have special requirements or would like to discuss how we can better support your business growth, contact us at support@kinde.com and we’ll make an appointment to chat.

# Manage your account - Profile and plan - Update billing details for your Kinde account

> Guide to updating billing details for Kinde accounts including invoice email changes and business address updates via support requests.

billing details, invoice email, business address, tax purposes, owner contact, support request, self service, billing contact
manage-your-account, profile-and-plan

When you first set up a Kinde business, the **Owner** becomes the primary contact for billing and your account. You need to contact support@kinde.com to request: - A change the invoice email address - Updates to business details, such as address for tax purposes, etc. We do plan to enable more self-service in this area, but for now we can only change these details on request.

# Manage your account - Profile and plan - Add or update payment details

> Guide to managing payment details in Kinde including adding, updating, and removing payment methods for subscription billing.

payment details, credit card, payment method, default payment, subscription billing, monthly billing, payment management, billing cycle
manage-your-account, profile-and-plan

Kinde’s approach to charging subscription fees is to deduct a payment for paid plans on the monthly anniversary of your sign up, calculated in arrears. So if you signed up on 1 December, your first bill will be issued on 1 January, for usage in December. Use the procedures below to keep your credit card details up to date. ## Add new payment method 1. On the Kinde home page, select the avatar menu at the bottom left and then select **Business Settings**. 2. In the window that opens, select **Payment details**. If you have already entered payment details, they will appear here. 3. Select **Add payment method**. 4. In the window that appears, add your credit card details and follow the prompts to save. ## Change default payment method 1. Add the new payment details as per the above procedure. 2. Select the three dots on the card showing the new details, and select **Set as default**. ## Remove a payment method If you are on a paid plan, add a new payment method before removing the old method. 1. On the Kinde home page, select the avatar menu at the bottom left and then select **Business Settings**. 2. In the window that opens, select **Payment details**. All your payment methods are shown in this section. 3. Select the three dots on the payment method you want to remove, select **Remove**. 4. In the message that appears, confirm that you want to remove the payment method.

# Manage your account - Profile and plan - View your Kinde plan

> Guide to viewing your Kinde plan including subscription details, feature limits, billing information, and plan management options.

kinde plan, subscription details, monthly active users, monthly active organizations, enterprise connections, machine to machine tokens, environments, billing history, plan features, plan limits
manage-your-account, profile-and-plan

Whether you pay us to use Kinde or not, your Kinde account is linked to a plan. A plan describes what features and limits apply to your Kinde account. You'll have [selected a plan](https://kinde.com/pricing/) when you first signed up with us. ## Plan options We’ve made it so our free plan includes a lot, so you can run your business for free if you want. But you will see prompts throughout the Kinde admin area, indicating which features can be extended, included, or made unlimited, by upgrading. You can also view [full plan details and comparisons](https://kinde.com/pricing/) on our website. ## To view your plan 1. On the Kinde home page, select the avatar menu at the bottom left and then select **Business Settings**. 2. In the window that opens, select **Plan**. ## Subscription details - **Current estimated total** - An estimate of the month to date amount due on your plan - **Plan type and base price** - the base price is $0.00 for Free plans and $X USD for paid plans - **Monthly active users (MAU)** - Included in your plan and the additional metered price - **Monthly active organizations (MAO)** - Included in your plan, and the additional unit price - **Enterprise connections** - Included in your plan, and additional unit price - **Machine to machine tokens** - Included in your plan, and additional metered price - **Environments** - Included in your plan, and the additional unit price - **Payment details** - You add these when you upgrade - **Billing history** - only shown for paid plan users after the first billing cycle is complete. ## Plan upgrade and downgrade See [Change your Kinde plan](/manage-your-account/profile-and-plan/change-kinde-plan/).

# Manage your account - Your data - Check your MAU and MAO

> Guide to checking MAU and MAO metrics in Kinde including calculation methods, billing period tracking, and business growth indicators.

mau, monthly active users, mao, monthly active organizations, billing period, access tokens, b2b metrics, business growth, plan limits, subscription tracking
manage-your-account, your-data

The number of monthly active users (MAU) you have is a common metric for predicting recurring revenue and tracking business growth. If you have business customers, the number of monthly active organizations (MAO) is another important indicator of how your business is going. Higher MAU and MAO means more customers. ## **How MAU is calculated** Kinde counts one MAU for every user who is ‘active’ during a billing period. Active means they have been issued at least one access token. One MAU is counted regardless of how many times the same user signs in. If a user is created and then deleted before signing in, they are not counted in MAU. However, if a user signs in during a billing period and they are deleted within the same period, they are still counted in MAU. ## How MAO is calculated If you are a B2B company, your business customers will be managed in Kinde as an organization. For MAO calculations, Kinde considers an organization is 'active' if there are at least 2 users, and at least one of those users is active (i.e they sign in to the organization) during a billing period. If an organization is created and deleted in the same monthly billing period, it will only be counted as MAO if the above conditions are met. ## To check your MAU and MAO 1. On the Kinde home page, select the avatar menu at the bottom left and then select **Business Settings**. 2. Select *Plan** in the side menu. 2. In the main **Subscription** area of the window, view your MAU and MAO. If you’re on a free plan, you’ll be able to see when you’re approaching or exceeding free plan limits. If you’re on a paid plan, you’ll be able to see how costs are tracking in your current bill cycle. For full details of inclusions and pricing, see [Kinde plan details](https://kinde.com/pricing/).

# Manage your account - Your data - Closing your account

> Information about closing your Kinde account and business deletion process through support contact.

account closure, business deletion, support contact, account termination, customer feedback
manage-your-account, your-data

If you want to delete your Kinde business and close your Kinde account, email us at [support@kinde.com](mailto:support@kinde.com) and we’ll help you out. We’re always sad to see great customers like you leave, so feel free to give us any feedback along with the closure request.

# Manage your account - Your data - Delete your Kinde business

> Guide to deleting a Kinde business including irreversible consequences, data export requirements, and domain management considerations.

delete business, business deletion, nuclear action, data destruction, domain reuse, custom domain, data export, team access, paid plans, support contact
manage-your-account, your-data

Deleting a business in Kinde is a nuclear action that cannot be reversed. Only a business owner can delete the business. ## IMPORTANT: Read this document before you delete ### When you delete a business - The domain associated with the business can't be used again (unless freed up by Kinde) - All environments, applications, organizations, users, and stored data is destroyed - Owner, admin, and team member access to the business is removed - Any connections and integrations you set up will break Once you delete a business, the action cannot be reversed. <Aside type="warning"> Do not delete the business if you want to re-use the Kinde domain issued to the business. Instead, consider using a [custom domain](/build/domains/pointing-your-domain/). </Aside> ### Before you delete a business - Make sure you [export your data](/manage-your-account/your-data/exporting-data/) before you delete - Remove any custom domain you have set up - Let team members know they will no longer be able to access the business ## Delete your business <Aside type="warning"> Only owners of businesses on a free plan can self-serve delete. All businesses on paid plans need to contact Kinde support. </Aside> 1. Sign in to the business you want to delete. 2. Go to **Settings > Business > Details**. 3. Scroll to the the **Admin functions** section and select **Delete business**. 4. Confirm the action in the dialog by selecting **Delete business**. The business is deleted and can no longer be accessed. ## Other information Team members who have access to multiple businesses can still access those businesses. If you have other Kinde businesses, the data in those businesses will not be affected. If you want to re-use the domain of the business you delete, you need to contact support@kinde.com to make this possible.

# Manage your account - Your data - Export your data

> Comprehensive guide to exporting Kinde data including secure password export processes, encryption/decryption, and data format specifications.

data export, password export, owner approval, encryption, decryption, openssl, ndjson format, security process, data protection, export approval
manage-your-account, your-data

We know it’s really important that you can easily get your data out of Kinde when you need to. It’s equally important that your data - especially password data - is safe and cannot be easily accessed. **Important note**: For security reasons, only team members who are **Owners** can export data. You can download most of your Kinde data in a few steps, but if the export includes user passwords, this triggers an owner approval process to ensure that only authorized people can access them. See the fairly long but secure process outlined below. Big disclaimer of course: Once you have downloaded your data, you are entirely responsible for protecting it. ## Initiate a data export 1. Go to **Settings > Business > Details** to the **Business Information** page in Kinde. 2. In the **Export data** section, select **Export**. Note, this section is only visible if you are an **Owner**. 3. In the window that appears, select one of the export options. 4. If you select **All data (except passwords)**: 1. Select **Next**. You will be sent an email with a confirmation code. 2. Enter the code and select **Next**. The download file is generated. 3. Download the file. Note that this is the only opportunity to download. To get the file again, you need to go back to step 2. 5. If you select **All data**: 1. Select **Next**. A request is sent to all business owners to approve the export. 2. Read about the process below. ## The export and approval process (when passwords are included) There are a number of checks and validations done to enable password export. Unfortunately there is no way to avoid this being long and somewhat notification-heavy, as the aim is to prevent unauthorized access to passwords and other data. <Aside> If a business has a sole owner, this might seem like a more complex process than it needs to be. But we implemented this process to maximize security. At some stage in future we may optimize it for the solo owner experience, but for now, this applies to all businesses. </Aside> Here’s how it works: 1. An owner initiates a data export (including passwords) in Kinde. See above. 2. All Kinde owners are notified by email of the export request (including any additional owners). They then have 24 hours to review it and ensure that it is a legitimate request. Note that this email is still sent if there is only one owner. 3. If the request seems suspect, any owner can reject it immediately: 1. Select **Review** in the email to open the request in Kinde. 2. Select **Reject** in the far column of the data export table. This ends the export process. 4. If the request is fine to approve, the notified owners have to wait 24 hours from the initial request for a new email which will allow them to approve the request in Kinde. 5. The request can be approved by whichever notified owner responds first: 1. Select **View** in the email. 2. Select **Approve** in the right column of the data export table. 3. Enter a one-time code to verify your identity and complete the approval. 6. Approval triggers an email to the original requestor, who receives instructions on how to download the data. To download: 1. In the email, select **Download**. This opens Kinde. 2. Select the **Download** button in the export area. A confirmation window opens. 3. Enter the one-time verification code sent to your email and select **Next**. The data starts to be prepared. 4. After the data is generated, a window appears showing an encrypted .dat file for download, as well as a **Key** and an **Initialization Vector** for decrypting the file. 5. Copy the **Key** and the **Initialization Vector** somewhere you can access it again later. 6. Download the file. Note that this is the only opportunity to download. To get the file again, you need to request the data export again. 7. An email is sent to the owner, advising them you have downloaded the data. 8. Next, decrypt the downloaded file (see below). We know this is a long process, especially since you are likely both the requestor and the owner, but we have made password security a top priority. ## Decrypt your data export file To decrypt the .dat file, you need to run a decryption command. You can use a tool like OpenSSL or a native command prompt. 1. Open a command prompt window. 2. Paste the following command. `openssl aes-256-ctr -d -e -in /path/to/kinde_export.dat -out /path/to/kinde_export.zip -nosalt -p -K YOUR_ENCRYPTION_KEY -iv YOUR_ENCRYPTION_IV` 3. Replace `YOUR_ENCRYPTION_KEY` with the **Key** you copied above. 4. Replace `YOUR_ENCRYPTION_IV` with the **Initialization Vector** you copied above. 5. Replace the **-in** path with the .dat file location (e.g. `-in ~/Downloads/kinde_export.dat` ), and update the **-out** path to where you would like the decrypted zip file to be generated (e.g. `-out ~/Desktop/kinde_export.zip` ) Example of how the command might look: ```text openssl aes-256-ctr -d -e -in /Users/DriveName/Downloads/kinde_export.dat -out /Users/Drivename/Desktop/kinde_export.zip -nosalt -p -K 5f2xxxxxxx6b51ca282745852b0caxxxxxxxxxxxcd5832ecb97500956f3 -iv 4d4axxxxxxxxd2bd1994xxxxc698d3 ``` 6. Press **Enter**. The file decrypted kinde_export.zip file should appear in the specified -out location. ## Cancel a request At any time, the person who made the export request can cancel it by going to the **Business Information** page in Kinde and selecting **Cancel request**. This ends both the export and approval process. ## What the exported data looks like Data is exported in NDJSON format, with separate data files for users and organizations. Here’s an example of `users.ndjson`. ```json { "$schema": "http://json-schema.org/draft-07/schema#", "type": "object", "properties": { "id": { "type": "string", "description": "Unique identifier for the object" }, "email": { "type": ["string", "null"], "format": "email", "description": "Email address of the user" }, "phone": { "type": ["string", "null"], "description": "Phone number of the user, if available" }, "username": { "type": ["string", "null"], "description": "Username of the user, if available" }, "last_name": { "type": ["string", "null"], "description": "Last name of the user, if available" }, "created_on": { "type": "string", "format": "date-time", "description": "Timestamp when the user was created" }, "first_name": { "type": ["string", "null"], "description": "First name of the user, if available" }, "identities": { "type": "array", "items": { "type": "object", "properties": { "type": { "type": "string", "description": "Type of identity (e.g., email)" }, "identity": { "type": "string", "description": "Identity value (e.g., email address)" }, "provider": { "type": ["string", "null"], "description": "Provider associated with the identity, if any" } }, "required": ["type", "identity"] }, "description": "List of identities associated with the user" }, "external_id": { "type": ["string", "null"], "description": "External identifier for the user, if available" }, "business_code": { "type": "string", "description": "Code representing the associated business" }, "organizations": { "type": "array", "items": { "type": "string" }, "description": "List of organizations the user belongs to" }, "email_verified": { "type": "boolean", "description": "Indicates if the email address is verified" }, "password": { "type": "object", "properties": { "hashing_config": { "type": "object" }, "hashed_password": { "type": "string" }, "hashing_algorithm": { "type": ["string", "null"] } }, "required": ["hashing_config", "hashed_password"] } }, "required": ["id", "email", "created_on", "identities", "business_code", "organizations", "email_verified"], "additionalProperties": false } ``` Here's an example of `organizations.ndjson`. ```json { "$schema": "http://json-schema.org/draft-07/schema#", "type": "object", "properties": { "name": { "type": "string", "description": "Name of the organization" }, "created_on": { "type": "string", "format": "date-time", "description": "Timestamp when the organization was created" }, "business_code": { "type": "string", "description": "Code representing the associated business" }, "organization_code": { "type": "string", "description": "Code representing the organization" } }, "required": ["name", "created_on", "business_code", "organization_code"], "additionalProperties": false } ``` ## How passwords are exported As above, when passwords are exported, they appear as a hashed password, a hashing algorithm (e.g. bcrypt), and other hashing configuration details (e.g. salt and salt location). With this data you can authenticate against these credentials in another system using the same algorithm. Plain text passwords are never stored by Kinde for security purposes. ## Considerations if switching to another provider Kinde provides all your data in standard JSON files in a simple format. You will need to refer to the documentation of your new provider to establish what format the data needs to be in for importing. ## Data security Once your user data is exported and downloaded, it becomes your business’s responsibility to protect. When we export the file containing passwords, it is encrypted using AES-256-CTR. The file can only be decrypted if you have the unique Key and Initialization Vector (IV) provided during download. The encryption of the export file is designed to keep passwords secure during export, but once downloaded and decrypted, they become vulnerable.

# Manage your account - Your data - About your Kinde domain

> Guide to Kinde domains including domain allocation, custom domain usage, and domain management when deleting or recreating businesses.

kinde domain, custom domain, domain allocation, business deletion, domain reuse, scale plan, domain management, business registration
manage-your-account, your-data

When you sign up with Kinde, you also create a kinde domain, e.g. `yourbusiness.kinde.com`. Once in use, the Kinde domain is not available to anyone else. Even if you delete your business on Kinde, the domain remains allocated. We do not recommend deleting your business, if you want to keep the domain. ## Does the Kinde domain matter? Not really. Most founders and companies will use a [custom domain](/build/domains/pointing-your-domain/) to hide the "kinde" part. Even if you signed up with `testymctestface.kinde.com`, you can change your custom domain as many times as you like. If you're on a Kinde Scale plan, you can even have custom domains for orgs within your business. ## To change domains If you really want to change domains, you'll need to register a new business with the domain you want. Kinde cannot update the domain for your existing business. ## To start a new business but keep your domain It's pretty common for people to kick our tyres. So if you've been playing around on the Free plan and want to start fresh, you can [delete your business](/manage-your-account/your-data/delete-business/) in Kinde. Then to get the same domain back, you need to formally request that we make it free for you to use again. It's a bit of a process, so we ask you to give us at least a few days to sort it out. The business owner must make the request to free the domain by sending us an email to support@kinde.com, from the email they signed up with.

# Manage your apis - About api keys - API best practice for AI apps

> Tips for using API keys to securely integrate AI applications, including performance, and monitoring recommendations.

ai applications, api keys, ai integration, ai security
api-keys, key-types

Here's a selection of recommendations for using API keys to build AI apps. ## Security tips for AI apps - **Always verify API keys**: Never trust unverified API keys - **Validate trusted context**: Ensure AI operations are within user or organization boundaries - **Sanitize inputs**: Clean AI inputs to prevent injection attacks - **Validate outputs**: Check AI responses for harmful content - **Rate limiting**: Implement stricter limits for AI endpoints ## Performance tips for AI apps - **Cache AI responses**: Cache common AI responses to reduce latency - **Async processing**: Use async/await for AI operations - **Timeout handling**: Set reasonable timeouts for AI requests - **Resource monitoring**: Track AI resource usage per user or organization ## Monitoring tips for AI apps - **Usage tracking**: Monitor AI usage patterns per user or organization - **Performance metrics**: Track response times and success rates - **Error logging**: Log all AI-related errors with context - **Cost tracking**: Monitor AI costs per organization ## Integration tips for AI apps - **Clear boundaries**: Define clear limits for AI access - **Documentation**: Document AI capabilities and limitations - **Testing**: Test AI integration thoroughly - **Fallbacks**: Provide fallback options when AI is unavailable

# Manage your apis - About api keys - API key best practices

> Recommended security, performance, and monitoring practices for implementing API keys with Kinde.

api key best practices, security, performance, monitoring
api-keys, best-practices

Here's some tips to ensure you use API keys with security and performance in mind. ## Security - **Validate scopes**: always check that a key has the required scopes for the requested action. - **Cache verification results**: cache positive verification results briefly to reduce load and latency. - **Log verification attempts**: record verification attempts and outcomes for auditing. - **Rotate API keys**: rotate keys on a regular cadence and after suspected exposure. See (/manage-your-apis/add-manage-api-keys/rotate-api-keys/) - **Revoke keys**: promptly revoke keys that are no longer needed. See (/manage-your-apis/add-manage-api-keys/revoke-api-keys/) ## Performance - **Implement caching**: cache verification results for 5–10 minutes where appropriate. - **Use async verification**: avoid blocking request handlers while waiting on verification. ## Monitoring - **Track usage**: Monitor which keys are used most and when, in general and by specific customers. - **Set up alerts**: Alert on spikes in failed verification attempts and unusual patterns. - **Monitor performance**: Track verification latency and error rates over time.

# Manage your apis - About api keys - Using API keys for AI products

> Learn how to use API keys to securely integrate AI applications for both B2C (user-level) and B2B (organization-level) products while maintaining proper data isolation

ai applications, api keys, user level, organization level, ai integration, data isolation, ai security
api-keys, key-types

API keys are ideal for people building AI products. They allow developers to securely connect apps to third-party services (like OpenAI) and to manage access to AI models or data. For example, a SaaS app might use API keys to let users generate AI-powered content, analyze data, or automate workflows. API keys also provide secure authentication, usage tracking, and control over access, making it easier to safely expose AI capabilities to end-users without exposing underlying system credentials. This guide shows you how to implement secure AI integrations for both B2C (user-level) and B2B (organization-level) products while maintaining proper data isolation. ## Why use API keys for AI (B2C and B2B)? ### B2C (user-level) benefits - **Clear user context**: Every AI action is attributed to a specific user (`user_id`). - **Trusted verification**: The `user_id` in verification responses is verified and cannot be tampered with. - **Audit trail**: Attribute model actions, prompts, and results to a user. ### B2B (organization-level) benefits - **Clear organization context**: AI applications are associated with specific organizations (`org_code`). - **Trusted verification**: The `org_code` in verification responses is verified and cannot be tampered with. - **Audit trail**: Track which organization each AI operation affects. ### Use case examples (both) - **Customer AI assistants**: Respond using a user's or organization's data. - **AI-powered analytics**: Analyze personal or organization datasets. - **Automated workflows**: Perform tasks within user or organization boundaries. - **Intelligent integrations**: Connect to customer systems with the right context. ## Choose the right API key type - Use user-level API keys for B2C features, personal assistants, or per-user automations. - Use organization-level API keys for multi-tenant B2B features, shared datasets, or team automations. Learn more: user-level keys (/manage-your-apis/key-types/api-keys-for-users/), organization-level keys (/manage-your-apis/key-types/api-keys-for-organizations/) ## Setting up AI applications with API keys ### Step 1a: Create organization-level API keys (B2B) ```bash # Create an API key for each customer's AI integration curl -X POST https://your-domain.kinde.com/api/v1/api_keys \ -H "Authorization: Bearer YOUR_M2M_TOKEN" \ -H "Content-Type: application/json" \ -d '{ "name": "AI Assistant for Customer ABC", "api_id": "api_customer_data", "scope_ids": ["read:users", "read:analytics", "read:support"], "org_code": "org_customer_abc" }' ``` ### Step 1b: Create user-level API keys (B2C) ```bash # Create an API key for a user's personal AI assistant curl -X POST https://your-domain.kinde.com/api/v1/api_keys \ -H "Authorization: Bearer YOUR_M2M_TOKEN" \ -H "Content-Type: application/json" \ -d '{ "name": "Personal AI Assistant for Jane Doe", "api_id": "api_user_data", "scope_ids": ["read:profile", "read:history"], "user_id": "kp_1234567890" }' ``` ### Step 2: Configure your API scopes - Define scopes for your AI endpoints in your API settings. For example: - `read:ai_chats` - `write:ai_chat` - `read:ai_analytics` - `write:ai_analytics` - `read:ai_workflows` - Assign the appropriate `scope_ids` when creating keys (see step 1a/1b above). - Enforce scopes at runtime when handling requests: ```javascript // After verifying the API key const requiredScopes = ["read:ai_chats"]; // adjust per endpoint for (const scope of requiredScopes) { if (!verification.scopes.includes(scope)) { return res.status(403).json({error: `Insufficient scope: ${scope}`}); } } ``` Learn more: Scopes for API keys (/manage-your-apis/api-key-setup/scopes-for-api-keys/), Secure your API using scopes (/manage-your-apis/your-apis/custom-api-scopes/) ### Step 3: Implement AI logic with trusted context ```javascript class AIApplication { constructor(apiKey) { this.apiKey = apiKey; this.organization = null; // For org-level keys this.userId = null; // For user-level keys } async authenticate() { const verification = await this.verifyApiKey(); this.organization = verification.org_code || null; this.userId = verification.user_id || null; return verification; } async verifyApiKey() { const response = await fetch("https://your-domain.kinde.com/api/v1/api_keys/verify", { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ api_key: this.apiKey }) }); if (!response.ok) { throw new Error("API key verification failed"); } return response.json(); } async processAIRequest(prompt, context = {}) { // Ensure we have some trusted context if (!this.organization && !this.userId) { throw new Error("AI application not authenticated"); } // Add context (user or organization) to the prompt const enhancedPrompt = ` ContextOwner: ${this.organization ? `org:${this.organization}` : `user:${this.userId}`} Context: ${JSON.stringify(context)} User Request: ${prompt} `; // Process with AI provider const aiResponse = await this.callAIProvider(enhancedPrompt); return { response: aiResponse, organization: this.organization, user_id: this.userId, context }; } } ``` ## Common AI integration patterns ### AI support or help assistant (handles both) ```javascript app.post("/ai/support", async (req, res) => { try { const apiKey = extractApiKey(req); const verification = await verifyApiKey(apiKey); if (!verification.is_valid) { return res.status(401).json({error: "Invalid API key"}); } // Restrict data to either the user or organization context const contextOwner = verification.org_code ? {org: verification.org_code} : {user: verification.user_id}; if (!contextOwner.org && !contextOwner.user) { return res .status(403) .json({error: "Trusted context required (user-level or org-level API key)"}); } // Fetch only allowed data for that context const supportHistory = contextOwner.org ? await getOrgSupportHistory(contextOwner.org) : await getUserSupportHistory(contextOwner.user); const profile = contextOwner.org ? await getOrgProfile(contextOwner.org) : await getUserProfile(contextOwner.user); // Process AI request with context const aiResponse = await processSupportRequest( req.body.message, supportHistory, profile, contextOwner ); res.json({ response: aiResponse, organization: verification.org_code || null, user_id: verification.user_id || null, data_sources: ["support_history", "profile"] }); } catch (error) { console.error("AI support error:", error); res.status(500).json({error: "Internal server error"}); } }); ``` ### AI-powered analytics dashboard ```javascript app.get("/ai/analytics", async (req, res) => { try { const apiKey = extractApiKey(req); const verification = await verifyApiKey(apiKey); if (!verification.is_valid) { return res.status(401).json({error: "Invalid API key"}); } // If it's org-level, analyze org data; otherwise analyze per-user analytics const analyticsData = verification.org_code ? await getOrgAnalyticsData(verification.org_code) : await getUserAnalyticsData(verification.user_id); // Generate AI insights const insights = await generateAnalyticsInsights( analyticsData, verification.org_code || verification.user_id ); res.json({ insights, organization: verification.org_code || null, user_id: verification.user_id || null, data_summary: { total_records: analyticsData.length, date_range: analyticsData.dateRange } }); } catch (error) { console.error("AI analytics error:", error); res.status(500).json({error: "Internal server error"}); } }); ``` ### AI workflow automation ```javascript app.post("/ai/workflow", async (req, res) => { try { const apiKey = extractApiKey(req); const verification = await verifyApiKey(apiKey); if (!verification.is_valid) { return res.status(401).json({error: "Invalid API key"}); } // Execute within the allowed boundary (user or organization) const workflowData = verification.org_code ? await getOrgWorkflowData(verification.org_code) : await getUserWorkflowData(verification.user_id); const permissions = verification.org_code ? await getOrgPermissions(verification.org_code) : await getUserPermissions(verification.user_id); // Execute AI workflow const result = await executeAIWorkflow( req.body.workflow, workflowData, permissions, verification.org_code || verification.user_id ); res.json({ result, organization: verification.org_code || null, user_id: verification.user_id || null, workflow_id: result.id, execution_time: new Date().toISOString() }); } catch (error) { console.error("AI workflow error:", error); res.status(500).json({error: "Internal server error"}); } }); ``` ## AI-specific security considerations ### Rate limiting for AI applications ```javascript const rateLimit = require("express-rate-limit"); // Stricter rate limiting for AI endpoints const aiRateLimiter = rateLimit({ windowMs: 15 * 60 * 1000, // 15 minutes max: 50, // Limit each API key to 50 AI requests per window message: { error: "AI rate limit exceeded", code: "AI_RATE_LIMITED" }, keyGenerator: (req) => { // Use API key as rate limit key return req.apiKey?.key_id || req.ip; } }); app.use("/ai/*", aiRateLimiter); ``` ### AI prompt security ```javascript function sanitizeAIInput(input) { // Remove potentially harmful content const sanitized = input .replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, "") .replace(/javascript:/gi, "") .replace(/on\w+\s*=/gi, ""); // Limit input length if (sanitized.length > 10000) { throw new Error("Input too long"); } return sanitized; } app.post("/ai/process", async (req, res) => { try { const sanitizedInput = sanitizeAIInput(req.body.input); // Process with AI... const result = await processWithAI(sanitizedInput); res.json({result}); } catch (error) { res.status(400).json({error: error.message}); } }); ``` ### AI response validation ```javascript function validateAIResponse(response) { // Check for potentially harmful content const harmfulPatterns = [ /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, /javascript:/gi, /on\w+\s*=/gi ]; for (const pattern of harmfulPatterns) { if (pattern.test(response)) { throw new Error("AI response contains potentially harmful content"); } } // Check response length if (response.length > 50000) { throw new Error("AI response too long"); } return response; } ``` ## Monitoring AI applications ### Track AI usage patterns ```javascript function logAIUsage(apiKey, organization, endpoint, inputLength, responseLength) { logger.info("AI usage", { api_key: apiKey, organization, endpoint, input_length: inputLength, response_length: responseLength, timestamp: new Date().toISOString() }); } // Usage in endpoints app.post("/ai/chat", async (req, res) => { const startTime = Date.now(); try { // ... AI processing logic ... // Log usage logAIUsage( req.apiKey.key_id, req.apiKey.org_code || req.apiKey.user_id, "/ai/chat", req.body.message.length, response.length ); res.json({response}); } catch (error) { // Log errors too logger.error("AI chat error", { error: error.message, context: req.apiKey?.org_code || req.apiKey?.user_id }); res.status(500).json({error: "Internal server error"}); } }); ``` ### AI performance monitoring ```javascript function monitorAIPerformance(organization, endpoint, duration, success) { // Track response times if (duration > 5000) { // 5 seconds logger.warn("Slow AI response", { organization, endpoint, duration, threshold: 5000 }); } // Track success rates if (!success) { logger.error("AI request failed", { organization, endpoint, duration }); } } ```

# Manage your apis - About api keys - API keys overview

> Learn how to manage API keys for your own APIs using Kinde's API key management system

api key management, api keys, key verification, registered apis, Verify keys, key lifecycle
api-keys, about-api-keys

Kinde provides a comprehensive API key management system that allows you to issue and manage API keys for your own APIs. This system supports both organization-level and user-level key management, making it suitable for B2B, B2C, and B2B2C business models. <Aside type="upgrade"> This feature is available on [Kinde paid plans](https://kinde.com/pricing/) </Aside> ## What are API keys? API keys are long-lived credentials that allow end users to authenticate with your APIs. They provide a simple way for users to access your services without going through OAuth flows and enables them to make requests outside of the browser, such as with CLIs, cURL, etc. ### Key characteristics - **Scoped**: each key is limited to a specific API - **Permissions**: each key can be granted specific scopes/permissions - **Secure**: keys are stored as secure hashes and never exposed after creation - **Manageable**: keys can be created, rotated, and revoked as needed - **Long-lived**: API keys don't expire unless you set an expiration date (coming soon) ## Key management models ### Organization-level keys - Managed by organization administrators - Suitable for B2B scenarios where customers need access to your APIs - Keys are associated with specific organizations - Admins can manage keys on behalf of their users ### User-level keys - Managed by individual users - Suitable for B2C scenarios where end users need API access - Users create and manage their own keys - Keys are associated with specific user accounts ## How API keys work ### 1. Register an API Before you can issue API keys, you must register your APIs in Kinde: - Provide a name and description - Define available scopes - Get a unique `api_id` for each API Read more about [API registration](/developer-tools/your-apis/register-manage-apis/). ### 2. Create keys When creating an API key: - Associate it with a registered API - Assign specific scopes for access control - Generate a secure secret (shown only once) - Create a stable `key_id` for management ### 3. Use keys End users include the API key in their requests to your API: - Usually sent in an `Authorization` header - Your API extracts the key and verifies it with Kinde - Kinde returns validation results including scopes and metadata Read more about [verifying API keys](/manage-your-apis/add-manage-api-keys/verify-api-keys-in-your-api/). ### 4. Manage keys Keys can be managed throughout their lifecycle: - **Rotate**: generate new secrets while keeping the same key ID - **Revoke**: mark keys as inactive - **Update**: modify associated APIs or scopes (requires new key) ## What you can use API keys for ### AI and automation - Enable AI agents to access your APIs - Support automated workflows and integrations - Provide secure access for machine learning applications ### Third-party integrations - Allow customers to integrate with your platform - Provide different access levels based on customer tier - Track usage and enforce rate limits ### Internal automation - Enable automated scripts and tools - Provide secure access for CI/CD pipelines - Support internal development and testing ### Partner access - Grant partners access to specific APIs - Control what data and features partners can access - Maintain audit trails for compliance ### Developer tools - Provide API access for developer tools and SDKs - Enable self-service API exploration - Support API testing and development ## API key security features ### Secure storage - API key secrets are never stored in plain text - All secrets are hashed using secure algorithms - No way to retrieve the original secret after creation ### Access control - Keys are tied to a single API - Keys can be granted specific scopes/permissions - Organization-level isolation prevents cross-tenant access

# Manage your apis - About api keys - API keys quick start

> Get started with API key management in Kinde - create, manage, and verify API keys for your own APIs

api key quick start, get started with api keys, api key management, key verification, registered apis
api-keys, about-api-keys

This guide will walk you through setting up API key management for your APIs using Kinde. You'll learn how to register your APIs, create API keys, and implement key verification in your application. ## Prerequisites Before you following this guide, ensure you have: - A Kinde account with admin access - An API that you want to protect with API keys ## Step 1: Register your API Before you can issue API keys, you need to register your API in Kinde: 1. Go to **Settings** > **APIs**. 2. Select **Add API**. 3. Enter an API name and Audience. The audience (aud) is a unique identifier for this API. Often a short code or the URL of the API is used. 4. Select **Save**. You'll see an `API ID` for your new API. This ID is used when creating API keys. ## Step 2: Create an API key for a user or organization You can enable your customers to create API keys via the self-service portal or via API, but for this guide we'll assume you are creating them on their behalf inside the Kinde admin area. 1. Open a user or organization record in Kinde. 2. Select **API keys** from the menu. 3. Click **Add API key**. 5. Configure the key: - **Name**: Give it a descriptive name (e.g., "Production Integration") - **API**: Select the API this key can access - **Scopes**: Choose specific scopes for the API 6. Select **Save** Securely issue this API key to your customer. ## Step 3: Test calling your API and verify the API key 1. Call your API endpoint with the API key as the `Authorization` header. 2. Extract the API key from the `Authorization` header. 3. Call the Kinde Management API to verify the API key (you will need an [M2M token](/developer-tools/kinde-api/connect-to-kinde-api/) for this). ```javascript // Extract API key from request const apiKey = req.headers.authorization?.replace("Bearer ", ""); // Verify with Kinde (requires M2M access token) // Obtain an M2M token as per /developer-tools/kinde-api/connect-to-kinde-api/ const verificationResult = await verifyApiKey(apiKey, m2mAccessToken); if (verificationResult.is_valid) { // Key is valid, check scopes if (verificationResult.scopes.includes("read:users")) { // Proceed with request res.json({data: "Your data here"}); } else { res.status(403).json({error: "Insufficient scope"}); } } else { res.status(401).json({error: "Invalid API key"}); } async function verifyApiKey(apiKey, m2mAccessToken) { const response = await fetch("https://your-domain.kinde.com/api/v1/api_keys/verify", { method: "POST", headers: { "Content-Type": "application/json", "Authorization": `Bearer ${m2mAccessToken}` }, body: JSON.stringify({ api_key: apiKey }) }); return response.json(); } ``` The response will look like this: ```json { "code": "API_KEY_VERIFIED", "message": "API key verified", "is_valid": true, "key_id": "api_key_0195ac80a14e8d71f42b98e75d3c61ad", "status": "active", "scopes": ["read:users", "write:users"], "org_code": "org_1234567890", "user_id": "kp_1234567890", "last_verified_on": "2024-11-18T13:32:03+11", "verification_count": 42 } ``` That's it! You have verified the API key and can proceed with the request.

# Manage your apis - About api keys - Organization-level API keys

> Learn how to create and use organization-level API keys for secure, isolated access to organization-specific resources

organization level api keys, org level, multi tenant, organization isolation, api key security
api-keys, key-types

Organization-level API keys provide enhanced security by ensuring that all API calls are associated with a specific organization context. This is particularly useful for multi-tenant applications where you need to maintain clear boundaries between different organizations. ## What are organization-level API keys? Organization-level API keys are API keys that are tied to a specific organization within your Kinde account. When these keys are used to authenticate, the resulting verification includes the organization context, ensuring that all API operations can be properly scoped to that organization. ## Benefits of organization-level API keys ### Security - **Clear ownership**: All API calls are clearly associated with an organization - **Reduced risk**: Prevents accidental cross-organization data access - **Audit trail**: Clear tracking of which organization each API call affects ### Compliance - **Data isolation**: Helps ensure compliance with data residency requirements - **Access control**: Maintains clear boundaries for sensitive data - **Regulatory compliance**: Helps meet industry-specific compliance requirements ### Multi-tenancy - **Tenant isolation**: Perfect for SaaS applications serving multiple customers - **Resource management**: Clear separation of resources between organizations - **Billing isolation**: Separate tracking and billing per organization ### Let organizations self-serve You can expose API key creation to organizations in the Kinde self-serve portal. See [Self-serve API keys](/manage-your-apis/add-manage-api-keys/self-serve-api-keys/) for more information. ## Organization context in verification When you use an organization-level API key, the verification response automatically includes the `org_code` field: ```json { "code": "API_KEY_VERIFIED", "message": "API key verified", "is_valid": true, "key_id": "api_key_123", "status": "active", "scopes": ["read:users", "write:users"], "org_code": "org_abc123", "user_id": null, "last_verified_on": "2024-11-18T13:32:03+11", "verification_count": 42 } ``` This `org_code` field is trusted and cannot be tampered with, ensuring that your application can rely on it for authorization decisions. ## Use cases for organization-level API keys ### SaaS applications - **Customer integrations**: Each customer gets their own API key. - **Data isolation**: Customer data is automatically separated. - **Customization**: Customer-specific configurations and features. ### Internal tools - **Department access**: Different departments get different API keys. - **Project isolation**: Separate keys for different projects. - **Resource management**: Control access to organization resources. ### Partner integrations - **Third-party access**: Grant partners access to specific APIs. - **Limited scope**: Control what partners can access. - **Audit trails**: Track all partner API usage. ### AI and automation - **AI assistants**: AI tools that help with organization-specific data. - **Automated workflows**: Scripts that operate within organization boundaries. - **Integration tools**: Tools that connect with organization systems. ## Best practices for organization-level API keys ### Key management - **Naming conventions**: Use clear names that indicate the organization. - **Scope limits**: Only grant the minimum required scopes. - **Regular rotation**: Rotate keys periodically for security. - **Monitoring**: Track usage patterns for each organization. ### Security considerations - **Organization validation**: Always verify the `org_code` in verification responses. - **Scope enforcement**: Enforce scope restrictions in your API. - **Audit logging**: Log all API operations with organization context. - **Access reviews**: Regularly review organization access patterns. ### Integration patterns - **Multi-tenant APIs**: Design your APIs to handle organization context. - **Data isolation**: Ensure data is properly isolated between organizations. - **Error handling**: Provide clear error messages for organization-related issues. - **Documentation**: Document organization-specific API behavior.

# Manage your apis - About api keys - User-level API keys

> Learn how to create and use user-level API keys that carry a trusted user context for B2C apps and per-user integrations.

user-level api keys, b2c, user isolation, api key security
api-keys, key-types

User-level API keys are tied to an individual user account. When verified, these keys return a trusted user context so you can authorize requests on a per-user basis. This is ideal for B2C apps, personal automations, and integrations where actions should be attributed to a specific user. ## What are user-level API keys? User-level API keys authenticate requests on behalf of a single user. The verification response includes that user's identifier so you can enforce user-specific authorization rules in your API. ## Benefits of user-level API keys ### Security - **Clear ownership**: Every call is attributed to a specific user. - **Fine-grained access**: Enforce per-user permissions and quotas. - **Auditability**: Attribute changes and access to a concrete user identity. ### Simplicity - **Straightforward logic**: No need to infer user context from other signals. - **Consistent across services**: Portable for personal integrations and scripts. ### Let users self-serve You can expose API key creation to users in the Kinde self-serve portal. See: [Self-serve API keys](/manage-your-apis/add-manage-api-keys/self-serve-api-keys/). ## User context in verification When you verify a user-level API key, the response includes a non-null `user_id`: ```json { "code": "API_KEY_VERIFIED", "message": "API key verified", "is_valid": true, "key_id": "api_key_123", "status": "active", "scopes": ["read:profile"], "org_code": null, "user_id": "kp_1234567890", "last_verified_on": "2024-11-18T13:32:03+11", "verification_count": 42 } ``` Rely on the `user_id` for authorization and auditing within your API. If you need organization context, consider using [organization-level API keys](/manage-your-apis/about-api-keys/organization-api-keys/) instead. ## Use cases for user-level API keys ### B2C applications - **Personal data access**: Users access and manage their own data. - **Per-user rate limits**: Enforce limits per user account. ### Personal automations and scripts - **Background jobs**: Users run scripts that act as them. - **Third-party tooling**: Allow integrations to operate within a single user's scope. ### AI assistance - **User-specific retrieval**: Attribute AI actions and retrieval to a user. ## Best practices for user-level API keys ### Key management - **Naming**: Include the user's name or ID in key names for clarity. - **Minimum scopes**: Grant only the scopes needed. - **Rotation**: Encourage periodic key rotation. - **Monitoring**: Track usage and anomalies per user. ### Security considerations - **User validation**: Always validate `user_id` from verification before processing. - **Scope enforcement**: Enforce scopes server-side. - **Audit logging**: Log operations with the `user_id` for traceability.

# Manage your apis - Add manage api keys - Create an API key

> Learn how to create API keys for your registered APIs, including organization-level and user-level keys

create api key, api key setup, organization level, user level, registered apis, key scopes
api-keys, api-key-setup

This guide shows you how to create API keys in Kinde for your registered APIs. API keys can be created at the organization level (managed by admins) or user level (managed by individual users), depending on your business model. ## Prerequisites Before creating API keys: 1. **Register your APIs** in Kinde (see [API registration guide](/developer-tools/your-apis/)). 2. **Define scopes** for your APIs (optional). 3. Set up an **M2M application** for accessing the [Kinde management API](/developer-tools/kinde-api/connect-to-kinde-api/) (if you intend to use our API). ## Create API keys You can enable your customers to [create API keys via the self-service portal](/manage-your-apis/add-manage-api-keys/self-serve-api-keys/). You can also create API keys on their behalf via the Kinde admin area or via API. See below. ### Via the Kinde admin area #### Create organization-level keys 1. Go to **Organizations** 2. Select an organization. 3. Select **API keys** from the left sidebar. 4. Click **Add API key**. 5. Configure the key: - **Name**: Give it a descriptive name (e.g., "Production Integration") - **API**: Select the API this key can access - **Scopes**: Choose specific scopes for the API 6. Select **Save** #### Create user-level keys 1. Go to **Users** 2. Select a user. 3. Select **API keys** from the left sidebar. 4. Click **Add API key**. 5. Configure the key: - **Name**: Give it a descriptive name (e.g., "Production Integration") - **API**: Select the API this key can access - **Scopes**: Choose specific scopes for the API 6. Select **Save** ### Via API Use your [M2M application](/developer-tools/kinde-api/connect-to-kinde-api/) to create API keys programmatically: ```bash # Create an organization-level key curl -X POST https://your-domain.kinde.com/api/v1/api_keys \ -H "Authorization: Bearer YOUR_M2M_TOKEN" \ -H "Content-Type: application/json" \ -d '{ "name": "Production Integration", "api_id": "<your-api-id>", "scope_ids": ["read:users", "write:users"], "org_code": "<your-org-code>" }' # Create a user-level key curl -X POST https://your-domain.kinde.com/api/v1/api_keys \ -H "Authorization: Bearer YOUR_M2M_TOKEN" \ -H "Content-Type: application/json" \ -d '{ "name": "User API Access", "api_id": "<your-api-id>", "scope_ids": ["read:users"], "user_id": "<your-user-id>" }' ``` ## API key response When you create a key via API, Kinde returns a `key` value. Store it securely immediately — you won't be able to see it again. You can use the `id` later to manage the key (for example, rotate, revoke, or fetch metadata). You cannot retrieve the secret again. ```json { "message": "API key created", "code": "API_KEY_CREATED", "api_key": { "id": "api_key_0195ac80a14e8d71f42b98e7xxxxxxx", "key": "k_live_12345678abcdefghijkl" // example placeholder; not a real key" } } ```

# Manage your apis - Add manage api keys - Revoke API keys

> Immediately disable an API key and block further use across your APIs.

revoke api key, disable api key, incident response
api-keys, api-key-setup

Revoking an API key immediately prevents it from authenticating with your APIs. Use this when a key is no longer needed, has the wrong scopes, or is suspected to be exposed. ## How to revoke an API key You can revoke an API key in the dashboard or [via the API](https://docs.kinde.com/kinde-apis/management/#tag/api-keys/delete/api/v1/api_keys/). Your customers can also revoke keys themselves in the self-serve portal if you have enabled self-serve API keys. See [Self-serve API keys](/manage-your-apis/add-manage-api-keys/self-serve-api-keys/) for more information. ### Revoke a key on behalf of a user or organization in Kinde - For a user-level key: Go to **Users > [User] > API keys**. Find the key and open the three dots menu > **Revoke**. - For an organization-level key: Go to **Organizations > [Organization] > API keys**. Find the key and open the three dots menu > **Revoke**. ![Submenu on API key](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/bd8fdfaa-5146-4f11-2c30-a3263ee3e500/public) ## What changes after an API key is revoked? Verification responses will indicate the key is not usable. Ensure your API enforces this: ```javascript // After verifying the API key with Kinde if (!verification.is_valid || verification.status !== "active") { return res.status(401).json({error: "Invalid or inactive API key"}); } ``` ## Recommendations - If the key was in use, create a replacement key and distribute it securely. - Audit logs for usage of the revoked `key_id`. - Consider rotating other keys if there was a broader incident.

# Manage your apis - Add manage api keys - Rotate API keys

> Safely rotate API keys using built-in rotation (same key_id, new secret) or a dual-key rollout with zero downtime.

api key rotation, key rollover, deprecation window
api-keys, api-key-setup

Rotating API keys helps reduce risk from accidental exposure and aligns with security best practices. This guide shows two rotation methods for both user‑level and organization‑level API keys. ## When to rotate API keys - On a regular schedule (e.g., every 60–90 days) - After suspected exposure or repository history changes - When scope requirements change ## Choosing an approach to API key rotation - **Built‑in rotation**: When you control client updates and can push new secrets quickly; keeps `key_id` stable - **Dual‑key rotation**: When you need a migration window; supports staggered updates across many clients/services ## Approach 1: Built‑in rotation (same key_id, new secret) Use the Rotate key action to keep the `key_id` the same and replace only the secret. This is the simplest option when you can quickly update clients with the new secret. Steps: 1. Open the key you want to rotate: - User key: **Users > [User] > API Keys > [Key]** - Organization key: **Organizations > [Organization] > API Keys > [Key]** 2. Select **Rotate key** and confirm. 3. Securely distribute the new secret to your clients/services. 4. Ensure your clients reload configuration or secrets promptly. Verification behavior: - `key_id` remains the same - `status` remains `active` - Only the secret changes; old secret will fail verification Choose this when you control secret distribution and can update clients near‑immediately. ## Approach 2: Dual‑key rotation (new key_id) Create a second key, migrate traffic, then revoke the old one. This minimizes risk when you cannot coordinate an immediate secret update. Steps: 1. Create a new key with the same API and scopes. - User: **Users > [User] > API Keys > Add API key**. - Organization: **Organizations > [Organization] > API Keys > Add API key**. - Or use the Management API to create a new key. 2. Update your client(s) to use the new key. - Ship configuration changes or secrets to the environments that call your API. 3. Keep both keys valid during a grace period. - Allow traffic with either key while clients roll over. - Monitor verification results to ensure migration progress. 4. Revoke the old key. - Once traffic has fully moved to the new key, revoke the old one. ## Verifying during rotation Use Kinde to verify incoming keys. During a dual‑key grace window, both old and new keys verify as valid. You can optionally check `key_id` to track when clients have switched. ```javascript // Example Express handler (after verifying with Kinde) if (!verification.is_valid || verification.status !== "active") { return res.status(401).json({error: "Invalid or inactive API key"}); } // Optional: observe rollout by key_id (for telemetry/alerts only) logger.info("api_key_used", {key_id: verification.key_id}); // Enforce required scopes as usual const requiredScopes = ["read:ai_chats"]; // adjust per endpoint for (const scope of requiredScopes) { if (!verification.scopes.includes(scope)) { return res.status(403).json({error: `Insufficient scope: ${scope}`}); } } ``` ## Rotate via self‑serve portal (optional) If you’ve enabled the self-serve portal, customers can rotate their keys themselves using the built-in **Rotate key** option. You can also deep link to the API Keys page. See [Self-serve API keys](/manage-your-apis/add-manage-api-keys/self-serve-api-keys/). ## Best practices for API key rotation - Keep rotations small and frequent rather than rare and large - Automate notifications to teams when a rotation window begins or ends - Use monitoring to detect lingering use of old `key_id`

# Manage your apis - Add manage api keys - Scopes for API keys

> Learn about the different scopes available for API keys and how to configure them for proper access control

api key scopes, access control, permissions, scope configuration, api key permissions
api-keys, api-key-setup

Scopes define what permissions an API key has when making requests to your API. You can create and define [custom scopes](/developer-tools/your-apis/custom-api-scopes/) when you register your API in Kinde, then assign them for each API key you create. This topic is about strategies and considerations when assigning scopes to API keys. ## Example custom scopes The scopes you set will be related to what your app is and does. These are just some examples for AI apps. - `read:ai_chats` - `write:ai_chat` - `read:ai_analytics` - `write:ai_analytics` - `read:ai_workflows` ## Scope configuration ### When creating an API key 1. Select the minimum required scopes for your use case. 2. Consider the principle of least privilege. 3. Review scope descriptions carefully. ### Updating existing API keys API keys are immutable, so you can't update the scopes of an existing API key. You can only create a new API key with the desired scopes. ## Recommendations for API scopes best practice ### Security - **Principle of least privilege**: Only grant the minimum required scopes. - **Regular review**: Periodically review and audit scope assignments. - **Scope isolation**: Use different API keys for different purposes. ### Structure - **Naming conventions**: Use clear, descriptive scope names. - **Documentation**: Document what each scope provides access to. - **Versioning**: Consider scope versioning for breaking changes. ## Scope validation When your application receives a token, validate that it has the required scopes: ```javascript function hasRequiredScope(scopes, requiredScope) { return Array.isArray(scopes) && scopes.includes(requiredScope); } // Example usage (after verifying the API key) if (!hasRequiredScope(verification.scopes, "write:users")) { return res.status(403).json({ error: "Insufficient scope" }); } ```

# Manage your apis - Add manage api keys - Self-serve API keys

> Turn on API key management in the self-serve portal for users and organizations, and deep link straight to the API keys page using SDK helpers.

self-serve portal, api keys, PortalLink, deep link
api-keys, self-serve-portal

You can allow your customers to create and manage their own API keys directly in the self-serve portal for users and organizations. ## Switch on self-serve API keys in Kinde 1. Go to **Settings** > **Environment** > **Self-serve portal**. 2. Enable the API Keys option for the audience you want: - Users (B2C) - Organizations (B2B) 3. Select **Save**. An **API keys** navigation item will appear in the portal for your customers. ### Self-serve portal details - [Self-serve portal for orgs](/build/self-service-portal/self-serve-portal-for-orgs/) - [Self-serve portal for users](/build/self-service-portal/self-serve-portal-for-users/) ## Deep link to API keys from your app Most SDKs provide a `PortalLink` helper that generates a one-time portal URL and redirects the user. Use the `subNav` parameter to open the API Keys section directly. ### React ```jsx import {PortalLink} from "@kinde-oss/kinde-auth-react"; // Opens the organization level API Keys section in the self-serve portal <PortalLink subNav="organization_api_keys">Manage API keys</PortalLink>; ``` ### Next.js ```jsx import {PortalLink} from "@kinde-oss/kinde-auth-nextjs/components"; // Opens the API Keys section in the self-serve portal <PortalLink subNav="user_api_keys">Manage API keys</PortalLink>; ``` ### Without an SDK (server-side) If you generate portal links using an API on your server, include a `sub_nav` field to deep link to API Keys. ```json { "user_id": "kp_abc123", // or organization_code for org-level links "return_url": "https://yourapp.com/account", "sub_nav": "api_keys" } ``` ### Tips for setting up - Use `subNav` (camelCase) in SDK helpers and `sub_nav` (snake_case) in API payloads. - For organization-level experiences, pass organization context according to your integration pattern. ## Customer portal experience After enabling the API key function for customers, an **API Keys** item shows in the portal navigation where customers can create, view, rotate and revoke keys. ## Access control for self-serve organization level API keys There are system level permissions which Kinde provides which you can assign to your custom roles. - `read:org:authentication` - The user is able to view API keys created by the organization - `write:org:authentication` - The user is able to create, rotate and revoke API keys for the organization. When assigning permissions to roles, our recommendation is to only give the minimum permissions required for someone to do their job. It is always better to be more granular in this area.

# Manage your apis - Add manage api keys - Verify API keys in your API

> Learn how to implement API key verification in your API endpoints to authenticate requests from end users

api key verification, key validation, authentication, api security, key verification endpoint
api-keys, api-key-setup, FASTapi, API-middleware

When end users make requests to your API using their API keys, you need to verify those keys with Kinde before processing the request. This guide shows you how to implement API key verification in your API endpoints. ## How API key verification works The verification flow follows these steps: 1. **End user** sends a request to your API with their API key 2. **Your API** extracts the key and calls Kinde's verification endpoint (this call requires an [M2M token](/developer-tools/kinde-api/connect-to-kinde-api/)) 3. **Kinde** validates the key and returns verification results 4. **Your API** processes the request based on verification results ## Basic implementation ### Extract API key from request First, extract the API key from the incoming request: ```javascript // Express.js example function extractApiKey(req) { const authHeader = req.headers.authorization; if (!authHeader) { throw new Error('No authorization header'); } if (!authHeader.startsWith('Bearer ')) { throw new Error('Invalid authorization format'); } return authHeader.substring(7); // Remove 'Bearer ' prefix } // FastAPI example def extract_api_key(authorization: str = Header(None)): if not authorization: raise HTTPException(status_code=401, detail="No authorization header") if not authorization.startswith("Bearer "): raise HTTPException(status_code=401, detail="Invalid authorization format") return authorization[7:] # Remove 'Bearer ' prefix ``` ### Verify API key with Kinde Call Kinde's verification endpoint to validate the key: ```javascript // Node.js/Express example async function verifyApiKey(apiKey) { try { const response = await fetch('https://your-domain.kinde.com/api/v1/api_keys/verify', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ api_key: apiKey }) }); if (!response.ok) { throw new Error(`Verification failed: ${response.status}`); } return await response.json(); } catch (error) { console.error('API key verification error:', error); throw new Error('Failed to verify API key'); } } // Python/FastAPI example async def verify_api_key(api_key: str): async with httpx.AsyncClient() as client: response = await client.post( "https://your-domain.kinde.com/api/v1/api_keys/verify", headers={ "Content-Type": "application/json" }, json={ "api_key": api_key } ) if not response.is_success: raise HTTPException(status_code=400, detail="Verification failed") return response.json() ``` ### Implement in your API endpoint Use this verification in your API endpoints: ```javascript // Express.js endpoint app.get('/api/data', async (req, res) => { try { // Extract API key const apiKey = extractApiKey(req); // Verify with Kinde const verification = await verifyApiKey(apiKey); if (!verification.is_valid) { return res.status(401).json({ error: 'Invalid API key' }); } // Check if key is active if (verification.status !== 'active') { return res.status(401).json({ error: 'API key is not active' }); } // Check required scopes if (!verification.scopes.includes('read:users')) { return res.status(403).json({ error: 'Insufficient scope' }); } // Process request const data = await getData(); res.json({ data, key_id: verification.key_id }); } catch (error) { console.error('API key verification error:', error); res.status(500).json({ error: 'Internal server error' }); } }); # FastAPI endpoint @app.get("/api/data") async def get_data(authorization: str = Header(None)): try: # Extract API key api_key = extract_api_key(authorization) # Verify with Kinde verification = await verify_api_key(api_key) if not verification["is_valid"]: raise HTTPException(status_code=401, detail="Invalid API key") # Check if key is active if verification["status"] != "active": raise HTTPException(status_code=401, detail="API key is not active") # Check required scopes if "read:users" not in verification["scopes"]: raise HTTPException(status_code=403, detail="Insufficient scope") # Process request data = await get_data() return {"data": data, "key_id": verification["key_id"]} except HTTPException: raise except Exception as error: logger.error(f"API key verification error: {error}") raise HTTPException(status_code=500, detail="Internal server error") ``` <Aside> If you see a `Scope missing` error when calling Kinde, ensure the M2M client you use to call the verification endpoint has the `read:api_keys` scope. Grant this scope to your M2M application in Kinde, then retry. </Aside> ## Verification response Kinde's verification endpoint returns: ```json { "code": "API_KEY_VERIFIED", "message": "API key verified", "is_valid": true, "key_id": "api_key_0195ac80a14e8d71f42b98e75d3c61ad", "status": "active", "scopes": ["read:users", "write:users"], "org_code": "org_1234567890", "user_id": "kp_1234567890", "last_verified_on": "2024-11-18T13:32:03+11", "verification_count": 42 } ``` ### Response fields - **`code`**: Response code indicating the result - **`message`**: Human-readable message - **`is_valid`**: Boolean indicating if the key is valid - **`scopes`**: Array of scopes the key has access to - **`status`**: Key status (`active`, `inactive`, `revoked`) - **`key_id`**: Unique identifier for the key - **`org_code`**: Organization code if it's an organization-level key - **`user_id`**: User ID if it's a user-level key - **`last_verified_on`**: When the key was last verified - **`verification_count`**: Number of times the key has been verified ## Advanced implementation ### Middleware for Express.js Create reusable middleware for API key verification: ```javascript function requireApiKey(requiredScopes = []) { return async (req, res, next) => { try { const apiKey = extractApiKey(req); const verification = await verifyApiKey(apiKey); if (!verification.is_valid) { return res.status(401).json({error: "Invalid API key"}); } if (verification.status !== "active") { return res.status(401).json({error: "API key is not active"}); } // Check required scopes for (const scope of requiredScopes) { if (!verification.scopes.includes(scope)) { return res.status(403).json({ error: `Insufficient scope. Required: ${scope}` }); } } // Attach verification data to request req.apiKey = verification; next(); } catch (error) { console.error("API key middleware error:", error); res.status(500).json({error: "Internal server error"}); } }; } // Use middleware app.get("/api/data", requireApiKey(["read:users"]), (req, res) => { // req.apiKey contains verification data const data = getData(); res.json({data, key_id: req.apiKey.key_id}); }); app.post("/api/data", requireApiKey(["read:users", "write:users"]), (req, res) => { // Requires both read and write scopes const result = createData(req.body); res.json({result, key_id: req.apiKey.key_id}); }); ``` ### Dependency injection for FastAPI Create a dependency for API key verification: ```python async def verify_api_key_dependency( authorization: str = Header(None), required_scopes: List[str] = [] ) -> dict: try: api_key = extract_api_key(authorization) verification = await verify_api_key(api_key) if not verification["is_valid"]: raise HTTPException(status_code=401, detail="Invalid API key") if verification["status"] != "active": raise HTTPException(status_code=401, detail="API key is not active") # Check required scopes for scope in required_scopes: if scope not in verification["scopes"]: raise HTTPException( status_code=403, detail=f"Insufficient scope. Required: {scope}" ) return verification except HTTPException: raise except Exception as error: logger.error(f"API key verification error: {error}") raise HTTPException(status_code=500, detail="Internal server error") # Use dependency @app.get("/api/data") async def get_data(api_key: dict = Depends(verify_api_key_dependency)): data = await get_data() return {"data": data, "key_id": api_key["key_id"]} @app.post("/api/data") async def create_data( data: dict, api_key: dict = Depends(lambda: verify_api_key_dependency(required_scopes=["read:users", "write:users"])) ): result = await create_data(data) return {"result": result, "key_id": api_key["key_id"]} ``` ## Performance optimization ### Implement caching Cache verification results to avoid repeated calls to Kinde: ```javascript class ApiKeyCache { constructor() { this.cache = new Map(); this.ttl = 5 * 60 * 1000; // 5 minutes } get(key) { const cached = this.cache.get(key); if (cached && Date.now() - cached.timestamp < this.ttl) { return cached.data; } return null; } set(key, data) { this.cache.set(key, { data, timestamp: Date.now() }); } clear() { this.cache.clear(); } } const apiKeyCache = new ApiKeyCache(); async function verifyApiKeyWithCache(apiKey) { // Check cache first const cached = apiKeyCache.get(apiKey); if (cached) { return cached; } // Verify with Kinde const verification = await verifyApiKey(apiKey); // Cache valid results if (verification.is_valid && verification.status === "active") { apiKeyCache.set(apiKey, verification); } return verification; } ``` ### Batch verification If you need to verify multiple keys, consider implementing batch verification: ```javascript async function verifyMultipleApiKeys(apiKeys) { // Note: This would require a batch endpoint from Kinde // For now, verify keys in parallel const verificationPromises = apiKeys.map((key) => verifyApiKey(key)); return Promise.all(verificationPromises); } ``` ## Error handling ### Common error responses ```javascript // Invalid API key { "error": "Invalid API key", "code": "INVALID_KEY" } // Insufficient scope { "error": "Insufficient scope. Required: write:users", "code": "INSUFFICIENT_SCOPE", "required_scopes": ["write:users"], "available_scopes": ["read:users"] } // Revoked key { "error": "API key is not active", "code": "KEY_REVOKED" } ``` <Aside> If you receive a `Scope missing` error, it might be because the `read:api_keys` scope is missing. </Aside> ### Rate limiting Implement rate limiting for verification attempts: ```javascript const rateLimit = require("express-rate-limit"); const verificationLimiter = rateLimit({ windowMs: 15 * 60 * 1000, // 15 minutes max: 100, // Limit each IP to 100 verification attempts per window message: { error: "Too many verification attempts", code: "RATE_LIMITED" } }); app.use("/api/v1/api_keys/verify", verificationLimiter); ``` ## Recommendations ### Secure API key verification - **HTTPS only**: Always use HTTPS for verification requests - **Input validation**: Validate the API key format before sending to Kinde - **Error handling**: Don't expose sensitive information in error messages ### Verify and validate - Always validate the verification response from Kinde - Check all required fields before processing requests - Implement proper error handling for verification failures ### Monitor verification activity - Log verification attempts (without sensitive data) - Monitor for unusual verification patterns - Set up alerts for verification failures ## Test the API key validation process ### Test with valid keys ```bash # Test with a valid API key curl -X GET https://your-api.com/data \ -H "Authorization: Bearer YOUR_TEST_API_KEY" ``` ### Test error cases ```bash # Test with invalid key curl -X GET https://your-api.com/data \ -H "Authorization: Bearer invalid_key" # Test with missing header curl -X GET https://your-api.com/data # Test with revoked key curl -X GET https://your-api.com/data \ -H "Authorization: Bearer REVOKED_API_KEY" ``` ## Verification for AI applications ### Validate API keys for AI assistant integration ```javascript // AI assistant using API key for customer support app.post("/ai/chat", async (req, res) => { try { const apiKey = extractApiKey(req); const verification = await verifyApiKey(apiKey); if (!verification.is_valid) { return res.status(401).json({error: "Invalid API key"}); } // Check if key has access to support data if (!verification.scopes.includes("read:tickets")) { return res.status(403).json({error: "Insufficient scope for support data"}); } // AI can now access customer support data within the organization scope const customerData = await getCustomerSupportData(verification.org_code); // Process AI request with customer context const aiResponse = await processAIRequest(req.body.message, customerData); res.json({ response: aiResponse, context: `Organization: ${verification.org_code}`, key_id: verification.key_id }); } catch (error) { console.error("AI chat error:", error); res.status(500).json({error: "Internal server error"}); } }); ``` ### Validate API keys for automated workflow with AI ```javascript // AI-powered workflow automation app.post("/workflow/automate", async (req, res) => { try { const apiKey = extractApiKey(req); const verification = await verifyApiKey(apiKey); if (!verification.is_valid) { return res.status(401).json({error: "Invalid API key"}); } // AI workflow needs both read and write access const requiredScopes = ["read:users", "write:workflows"]; for (const scope of requiredScopes) { if (!verification.scopes.includes(scope)) { return res.status(403).json({ error: `Insufficient scope. Required: ${scope}` }); } } // AI can now automate workflows within the organization const workflowResult = await executeAIWorkflow( req.body.workflow, verification.org_code, verification.user_id ); res.json({ result: workflowResult, automated_by: verification.key_id, organization: verification.org_code }); } catch (error) { console.error("Workflow automation error:", error); res.status(500).json({error: "Internal server error"}); } }); ```

# Manage your apis - Troubleshoot api keys - Troubleshoot API key errors

> Common API key errors and their solutions, including authentication issues, scope problems, and organization access errors

api key errors, troubleshooting, authentication errors, scope errors, organization access, api key issues
api-keys, troubleshooting-api-keys

Although we hope nothing goes awry with API keys, it can happen. This guide will help you identify, diagnose, and resolve problems that could arise when using API keys. ## Perform regular maintenance to prevent errors with API keys It's always better to prevent errors than have to deal with them in a moment of crisis. Here's some tips for long-term API key management. - **Rotate API keys**: Periodically rotate keys for security. See [Rotate API keys](/manage-your-apis/add-manage-api-keys/rotate-api-keys/) - **Revoke unused keys**: Clean up keys that are no longer needed. See [Revoke API keys](/manage-your-apis/add-manage-api-keys/revoke-api-keys/) - **Review scopes**: Regularly audit and update API key permissions. See [Scopes for API keys](/manage-your-apis/add-manage-api-keys/scopes-for-api-keys/) - **Monitor usage**: Track API key usage patterns and anomalies. See [Verify API keys](/manage-your-apis/add-manage-api-keys/verify-api-keys-in-your-api/) ## Common error types Here's a summary of some of the most common errors and the type of errors that can occur. ### Authentication errors - Invalid API key - Expired tokens - Malformed requests - Missing authentication headers ### Authorization errors - Insufficient scopes - Organization access denied - Rate limit exceeded - Geographic restrictions ### Configuration errors - Missing properties - Invalid scopes - Organization mismatch - Workflow failures See below for full explanations and de-bugging assistance. ## Authentication errors ### "Invalid API key" error **Symptoms:** - HTTP 401 Unauthorized response - Error message: "Invalid API key" or "Authentication failed" **Common causes:** 1. **API key copied incorrectly**: Missing or extra characters 2. **API key revoked**: Key was deleted or deactivated 3. **Wrong environment**: Using production key in test environment 4. **Malformed request**: Incorrect header format **Solutions:** ```bash # Verify API key format # Should look like: k_live_1234567890abcdef... # Check header format curl -X GET https://your-domain.kinde.com/api/users \ -H "Authorization: Bearer YOUR_API_KEY" # Note: "Bearer " prefix # Verify key is active # Go to Settings > API Keys and check if key is enabled ``` **Debugging steps:** 1. Copy the API key again from the dashboard. 2. Check if the key is still active in your dashboard. 3. Ensure you're using the correct domain. ### "Token expired" error **Symptoms:** - HTTP 401 Unauthorized response - Error message: "Token expired" or "Invalid token" **Common causes:** 1. **Access token expired**: Tokens typically expire after 1 hour 2. **Clock skew**: Server time differs from client time 3. **Cached expired token**: Application using old token **Solutions:** ```javascript // Implement token refresh logic async function getValidToken(apiKey) { try { const response = await fetch("https://your-domain.kinde.com/oauth2/token", { method: "POST", headers: { "Content-Type": "application/x-www-form-urlencoded", Authorization: `Bearer ${apiKey}` }, body: "grant_type=client_credentials&scope=openid profile" }); const data = await response.json(); return data.access_token; } catch (error) { throw new Error("Failed to obtain access token"); } } // Use in your application let accessToken = await getValidToken(apiKey); let tokenExpiry = Date.now() + 3600000; // 1 hour // Check if token needs refresh if (Date.now() >= tokenExpiry) { accessToken = await getValidToken(apiKey); tokenExpiry = Date.now() + 3600000; } ``` **Debugging steps:** 1. Check your system clock for accuracy. 2. Implement proper token caching with expiration. 3. Add logging to track token refresh cycles. 4. Verify token expiration time in response. ### "Malformed request" error **Symptoms:** - HTTP 400 Bad Request response - Error message: "Malformed request" or "Invalid request format" **Common causes:** 1. **Missing Authorization header**: No Bearer token provided 2. **Incorrect header format**: Wrong header name or value 3. **Invalid request body**: Malformed JSON or form data **Solutions:** ```javascript // Ensure proper header format const headers = { Authorization: `Bearer ${apiKey}`, "Content-Type": "application/json" }; // For token exchange const formData = new URLSearchParams(); formData.append("grant_type", "client_credentials"); formData.append("scope", "openid profile"); const response = await fetch("https://your-domain.kinde.com/oauth2/token", { method: "POST", headers: { "Content-Type": "application/x-www-form-urlencoded", Authorization: `Bearer ${apiKey}` }, body: formData }); ``` ## Authorization errors ### "Insufficient scope" error **Symptoms:** - HTTP 403 Forbidden response - Error message: "Insufficient scope" or "Access denied" **Common causes:** 1. **Missing required scopes**: API key doesn't have necessary permissions 2. **Scope mismatch**: Requested scope not granted to key 3. **Organization restrictions**: Key scoped to different organization **Solutions:** ```bash # Check current scopes # Go to the relevant user or organization > API Keys > [Your Key] > View # Verify required scopes are assigned ``` **Debugging steps:** 1. Review the API key's assigned scopes. 2. Check what scopes your endpoint requires. 3. Verify organization scoping if applicable. 4. Update API key scopes if needed. ### "Organization access denied" error **Symptoms:** - HTTP 403 Forbidden response - Error message: "Organization access denied" or "Invalid organization" **Common causes:** 1. **Wrong organization scope**: API key scoped to different organization 2. **Organization not found**: Organization doesn't exist or is inactive 3. **Cross-organization access**: Attempting to access different organization's data **Solutions:** ```javascript // Verify organization in token function validateOrganizationAccess(token, requiredOrgCode) { if (!token.org_code) { throw new Error("Organization-scoped token required"); } if (token.org_code !== requiredOrgCode) { throw new Error("Access denied: organization mismatch"); } return true; } // Use in your API endpoint app.get("/api/users/:userId", async (req, res) => { try { const token = extractTokenFromRequest(req); const user = await getUserById(req.params.userId); // Validate organization access validateOrganizationAccess(token, user.organization_code); res.json(user); } catch (error) { res.status(403).json({error: error.message}); } }); ``` **Debugging steps:** 1. Check if your API key is organization-scoped. 2. Verify the organization code in the token. 3. Ensure you're not trying to access cross-organization data. 4. Check the organization status in the dashboard. ### "Rate limit exceeded" error **Symptoms:** - HTTP 429 Too Many Requests response - Error message: "Rate limit exceeded" or "Too many requests" **Common causes:** 1. **High request volume**: Exceeding API key rate limits 2. **Burst requests**: Too many requests in short time 3. **Shared rate limits**: Multiple applications using same key **Solutions:** ```javascript // Implement rate limiting in your application class RateLimiter { constructor(limit, window) { this.limit = limit; this.window = window; this.requests = new Map(); } async checkLimit(key) { const now = Date.now(); const windowStart = now - this.window; // Clean old entries if (this.requests.has(key)) { this.requests.set( key, this.requests.get(key).filter((timestamp) => timestamp > windowStart) ); } const currentRequests = this.requests.get(key) || []; if (currentRequests.length >= this.limit) { return false; // Rate limited } currentRequests.push(now); this.requests.set(key, currentRequests); return true; } } // Usage const rateLimiter = new RateLimiter(100, 60000); // 100 requests per minute if (!(await rateLimiter.checkLimit(apiKey))) { throw new Error("Rate limit exceeded. Please try again later."); } ``` **Debugging steps:** 1. Check your API key's rate limit settings. 2. Monitor request frequency in your application. 3. Implement proper request throttling. 4. Consider using separate API keys for different services. ## Configuration errors ### "Invalid scopes" error **Symptoms:** - API key creation fails - Error message: "Invalid scope" or "Scope not found" **Common causes:** 1. **Scope doesn't exist**: Requested scope not defined 2. **Scope name typo**: Incorrect scope name 3. **Scope not available**: Scope not enabled for your plan **Solutions:** ```bash # Check available scopes # Go to Settings > APIs > Scopes # Verify scope names and availability # Common standard scopes: # Common standard scopes: # - openid # - profile # - email # - offline_access **Debugging steps:** 1. Review available scopes in dashboard. 2. Check scope spelling and format. 3. Verify scope availability for your plan. 4. Create custom scopes if needed.

# Properties - About properties - View and edit application properties

> Guide to viewing and editing application properties in Kinde including manual editing and API management for application data

application properties, property management, internal id, api management, property editing, application data, property values
properties, about-properties

If you use properties to manage application data, you can edit property values manually in Kinde or via API. For example, you might want to associate an application with a specific internal ID to reference your systems. ## View the properties of an application 1. In Kinde, go to **Settings > Applications**. 2. Select **View details** on the application whose properties you want to view. 3. Select **Properties**. ## Edit property values for an application 1. In Kinde, go to **Settings > Applications**. 2. Select **View details** on the application whose properties you want to view. 3. Select **Properties**. 4. Select **Edit** next to the property you want to update. 5. In the window that opens, enter or edit the value. 6. Select **Save**. ## Manage properties via API You can also manage application properties via the [Kinde Management API](/kinde-apis/management#tag/properties).

# Properties - About properties - About properties

> Overview of properties in Kinde including custom data management, token claims, property categories, and API integration for flexible data storage

properties, custom data, custom claims, tokens, kinde-provided properties, property categories, organization properties, user properties, application properties, api management
properties, about-properties

Properties are a way for you to add custom data to Kinde, and then use that data for custom claims and in tokens. Kinde comes with a standard set of properties that make up business, user, application, and organization profiles, but you can also [add custom properties](/properties/work-with-properties/manage-properties/) to capture any data you like. For example, you might want to record a billing address separate to a delivery address, or capture screen names, job titles, or other customer information. Properties can also be used to create custom claims. ## Properties can be passed in tokens You can choose to make a property ‘public’ so it can be made available to be passed via a token. This is essentially a way of creating a custom claim, enabling data to be transferred system to system, via API. For more information see [Add and manage properties in tokens](/properties/work-with-properties/properties-in-tokens/). ## Kinde-included properties To get you started, we’ve included a set of common properties. You can easily identify these as the code key starts with `kp-` meaning Kinde-provided. You cannot edit or delete these properties. ## Custom properties The needs of every business are different, that’s why you can create your own properties and use them any way you want. For example, you might want to create a property to collect marketing information, identifiers from your app, or customer relationship data. ## Property categories Properties can be organized using [property categories](/properties/work-with-properties/property-groups/). When you create a category, it becomes a heading in a user, application, or organization record. Property categories ensure similar fields are grouped together for easier display. ### Organization properties example | Category | Properties | For | | -------------------- | -------------------------------------------------- | ------------ | | Billing information | Billing contact, Billing address, Billing phone | Organization | | Delivery information | Delivery contact, Delivery address, Delivery phone | Organization | ### User properties example | Category | Properties | For | | ---------------- | ------------------ | ---- | | Accounts contact | Name, email, phone | User | | Next of kin | Name, email, phone | User | ### Application properties example A common use case for application properties is to correlate M2M apps with organizations. | Category | Properties | For | | ----------- | ------------ | ---- | | Application org | Organization ID | Application | | External ID | External ID | Application | ## How properties are displayed in Kinde The way you label and group properties impacts how the data is displayed in Kinde. Here’s an example of how properties are displayed: <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/8250f7ea-f6a2-4c47-2e40-a824ef4f4800/public" alt="" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" /> ## Properties can be added and edited via API You need to [set up an M2M application to access the Kinde Management API](/developer-tools/kinde-api/connect-to-kinde-api/), and then create and edit properties using [dedicated endpoints](/kinde-apis/management#tag/properties).

# Properties - About properties - View and edit organization properties

> Guide to viewing and editing organization properties in Kinde including manual editing and API management for organization data

organization properties, property management, organization data, property editing, api management, property values, organization details
properties, about-properties

If you use properties to manage organization data, you can edit the property values manually in Kinde or via API. ## View the properties of an organization 1. In Kinde, go to **Organizations**. 2. Select the organization who’s properties you want to view. 3. Select **Properties**. ## Edit property values for an organization 1. In Kinde, go to **Organizations**. 2. Select the organization who’s properties you want to view. 3. Select **Properties**. 4. Select **Edit** next to the property you want to update. 5. In the window that opens, enter or edit the value. 6. Select **Save**. ## Manage properties via API You can also manage organization properties via the [Kinde Management API](/kinde-apis/management#tag/organizations/patch/api/v1/organizations/{org_code}/properties).

# Properties - Work with properties - Add and manage properties

> Comprehensive guide to adding and managing properties in Kinde including property types, creation, editing, and token integration considerations

add properties, manage properties, property creation, property types, boolean properties, text properties, property keys, private properties, public properties, api management
properties, work-with-properties

For properties to be available in an application, user or organization record, they first need to exist in your business. This topic describes how to create and edit properties. Follow the procedure below to: - add properties for users - add properties for organizations - add properties for applications ## Add a property You can also create and update properties through the [Kinde Management API](/kinde-apis/management#tag/properties). 1. In Kinde, go to **Settings** **> Data management > Properties**. 2. Select **Add Property**. ![Top half of Add property window](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/14161413-5a55-4455-bdb7-87d00ae6d900/public) 3. Enter a **Name** for the property. 4. (Optional) Add a short description. Note that this description will appear when someone goes to edit the value of a property in a User or Organization record. 5. Assign a **Key** to the property. This needs to be unique so that you can identify it in your code. The key cannot be changed later. Note that any Kinde included properties start with `kp-`. 6. Select if the property needs to remain **Private**. If you switch this off, the property can be selected to be included in tokens. See [Add and manage properties in tokens](/properties/work-with-properties/properties-in-tokens/). ![Screen shot of botton half of property window](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/38738ae6-1f04-4973-0532-4653656c0f00/public) 7. Select if the property is for **Users**, **Applications**, or **Organizations**. 8. Select a **Category**. Use an existing one or create your own, see [Create property categories](/properties/work-with-properties/property-groups/). 9. Select the **Property type**. You can choose from Boolean, single line text, or multi line text. For more information, see below. 10. Select **Save**. ## Choosing a property type - Boolean: For when you want to indicate a true or false status, e.g. `paid_membership="true"` - Single line text: For including a short piece of info in a property, e.g. `membership_type="bronze"` - Multi line text: For including more substantial information, e.g. an address or business description. ## Include properties in tokens One of the powers of properties is being able to use them to [include custom claims in tokens](/properties/work-with-properties/properties-in-tokens/). To ensure a property can be used in tokens, make sure you switch off the **Private** option at step 6, in the procedure above. ## Edit or delete a property You can change the name and some property settings, but not all attributes can be edited. For example, you cannot change the property key once it has been created. You can also only delete the properties you created, not Kinde-created properties. <Aside type="warning"> Take care changing the availability of a property to be included in tokens, such as switching a property from public to private. This could cause a breaking change if the property is already used in tokens. See [Add and manage properties in tokens](/properties/work-with-properties/properties-in-tokens/). </Aside> 1. In Kinde, go to **Settings** **> Data management > Properties**. 2. Search or scroll for the property you want and select the three dots next to the property. 3. To edit, Choose **Edit property**, make the changes you want and select **Save**. 4. To delete, select **Delete property** then confirm that you want to delete.

# Properties - Work with properties - Add marketing tags using properties

> Comprehensive guide to using marketing tags as properties in Kinde including UTM tracking, Google Ads integration, and campaign analytics implementation

marketing tags, utm tags, google ads, campaign tracking, analytics, properties, auth flow, react sdk, api management, search api
properties, work-with-properties

Marketing analytics relies on data about customer behaviour. This can include how a customer finds you, e.g. through a campaign, and what a customer does when they interact. Kinde allows you to pass marketing tag data in tokens, and store it as [properties](/properties/about-properties/) in Kinde. From here, you can extrapolate campaign success and other metrics you wish to track. ## What tracking tags are supported? Out of the box Kinde gives you 3 categories containing marketing properties which are available at both an organization and user level: ### UTM tags category Contains the following properties: * UTM source `utm_source` * UTM medium `utm_medium` * UTM campaign `utm_campaign` * UTM content `utm_content` * UTM term `utm_term` ### Google Ads smart campaign tracking Contains the following properties: * Google ID `gclid` * Google click ID `click_id` * HSA account `hsa_acc` * HSA campaign `hsa_cam` * HSA group `hsa_grp` * HSA ad `hsa_ad` * HSA source `hsa_src` * HSA target `hsa_tgt` * HSA keyword `hsa_kw` * HSA match type `hsa_mt` * HSA network `hsa_net` * HSA version `hsa_ver` ### Marketing category Contains the following properties: * Match type `match_type` * Keyword `keyword` * Device `device` * Ad group `ad_group_id` * Campaign ID `campaign_id` * Creative `creative` * Network `network` * Ad position `ad_position` * Facebook ID `fbclid` * LinkedIn ID `li_fat_id` * Microsoft ID `msclkid` * X ID `twclid` * TikTok ID `ttclid` ## Getting marketing tags into Kinde There are a few mechanisms for updating these property values in Kinde. ### Pass the tracking tags via the auth flow This is the most common method. For example, if you want to pass in the UTM source, you just need to forward the `utm_source` query parameter as part of the sign up flow authentication url. Most of our SDKs allow you to pass this in via additional URL params. For example in the React SDK: ```jsx <RegisterLink className="btn btn-dark properties={{ utm_source: "my source", utm_medium: "some medium", utm_campaign: "awesome campaign", utm_content: "something else", utm_term: "my terms", click_id: "1234" }} >Register</RegisterLink> ``` We automatically map the standard query parameters to the specific Kinde properties for you. For example `utm_source` URL param will be mapped to the `kp_usr_utm_source` Kinde parameter for a user and `kp_org_utm_source` for an organization. We map these automatically so that you do not need to make changes to the parameters in your code. The property values are set during the sign up flow for new users and at the point of organization creation for new organizations. ### Update the tracking tags manually * Via dashboard - Open a user or organization in Kinde, then select *Properties* from the side navigation. Update the relevant property. * Via the Kinde Management API - * [Update user property](https://docs.kinde.com/kinde-apis/management/#tag/users/put/api/v1/users/{user_id}/properties/{property_key}) - make sure to add `kp_usr_` as a prefix to the standard tag key. * [Update organization property](https://docs.kinde.com/kinde-apis/management/#tag/organizations/put/api/v1/organizations/{org_code}/properties/{property_key}) - make sure to add `kp_org_` as a prefix to the standard tag key. ## Accessing marketing tags data * Via dashboard - Open a user or organization in Kinde, then select *Properties* from the side navigation. * Via the Kinde Management API - * [View user properties](https://docs.kinde.com/kinde-apis/management/#tag/users/get/api/v1/users/{user_id}/properties) * [View organization properties](https://docs.kinde.com/kinde-apis/management/#tag/organizations/get/api/v1/organizations/{org_code}/properties) ## Check how specific marketing tags are performing Likely you will want to see which tags are converting into sign ups and are performing well. For this, you can use the User search API to return all users that match a specific property value. For example, if you wanted to see all users who signed up with a UTM source of "Hello" and a UTM campaign of "World" you could use this query: ``` /api/v1/search/users?query=properties[kp_usr_utm_source]=Hello&properties[kp_usr_campaign]=World ``` The search organizations API is coming soon.

# Properties - Work with properties - Add and manage properties in tokens

> Guide to adding and managing properties in tokens including token customization rules for different application types and token types

properties in tokens, token customization, access tokens, id tokens, m2m tokens, public properties, token claims, backend applications, frontend applications, m2m applications
properties, work-with-properties

You can select what information to include in application tokens. Before you can add properties to tokens, they need to be set to **public** in the property settings. See [Add and manage properties](/properties/work-with-properties/manage-properties/). ## Applications and token customization rules - You can edit **Access tokens**, **ID tokens**, and **M2M tokens** for backend applications. - You can edit **Access tokens** and **ID tokens** for frontend applications. - You can only edit **M2M tokens** for M2M applications. ## Add properties to tokens 1. Open the relevant application. You can do this from the **Home** screen or in **Settings > Applications,** select **View details** on an application. 2. Select **Tokens**. 3. Scroll to the **Token customization** section. 4. Select **Customize** on the relevant token type. The **Customize [access/ID/M2M] token** dialog opens. 5. Select the **Properties** you want to add. These will be included in the token. 6. Select **Save**. ## Edit or remove properties from tokens 1. Open the relevant application. On the **Home** screen or in **Settings > Applications,** select **View details** on your application. 2. Select **Tokens**. and scroll to the **Token customization** section. 3. Select **Customize** on the relevant token type. The **Customize [access/ID/M2M] token** dialog opens. 4. Select or deselect the **Properties** you want to edit or remove. 5. Select **Save**.

# Properties - Work with properties - Add and manage property categories

> Guide to adding and managing property categories in Kinde for organizing user, organization, and application properties for better display and management

property categories, property groups, property organization, user properties, organization properties, application properties, api management, property display
properties, work-with-properties

In Kinde, properties are organized into categories so they can be more easily managed and displayed. A property category either applies to user, organization, or application data. You can also create and manage property categories through the [Kinde Management API](/kinde-apis/management#tag/property-categories). ## Add a property category 1. In Kinde, go to **Settings** **> Data management > Properties**. 2. Select **Categories**. A page opens showing the different categories for each property type: User, organization, or application. 3. Select **Add Category**. The **Add category** window opens. 4. Enter a name for the category. Remember this becomes a heading on the user, organization, or application properties page. 5. Select if the category is for users, organizations, or applications. 6. Select **Save**. Here’s an example: <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/8250f7ea-f6a2-4c47-2e40-a824ef4f4800/public" alt="" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" />

# Properties - Work with properties - View and edit user properties

> Guide to viewing and editing user properties in Kinde including manual editing and API management for user data

user properties, property management, user data, property editing, api management, property values, user details
properties, work-with-properties

If you use properties to manage user data, you can edit the property values manually in Kinde or [via API](/kinde-apis/management#tag/users/patch/api/v1/users/{user_id}/properties). ## View the properties of a user 1. In Kinde, go to **Users**. 2. Browse or search, and select the user who’s properties you want to view. 3. Select **Properties**. ## Edit property values for a user 1. In Kinde, go to **Users**. 2. Browse or search, and select the user who’s properties you want to view. 3. Select **Properties**. 4. Select **Edit** next to the property you want to change. 5. In the window that opens, enter or edit the value. 6. Select **Save**. ## Manage user properties via API You can also manage user properties via the [Kinde Management API](/kinde-apis/management#tag/users/patch/api/v1/users/{user_id}/properties).

# Releases - About - About feature flags

> Comprehensive overview of feature flags in Kinde including flag types, use cases, override mechanisms, and implementation examples for controlled feature releases

feature flags, feature toggles, boolean flags, string flags, integer flags, json flags, flag types, flag values, flag overrides, continuous delivery
releases, about

Feature flags, along with other kinds of development flags, are an essential part of building and managing digital products. Feature flags (sometimes called feature toggles) control who can see features in specific environments for your app or site. Feature flags are defined by a `key` identifier, flag `type`, and flag `value`, which gets included in your code. ## What to use feature flags for Feature flags let you control user access to specific features as they are being built. They keep untested features out of the hands of your customers and safe from accidental discovery. A simple application of a feature flag is to create a flag when you start working on a feature, then remove the flag when the feature is ready for release. There’s many benefits to using feature flags. - Engineers can keep their in-progress work confined to a development environment - Allows for more secure feature testing prior to release - Enables more granular release control, e.g. for continuous delivery - Gives you the ability to target users with specific features ## Types of feature flags in Kinde There are several types of feature flags that can be used for different reasons. Kinde currently offers: - **Boolean** - operate like an on/off switch using `true | false` values. Ideal for showing and hiding features or switching functions on and off. - **String** - to pass configuration values, e.g. colour, and content such as label text, etc. Say if you want to test if a green or a red button gets more clicks. - **Integer** - for updating numeric values using whole numbers only. Decimal numbers will be trimmed after the decimal point. The integer range is -2147483648 to +2147483647. - **JSON** - allow you to define a set of key-value pairs in a JSON file, where each key represents a feature or functionality in your application. ## Overriding feature flags Feature flag values cascade downward from the business level setting. You can also allow overrides to be applied in environments, organizations, or at the user level, as part of the flag definition. See [override feature flag values](/releases/feature-flags/edit-feature-flag/). | When the value is set or changed… | then the value is defined for… | | ----------------------------------------- | -------------------------------------------------------------- | | at the business level where it is created | all users in the environment and organizations in the business | | in an environment | all users in the environment | | for an organization | all users in the organization | | for a user | that user in every organization they belong to | ## Feature flag use cases ### Boolean You’re building a new major feature such as ‘notifications’ and you want to make sure that nobody can use it until development is complete. You set the feature value to `false` for everyone, to ensure it is hidden. But because you want to test it later, you also make sure that the value can be overriden for your testing environment. Once you’ve finished building and you’re ready to test, you change the value to `true` for the testing environment to enable your internal QA team to look at it. When it’s finished and bug-free, you can go back and change the value to `true` so all environments and organizations can access it. Released! ### String You want to test out some new button names in your app. You create a string type flag called `buy-button` where the value can be overridden for different environments and organizations. Instead of making changes in production, test them behind a flag to select organizations or cohorts before you decide what works best. For example, you could test if `buy it now` or `add to cart` is a more effective call to action. Another use for string flags is to apply a unique color scheme for each different environment you work in. Developers frequently switch between production, staging, and local environments as they work, and with string flags it’s easy to make these visually distinct. In his own project, one of Kinde’s founders created the `heading-color` string flag to distinguish each of his three environments: `yellow` for local, `orange` for staging, and `pink` for production. ### Integer Less used for releasing features than for controlling various elements in your app or site, integer flags enable more granular control in certain situations. For example, say you want to set the number of items you display on a page in your online store, you can use an integer flag to create a page limit. You might set the display limit to 12 for mobile devices, and to 24 for desktop. Integer flags can also be used to set other limits, such as limiting the number of concurrent requests to an API endpoint, or to limit the number of password attempts before locking a user out. The advantage of using a flag for this is being able to edit the value and deploy changes quickly and easily, without major code updates. ### JSON With JSON feature flags, you can define a set of key-value pairs in a JSON file, where each key represents a feature or functionality in your application. For example: ```json { "is_dark_mode": true, "font_size": "large", "employee_count": 5 } ``` JSON feature flags might suit you if you use a separate feature flag management system or library for your application.

# Releases - Feature flags - Add a feature flag in Kinde

> Step-by-step guide to adding feature flags in Kinde including flag types, key naming, value configuration, and override settings for controlled feature releases

add feature flag, feature flag creation, flag types, boolean flags, string flags, integer flags, json flags, flag keys, flag values, flag overrides
releases, feature-flags

Kinde’s feature flags enable you to control how you release features to your users. You can add them through the Kinde admin interface, or you can connect and add flags via API. The procedure below is for adding them in Kinde. Learn more about flags. ## Add a feature flag 1. Go to **Releases > Feature flags**. 2. Select **Add feature flag**. 3. Enter a **Name** and **Description** for the flag. Try to keep names short, but be descriptive enough to recognize the flag purpose. 4. Enter a **Key** for the flag. This will be referenced in your code. For example `feature-key` or `feature_key`. Stick to whatever naming pattern you use in your code, such as hyphen separated (kebab case), or underscore separated (snake case), etc. <Aside type="danger"> Keys cannot be edited later or your code might break </Aside> <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/2b576fb7-2a3e-4bac-ddfd-7940ff736500/public" alt="Adding a feature flag" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" /> 5. Define the flag by selecting a **Type** and **Value**. - **Boolean** - operate like an on/off switch using `true | false` values. Ideal for showing and hiding features or switching functions on and off. - **String** - to pass configuration values, e.g. color, and content such as label text, etc. Say if you want to test if a green or a red button gets more clicks. - **Integer** - for updating numeric values using whole numbers only. Decimal numbers will be trimmed after the decimal point. The integer range is -2147483648 to +2147483647. - **JSON** - allow you to define a set of key-value pairs in a JSON file, where each key represents a feature or functionality in your application. <Aside type="danger"> The flag type cannot be edited later or your code might break </Aside> <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/5470f527-c511-4190-e93e-2c220a6f2b00/public" alt="" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" /> 6. For String, Integer, and JSON type flags, enter the flag value in the field that appears. 7. Select if you want to allow the flag value to be set differently in environments, for users, or for organizations. You might do this, for example, if a feature is to have a limited release for testing. Note that currently, you cannot edit this once the flag has been added. Consider if you want to enable this option now. <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/1ea5f847-6480-4022-9c2b-a31861662d00/public" alt="" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" /> 8. Select **Save**.

# Releases - Feature flags - Override feature flag values

> Guide to overriding feature flag values at environment, organization, and user levels including inheritance rules and testing scenarios

override feature flags, flag overrides, environment overrides, organization overrides, user overrides, flag values, flag inheritance, feature testing, early access, flag cascading
releases, feature-flags

It’s common practice to override feature flag values for specific environments or for specific organizations or users. This might be done to enable feature testing, to analyse the effectiveness of a change, or to give early access to a preferred customer. Feature flags values cascade from business to environment to organization to user. But overrides can be applied if they are available. ## Check if a flag override is available 1. Go to **Releases > Feature flags**. 2. Find the flag in the list. 3. Check the column indicating where overrides can be applied. <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/a0c63a40-d3ae-4cde-31cd-4648569ff300/public" alt="The column showing where an override can be applied" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" /> If overrides are allowed, follow one of the below procedures. ## Override feature flag value in an environment When you apply an override in an environment, it will be applied to all users in the environment. 1. Go to **Settings > Environment > Feature flags**. All the feature flags are listed. 2. Find the flag you want to update and select **Edit value**. You can only do this if the flag value can be overridden for environments. 3. In the **Edit feature flag** window: 1. For Boolean flag types, select the new value and then select **Save**. 2. For string, integer, or JSON flag types, enter the new value and then select **Save**. 4. If you want to revert to the inherit default value, in the **Edit feature flag** window: 1. For Boolean flag types, select the default value and then select **Save**. 2. For string, integer, or JSON flag types, enter the new value and then select **Save**. ## Override feature flag value for an organization When you apply a value override for an organization, it will be applied for all users in the organization. 1. Go to **Organizations** and select the organization. The **Organization details** window opens. 2. Select **Feature flags**. All the feature flags are listed. 3. Find the flag you want to update and select **Edit value**. You can only do this if the flag value can be overridden for organizations. 4. In the **Edit feature flag** window: 1. For Boolean flag types, select the new value and then select **Save**. 2. For string, integer, or JSON flag types, enter the new value and then select **Save**. 5. If you want to revert to the inherit default value, in the **Edit feature flag** window: 1. For Boolean flag types, select the default value and then select **Save**. 2. For string, integer, or JSON flag types, enter the new value and then select **Save**. ## Override feature flag value for a user When you apply a value override for a user, it will be applied for that user across all organizations. 1. Go to **Users** and select the user. Their profile opens. 2. Select **Feature flags**. All the feature flags available to this user are listed. 3. Find the flag you want to update and select **Edit value**. You can only do this if the flag value can be overridden for users. 4. In the **Edit feature flag** window: 1. For Boolean flag types, select the new value and then select **Save**. 2. For string, integer, or JSON flag types, enter the new value and then select **Save**. 5. If you want to revert to the inherit default value, in the **Edit feature flag** window: 1. For Boolean flag types, select the default value and then select **Save**. 2. For string, integer, or JSON flag types, enter the new value and then select **Save**.

# Releases - Feature flags - Manage feature flags through the Kinde API

> Guide to managing feature flags through the Kinde API including setup requirements and available flag management functions

feature flags api, kinde api, m2m application, access token, add flag, edit flag, override flag, delete flag, api management, management api
releases, feature-flags

You can add and manage Kinde’s feature flags through the Kinde API as well as through the main admin interface. ## What you need - A machine to machine application set up to [connect to the Kinde Management API](/developer-tools/kinde-api/connect-to-kinde-api/) - [A valid access token](/developer-tools/kinde-api/connect-to-kinde-api/) ## Current flag functions in the API If you plan to use feature flags through the Kinde API, you will be able to do the following: - Add a new flag - Edit a flag - Override a flag value in an environment or organization - Delete a flag [See relevant posts and responses in the API documentation.](/kinde-apis/management#tag/feature-flags)

# Releases - Feature flags - Manage feature flags

> Guide to managing feature flags in Kinde including searching, editing, deleting, and best practices for flag lifecycle management

manage feature flags, edit feature flags, delete feature flags, flag search, flag sorting, flag editing, breaking changes, flag deletion, beta access, incremental rollout
releases, feature-flags

Feature flags let you control user access to specific features in your app or site. Typically, feature flags are used to restrict feature access while a feature is being built. You can incrementally roll the feature out by giving beta access to specific users, organizations, or environments, and then remove the flag when the feature is ready for global release. Once a flag is created, you can only edit the name, description and default value. If you’re not familiar with feature flags, you might want to read up about feature flags first. ## Find a feature flag You can search feature flags by name or key. 1. Go to **Releases > Feature flags**. <img src="https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/d5b6da7f-3e05-45d7-b39f-2d88df6eb600/public" alt="The Feature flags page in Kinde" width="672px" height="auto" fetchpriority="low" loading="lazy" decoding="async" /> 2. Click a column heading to sort the list. 3. Type a flag name in the search bar above the list to find a specific flag. 4. Press **Enter** to show results. 5. Clear the list by deleting the search term and pressing **Enter**. ## Edit a feature flag You can only change the name, description, and default value of a feature flag. This changes the default value for all users that inherit the flag value. <Aside type="danger" title="You cannot edit the key, type, or override definitions of a feature flag"> Editing these fields in a feature flag that is in use will cause breaking changes in your code, which is why we don’t allow it. We suggest you create a new flag in cases where you make an error when you create a flag, or if you want to re-purpose a flag. </Aside> 1. Go to **Releases > Feature flags**. 2. Select the three dots menu on the flag entry, and select **Edit feature flag**. 3. Edit the **Name** or **Description**. 4. Edit the **Default value**. 5. Select **Save**. The changes will apply to all environments, organizations, and users that inherit the flag value. If you just want to edit the flag value in a specific environment or for a particular organization or user, see [Override feature flag values](/releases/feature-flags/edit-feature-flag/). ## Delete a feature flag You can delete a feature flag in Kinde. Deleting also removes any flag value overrides in environments, organizations, and for users. This action is not reversible. 1. Go to **Releases > Feature flags**. 2. Select the three dots menu on the flag entry, and select **Delete feature flag**. 3. In the confirmation window that appears, select **Delete feature flag**.

# Releases - Guides - Guide to app store reviews

> Comprehensive guide to preparing apps for app store reviews including Apple App Store and Google Play Store authentication setup and feature flag integration

app store review, apple app store, google play store, testflight, sandbox receipt, hidden login, deep link, feature flags, review environment, authentication
releases, guides

This guide is designed to help prepare your app for an app store review if you’re using Kinde for auth. It provides recommendations and solutions for setting up reviewer access. This isn’t a complete list of preparation tasks, and there’s no guarantee your app will pass using only this guide, but it’s a solid starting point. We’ll continue updating it as new scenarios arise. If you have suggestions, let us know. ## Prepare for Apple App Store review Here’s how to set up Kinde in preparation for an Apple App Store review. We recommend setting up a hidden login route that’s only active when your app is being reviewed by Apple. Here’s how: ### Step 1: Detect the App Store review environment Apple doesn’t offer an official way to detect its review environment, but you can use a few indirect methods. **Method A: Check for a sandbox receipt** When Apple reviews your app, all transactions occur in a sandbox environment. On iOS, you can check whether the app’s receipt is a sandbox receipt: ```swift func isRunningInTestFlightOrAppStoreReview() -> Bool { #if DEBUG return false // Debug builds should not use the hidden route #else if let url = Bundle.main.appStoreReceiptURL { return url.lastPathComponent == "sandboxReceipt } return false #endif } ``` This method works because Apple’s review devices generate a `sandboxReceipt` file. **Method B: Check TestFlight for a sandbox receipt** If your app is distributed via TestFlight, you can also check for a sandbox receipt: ```swift func isRunningInTestFlight() -> Bool { return Bundle.main.appStoreReceiptURL?.lastPathComponent == "sandboxReceipt } ``` ### Step 2: Create a hidden login route for Apple testers Once you detect that the app is running in Apple’s review environment, you can enable a special login route. **Method A: Display a hidden sign-in button** Using this method, you display a hidden sign-in button only when `isRunningInTestFlightOrAppStoreReview()` returns `true`. Testers can then sign in with predefined credentials: ```swift if isRunningInTestFlightOrAppStoreReview() { showHiddenLoginButton() } ``` **Method B: Provide a deep link for signing in** Using this method, you provide Apple with a deep link like `myapp://hidden-login`. You must ensure this route is only active when the app is in review mode. You can set this up so that when Apple taps the link, they are signed in automatically or they are shown a sign-in screen with pre-filled demo credentials. You might need to set up a webhook or other alert so you know when the link is clicked. ### Step 3: Add notes in the App Store review submission Whatever method you use, clearly explain how testers can access your app in the **App Review Notes**. Provide the method and the credentials they can use. Example message: > Dear Apple Reviewer, Since our app does not use email/password authentication, we have created a hidden sign in option for you to test. If you are testing in `TestFlight` or the App Store review environment, a special sign in button will appear. Alternatively, access the sign in screen via this deep link: `myapp://hidden-login` Test credentials: review@myapp.com P******d > ## Google Play Store Here’s how to set up Kinde in preparation for an Google Play review. We recommend setting up a hidden login route that’s only active when your app is being reviewed by Google. Here’s how to set up a hidden authentication route for the Google Play app review process. ### Step 1: Detect the Google Play review environment Google Play doesn’t offer an official review environment flag, but you can use indirect methods to detect it: - **Check the installer package**: Apps installed from Google Play will have `com.android.vending` as the installer. - **Check device characteristics**: Review devices may share common traits, though this is less reliable. **Example (Kotlin):** ```kotlin import android.content.Context import android.content.pm.PackageManager fun isGooglePlayReviewEnvironment(context: Context): Boolean { val installer = context.packageManager.getInstallerPackageName(context.packageName) return installer == "com.android.vending } ``` ### **Step 2: Restrict access to the hidden auth route** Once you detect the review environment, create a secure, hidden API route. 1. Check for a secret token in the request header. 2. Allow access only if the token matches your predefined key. **Example (Next.js API Route):** ```kotlin import { NextResponse } from 'next/server'; export async function POST(req: Request) { const playStoreSecret = req.headers.get('x-play-review-secret'); const isPlayStoreReview = playStoreSecret === process.env.PLAY_REVIEW_SECRET; if (isPlayStoreReview) { return NextResponse.json({ message: 'Hidden auth route accessed!' }); } else { return NextResponse.json({ error: 'Forbidden' }, { status: 403 }); } } ``` ### **Step 3: Add a secret header in the app (during review only)** When the app detects it's running in the Google Play review environment, send the secret header. **Example (Kotlin using Retrofit):** ```kotlin val isReview = isGooglePlayReviewEnvironment(context) if (isReview) { val request = Request.Builder() .url("https://yourapi.com/hidden-auth") .header("x-play-review-secret", "your-secret-key") .build() } ``` **Official resources** - [Requirements for providing login credentials for app access](https://support.google.com/googleplay/android-developer/answer/15748846?hl=en&sjid=2614470000031657771-NC) - [Make your app available for review](https://playacademy.exceedlms.com/student/collection/260728/path/345815/activity/776873) ## Use Kinde feature flags to switch on review mode You can use Kinde feature flags to dynamically enable hidden routes or functionality during the app review process—without needing to redeploy or hard-code conditions. ### Step 1: Create a feature flag 1. In **Kinde** go to **Settings > Feature Flags.** 2. Select **Add feature flag**. The **Add feature flag** window opens. ![feature flag top half of screen](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/59e501e6-77d6-4cf6-feed-b88a46a96f00/public) 3. Fill out the name, description, and key (e.g., `app_store_review_mode`). 4. Select **Boolean** as the flag type. ![feature flag screen bottom half in Kinde](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/abd5ae55-cb13-4467-0d4b-d7eae2d7f800/public) 5. Set the **Boolean definition** to `false` (default state). 6. Select **Save**. You’ll toggle this flag to `true` during the review period, then back to `false` afterward. ### Step 2: Manage the flag in your backend You’ll now use the flag in your backend logic to control access to a hidden login route. **Example: Next.js API Route with Kinde Feature Flag:** ```tsx import { NextResponse } from 'next/server'; import { getKindeServerSession } from '@kinde-oss/kinde-auth-nextjs/server'; export async function POST(req: Request) { const { getBooleanFlag } = getKindeServerSession(); const isFeatureEnabled = await getBooleanFlag( 'app_store_review_mode', // Your feature flag key false // Default value ); if (isFeatureEnabled.value) { return NextResponse.json({ message: 'Hidden auth route accessed via feature flag!' }); } else { return NextResponse.json({ error: 'Forbidden' }, { status: 403 }); } } ``` ### Step 3: Toggle the flag during review When you submit your app for review: - Set the flag `app_store_review_mode` to **true** in the Kinde dashboard. - After approval, set it back to **false** to hide the route again. ## You're ready to give app access to app store reviewers! With these strategies, you can securely provide access to your app, for both Apple and Google Play reviewers, while keeping the login routes hidden from real users. Using tools like Kinde feature flags, deep links, and environment checks ensures your review process is smooth and secure. ## Need help? Join the [Kinde community on Slack](https://join.slack.com/t/thekindecommunity/shared_invite/zt-1vyq8qilj-jFH5V27jfFnHk~BuBSU0ZA) or the [Kinde community on Discord](https://discord.com/invite/tw5ng5tK6V) for support and advice from our team and other legends working with Kinde.

# Trust center - Agreements - End User Licence Agreement

> Complete End User License Agreement (EULA) for Kinde's platform covering terms of service, intellectual property rights, liability limitations, PCI DSS compliance, and legal obligations for users.

EULA, license agreement, terms, legal, compliance, intellectual property, liability, PCI DSS
trust-center, agreements, legal

1. ## **Our Disclosures** Our complete terms and conditions are contained below, but some important points for you to know before you access the Platform 1. We may amend these Terms, or the features of the Platform at any time, by providing written notice to you; 2. We will handle your personal information in accordance with our privacy policy, available on our Website; 3. Our liability under these Terms is limited to us resupplying the Platform to you, and we will not be liable for Consequential Loss, any loss that is a result of a Third Party Service, or any loss or corruption of data; and 4. We may receive a benefit (which may include a referral fee or a commission) should you visit certain third-party websites via a link on the Platform or for featuring certain products or services on the Platform. 2. ## Introduction 1. These terms and conditions (**Terms**) are entered into between Kinde Australia Pty Ltd ABN 11 655 096 263 (**we**, **us** or **our**) and you, together the **Parties** and each a **Party**. 2. We provide a cloud-based, software as a service platform where we help our customers with, authentication, authorisation user management, feature management, experimentation, advanced billing features and other back-office features for running and managing their businesses (**Platform**). 3. In these Terms, **you** means the person or entity using the Platform. If you are agreeing to these Terms not as an individual but on behalf of your company, government, or other entity for which you are acting (for example, as an employee or governmental official), then you means your entity and you are binding your entity to these Terms. 3. ## Acceptance and Platform Licence 1. You accept these Terms by registering on the Platform, or using the Platform. 2. You must be at least 16 years old to use the Platform. 3. We may amend these Terms at any time, by providing written notice to you. By continuing to use the Platform after the notice or 30 days after notification (whichever date is earlier), you agree to the amended Terms. If you do not agree to the amendment, you may cease accessing the Platform. 4. Subject to your compliance with these Terms, we grant you a personal, non-exclusive, royalty-free, revocable, worldwide, non-transferable licence to use our Platform in accordance with these Terms. All other uses are prohibited without our prior written consent. 5. When using the Platform, you must not do or attempt to do anything that is unlawful or inappropriate, including: 1. anything that would constitute a breach of an individual’s privacy (including uploading private or personal information without an individual’s consent) or any other legal rights; 2. using the Platform to defame, harass, threaten, menace or offend any person, including using the Platform to send unsolicited electronic messages; 3. tampering with or modifying the Platform (including by transmitting viruses and using trojan horses); 4. using data mining, robots, screen scraping or similar data gathering and extraction tools on the Platform; or 5. facilitating or assisting a third party to do any of the above acts. 4. ## Kinde Services 1. We agree to use our best endeavours to make the Platform available at all times. However, from time to time we may perform reasonable scheduled and emergency maintenance, and the Platform may be unavailable during the times we are performing such maintenance. 2. You acknowledge and agree that the Platform may be reliant on, or interface with third party systems that are not provided by us (for example, cloud storage providers, email clients, and internet providers) (**Third Party Services**). To the maximum extent permitted by law, we shall have no Liability for any Third Party Services, or any unavailability of the Platform due to a failure of the Third Party Services. 3. Without limiting clause 4.2, to enjoy Kinde Services, including the billing feature, you must have your own account with our designated payment processor. You acknowledge and agree that you are responsible for setting up and managing this account independently, and for complying with the payment processor’s policies and fees. 4. You acknowledge and agree that data loss is an unavoidable risk when using any software. To the extent you input any data into the Platform, you agree to maintain a backup copy of any data you input into the Platform. 5. To the maximum extent permitted by law, we shall have no Liability to you for any loss or corruption of data, or any scheduled or emergency maintenance that causes the Platform to be unavailable. 5. ## Access to the Platform 1. You must register on the Platform to access the Platform’s features. You will be invited to access the Platform via an email with a link provided by the entity you are involved with or you may also sign up on the Platform. 2. You must provide basic information when registering for the Platform including your contact name and email address and you may be asked to choose a password. 3. All personal information you provide to us will be treated in accordance with our Privacy Policy. 4. You agree not to share your login details with any other person. Your login is personal and you must not transfer or provide it to others. 5. You are responsible for keeping your login details and your username and password confidential and you will be liable for all activity via your login. You agree to immediately notify us of any unAuthorised use of your login. 6. ## PCI DSS 1. We acknowledge that we are responsible for complying with the Payment Card Industry Data Security Standards (as amended and updated from time to time) (PCI DSS) when we store, process, transmit or access your credit card details. We confirm that we are compliant with the PCI DSS. 2. We will notify you should we become aware of any actual or potential non-compliance of PCI DSS requirements. 3. If requested by you in writing, we will provide you with evidence of our compliance in the form of a current attestation of compliance. 4. We will create and maintain reasonably detailed and complete documentation which conforms with the PCI DSS, describing the systems, processes, security controls, etc. used by us to receive, transmit, store and secure credit card details that we hold. Such documentation and the persons responsible for implementing such processes, systems, etc. will be made available to you, your QSA and any other relevant third parties retained by you to assess our compliance. 7. ## Our Intellectual Property 1. You acknowledge and agree that any Intellectual Property or content (including copyright and trademarks) available on the Platform, the Platform itself, and any algorithms or machine learning models used on the Platform (**Our Intellectual Property**) will at all times vest, or remain vested, in us. 2. We Authorise you to use Our Intellectual Property solely for your limited commercial use. You must not exploit Our Intellectual Property for any other purpose, nor allow, aid or facilitate such use by any third party. 3. You must not, without our prior written consent: 1. copy, in whole or in part, any of Our Intellectual Property; 2. reproduce, retransmit, distribute, disseminate, sell, publish, broadcast or circulate any of Our Intellectual Property to any third party; or 3. breach any intellectual property rights connected with the Platform, including (without limitation) altering or modifying any of Our Intellectual Property, downloading Our Intellectual Property, causing any of Our Intellectual Property to be framed or embedded in another website, or creating derivative works from any of Our Intellectual Property. 8. ## Warranties 1. You represent, warrant and agree that: 1. you will not use our Platform, including Our Intellectual Property, in any way that competes with our business; 2. if you are agreeing to these Terms not as an individual but on behalf of your company, government, or other entity for which you are acting (for example, as an employee or governmental official), then you access and use the Platform on behalf of that entity; 3. there are no legal restrictions preventing you from entering into these Terms; 4. all information and documentation that you provide to us in connection with these Terms is true, correct and complete; and 5. you have not relied on any representations or warranties made by us in relation to the Platform (including as to whether the Platform is or will be fit or suitable for your particular purposes), unless expressly stipulated in these Terms. 9. ## Liability 1. Despite anything to the contrary, to the maximum extent permitted by law: 1. you agree to indemnify us for any Liability we incur due to your breach of the Acceptance and Platform Licence clause and the Intellectual Property clause of these Terms; 2. neither Party will be liable for Consequential Loss; 3. each Party’s liability for any Liability under these Terms will be reduced proportionately to the extent the relevant Liability was caused or contributed to by the acts or omissions of the other Party or any of that Party’s personnel, including any failure by that Party to mitigate its losses; and 4. our aggregate liability for any Liability arising from or in connection with these Terms will be limited to us resupplying the Platform to you. 10. ## Access 1. We may revoke your access to the Platform at any time by giving 15 days’ written notice to you. 2. Should we suspect that you are in breach of these Terms, we may suspend your access to the Platform while we investigate the suspected breach. Should we determine that you are in breach of these Terms, your access to the Platform will be terminated immediately. 11. ## General 1. **Assignment:** You must not assign or deal with the whole or any part of your rights or obligations under these Terms without our prior written consent. 2. **Disputes:** A Party may not commence court proceedings relating to a dispute without first meeting with the other Party to seek (in good faith) to resolve the dispute, failing which the Parties agree to engage a mediator to attempt to resolve the dispute. The costs of the mediation will be shared equally between the Parties. Nothing in this clause will operate to prevent a Party from seeking urgent injunctive or equitable relief from a court of appropriate jurisdiction. 3. **Entire Terms:** These Terms contains the entire understanding between the Parties and the Parties agree that no representation or statement has been made to, or relied upon by, either of the Parties, except as expressly stipulated in these Terms, and these Terms supersedes all previous discussions, communications, negotiations, understandings, representations, warranties, commitments and agreements, in respect of its subject matter. 4. **Force Majeure:** To the maximum extent permitted by law, we shall have no Liability for any event or circumstance outside of our reasonable control. 5. **Governing law:** This Agreement is governed by the laws of New South Wales, Australia. Each Party irrevocably and unconditionally submits to the exclusive jurisdiction of the courts operating in New South Wales, Australia and any courts entitled to hear appeals from those courts and waives any right to object to proceedings being brought in those courts. 6. **Notices:** Any notice given under these Terms must be in writing addressed to us at the details set out below or to you at the details provided when you sign up to the Platform. Any notice may be sent by standard post or email, and will be deemed to have been served on the expiry of 48 hours in the case of post, or at the time of transmission in the case of transmission by email. 7. **Privacy:** We agree to comply with the legal requirements of the Australian Privacy Principles as set out in the Privacy Act 1988 (Cth) and any other applicable legislation or privacy guidelines. 8. **Severance:** If a provision of these Terms is held to be void, invalid, illegal or unenforceable, that provision is to be read down as narrowly as necessary to allow it to be valid or enforceable, failing which, that provision (or that part of that provision) will be severed from these Terms without affecting the validity or enforceability of the remainder of that provision or the other provisions in these Terms. 9. **Third party sites:** The Platform may contain links to websites operated by third parties. Unless we tell you otherwise, we do not control, endorse or approve, and are not responsible for, the content on those websites. We recommend that you make your own investigations with respect to the suitability of those websites. If you purchase goods or services from a third party website linked from the Platform, such third party provides the goods and services to you, not us. We may receive a benefit (which may include a referral fee or a commission) should you visit certain third-party websites via a link on the Platform (Affiliate Link) or for featuring certain products or services on the Platform. We will make it clear by notice to you which (if any) products or services we receive a benefit to feature on the Platform, or which (if any) third party links are Affiliate Links. 12. ## Definitions 1. **Consequential Loss** includes any consequential loss, indirect loss, real or anticipated loss of profit, loss of benefit, loss of revenue, loss of business, loss of goodwill, loss of opportunity, loss of savings, loss of reputation, loss of use and/or loss or corruption of data, whether under statute, contract, equity, tort (including negligence), indemnity or otherwise. 2. **Intellectual Property** means any domain names, know-how, inventions, processes, trade secrets or confidential information; or circuit layouts, software, computer programs, databases or source codes, including any application, or right to apply, for registration of, and any improvements, enhancements or modifications of, the foregoing. 3. **Liability** means any expense, cost, liability, loss, damage, claim, notice, entitlement, investigation, demand, proceeding or judgment (whether under statute, contract, equity, tort (including negligence), indemnity or otherwise), howsoever arising, whether direct or indirect and/or whether present, unascertained, future or contingent and whether involving a third party or a party to these Terms or otherwise. **Website** is [https://kinde.com](https://kinde.com/). **For any questions or notices, please contact us at:** Kinde Australia Pty Ltd ([ABN 11 655 096 263](https://abr.business.gov.au/ABN/View?abn=11655096263)) Email: support@kinde.com Last update: 12 June 2025

# Trust center - Agreements - Terms of Service

> Complete Terms of Service for Kinde's platform covering subscription terms, billing, intellectual property rights, data ownership, PCI DSS compliance, liability limitations, and legal obligations for business users.

terms of service, legal, agreement, subscription, billing, PCI DSS, intellectual property, liability, modern slavery
trust-center, agreements, legal

Welcome to Kinde - a beautifully simple dev-acceleration infrastructure software platform for SaaS teams. We’re excited to help you build, launch, and get to market faster and with more confidence. 1. **Our Disclosures** Our complete terms of service are contained below, but some important points for you to know before you become a customer are set out below: 1. We may amend these Terms, the features of the Platform or your Subscription at any time, by providing written notice to you; 2. Unless your Subscription is suspended or terminated in accordance with these Terms, your Subscription will roll over on an ongoing basis; 3. We will handle your personal information in accordance with our privacy policy, available on our website; 4. To the maximum extent permitted by law, the Fees are non-refundable; 5. You are responsible and liable for the actions of your Authorised Users; 6. Our liability under these Terms is limited to us resupplying the Platform to you or, in our sole discretion, to us repaying you the amount of the Fees paid by you to us during the term of your Subscription, and we will not be liable for Consequential Loss, any loss that is a result of a Third Party Service, or any loss or corruption of data; 7. We may terminate your Subscription at any time by giving 15 days’ written notice to you; and 8. We may receive a benefit (which may include a referral fee or a commission) should you visit certain third-party websites via a link on the Platform or for featuring certain products or services on the Platform. 9. Nothing in these terms limit your rights under the Australian Consumer Law. 2. **Introduction** 1. These terms of service (Terms) are entered into between Kinde Australia Pty Ltd ACN 655 096 263 (we, us or our) and you, together the Parties and each a Party. 2. We provide a cloud-based, software as a service platform where we help you build authentication, authorisation, user management, feature management, experimentation, billing and other back-office features for running and managing your business (Platform). Our Platform supports both B2B and B2C use cases, allowing you to manage subscriptions and assign plans at both the organisation and individual user level. As part of your use of the Platform you may use the Platform, you may facilitate transactions between you and your customers, set up subscription plans, process payments, control feature access for your end users, and other Platform functions to streamline your business operations. 3. In these Terms, you means the person or entity registered with us as an Account holder. 4. If you are using the Platform on behalf of your employer or a business entity, you, in your individual capacity, represent and warrant that you are Authorised to act on behalf of your employer or the business entity and to bind the entity and the entity’s personnel to these Terms. 3. **Acceptance and Platform Licence** 1. You accept these Terms by registering on the Platform or using the Platform. 2. We may amend these Terms at any time, by providing written notice to you. By continuing to use the Platform after the notice or 30 days after notification (whichever date is earlier), you agree to the amended Terms. If you do not agree to the amendment, you may terminate your Subscription in accordance with the “Cancellation of Subscription” clause. 3. We may use third party APIs. Your use of those products is subject to their own terms of service. 4. Subject to your compliance with these Terms, we grant you and your Authorised Users a personal, non-exclusive, royalty-free, revocable, worldwide, non-transferable licence to use our Platform in accordance with these Terms. All other uses are prohibited without our prior written consent. 5. When using the Platform, you and your Authorised Users must not do or attempt to do anything that is unlawful or inappropriate, including: 1. anything that would constitute a breach of any laws, including any criminal activity; 2. anything that would constitute a breach of an individual’s privacy (including uploading private or personal information without an individual’s consent) or any other legal rights; 3. using the Platform to defame, harass, threaten, menace or offend any person, including using the Platform to send unsolicited electronic messages; 4. tampering with or modifying the Platform (including by transmitting viruses and using trojan horses); 5. using data mining, robots, screen scraping or similar data gathering and extraction tools on the Platform; or 6. facilitating or assisting a third party to do any of the above acts. 6. You acknowledge and agree that you will be responsible for ensuring your use of the Platform is compliant with all applicable laws and regulations, including but not limited to ensuring you comply with any age or jurisdictional limitations in your use of the Platform. 4. **Kinde Services** 1. In consideration for your payment of the Fees, we agree to provide you and your Authorised Users with access to the Platform, the support services as detailed in this section, and any other services we agree to provide as set out in your Account. 2. We agree to use our best endeavours to make the Platform available at all times. However, from time to time we may perform reasonable scheduled and emergency maintenance, and the Platform may be unavailable during the times we are performing such maintenance. 3. Should you be unable to access the Platform, or should you have any other questions or issues impacting on your use and enjoyment of the Platform, you and your Authorised Users must place a request via our support channels which can be found on our website’s support page. We will endeavour to respond to any support requests in a reasonable period. We may require access to your Account to provide support services. 4. You acknowledge and agree that the Platform may be reliant on, or interface with third party systems that are not provided by us (for example, cloud storage providers, email clients, tracking and internet providers) (Third Party Services). To the maximum extent permitted by law, we shall have no Liability for any Third Party Services, or any unavailability of the Platform due to a failure of the Third Party Services. 5. You acknowledge and agree that data loss is an unavoidable risk when using any software. To the extent you input any data into the Platform, you agree to maintain a backup copy of any data you input into the Platform. 6. To the maximum extent permitted by law, we shall have no Liability to you for any loss or corruption of data, or any scheduled or emergency maintenance that causes the Platform to be unavailable. 5. **Accounts** 1. You must register on the Platform and create an account (**Account**) to access the Platform’s features. Each Authorised User will require a login that is linked to your Account in order to access the Platform. 2. You must provide basic information when registering for an Account including your business name, contact name and email address and you may need to choose a password. 3. You may also register for an Account using your social media network account (**Social Media Account**). If you sign in to your Account using your Social Media Account, you authorize us to access certain information on your Social Media Account including but not limited to your current profile photo and other basic information. 4. All personal information you and your Authorised Users provide to us will be treated in accordance with our Privacy Policy. 5. You agree to provide and maintain up to date information in your Account and to not share your Account password with any other person. Your Account is personal and you must not transfer or provide it to others with the exception of your Authorised Users. 6. You are responsible for keeping your Account details and your username and password confidential and you will be liable for all activity on your Account, including purchases made using your Account details, and any activity from one of your Authorised Users. Each Authorised User is responsible for keeping their login details confidential. You agree to immediately notify us of any unAuthorised use of your Account. 7. When you create an Account, you will automatically be provided with a subscription (**Subscription**). You may choose between different tiers of Subscription with different services and different Subscription periods as set out on our Platform. 6. **Email Communication** 1. All users subscribing to our Platform are required to provide a valid and active email address for communication purposes. It is your responsibility to ensure that the email address associated with your account is kept current and accessible. Our Platform relies on email as the primary mode of communication for sending important notifications, updates, billing invoices, and support-related correspondence. Failure to receive such communications due to an incorrect or inaccessible email address can lead to disruptions in service or important missed notifications. 2. If, for any reason, you becomes uncontactable via the email address provided, or if we receive bounce-backs, auto-responses, or any other indications that an email has not been successfully delivered, we reserve the right to suspend or terminate your Subscription to our Platform, at our sole discretion. 3. Before any such action is taken, we will make reasonable attempts to contact you to rectify the situation. However, if these attempts are unsuccessful and we are unable to establish contact via email within a reasonable timeframe, suspension or termination may be enacted. 7. **Authorised Users** 1. If set out in your Account, you may be permitted to invite a number of users to the Platform, who will be permitted to access and use the Platform under your Account (**Authorised Users**). We agree to provide you with the number of Authorised Users as set out in your Account. 2. The Authorised Users will have permission to access certain features of the Platform and your Account, as detailed in your Account and you may adjust these permission settings in your Account. 3. You will ensure that each Authorised User complies with these Terms and our End User Licence Agreement. You are responsible and liable for the acts or omissions of your Authorised Users. 4. Each Authorised User must agree to our End User Licence Agreement (as available on our website) in order to access the Platform. 8. **Subscriptions** 1. Your Subscription will last for the period specified in your Account. We will charge your chosen payment method for the Subscription you have chosen and its corresponding Subscription fee (**Subscription Fees**) and usage fee (**Usage Fee**) on the day set out in your Account (**Payment Date**), or as communicated in writing to you. 2. The fee structure for our Platform is as set out on our website. The fees are charged based on your access to and use of the Platform. For transactions processed through our billing product, fees are deducted before funds are sent to your account. We may bill certain fees monthly or at the time the end customer transaction is made, depending on our billing provider. 3. To use our billing feature, you must have an account with one of our designated payment processors. You are responsible for setting up and managing these accounts independently, and for complying with the payment processor’s policies and fees. 4. Unless your Subscription is suspended or terminated in accordance with these Terms, your Subscription will roll over on an ongoing monthly basis, and you will be charged the same Subscription Fees on an ongoing monthly basis from the Payment Date. Without limiting your rights under the Australian Consumer Law, you can cancel your Subscription at any time in accordance with the “Cancellation of Subscriptions” clause of these Terms but the cancellation will only have effect from expiry of the monthly period for which you have paid the Subscription Fees and Usage Fees. 5. We support transactions in multiple currencies. For a full list of supported currencies, please refer to our documentation. 6. The payment methods we offer for the Subscription Fees and Usage Fees are set out on the Platform. We may offer payment through a third-party provider. You acknowledge and agree that we have no control over the actions of the third-party provider, and your use of the third-party payment method may be subject to additional terms and conditions. 7. You must not pay, or attempt to pay, the Subscription Fees and Usage Fees by fraudulent or unlawful means. If you make a payment by debit card or credit card, you warrant that you are Authorised to use the debit card or credit card to make the payment. 8. You agree that we may set-off or deduct from any monies payable to you under these Terms, any amounts which are payable by you to us (whether under these Terms or otherwise). 9. Changes to your Subscription: If you wish to suspend or change your Subscription (for example, by upgrading to a different Subscription tier), you must provide notice to us through support channels or via email that you wish to suspend or vary your Subscription at least 7 days before the next Payment Date. If you vary your Subscription and the Subscription Fees increase, the increased Subscription Fees will apply on the next Payment Date, and you will have access to the additional Subscription features on the next Payment Date. If you vary your Subscription and the Subscription Fees decrease, the decreased Fees will apply on the next Payment Date, and you will lose access to the additional Subscription features on the next Payment Date. 10. Our pricing model does not incorporate any charges based on the number of team members or users associated with your Subscription and fees associated with usage are charged separately from the Subscription Fee as a Usage Fee, subject to clause 8(c). 11. To the extent permitted by law, the Subscription Fees and Usage Fees are non-refundable and non-cancellable once paid to cover our estimated losses resulting from the cost of resources spent in providing your our Platform and support services. 12. We may need to change what is available as part of your Subscription (for example, any plan change or feature removal) from time to time. If we change what is available as part of your Subscription, we will provide you with 30 days’ notice of the change. After 30 days, we will apply the changes to your Subscription. If the changes substantially and adversely affect your enjoyment of the Subscription, you may cancel your Subscription in accordance with the ‘Cancelling Subscriptions’ clause. If the changes are to your benefit, we will be deploying those new features and adjustments continuously at our discretion. 13. We may need to change the Subscription Fees from time to time. If we change the Subscription Fees, we will provide you with 30 days’ notice of the change. After 30 days, we may apply the updated Subscription Fee to your Subscription. If the updated Subscription Fee is not acceptable to you, you may cancel your Subscription in accordance with the ‘Cancelling Subscriptions’ clause. 9. **Beta Services** 1. For the purposes of this clause: 1. “**Beta Services**” means any services, software or functionality provided by us that are not generally available to customers and which are designated as beta, pilot, limited release, developer preview, non-production, evaluation, or by a similar description. 2. From time to time, we may invite you to try Beta Services. You may accept or decline any such trial at your sole discretion. If you accept, we will provide you with access to the Beta Services at no additional cost. 3. You acknowledge and agree that: 1. any Beta Services are for evaluation purposes only and not for production use; 2. the Beta Services may be subject to additional terms and conditions (which if applicable, will be provided to you and that you must accept before you are provided with access to the Beta Services); 3. we have no obligation to maintain, support, update, or provide error corrections for the Beta Services; and 4. we may discontinue Beta Services at any time at our sole discretion, and we reserve the right to never make the Beta Services generally available. 4. To the maximum extent permitted by law: 1. we will not be liable for, and you waive and release us from and against, any Liability caused or contributed to by, arising from or connected with any Beta Services; and 2. the Beta Services are provided “as is”, are exclusive of any warranty whatsoever, and we expressly disclaim any warranties of merchantability or fitness for a particular purpose. 10. **Support Services** 1. We will supply you with Support Services. 2. In order for you to receive the Support Services, you must place a request in writing. 3. We will use our best endeavours to make the Support Services available to you within a reasonable timeframe. 11. **Payments** 1. Upon receipt of the fees from your customers, our third party payment processor, will hold and will pay the fees (minus any of the third party payment processor’s transaction fees) to you. You acknowledge and agree that we will charge our Transaction Fee for each end customer transaction, in accordance with clause 8(b). 12. **Local Taxes** 1. We reserve the right to charge any applicable local taxes in addition to the Fee, in compliance with the prevailing local tax laws and regulations of your jurisdiction. 2. The local taxes may include but are not limited to sales tax, value-added tax (VAT), goods and services tax (GST), or any other similar taxes, levies or duties which are applicable in your location. The amount of these taxes will be calculated based on the Fee and will be added to the total amount payable by you. When you use our Platform to bill and charge your own customers, you should include any applicable taxes in the total amount payable by your customers, in accordance with your local tax laws and regulations. 13. **Our Intellectual Property** 1. You acknowledge and agree that any Intellectual Property or content (including copyright and trademarks) available on the Platform, the Platform itself, and any algorithms or machine learning models used on the Platform **(Our Intellectual Property)** will at all times vest, or remain vested, in us. 2. We authorize you to use Our Intellectual Property solely for your limited commercial use. You must not exploit Our Intellectual Property for any other purpose, nor allow, aid or facilitate such use by any third party. Use must be limited to Authorised Users on devices that are controlled or approved by you. 3. You must not, without our prior written consent: 1. copy, in whole or in part, any of Our Intellectual Property; 2. reproduce, retransmit, distribute, disseminate, sell, publish, broadcast or circulate any of Our Intellectual Property to any third party; or 3. breach any intellectual property rights connected with the Platform, including (without limitation) altering or modifying any of Our Intellectual Property, downloading Our Intellectual Property, causing any of Our Intellectual Property to be framed or embedded in another website, or creating derivative works from any of Our Intellectual Property. 4. This clause will survive the termination or expiry of your Subscription. 14. **Your Data** 1. You own all data, information or content you and your Authorised Users upload into the Platform (**Your Data**), as well as any data or information output from the Platform using Your Data as input (**Output Data**). Note that Output Data does not include the Analytics (as described below). 2. You grant us a limited licence to copy, transmit, store, backup and/or otherwise access or use Your Data and the Output Data to: 1. communicate with you (including to send you information we believe may be of interest to you); 2. supply the Platform to you and otherwise perform our obligations under these Terms; 3. diagnose problems with the Platform; 4. provide support services to you; 5. enhance and otherwise modify the Platform; 6. perform Analytics; 7. develop other services; and 8. as reasonably required to perform our obligations under these Terms. 3. You agree that you are solely responsible for all of Your Data that you and your Authorised Users make available on or through the Platform. You represent and warrant that: 1. you are either the sole and exclusive owner of Your Data or you have all rights, licences, consents and releases that are necessary to grant to us the rights in Your Data (as contemplated by these Terms); and 2. neither Your Data nor the posting, uploading, publication, submission or transmission of Your Data or our use of Your Data on, through or by means of our Platform will infringe, misappropriate or violate a third party’s intellectual property rights, or rights of publicity or privacy, or result in the violation of any applicable law or regulation. 4. You acknowledge and agree that we may monitor, analyse and compile statistical and performance information based on and/or related to your use of the Platform, in an aggregated and anonymized format (**Analytics**). You acknowledge and agree that we own all rights in the Analytics, and that we may use the Analytics for our own internal business purposes, provided that the Analytics do not contain any identifying information 5. We shall collect, process and use certain information relating to the use and performance of the Product by you (**Usage Data**) for purposes including but not limited to: 1. improving the quality, performance and features of the Platform; 2. understanding the utilisation and needs of our customers; 3. developing new products, services and features; and 4. to accurately determine the fees charged for the use of the Platform based on your usage. 6. We do not endorse or approve, and are not responsible for, any of Your Data. 7. You acknowledge and agree that the Platform and the integrity and accuracy of the Output Data is reliant on the accuracy and completeness of Your Data, and the provision by you of Your Data that is inaccurate or incomplete may affect the use, output and operation of the Platform. 8. This clause will survive the termination or expiry of your Subscription. 15. **PCI DSS** 1. We acknowledge that we are responsible for complying with the Payment Card Industry Data Security Standards (as amended and updated from time to time) (**PCI DSS**) when we store, process, transmit or access your credit card details. We confirm that we are compliant with the PCI DSS. 2. We will notify you of any actual or potential contravention by us of any PCI DSS as soon as possible. 3. We will create and maintain reasonably detailed and complete documentation which conforms with the PCI DSS, describing the systems, processes, security controls, etc. used by us to receive, transmit, store and secure credit card details that we hold. 16. **Sanctions** 1. We reserve the right to suspend or terminate your access to our Platform, without notice and at our sole discretion, if we determine that you are subject to or associated with any sanctions, restrictions, or penalties imposed by any governmental authority, including but not limited to, any applicable national, international or other regulatory authorities (**Sanctions**). 17. **Warranties** 1. You represent, warrant and agree that: 1. you will not use our Platform, including Our Intellectual Property, in any way that competes with our business; 2. there are no legal restrictions preventing you from entering into these Terms; 3. your use of the Platform is compliant with all laws; 4. all information and documentation that you provide to us in connection with these Terms is true, correct and complete; and 5. you have not relied on any representations or warranties made by us in relation to the Platform (including as to whether the Platform is or will be fit or suitable for your particular purposes), unless expressly stipulated in these Terms. 18. **Australian Consumer Law** 1. Certain legislation, including the Australian Consumer Law (**ACL**) in the Competition and Consumer Act 2010 (Cth), and similar consumer protection laws and regulations, may confer you with rights, warranties, guarantees and remedies relating to the provision of the Platform by us to you which cannot be excluded, restricted or modified (**Consumer Law Rights**). 2. If the ACL applies to you as a consumer, nothing in these Terms excludes your Consumer Law Rights as a consumer under the ACL. You agree that our Liability for the Platform provided to an entity defined as a consumer under the ACL is governed solely by the ACL and these Terms. 3. Subject to your Consumer Law Rights, we exclude all express and implied warranties, and all material, work and services (including the Platform) are provided to you without warranties of any kind, either express or implied, whether in statute, at law or on any other basis. 4. This clause will survive the termination or expiry of your Subscription. 19. **Liability** 1. Despite anything to the contrary, to the maximum extent permitted by law: 1. you agree to indemnify us for any Liability we incur due to your breach of the Acceptance and Platform Licence clause, and the Intellectual Property clause of these Terms and your breach of any law; 2. neither Party will be liable for Consequential Loss; 3. each Party’s liability for any Liability under these Terms will be reduced proportionately to the extent the relevant Liability was caused or contributed to by the acts or omissions of the other Party or any of that Party’s personnel (including a Party’s Authorised Users), including any failure by that Party to mitigate its losses; and 4. our aggregate liability for any Liability arising from or in connection with these Terms will be limited to us resupplying the Platform to you or, in our sole discretion, to us repaying you the amount of the Fees paid by you to us during the term of your Subscription. 2. This clause will survive the termination or expiry of your Subscription. 20. **Termination** 1. Cancellation of Subscription: You may request to cancel your Subscription at any time by notifying us via email. As we bill in arrears, your cancellation will take effect at the end of the current billing period for which you have been billed. No further charges will be made after the receipt of your cancellation request, except for any Usage Fees incurred during the current billing period up until the cancellation takes effect. If you cancel your Subscription due to us implementing changes to the Subscription inclusions, which have a substantial and adverse impact on you, or because of changes to the Subscription Fees, then the termination of the Subscription will be immediate. Any Subscription Fees incurred for services used during the current billing period up until the point of cancellation will still apply. No charges will apply for services not used after the cancellation has taken effect. 2. We may terminate your Subscription at any time by giving 15 days’ written notice to you (**Termination for Convenience**). 3. A Subscription will terminate immediately upon written notice by a Party (**Non-Defaulting Party**) if: 1. the other Party (**Defaulting Party**) breaches a material term of these Terms that breach has not been remedied within 10 Business Days of the Defaulting Party being notified of the breach by the Non-Defaulting Party; or 2. the Defaulting Party is unable to pay its debts as they fall due. 4. Should we suspect that you are in breach of these Terms, we may suspend your access to the Platform while we investigate the suspected breach. 5. Upon expiry or termination of your Subscription: 1. we will remove your access to the Platform and your Account may be deleted; 2. you agree that other than where termination is due to our Termination for Convenience or our breach of these Terms, and to the maximum extent permitted by law, any payments made by you to us (including any Fees) are not refundable to you; 3. where we terminate your Subscription for any reason other than a Termination for Convenience, you also agree to pay us our reasonable additional costs directly arising from such termination. 6. Where termination is due to our Termination for Convenience or our breach of these Terms, we agree to refund you for any prepaid unused Fees on a pro-rata basis. 7. Termination of a Subscription will not affect any rights or liabilities that a Party has accrued under these Terms. 8. This clause will survive the termination or expiry of your Subscription. 21. **Modern Slavery** 1. You represent, warrant and undertake that, as at the date of your acceptance of these Terms, neither you, nor any entity that you own or control or, to the best of your knowledge, any subcontractor of yours, has been convicted of a Modern Slavery offence under Modern Slavery Laws. 2. You must: 1. take reasonable steps to ensure that Modern Slavery is not occurring in your operations and supply chains or in the operations and supply chains of any entity you own or control; 2. provide to us any information and other assistance, as reasonably requested by us, to enable us to meet any of our obligations under the Modern Slavery Laws and associated regulatory requirements, including co-operating in any Modern Slavery audit undertaken by us or an Authority; 3. during the term of your subscription and for a period of seven (7) years after, maintain and upon the our reasonable request, give us access to and/or copies of, records in your possession or control to trace, so far as practicable, the supply chains involved in your use of the Platform under these Terms to enable us to assess your compliance with this clause 21; and 4. notify us in writing as soon as you become aware of any material change to any of the information it has provided to us in relation to Modern Slavery, or any actual or suspected occurrence of Modern Slavery your operations or supply chains (or those of any entity that you own or control). 3. In respect of any subcontracts that relate to your business, you must take reasonable steps to ensure that those subcontracts contain: 1. in relation to subcontracts that relate exclusively to you, provisions in relation to Modern Slavery that are substantially the same provisions as this clause 21; and 2. in all other cases, Modern Slavery provisions that are reasonably consistent with the provisions in this clause 21. 4. If you become aware of any actual or suspected occurrence of Modern Slavery in your operations or supply chains (or in those of any entity that you own or control), you must take reasonable steps to respond to the occurrence in accordance with any of your internal Modern Slavery strategy and procedures and any relevant policies, codes and standards (including any code of practice or conduct) or other guidance issued by any relevant Authority. 22. **General** 1. Assignment: Subject to the below clause, a Party must not assign or deal with the whole or any part of its rights or obligations under these Terms without the prior written consent of the other Party (such consent is not to be unreasonably withheld). 2. Assignment of Debt: You agree that we may assign or transfer any debt owed by you to us, arising under or in connection with these Terms, to a debt collector, debt collection agency, or other third party. 3. Disputes: A Party may not commence court proceedings relating to a dispute without first meeting with the other Party to seek (in good faith) to resolve the dispute, failing which the Parties agree to engage a mediator to attempt to resolve the dispute. The costs of the mediation will be shared equally between the Parties. Nothing in this clause will operate to prevent a Party from seeking urgent injunctive or equitable relief from a court of appropriate jurisdiction. 4. Entire Terms: Subject to your Consumer Law Rights, these Terms contains the entire understanding between the Parties and the Parties agree that no representation or statement has been made to, or relied upon by, either of the Parties, except as expressly stipulated in these Terms, and these Terms supersedes all previous discussions, communications, negotiations, understandings, representations, warranties, commitments and agreements, in respect of its subject matter. 5. Force Majeure: To the maximum extent permitted by law, we shall have no Liability for any event or circumstance outside of our reasonable control. 6. Governing law: This Agreement is governed by the laws of New South Wales, Australia. Each Party irrevocably and unconditionally submits to the exclusive jurisdiction of the courts operating in New South Wales, Australia and any courts entitled to hear appeals from those courts and waives any right to object to proceedings being brought in those courts. 7. Notices: Any notice given under these Terms must be in writing addressed to us at the details set out below or to you at the details provided in your Account. Any notice may be sent by standard post or email, and will be deemed to have been served on the expiry of 48 hours in the case of post, or at the time of transmission in the case of transmission by email. 8. Privacy: Each Party agrees to comply with the legal requirements of the Australian Privacy Principles as set out in the Privacy Act 1988 (Cth) and any other applicable legislation or privacy guidelines. 9. Publicity: You agree that we may advertise or publicize the fact that you are a user of our Platform, including on our website or in our promotional material. You grant us a non-exclusive, royalty-free, revocable, worldwide, sublicensable and non-transferable right and licence, for the duration of the Term, to use any marketing or promotional material that you provide to us, including your logo, solely for the purposes for which they were developed and solely for us to exercise our rights as set out in this clause. 10. Severance: If a provision of these Terms is held to be void, invalid, illegal or unenforceable, that provision is to be read down as narrowly as necessary to allow it to be valid or enforceable, failing which, that provision (or that part of that provision) will be severed from these Terms without affecting the validity or enforceability of the remainder of that provision or the other provisions in these Terms. 11. Third party sites: The Platform may contain links to websites operated by third parties. Unless we tell you otherwise, we do not control, endorse or approve, and are not responsible for, the content on those websites. We recommend that you make your own investigations with respect to the suitability of those websites. If you purchase goods or services from a third party website linked from the Platform, such third party provides the goods and services to you, not us. We may receive a benefit (which may include a referral fee or a commission) should you visit certain third-party websites via a link on the Platform (**Affiliate Link**) or for featuring certain products or services on the Platform. We will make it clear by notice to you which (if any) products or services we receive a benefit to feature on the Platform, or which (if any) third party links are Affiliate Links. 23. **Definitions** 1. Authority includes any governmental or semi-governmental or local government authority, administrative, regulatory or judicial body or tribunal, department, commission, public authority, agency, Minister, statutory corporation or instrumentality. 2. Consequential Loss includes any consequential loss, indirect loss, real or anticipated loss of profit, loss of benefit, loss of revenue, loss of business, loss of goodwill, loss of opportunity, loss of savings, loss of reputation, loss of use and/or loss or corruption of data, whether under statute, contract, equity, tort (including negligence), indemnity or otherwise. 3. Intellectual Property means any domain names, know-how, inventions, processes, trade secrets or confidential information; or circuit layouts, software, computer programs, databases or source codes, including any application, or right to apply, for registration of, and any improvements, enhancements or modifications of, the foregoing. 4. Liability means any expense, cost (including legal costs and expenses), liability, loss, damage, claim, notice, entitlement, investigation, demand, proceeding or judgment (whether under statute, contract, equity, tort (including negligence), indemnity or otherwise), howsoever arising, whether direct or indirect and/or whether present, unascertained, future or contingent and whether involving a third party or a party to these Terms or otherwise. 5. Limited Payment Collection Agent Fee means a fee for collection of payments from third parties on a customer’s behalf. 6. Modern Slavery has the same meaning as in the Modern Slavery Laws and includes slavery, servitude, forced labour, human trafficking, debt bondage, organ trafficking, forced marriage and the exploitation of children. 7. Modern Slavery Laws means the *Modern Slavery Act 2018* (Cth) and any other applicable legislation addressing similar subject matter. 8. Transaction Fee means the fee we charge you for facilitating the transaction between you and your customers. The Transaction Fee is calculated as a percentage of each end customer transaction processed through the Platform billing product. 9. Support Services mean a range of technical services that help customers to effectively use, manage, and maintain the Platform including but not limited to helpdesk or technical support and maintenance services. **For any questions or notices, please contact us at:** Kinde Australia Pty Ltd ([ABN 11655096263](https://abr.business.gov.au/ABN/View?abn=11655096263)) **Email**: [support@kinde.com](mailto:support@kinde.com) **Last update:** 12 June 2025

# Trust center - Kinde performance - Kinde services status

> Information about Kinde's service status page for monitoring uptime, downtime, maintenance scheduling, and system status, with support contact details.

service status, uptime, downtime, monitoring, status page, support
trust-center, kinde-performance, monitoring

Go to [status.kinde.com](https://status.kinde.com/) to view current and past information about uptime, downtime, maintenance scheduling, and system status. You can also access the status page from the **Help** widget in the bottom right corner of Kinde. To report issues, contact us via the Help widget anytime - on Slack or through direct chat. Note that while we strive to offer 24 hour coverage, most of our team is based in Australia, so it could take a few hours to receive a reply if you’re in an opposing timezone. Thanks for your understanding.

# Trust center - Privacy and compliance - Compliance

> Overview of Kinde's compliance certifications and security frameworks including ISO 27001, SOC 2 Type 2, GDPR, HIPAA, CAIQ, MVSP, and PCI-DSS compliance status.

compliance, ISO 27001, SOC 2, GDPR, HIPAA, CCPA, CPRA, CAIQ, MVSP, PCI-DSS, certification, security
trust-center, privacy-and-compliance, security

Kinde takes data privacy and security very seriously. We want you to trust us and our systems, which is why we engaged in external certification audits and conducted self assessments against globally recognized privacy and security frameworks to ensure our technology infrastructure and your data are kept secure. ## **ISO 27001** ![ISO and ISO 27001 logos](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/6a57d6a4-8291-4b37-4449-6c38b010bf00/public) Kinde is [ISO 27001:2022](https://www.iso.org/standard/27001) certified by [Compass Assurance Services](https://cas.com.au/) and maintains an information security management system (ISMS) with a dedicated internal security team. Our public listing is available on the [JASANZ certified organizations register](https://register.jasanz.org/certificate-details/0/af0526d5-c2d8-ed11-a7c7-00224818a490) and the [IAF CertSearch register](https://www.iafcertsearch.org/certified-entity/WrSSvBtTuGl9ks9O9oyp30SO). You can also download a copy of our [ISO 27001:2002 certificate](/assets/images/docs/certificates/Kinde-Australia-ISO-27001-2022.pdf). ISO 27001 specifies the requirements for establishing, implementing, maintaining and continually improving an ISMS within the context of the organization. This document also includes requirements for the assessment and treatment of information security risks tailored to the needs of the organization. ## SOC 2 Type 2 ![AICPA and SOC2 logos](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/99302f85-bdd0-482d-5e7e-caafb52bb900/public) Kinde has completed a SOC 2 Type 2 with report and attestation from [AssuranceLab](https://www.assurancelab.cpa/). You can download a copy of our [Attestation Status Confirmation](/assets/images/docs/certificates/Kinde-SOC-2-Type-2-Attestation-Status.pdf). Access to the full SOC 2 report is part of our Scale and Enterprise plans. Reach out to our team if you need a copy and note that you will require an NDA as there’s sensitive information in the report. A [SOC 2 examination](https://www.aicpa-cima.com/topic/audit-assurance/audit-and-assurance-greater-than-soc-2) is a report on controls at a service organization relevant to security, availability, processing integrity, confidentiality, or privacy. SOC 2 reports are intended to meet the needs of a broad range of users that need detailed information and assurance about the controls at a service organization relevant to security, availability, and processing integrity of the systems the service organization uses to process users’ data and the confidentiality and privacy of the information processed by these systems. ## GDPR ![GDPR logo](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/64af5136-0785-402d-66b9-e6e3f3b8e000/public) Kinde is compliant with the GDPR and supports our customers by maintaining strict privacy principles as a Data Processor. The General Data Protection Regulation (GDPR) is a European Union (EU) regulation on information privacy. It came into effect on May 25, 2018 and places obligations for any company targeting or collecting data related to people in the EU. It’s goal is to increase privacy protections for individuals and standardise data privacy laws across the various EU member countries. More information about the GDPR and what Kinde does for comply with it can be found on our [GDPR](/trust-center/privacy-and-compliance/gdpr/) page. ## HIPAA ![HIPAA and AssuranceLab HIPAA logos](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/88d46614-1631-48ae-fcf4-a0ee7c121c00/public) Kinde is HIPAA compliant and supports our customers as a Business Associate. Reach out to our team if you need a Business Associate Agreement in place before working with us. The Health Insurance Portability and Accountability Act of 1996 (HIPAA) is a US federal law on how to protect sensitive health information, known as Protected Health Information (PHI), which led to the creation of the Privacy Rule and Security Rule. It has since been updated with additional rules and supplemented by the Health Information Technology for Economic and Clinical Health (HITECH) Act in 2009. More information about HIPAA can be found on the US Department of Health and Human Services's [health information privacy](https://www.hhs.gov/hipaa/index.html) page. ## CCPA and CPRA ![CCPA and CPRA logos](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/ffc476f3-6b5f-43ac-8406-d6ab5dce8100/public) Kinde is compliant with the CCPA (as amended by the CPRA) and supports our customers by maintaining strict privacy principles. The California Consumer Privacy Act (CCPA) gives consumers more control over the personal information that companies collect about them. The law took effect on January 1, 2020 (its initial regulations were approved on August 14, 2020) and applies to companies targeting or collecting data related to California residents. An amendment—the California Privacy Rights Act (CPRA)—expanded the CCPA’s scope; it became legally effective on December 16, 2020, most substantive provisions became operative on January 1, 2023 (with a look-back to data collected on or after January 1, 2022), and formal enforcement began July 1, 2023. More information can be found on the California Attorney General’s [CCPA/CPRA page](https://oag.ca.gov/privacy/ccpa) and the California Privacy Protection Agency’s website. ## **CAIQ v4** ![CAIQ self-assessment badge](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/ae7254c4-4fa9-4542-be17-86a2a3382d00/public) Kinde has completed a [Consensus Assessments Initiative Questionnaire (CAIQ)](https://cloudsecurityalliance.org/star/registry/kinde/services/kinde/) from the Cloud Security Alliance and submitted to their public STAR registry as a Level 1 self-assessment. Founded in 2013 by the Cloud Security Alliance, the Security Trust Assurance and Risk (STAR) registry encompasses key principles of transparency, rigorous auditing, and cloud security and privacy best practices. ## MVSP ![MVSP logo](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/c20625e4-2acf-43c4-e42e-66b853cafd00/public) Kinde has completed a Minimum Viable Secure Product (MVSP) self-assessment and implemented all recommended controls. Reach out to our team if you need to review our responses or have questions about specific controls. MVSP is a list of essential application security controls that should be implemented in enterprise-ready products and services. The controls are designed to be simple to implement and provide a good foundation for building secure and resilient systems and services. More information about MVSP can be found at the [Minimum Viable Secure Product](https://mvsp.dev/) website. ## PCI-DSS ![PCI logo](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/8358875d-ac43-43d3-f794-3d72bf3f1800/public) Please note that Kinde does not hold a PCI-DSS Report on Compliance (ROC) from a Qualified Security Assessor (QSA). In preparation for Kinde’s upcoming customer billing feature, we have engaged with a QSA to validate our scoping and we are preparing the necessary Self Assessment Questionnaire (SAQ) to meet the PCI-DSS requirements for processing cardholder data. Currently we use a third party service provider and their SAQ-A scoped method, which greatly reduces the scope that Kinde has to meet as a PCI-DSS Service Provider. Our SAQ and Attestation of Compliance (AOC) will be available when scoping work is completed and will transition to a Level 1 Service Provider when the necessary transaction volume is reached. More information about PCI can be found at the [PCI Security Standards Council](https://www.pcisecuritystandards.org/) website.

# Trust center - Privacy and compliance - General data protection regulation (GDPR)

> Detailed guide on how Kinde complies with GDPR requirements including consent management, data protection officer, encryption, privacy by design, and data subject rights.

GDPR, data protection, privacy, consent, data processing, encryption, privacy by design, data rights
trust-center, privacy-and-compliance, legal

Kinde is compliant with the GDPR and here’s how we do this. The list below are based on the key issues provided by [GDPR-Info](https://gdpr-info.eu/issues). They summarize the key issues facing companies in regard to data privacy protection. More information on the GDPR can also be found at [GDPR.EU](https://gdpr.eu/). Please note that this document is for guidance purposes only and is only updated occasionally. For the most up to date representation of our privacy stance, please refer to our [privacy policy](/trust-center/privacy-and-compliance/privacy-policy/). If you require a Data Processing Agreement (DPA), please reach out to our team at support@kinde.com. ## **Key issues** ### **Consent** <Aside> Processing personal data is generally prohibited, unless it is expressly allowed by law, or the data subject has consented to the processing. </Aside> Kinde processes personal data as part of our authentication product. Specifically first name, last name, and email address. Note that there may be less information provided depending on the type of authentication integration being used by our customers. For example, some social providers only provide the email or only provide a custom identifier without revealing any personal details. The consent for this is part of the terms between data subjects and Kinde’s customers. Kinde’s customers are the data controller, where as Kinde is only a data processor on behalf of our customer. With respect to marketing efforts, Kinde uses a legitimate interest assessment internally to determine broad scopes of marketing activities. ### **Data Protection Officer** <Aside> The GDPR has established the concept of a Data Protection Officer. </Aside> Kinde has nominated a Data Protection Officer internally, whose core responsibilities include ensuring Kinde is aware of, and trained on, all relevant privacy obligations, conduct audits to ensure compliance, address potential issues proactively, and act as a liaison with the public on privacy matters. You can reach out Data Protection Officer by emailing privacy@kinde.com. ### **Email marketing** <Aside> Newsletter mailings and e-mail marketing are a fixed part of the online marketing universe. </Aside> All marketing emails are sent with an opt-out link in the event that customers don’t want to receive products updates from us. Membership to the email marketing lists is collected when users voluntarily provide details to us, such as signing up for our product, registering for the newsletter, or signing up to blog post or product updates. ### **Encryption** <Aside> Companies can reduce the probability of a data breach and thus reduce the risk of fines in the future, if they chose to use encryption of personal data. </Aside> All customer data, including personal data, is encrypted at rest in Kinde’s production database using AES256. More information can be found on the [Security at Kinde](/trust-center/security/security-at-kinde/) page. Access to Kinde customer data and the back-end infrastructure is strictly limited and controlled. ### **Privacy by Design** <Aside> The term “Privacy by Design” means nothing more than “data protection through technology design.” Technical and organisational measures must be taken already at the time of planning a processing system to protect data safety. </Aside> One of Kinde’s product principles is Privacy by Design. In this effort, we have made a commitment to never sell our customer data. In addition to this, we’ve included privacy related checks throughout our software lifecycle to ensure that Kinde only collects the bare minimum amount of personal data to successfully run the product. ### **Privacy impact assessment** <Aside> This refers to the obligation of the controller to conduct an impact assessment and to document it before starting the intended data processing. </Aside> Kinde has completed privacy impact assessments for our key processing activities, which internally we’ve called a Data Protection Impact Assessments (DPIA), based on a template provided by the [UK’s Information Commissioners Office](https://ico.org.uk/for-organisations/guide-to-data-protection/guide-to-the-general-data-protection-regulation-gdpr/accountability-and-governance/data-protection-impact-assessments/). They’re long and thorough, and have been extremely useful in mapping out the personal data being handled, but also influencing the business and technical strategies in protecting that data. ### **Processing** <Aside> The GDPR offers a uniform, Europe-wide possibility for so-called ‘commissioned data processing’, which is the gathering, processing or use of personal data by a processor in accordance with the instructions of the controller based on a contract. </Aside> As Kinde is a business to business (B2B) company, we handle personal data on behalf of our customers, which makes us a data processor. Our customers are the data controllers. As a result, Kinde takes instruction from the customers about what to do with the personal data. With respect to the customer, Kinde is a sub-processor for them. To review Kinde's sub-processors, please see [sub-processors](/trust-center/privacy-and-compliance/sub-processors/). ### **Records of processing activities** <Aside> Written documentation and overview of procedures by which personal data are processed. Records of processing activities must include significant information about data processing, including data categories, the group of data subjects, the purpose of the processing and the data recipients. This must be completely made available to authorities upon request. </Aside> One of the outputs from the DPIA mentioned earlier is a privacy data map, which includes records of processing activities (RoPA). Privacy surveys are conducted with each department to identify their own activities and what personal data is being handled. This captures information across user types such as customers, users, and employees. Once the surveys are done, the information is collated back into our RoPA and then updated as needed. ### **Right of access** <Aside> The right of access plays a central role in the GDPR. On the one hand, because only the right of access allows the data subject to exercise further rights (such as rectification and erasure). On the other hand, because an omitted or incomplete disclosure is subject to fines. </Aside> Due to Kinde being a processor of data and not the controller, the right of access for a data subject should be directed at Kinde’s customers. These companies should handle the privacy request and forward onto Kinde if there’s anything that we can do to assist. For the most part, Kinde will allow customers to view, adjust, or remove personal data for their users, such as user’s names or emails. ### **Right to be forgotten** <Aside> For the first time, the right to be forgotten is codified and to be found in the GDPR in addition to the right to erasure. </Aside> Refer to [Right of access](/trust-center/privacy-and-compliance/gdpr/#right-of-access). ### **Right to be informed** <Aside> There is a need for transparency regarding the gathering and use of data in order to allow EU citizens to exercise their right to the protection of personal data. </Aside> Refer to [Right of access](/trust-center/privacy-and-compliance/gdpr/#right-of-access).

# Trust center - Privacy and compliance - Our privacy policy

> Comprehensive privacy policy covering data collection, processing, storage, and user rights under Australian Privacy Principles and GDPR for both customers and external users of Kinde's platform.

privacy policy, GDPR, data protection, personal information, cookies, PCI DSS, legal compliance, data rights
trust-center, privacy-and-compliance, legal

Kinde Australia Pty Ltd ([ABN 11 655 096 263](https://abr.business.gov.au/ABN/View?abn=11655096263)) (**we**, **us** or **our**), understands that protecting your personal information is important. This Privacy Policy sets out our commitment to protecting the privacy of personal information provided to us, or collected by us, when interacting with you. In this Privacy Policy, we may refer to you as our direct customer (**Customer**) or you as a customer of our customer (**External User**). Information about Australia’s privacy guidance can be found from the [Office of the Australian Information Commissioner](https://www.oaic.gov.au/) (**OAIC**). Kinde’s UK Company Reference Number (**CRN**) is [13920496](https://find-and-update.company-information.service.gov.uk/company/13920496). Information about the UK’s privacy guidance can be found with the [Information Commissioner’s Office](https://ico.org.uk/) (**ICO**). This Privacy Policy takes into account the requirements of the Privacy Act 1988 (Cth). In addition to the Australian laws, individuals located in the European Union or European Economic Area (**EU**) may also have rights under the General Data Protection Regulation 2016/679 and individuals located in the United Kingdom (**UK**) may have rights under the General Data Protection Regulation (**EU**) 2016/679) (**UK GDPR**) and the Data Protection Act 2018 (**DPA 2018**) (together, the **GDPR**). This document also details the additional rights of individuals located in the EU and UK, as well as information on how we process the personal information of individuals located in the EU and UK. ## The information we collect **Personal Information:** is information or an opinion, whether true or not and whether recorded in a material form or not, about an individual who is identified or reasonably identifiable. Where you are a Customer, the types of personal information we may collect about you include: * **Transaction Data** including inbound and outbound payments, products and services transaction details, and usage-based fees processed through our billing feature. Where you are an External User * **Identity Data** including your first and last name. * **Contact Data** including your telephone number and email. * **Financial Data** including bank account and payment card details. * **Transaction Data** including details about payments to you from us and from you to us and other details of products and services you have purchased from us or we have purchased from you. * **Technical and Usage Data** when you access any of our websites or platforms, details about your internet protocol (IP) address, login data, browser session and geo-location data, statistics on page views and sessions, device and network information, acquisition sources, search queries and/or browsing behaviour, access and use of our website (including through the use of Internet cookies), and communications with our website. * **Profile Data** including your username and password for the Kinde platform, purchases or orders you have made with us and support requests you have made. * **Interaction Data** including information you provide to us when you participate in any interactive features, including surveys, contests, promotions, activities or events. * **Marketing and Communications Data** including your preferences in receiving marketing from us and our third parties and your communication preferences. * **Professional data** including where you are a worker of ours or applying for a role with us, your professional history such as your previous positions and professional experience. * **Sensitive information** is a sub-set of personal information that is given a higher level of protection. Sensitive information means information relating to your racial or ethnic origin, political opinions, religion, trade union or other professional associations or memberships, philosophical beliefs, sexual orientation or practices, criminal records, health information or biometric information. We do not actively request sensitive information about you. If at any time we need to collect sensitive information about you, unless otherwise permitted by law, we will first obtain your consent and we will only use it as required or authorised by law. ## How we collect personal information We collect personal information in a variety of ways, including: * when you interact directly with us, including face-to-face, over the phone, over email, or online * when you complete a form, such as registering for any events or newsletters, or responding to surveys * when you apply for a job with us * from third parties, such as details of your use of any website we operate (from our analytics providers and marketing providers) or * from publicly available sources, such as social media or the Australian Securities and Investment Commission (ASIC). ## Why we collect, hold, use and disclose personal information We have set out below, in a table format, a description of the purposes for which we plan to collect, hold, use and disclose your personal information. | Purpose of use / disclosure | Type of Personal Information | | :---- | :---- | | To enable you to access and use our software, including to provide you with a login. | Identity Data, Contact Data | | To provide and manage billing services, including processing payments, managing subscriptions, and facilitating transactions through our platform. | Identity Data, Contact Data, Financial Data, Transaction Data, Billing Data | | To assess whether to take you on as a new client, including to perform anti-money laundering, anti-terrorism, sanction screening, fraud and other background checks on you. | Identity Data, Contact Data | | To do business with you, including to deliver our products and services to you, to respond to your requests and to register your attendance at our events. | Identity Data, Contact Data, Financial Data | | As a Customer, to contact and communicate with you about our business, including in response to any support requests you lodge with us or other enquiries you make with us. | Identity Data, Contact Data, Profile Data | | To contact and communicate with you about any enquiries you make with us via any website we operate. | Identity Data, Contact Data | | For internal record keeping, administrative, invoicing and billing purposes. | Identity Data, Contact Data, Financial Data, Transaction Data | | As a Customer, for analytics, market research and business development, including to operate and improve our business, associated applications and associated social media platforms. | Profile Data, Technical and Usage Data | | As a Customer, for advertising and marketing, including to send you promotional information about our events and experiences and information that we consider may be of interest to you. | Identity Data, Contact Data, Technical and Usage Data, Profile Data, Marketing and Communications Data | | As a Customer, to run promotions, competitions and/or offer additional benefits to you. | Identity Data, Contact Data, Profile Data, Interaction Data, Marketing and Communications Data | | If you have applied for employment with us, to consider your employment application. | Identity Data, Contact Data, Professional Data | | To comply with our legal obligations or if otherwise required or authorised by law. | Any relevant Personal Information | ## Our disclosures of personal information to third parties **Personal information:** Where you are a Customer, we may disclose personal information to: * our employees, contractors and/or related entities * IT service providers, data storage, web-hosting and server providers * marketing or advertising providers * professional advisors, bankers, auditors, our insurers and insurance brokers * payment systems operators or processors, including Stripe, who we use as our payment processing partner for our Billing feature. When you use our Billing services, your personal information may be shared with Stripe to facilitate payment processing. Stripe adheres to the PCI-DSS standards managed by the PCI Security Standards Council; * our existing or potential agents or business partners * anyone to whom our business or assets (or any part of them) are, or may (in good faith) be, transferred * courts, tribunals and regulatory authorities, in the event you fail to pay for goods or services we have provided to you * courts, tribunals, regulatory authorities and law enforcement officers, as required or authorised by law, in connection with any actual or prospective legal proceedings, or in order to establish, exercise or defend our legal rights * third parties to collect and process data, such as analytics providers and cookies * any other third parties as required or permitted by law, such as where we receive a subpoena. Where you are an External User, we may disclose personal information to: * our employees, contractors and/or related entities * IT service providers, data storage, web-hosting and server providers * professional advisors, bankers, auditors, our insurers and insurance brokers * payment systems operators or processors * anyone to whom our business or assets (or any part of them) are, or may (in good faith) be, transferred and * courts, tribunals, regulatory authorities and law enforcement officers, as required or authorised by law, in connection with any actual or prospective legal proceedings, or in order to establish, exercise or defend our legal rights. **Third-Party Analytics:** We have enabled analytics advertising features and use third-party analytics. We and third-party vendors may use first-party cookies or other first-party identifiers, and third-party cookies or other third-party identifiers together. These cookies and identifiers may collect Technical and Usage Data about you. To opt out of interest-based ads on mobile devices, please follow the instructions for your mobile device. ## Payment card details While we collect and display your payment methods and, if chosen, your payment card details for payment, your details are stored in a secure PCI DSS compliant payment gateway provider. Where we provide your details to our third-party payment processors, such processors will adhere to the standards set by PCI DSS. PCI DSS requirements help ensure the secure handling of payment card details. The payment processors we work with are: **Stripe**: Their Privacy Policy can be viewed at: [https://stripe.com/au/privacy](https://stripe.com/au/privacy) ## Overseas disclosure We may store personal information in Australia and overseas, including in Ireland, the United Kingdom, and the United States. Where we disclose your personal information to the third parties listed above, these third parties may also store, transfer or access personal information inside and outside of Australia, including but not limited to, the United States. We will only disclose your personal information overseas in accordance with the Australian Privacy Principles. ## Your rights and controlling your personal information **Your choice:** Please read this Privacy Policy carefully. If you provide personal information to us, you understand we will collect, hold, use and disclose your personal information in accordance with this Privacy Policy. You do not have to provide personal information to us, however, if you do not, it may affect our ability to do business with you. **Information from third parties:** If we receive personal information about you from a third party, we will protect it as set out in this Privacy Policy. If you are a third party providing personal information about somebody else, you represent and warrant that you have such person’s consent to provide the personal information to us. **Restrict and unsubscribe:** To object to processing for direct marketing/unsubscribe from our email database or opt-out of communications (including marketing communications), please contact us using the details below or opt-out using the opt-out facilities provided in the communication. **Access:** You may request access to the personal information that we hold about you. An administrative fee may be payable for the provision of such information. Please note, in some situations, we may be legally permitted to withhold access to your personal information. If we cannot provide access to your information, we will advise you as soon as reasonably possible and provide you with the reasons for our refusal and any mechanism available to complain about the refusal. If we can provide access to your information in another form that still meets your needs, then we will take reasonable steps to give you such access. **Correction:** If you believe that any information we hold about you is inaccurate, out of date, incomplete, irrelevant or misleading, please contact us using the details below. We will take reasonable steps to promptly correct any information found to be inaccurate, out of date, incomplete, irrelevant or misleading. Please note, in some situations, we may be legally permitted to not correct your personal information. If we cannot correct your information, we will advise you as soon as reasonably possible and provide you with the reasons for our refusal and any mechanism available to complain about the refusal. **Complaints:** If you wish to make a complaint, please contact us using the details below and provide us with full details of the complaint. We will promptly investigate your complaint and respond to you, in writing, setting out the outcome of our investigation and the steps we will take in response to your complaint. If you are not satisfied with our response, you may contact the [Office of the Australian Information Commissioner.](https://www.oaic.gov.au/) ## Storage and security We are committed to ensuring that the personal information we collect is secure. In order to prevent unauthorised access or disclosure, we have put in place suitable physical, electronic and managerial procedures, to safeguard and secure personal information and protect it from misuse, interference, loss and unauthorised access, modification and disclosure. While we are committed to security, we cannot guarantee the security of any information that is transmitted to or by us over the Internet. The transmission and exchange of information is carried out at your own risk. If you are a client of ours, we may keep your personal data for as long as we have a contract with you and then for a further 7 years. ## Cookies We may use cookies on our website from time to time. Cookies are text files placed in your computer’s browser to store your preferences. Cookies, by themselves, do not tell us your email address or other personally identifiable information. You can block cookies by activating the setting on your browser that allows you to refuse the setting of all or some cookies. However, if you use your browser settings to block all cookies (including essential cookies) you may not be able to access all or parts of our website. For more information about the cookies we use, please see our Cookie Policy below. We use the following cookies: * Strictly necessary cookies. These are cookies that are required for the operation of our online Services. They include, for example, cookies that enable you to log into secure areas of our online Services, use a shopping cart or make use of online payment services. * Social media cookies. These cookies are used when you share information using a social media sharing button or “like” button on our websites or you link your account or engage with our content on or through a social media site. The social network will record that you have done this. This information may be linked to targeting/advertising activities. * Targeting cookies. These cookies may be set through our site by our advertising partners. They may be used by those companies to build a profile of your interests and show you relevant adverts on other sites. If you do not allow these cookies, you will experience less targeted advertising. * Anonymized analytical cookies. These cookies ensure that anonymous data about your surfing behavior is collected every time you visit the website. This way we can see how visitors use the website and improve on that basis. We use anonymized analytical cookies for: * tracking the number of visitors to our web pages; * tracking the amount of time each visitor spends on our web pages; * keeping track of the order in which a visitor visits the different pages of our website; * assessing which parts of our site need updating; * measuring and optimizing the performance of our marketing campaigns; * redirecting traffic from different channels. * Billing functionality cookies. These cookies are used to support our Billing feature, including remembering your billing preferences and facilitating smooth transaction processes. ## Use of web beacons and other technologies Some of our websites, applications and electronic communications contain electronic tags known as web beacons, gifs or pixel tags, unique identifiers and similar technologies that help deliver cookies, measure online activity, provide more relevant advertising, or analyze the effectiveness of our promotional campaigns or other operations. ## Links to other websites Our website may contain links to other party’s websites. We do not have any control over those websites and we are not responsible for the protection and privacy of any personal information which you provide whilst visiting those websites. Those websites are not governed by this Privacy Policy. ## Additional rights and information for individuals located in the EU or UK Under the GDPR, individuals located in the EU and the UK have extra rights which apply to their personal information. Personal information under the GDPR is often referred to as personal data and is defined as information relating to an identified or identifiable natural person (individual). This ’Additional rights and information for individuals located in the EU or UK’ section sets out the additional rights we give to individuals located in the EU and UK, as well as information on how we process the personal information of individuals located in the EU and UK. Please read the Privacy Policy above and this ‘Additional rights and information for individuals located in the EU or UK’ section carefully and contact us at the details at the end of the Privacy Policy if you have any questions. ## What personal information is relevant? This ‘Additional rights and information for individual located in the EU or UK’ section applies to the personal information set out in the Privacy Policy above. This includes any Sensitive Information also listed in the Privacy Policy above which is known as ‘special categories of data’ under the GDPR. ## Purposes and legal bases for processing We collect and process personal information about you only where we have legal bases for doing so under applicable laws. We have set out below, in a table format, a description of all the ways we plan to use your personal information, and which of the legal bases we rely on to do so. We have also identified what our legitimate interests are where appropriate. Note that we may process your personal information for more than one lawful ground depending on the specific purpose for which we are using your data. Please reach out to us if you need further details about the specific legal ground, we are relying on to process your personal information where more than one ground has been set out in the table below. | Purpose of use / disclosure | Type of Data | Legal Basis for processing | | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :--------------------------------------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | | To enable you to access and use our software, including to provide you with a login. | Identity Data, Contact Data | Performance of a contract with you | | To provide and manage billing services | Identity Data, Contact Data, Financial Data, Transaction Data, Billing Data | Performance of a contract with you | | To do business with you, including to deliver our products and services to you, to respond to your requests and to register your attendance at our events. | Identity Data, Contact Data | Performance of a contract with you | | To contact and communicate with you about our business including in response to any support requests you lodge with us or other enquiries you make with us. | Identity Data, Contact Data, Profile Data | Performance of a contract with you | | To contact and communicate with you about any enquiries you make with us via our website. | Identity Data, Contact Data | Legitimate interests: to ensure we provide the best client experience we can offer by answering all of your questions. | | For internal record keeping, administrative, invoicing and billing purposes. | Identity Data, Contact Data, Financial Data , Transaction Data | Performance of a contract with you, To comply with a legal obligation, Legitimate interests: to recover debts due to us and ensure we can notify you about changes to our terms of business and any other administrative points. | | As a Customer, for analytics including profiling on our website, market research and business development, including to operate and improve our business, associated applications and associated social media platforms. | Profile Data, Technical and Usage Data | Legitimate interests: to keep our website updated and relevant, to develop our business, improve our business and to inform our marketing strategy | | As a Customer, for advertising and marketing, including to send you promotional information about our events and experiences and information that we consider may be of interest to you. | Identity Data, Contact Data, Technical and Usage Data, Profile Data, Marketing and Communications Data | Legitimate interests: to develop and grow our business | | As a Customer, to run promotions, competitions and/or offer additional benefits to you. | Identity Data, Contact Data, Profile Data, Interaction Data, Marketing and Communications Data | Legitimate interests: to facilitate engagement with our business and grow our business | | If you have applied for employment with us, to consider your employment application. | Identity Data, Contact Data, Professional Data | Legitimate interests: to consider your employment application | | To comply with our legal obligations or if otherwise required or authorised by law. | | To comply with a legal obligation | If you have consented to our use of data about you for a specific purpose, you have the right to change your mind at any time, but this will not affect any processing that has already taken place. Where we are using your data because we or a third party have a legitimate interest to do so, you have the right to object to that use though, in some cases, this may mean no longer doing business with us. Further information about your rights is available below. ## Data Transfers The countries to which we send data for the purposes listed above may be less comprehensive than what is offered in the country in which you initially provided the information. Where we transfer your personal information outside of the country where you are based, we will perform those transfers using appropriate safeguards in accordance with the requirements of applicable data protection laws and we will protect the transferred personal information in accordance with this Privacy Policy and this ‘Additional rights and information for individual located in the EU or UK’ section. This includes: * only transferring your personal information to countries that have been deemed by applicable data protection laws to provide an adequate level of protection for personal information * standard contractual clauses in our agreements with third parties that are overseas. ## Data retention We will only retain your personal information for as long as reasonably necessary to fulfil the purposes we collected it for, including for the purposes of satisfying any legal, regulatory, tax, accounting or reporting requirements. We may retain your personal information for a longer period in the event of a complaint or if we reasonably believe there is a prospect of litigation in respect to our relationship with you. To determine the appropriate retention period for personal information, we consider the amount, nature and sensitivity of the personal information, the potential risk of harm from unauthorised use or disclosure of your personal information, the purposes for which we process your personal information and whether we can achieve those purposes through other means, and the applicable legal, regulatory, tax, accounting or other requirements. You may request details of the personal information that we hold about you and how we process it (commonly known as a “data subject request”). You may also have a right in accordance with applicable data protection law to have your personal information rectified or deleted, to restrict our processing of that information, to object to decisions being made based on automated processing where the decision will produce a legal effect or a similarly significant effect on you, to stop unauthorised transfers of your personal information to a third party and, in some circumstances, to have personal information relating to you transferred to you or another organisation. If you are not happy with how we are processing your personal information, you have the right to make a complaint at any time to the relevant Data Protection Authority based on where you live. We would, however, appreciate the chance to deal with your concerns before you approach the Data Protection Authority, so please contact us in the first instance using the details set out below. ## General Data Protection Regulation (GDPR) – European Representative Pursuant to Article 27 of the General Data Protection Regulation (GDPR), Kinde Australia Pty Ltd has appointed European Data Protection Office (EDPO) as its GDPR Representative in the EU. You can contact EDPO regarding matters pertaining to the GDPR: * by using EDPO’s online request form: [https://edpo.com/gdpr-data-request/](https://edpo.com/gdpr-data-request/) * by writing to EDPO at Ground Floor, 71 Lower Baggot Street, Dublin, D02 P593, Ireland For any other questions or feedback, please contact us at [privacy@kinde.com](mailto:privacy@kinde.com). ## Additional rights and information for individuals located in California Under the California Consumer Privacy Act of 2018 (CCPA) and the California Privacy Rights Act of 2020 (CPRA), individuals located in California have extra rights which apply to their personal information. The table below sets out the additional rights we give to individuals located in California. | Rights | Legal basis | | :---- | :---- | | Disclosure of Personal Information We Collect About You | You have the right to know: The categories of Personal Information we have collected about you; The categories of sources from which the Personal Information is collected; Our business or commercial purpose for collecting or selling Personal Information; The categories of third parties with whom we share Personal Information, if any; and The specific pieces of Personal Information we have collected about you. Please note that we are not required to: Retain any personal information about you that was collected for a single one-time transaction if, in the ordinary course of business, that information about you is not retained; Reidentify or otherwise link any data that, in the ordinary course of business, is not maintained in a manner that would be considered personal information; or Provide the personal information to you more than twice in a 12-month period. | | Personal Information Sold or Used for a Business Purpose | In connection with any Personal Information we may sell or disclose to a third party for a business purpose, you have the right to know: The categories of Personal Information about you that we sold and the categories of third parties to whom the Personal Information was sold; and The categories of Personal Information that we disclosed about you for a business purpose. You have the right under the CCPA and the CPRA, as well as certain other privacy and data protection laws, as applicable, to opt-out of the sale or disclosure of your Personal Information. If you exercise your right to opt-out of the sale or disclosure of your Personal Information, we will refrain from selling your Personal Information, unless you subsequently provide express authorization for the sale of your Personal Information. To opt-out of the sale or disclosure of your personal information, please contact us at privacy@kinde.com. | | Right to Deletion | Subject to certain exceptions set out below, on receipt of a verifiable request from you, we will: Delete your Personal Information from our records; and Direct any service providers to delete your Personal Information from their records. Please note that we may not delete your Personal Information if it is necessary to: Complete the transaction for which the personal information was collected, fulfill the terms of a written warranty or product recall conducted in accordance with federal law, provide a good or service requested by you, or reasonably anticipated within the context of our ongoing business relationship with you, or otherwise perform a contract between you and us; Detect security incidents, protect against malicious, deceptive, fraudulent, or illegal activity; or prosecute those responsible for that activity; Debug to identify and repair errors that impair existing intended functionality; Exercise free speech, ensure the right of another consumer to exercise his or her right of free speech, or exercise another right provided for by law; Comply with the California Electronic Communications Privacy Act; Engage in public or peer-reviewed scientific, historical, or statistical research in the public interest that adheres to all other applicable ethics and privacy laws, when our deletion of the information is likely to render impossible or seriously impair the achievement of such research, provided we have obtained your informed consent; Enable solely internal uses that are reasonably aligned with your expectations based on your relationship with us; Comply with an existing legal obligation; or Otherwise use your personal information, internally, in a lawful manner that is compatible with the context in which you provided the information. | | Right to Correction | You have the right to request the correction of inaccurate personal information maintained by us. | | Right to Know About Automated Decision-Making | You have the right to know about and opt-out of automated decision-making, including profiling. | | Right to Access Information about Automated Decision-Making | You have the right to request information about the logic involved in automated decision-making processes and the potential consequences of those processes. | | Expanded Right to Access | You have the right to access personal information collected beyond the previous 12-month period, provided that doing so would not involve a disproportionate effort. | | Right to Limit Use of Sensitive Personal Information | You have the right to limit the use and disclosure of sensitive personal information to that which is necessary to perform the services or provide the goods reasonably expected by an average consumer. | | Protection Against Discrimination | You have the right to not be discriminated against by us because you exercised any of your rights under the CCPA or CPRA. This means we cannot, among other things: Deny goods or services to you; Charge different prices or rates for goods or services, including through the use of discounts or other benefits or imposing penalties; Provide a different level or quality of goods or services to you; or Suggest that you will receive a different price or rate for goods or services or a different level or quality of goods or services. Please note that we may charge a different price or rate or provide a different level or quality of goods or services to you, if that difference is reasonably related to the value provided to our business by your Personal Information. | ## Amendments We may, at any time and at our discretion, vary this Privacy Policy by publishing the amended Privacy Policy on our website. We recommend you check our website regularly to ensure you are aware of our current Privacy Policy. For any questions or notices, please contact us at [privacy@kinde.com](mailto:privacy@kinde.com). Last updated June 12, 2025. Kinde Australia Pty Ltd ([ABN 11 655 096 263](https://abr.business.gov.au/ABN/View?abn=11655096263))

# Trust center - Privacy and compliance - Sub-processors - Interactive

> Interactive tool to view relevant sub-processors based on your Kinde configuration including data region, services used, and email provider.

sub-processors, data processing, privacy, GDPR, DPA, third-party services, interactive, configuration
trust-center, privacy-and-compliance, data-processing

import SubProcessorsForm from '../../../../components/SubProcessorsForm.astro'; Please refer to the [sub-processors](/trust-center/privacy-and-compliance/sub-processors/) page for a comprehensive list of sub-processors, more information about how we use them, and how to request a Data Processing Agreement (DPA). Use the form below to see only the sub-processors relevant to your specific Kinde business. <SubProcessorsForm /> ## About this tool This interactive tool helps you identify which sub-processors are relevant to your specific Kinde business. The URL can be bookmarked for future reference. The results are filtered based on: - **Data Region**: The region where your Kinde instance is hosted - **Services Used**: Which Kinde services you're actively using - **Email Provider**: Whether you're using Kinde's default email service or your own [custom SMTP provider](/get-started/connect/customize-email-sender) - **SMS Provider**: Whether you're using Kinde's default SMS service or your own [custom SMS provider](/authenticate/authentication-methods/phone-authentication/)

# Trust center - Privacy and compliance - Sub-processors

> Comprehensive list of sub-processors used by Kinde for data processing, including authentication, billing, webhooks, and customer support services, with location information and update dates.

sub-processors, data processing, privacy, GDPR, DPA, third-party services, AWS, Stripe, webhooks
trust-center, privacy-and-compliance, data-processing

To support the delivery of our services, Kinde may engage and use data processors (“sub-processor“) with possible access to external user personal information that is uploaded, accessed, processed, or transmitted to and from our services. This page provides important information about the identity, role, and location of each sub-processor. If you have signed a Data Processing Agreement (DPA) with Kinde, we will notify you of any changes to sub-processors. If you need a DPA, please reach out to our team at support@kinde.com. Last update to the sub-processors for the external users is August 11, 2025. <Aside> **Want to see only the sub-processors relevant to your setup?** Use our [interactive sub-processors tool](/trust-center/privacy-and-compliance/sub-processors-interactive/) to filter results based on your specific configuration. </Aside> ## Sub-Processors for external users - Authentication External users are customers of Kinde’s customers. Kinde will share external user personal information to the following third parties to facilitate authentication and customer support. For public cloud hosting, SMS services, and webhooks, the location is directly aligned only with the customer’s selected Kinde region. Email services: If you are using your own [custom SMTP provider](/get-started/connect/customize-email-sender) to send emails via Kinde, AWS for email services is not a sub-processor. SMS services: If you are using your own [custom SMS provider](/authenticate/authentication-methods/phone-authentication/) to send SMS via Kinde, AWS for SMS services is not a sub-processor. Customer support: We do not recommend sending external user personal information, such as their email, in our support conversations, however we acknowledge that this may happen. All customer support tools, whether you interact with them or not, and their location of processing are listed. | Service provider | Entity type | Link | Location | | ---------------- | -------------------- | -------------------------------------------------------------- | --------------------------------------------------------- | | AWS | Public cloud hosting | [https://aws.amazon.com](https://aws.amazon.com/) | Australia, Canada, Ireland, United Kingdom, United States | | AWS | SMS services | [https://aws.amazon.com](https://aws.amazon.com/) | Australia, Canada, Ireland, United Kingdom, United States | | AWS | Email services | [https://aws.amazon.com](https://aws.amazon.com/) | Australia | | Temporal | Webhooks | [https://temporal.io](https://temporal.io/) | Australia, Canada, Ireland, United Kingdom, United States | | Discord | Customer support | [https://discord.com/](https://discord.com/) | United States | | Google | Customer support | [https://workspace.google.com/](https://workspace.google.com/) | United States | | InKeep | Customer support | [https://inkeep.com/](https://inkeep.com/) | United States | | Microsoft | Customer support | [https://www.microsoft.com/](https://www.microsoft.com/) | United States | | Plain | Customer support | [https://www.plain.com/](https://www.plain.com/) | United Kingdom | | Slack | Customer support | [https://slack.com/](https://slack.com/) | United States | ## Sub-Processors for external users - Billing External users are customers of Kinde’s customers. Kinde will share external user personal information to the following third parties to facilitate billing and customer support. For public cloud hosting, SMS services, and webhooks, the location is directly aligned only with the customer’s selected Kinde region. Email services: If you are using your own [custom SMTP provider](/get-started/connect/customize-email-sender) to send emails via Kinde, AWS for email services is not a sub-processor. SMS services: If you are using your own [custom SMS provider](/authenticate/authentication-methods/phone-authentication/) to send SMS via Kinde, AWS for SMS services is not a sub-processor. Customer support: We do not recommend sending external user personal information, such as their email, in our support conversations, however we acknowledge that this may happen. All customer support tools, whether you interact with them or not, and their location of processing are listed. | Service provider | Entity type | Link | Location | | ---------------- | --------------------- | -------------------------------------------------------------- | --------------------------------------------------------- | | AWS | Public cloud hosting | [https://aws.amazon.com](https://aws.amazon.com/) | Australia, Canada, Ireland, United Kingdom, United States | | AWS | SMS services | [https://aws.amazon.com](https://aws.amazon.com/) | Australia, Canada, Ireland, United Kingdom, United States | | AWS | Email services | [https://aws.amazon.com](https://aws.amazon.com/) | Australia | | Stripe | Billing and invoicing | [https://stripe.com](https://stripe.com/) | United States | | Temporal | Webhooks | [https://temporal.io](https://temporal.io/) | Australia, Canada, Ireland, United Kingdom, United States | | Discord | Customer support | [https://discord.com/](https://discord.com/) | United States | | Google | Customer support | [https://workspace.google.com/](https://workspace.google.com/) | United States | | InKeep | Customer support | [https://inkeep.com/](https://inkeep.com/) | United States | | Microsoft | Customer support | [https://www.microsoft.com/](https://www.microsoft.com/) | United States | | Plain | Customer support | [https://www.plain.com/](https://www.plain.com/) | United Kingdom | | Slack | Customer support | [https://slack.com/](https://slack.com/) | United States |

# Trust center - Security - Security at Kinde

> Comprehensive overview of Kinde's security practices including encryption, backups, disaster recovery, penetration testing, vulnerability management, and compliance measures.

security, encryption, backups, disaster recovery, penetration testing, vulnerability management, data residency, compliance
trust-center, security, infrastructure

Kinde takes security threats very seriously as the integrity, confidentiality, and availability of our systems potentially impact our customers. If you have detected a security threat or vulnerability against Kinde systems or personnel, please reach out to your account manager or to the security mailing group at [security@kinde.com](mailto:security@kinde.com). ## Availability Kinde production services are designed to be resistant to failure with multiple front-end servers and replicated back-end databases. Our main production databases are provisioned, but we use serverless for some supporting roles. All services are setup in AWS and are configured to use multiple availability zones for redundancy. Please refer to the [Kinde status page](https://status.kinde.com/) for uptime metrics. ## Backups Backups are performed at least daily to different storage for all production services and data. Databases holding customer data also have point in time recovery so that data can be retrieved from a particular update. Kinde performs restore testing at least annually to validate backup media and restore procedures. ## Business continuity and disaster recovery Kinde has documented and tested both our business continuity plan and disaster recovery plan. These are updated and refreshed at least annually to ensure that technical events such as a database failover or business impacting events such as a communications tool outage are understood with redundancy plans in place. ## Compliance Kinde holds a certificate of registration for ISO 27001:2022 and has a SOC 2 attestation. Please refer to our [Compliance certifications](/trust-center/privacy-and-compliance/compliance/) page for more information. ## Data residency Data is stored in the region you selected during sign up of our product. Currently the available regions are Sydney, Australia; Dublin, Ireland; Oregon, USA; and London, UK. The only data replicated between regions is backend metadata to facilitate the operation of the production services. Otherwise, all user data is not replicated between the regions and will remain in it’s original region. ## Denial of service Kinde uses a layered approach to protect it’s customers from denial of service attacks to the authentication pages and API, such as protections provided by AWS Shield, rate limiting rules with AWS WAF, and application based throttling. ## Encryption for data at rest All customer data at rest is encrypted in the Kinde production databases using the industry standard AES256 encryption algorithm. Encryption is facilitated by AWS KMS with access to administer KMS strictly limited to privileged admins. ## Encryption for data in transit All network traffic to Kinde production services uses TLS 1.2 or greater with a limited set of modern secure ciphers enforced. Security headers are applied to all production endpoints where possible. ## Identity management Internal identity is generally managed through the company’s single sign-on (SSO) platform provided by Google Workspace. All systems are connected to the company SSO platform where supported. Multi-factor authentication is enforced for all users and audit logs are enabled and monitored for systems connected to the company SSO. For systems that do not support SSO, employees are required to use the company provided password manager to generate and manage secure credentials as well as enable MFA for added protection. Access to systems is based on the employee’s job role with the least privileges assigned. Privileged access to any system is strictly limited based on the employee’s job role and accounts are individual to that user only. ## Penetration testing Kinde has completed a network and web application penetration test conducted by [Strike](https://strike.sh/), which was scoped for anything and everything related to Kinde. The test included common OWASP techniques and specifically targeted workflows such as privilege escalations, authentication bypasses, and cloud security. We intend to perform these at least annually. ## Security awareness All employees take part in a security onboarding session during their first week that covers topics such as acceptable use, phishing, data privacy, identity, endpoint protection, data classification, and incident response. ## Software development lifecycle All Kinde source code is managed by a company managed source code repository. Source code is scanned using a suite of open source tools, which will alert on insecure coding that could lead to vulnerabilities. Access to the source code repository is restricted based on job role with the identity linked to the company single sign-on platform. Merges to source code require a peer review. Pull requests to the master branch are performed by senior engineers. ## Vulnerability management Production services are deployed through a CICD pipeline using container technology. Server builds are done at least once a week and replace the existing servers. The build process will use the latest patched container host and container image to reduce the risk of vulnerabilities due to unpatched software. All container images are scanned at build using AWS Inspector for dependencies and third party library vulnerabilities. External production URLs and any public facing cloud IP addresses are scanned weekly for vulnerabilities by Intruder. All vulnerability reports are triaged, analysed, and assigned to the engineering team for remediation based on vulnerability management SLAs.

# Trust center - Security - Security wall of fame

> Recognition page for security researchers who have responsibly disclosed vulnerabilities to help secure Kinde's systems, organized by year with links to researcher profiles.

security researchers, vulnerability disclosure, bug bounty, responsible disclosure, security wall of fame
trust-center, security, vulnerability-disclosure

Kinde sends out huge thanks and massive props to the security researchers who responsibly disclose vulnerabilities that help secure our systems. The list also includes testers who take part in our security challenges each year. Everyone listed on this page has submitted one or more valid vulnerabilities, and they consented to their information being published. Love your work! ## 2025 ### Disclosures [Aftab Raja](https://www.linkedin.com/in/aftab-raja-a83052250) [Vorombetech Solutions](https://www.vorombetech.com/) [cyberritzzz](https://www.linkedin.com/in/prerit-yaduvanshi) [Nahid Hasan Limon](https://x.com/nh___limon) [Andrew Rauber](https://www.linkedin.com/in/andrew-rauber/) ## 2024 ### Disclosures [August Lilleaas](https://www.linkedin.com/in/augustlilleaas/) [Lindit Ajvazaj](https://www.linkedin.com/in/lindit-ajvazaj/) [Muhammad Naseem](https://www.linkedin.com/in/muhammad-naseem-746363229/) [Jonas Arnfred](https://www.linkedin.com/in/jonasarnfred/) ## 2023 ### Strike security challenge [Agustin Aguirre](https://www.linkedin.com/in/agus1/) [Genaro Franceschelli](https://www.linkedin.com/in/g-franceschelli/) [jav0x](https://www.linkedin.com/in/javier-bernardo-210b70178/) [Lemonoftroy](https://www.linkedin.com/in/apedrazzoli) [Luis Eduardo Jácome Valencia](https://www.linkedin.com/in/mortalpoison/) MrWhite [Yatin Sirpaul](https://in.linkedin.com/in/yatin-sirpaul-7a323674) ### Disclosures [Ayush Jaiswal](https://www.linkedin.com/in/jaiswal-ayush/) [Nicolas Hedger](https://www.linkedin.com/in/nhedger/) ## 2022 ### Disclosures [Hamza Farooqi](https://www.linkedin.com/in/hamza-farooqi-a87509204) [Niket Popat](https://twitter.com/niketatbar) [Sachin Kalkumbe](https://www.linkedin.com/in/sachin-kalkumbe-462824201/) [Karan Rathod](https://www.linkedin.com/in/karan-rathod-35aa951b1)

# Trust center - Security - Vulnerability disclosure policy

> Comprehensive vulnerability disclosure policy outlining how security researchers can report vulnerabilities to Kinde, including scope, expectations, safe harbor provisions, and official reporting channels.

vulnerability disclosure, security policy, bug bounty, responsible disclosure, safe harbor, security research
trust-center, security, vulnerability-disclosure

## **Introduction** Kinde welcomes feedback from security researchers and the general public to help improve our security. If you believe you have discovered a vulnerability, privacy issue, exposed data, or other security issues in any of our assets, we want to hear from you. This policy outlines steps for reporting vulnerabilities to us, what we expect, what you can expect from us. We value those who take the time and effort to report security vulnerabilities according to this policy. Validated submissions will be featured on our [Security wall of fame](/trust-center/security/security-wall-of-fame/) and will receive a security specific Kinde swag shirt as a thank you. We do not offer monetary rewards for vulnerability disclosures, this is not a bug bounty. ## **Systems in scope** This policy applies to any digital assets owned, operated, or maintained by Kinde. - kinde.com and subdomains. ## **Out of scope** Assets not owned by parties participating in this policy, such as, but not limited to: - status.kinde.com - chat.kinde.com Vulnerabilities discovered or suspected in out-of-scope systems should be reported to the appropriate vendor or applicable authority. Additionally: - Denial of service and volume based; - TLS configuration weaknesses such as cipher or versions; - Reports that our services do not align with best practices such as missing security headers; - Non-exploitable vulnerabilities. ## **Our commitments** When working with us, according to this policy, you can expect us to: - Respond to your report promptly, and work with you to understand and validate your report; - Strive to keep you informed about the progress of a vulnerability as it is processed; - Work to remediate discovered vulnerabilities in a timely manner, within our operational constraints; and - Extend Safe Harbor for your vulnerability research that is related to this policy; - Confirmed and valid vulnerabilities will be eligible for listing on our [Security wall of fame](/trust-center/security/security-wall-of-fame/) and security specific Kinde swag. ## **Our expectations** In participating in our vulnerability disclosure program in good faith, we ask that you: - Play by the rules, including following this policy and any other relevant agreements. If there is any inconsistency between this policy and any other applicable terms, the terms of this policy will prevail; - Report any vulnerability you’ve discovered promptly; - Avoid violating the privacy of others, disrupting our systems, destroying data, and/or harming user experience; - Use only the Official Channels to discuss vulnerability information with us; - Provide us a reasonable amount of time to resolve the issue; - Public or coordinated disclosure of the vulnerability is not allowed; - Perform testing only on in-scope systems, and respect systems and activities which are out-of-scope; - If a vulnerability provides unintended access to data: Limit the amount of data you access to the minimum required for effectively demonstrating a Proof of Concept; and cease testing and submit a report immediately if you encounter any user data during testing, such as Personally Identifiable Information (PII), Personal Healthcare Information (PHI), credit card data, or proprietary information; - You should only interact with test accounts you own or with explicit permission from the account holder; and - Do not engage in extortion. ## **Official channels** Please report security issues via [security@kinde.com](mailto:security@kinde.com), providing all relevant information. The more details you provide, the easier it will be for us to triage and fix the issue. ## **Safe harbor** When conducting vulnerability research, according to this policy, we consider this research conducted under this policy to be: - Authorized concerning any applicable anti-hacking laws; - Authorized concerning any relevant anti-circumvention laws, and we will not bring a claim against you for circumvention of technology controls; - Exempt from restrictions in our [Terms of Service](/trust-center/agreements/terms-of-service/) that would interfere with conducting security research, and we waive those restrictions on a limited basis; and - Lawful, helpful to the overall security of the Internet, and conducted in good faith. You are expected, as always, to comply with all applicable laws. If legal action is initiated by a third party against you and you have complied with this policy, we will take steps to make it known that your actions were conducted in compliance with this policy. If at any time you have concerns or are uncertain whether your security research is consistent with this policy, please submit a report through one of our Official Channels before going any further. <Aside> Note that the Safe Harbor applies only to legal claims under the control of the organization participating in this policy, and that the policy does not bind independent third parties. </Aside>

# Workflows - About workflows - About workflows

> Learn about Kinde workflows - custom code execution triggered by Kinde events that allows unlimited customization of authentication flows, token generation, and external integrations using TypeScript/JavaScript.

workflows, customization, triggers, TypeScript, JavaScript, token customization, external integrations
workflows, about-workflows, customization

In Kinde, workflows exist to give you (almost) unlimited power over how Kinde works for you. Develop code in your own repo, and push it to a Kinde workflow, where we execute it in ways that you define, triggered by Kinde events. See the [Triggers](/workflows/example-workflows/workflow-user-post-auth/) section for the whole list of triggers. We will add more (and allow you to create your own) as we develop the feature. ## When to use a workflow - You want Kinde to do something that it doesn’t currently do. - You want to customize an access or ID tokens in ways that we don’t support out of the box. For example, you want to fetch data from an external system to include it as claims in your tokens. - You want to reduce the size and weight of tokens, remove things that you don’t need. - You want to change the data type of a claim. For example changing from an array to a space delimited string. ## Basic workflow rules - Workflow actions need to be written in TypeScript or plain JavaScript - Filenames must end in the word 'Workflow' for Kinde to recognize them as containing workflow code. For example, `MFAWorkflow.ts` or `PreauthorizationWorkflow.jsx` - File extensions should be .ts, .js, .tsx or .jsx - Each trigger can only have one workflow - Only Kinde-defined triggers are available (for now) ## Explanation of methods and code helpers We’ve provided a set of methods and examples in our [Infrastructure repo in GitHub](https://github.com/kinde-oss/infrastructure). The README contains a guide to creating the code that powers your workflows.

# Workflows - Bindings - kinde.accessToken

> Learn how to modify access tokens for the current user using the kinde.accessToken binding, including adding custom claims that are included in the token returned to the client.

access token, custom claims, token modification, setCustomClaim, infrastructure library
workflows, bindings, tokens

The `kinde.accessToken` binding lets you modify access tokens for the current user. When you add custom claims, they are included in the access token returned to the client. ## Methods ### `setCustomClaim(name: string, value: any): void` Adds a custom claim to the access token. The claim will be available when the token is returned to the client. ## Available in workflows - [user:tokens_generation](/workflows/example-workflows/user-token-generation/) ## Configuration ```js export const workflowSettings = { // ...other settings bindings: {"kinde.accessToken": {}} }; ``` ## Usage ### Using the Kinde infrastructure library (recommended) The [Kinde infrastructure library](https://github.com/kinde-oss/infrastructure) provides type-safe access token modification: ```js import { accessTokenCustomClaims } from "@kinde/infrastructure"; export default async function (event: onUserTokenGeneratedEvent) { const accessToken = accessTokenCustomClaims<{ hello: string; ipAddress: string; }>(); accessToken.hello = "Hello there!"; accessToken.ipAddress = event.request.ip; }; ``` ### Using the low-level API If you're not using the infrastructure library, you can modify the access token directly: ```js kinde.accessToken.setCustomClaim("hello", "Hello there!"); kinde.accessToken.setCustomClaim("ipAddress", event.request.ip); ```

# Workflows - Bindings - kinde.auth

> Learn how to control authentication flows using the kinde.auth binding, including denying access to users based on custom logic in various workflow contexts.

auth, authentication, user management, infrastructure library
workflows, bindings, authentication

The `kinde.auth` binding affects the auth flow. ## Methods ### `denyAccess(reason: string): void` Prevent the user from accessing the application. ## Available in workflows - [user:pre_registration](/workflows/example-workflows/pre-user-registration-workflow/) - [user:post_authentication](/workflows/example-workflows/workflow-user-post-auth/) - [user:new_password_provided](/workflows/example-workflows/new-password-provided-workflow/) - [user:existing_password_provided](/workflows/example-workflows/existing-password-provided-workflow/) - [user:tokens_generation](/workflows/example-workflows/user-token-generation/) - [user:pre_mfa](/workflows/example-workflows/pre-mfa-workflow/) ## Configuration ```js export const workflowSettings = { // ...other settings bindings: {"kinde.auth": {}} }; ``` ## Usage ### Using the Kinde infrastructure library (recommended) The [Kinde infrastructure library](https://github.com/kinde-oss/infrastructure) provides a type-safe helper: ```js import { denyAccess } from "@kinde/infrastructure"; export default async function (event: onUserTokenGeneratedEvent) { if (event.request.ip.startsWith("192")) { denyAccess("You are not allowed to access this resource"); } } ``` ### Using the low-level API If you're not using the infrastructure library, you can call the underlying API directly: ```js kinde.auth.denyAccess("You are not allowed to access this resource"); ```

# Workflows - Bindings - kinde.env

> Learn how to access environment variables and configuration settings in your workflows using the kinde.env binding, including handling both regular and secret variables.

environment variables, configuration, secrets, env, infrastructure library
workflows, bindings, environment

The `kinde.env` binding lets you access environment variables in your workflows that you have previously set up in the [Kinde admin area](/build/env-variables/add-manage-env-variables/) or via the [management API](https://docs.kinde.com/kinde-apis/management/#tag/environment-variables/post/api/v1/environment_variables). ## Methods ### `getEnvironmentVariable(key: string): {value: string, isSecret: boolean}` Get the value of an environment variable. The value is returned as an object with two properties: `value` (the value of the variable) and `isSecret` (a boolean indicating whether the variable is a secret). Secret variables will be redacted in the logs. ## Available in workflows - [user:pre_registration](/workflows/example-workflows/pre-user-registration-workflow/) - [user:post_authentication](/workflows/example-workflows/workflow-user-post-auth/) - [m2m:token_generation](/workflows/example-workflows/m2m-token-generation-workflow/) - [user:new_password_provided](/workflows/example-workflows/new-password-provided-workflow/) - [user:existing_password_provided](/workflows/example-workflows/existing-password-provided-workflow/) - [user:tokens_generation](/workflows/example-workflows/user-token-generation/) - [user:pre_mfa](/workflows/example-workflows/pre-mfa-workflow/) - [user:plan_selection](/workflows/example-workflows/plan-selection-workflow/) - [user:plan_cancellation_request](/workflows/example-workflows/plan-cancellation-request-workflow/) ## Configuration ```js export const workflowSettings = { // ...other settings bindings: {"kinde.env": {}} }; ``` ## Usage ### Using the Kinde infrastructure library (recommended) The [Kinde infrastructure library](https://github.com/kinde-oss/infrastructure) provides type-safe environment variable access: ```js import {getEnvironmentVariable} from "@kinde/infrastructure"; const myVar = getEnvironmentVariable("MY_VAR")?.value; ``` ### Using the low-level API If you're not using the infrastructure library, you can call the underlying API directly: ```js kinde.env.getEnvironmentVariable("MY_VAR")?.value; ```

# Workflows - Bindings - kinde.fetch

> Learn how to make external API calls including to the Kinde Management API using the kinde.fetch binding, with support for GET/POST requests and JSON responses.

fetch, HTTP requests, API calls, external APIs, Management API, infrastructure library
workflows, bindings, HTTP requests

The `kinde.fetch` binding allows you to make external API calls including to the Kinde Management API. If you are passing sensitive data we recommend you instead use [kinde.secureFetch](/workflows/bindings/secure-fetch-binding/) where the POST body is encrypted. ## Available in workflows - [user:pre_registration](/workflows/example-workflows/pre-user-registration-workflow/) - [user:post_authentication](/workflows/example-workflows/workflow-user-post-auth/) - [m2m:token_generation](/workflows/example-workflows/m2m-token-generation-workflow/) - [user:new_password_provided](/workflows/example-workflows/new-password-provided-workflow/) - [user:existing_password_provided](/workflows/example-workflows/existing-password-provided-workflow/) - [user:tokens_generation](/workflows/example-workflows/user-token-generation/) - [user:pre_mfa](/workflows/example-workflows/pre-mfa-workflow/) - [user:plan_selection](/workflows/example-workflows/plan-selection-workflow/) - [user:plan_cancellation_request](/workflows/example-workflows/plan-cancellation-request-workflow/) ## Configuration ```js export const workflowSettings = { // ...other settings bindings: {"kinde.fetch": {}} }; ``` ## Usage ### Using the Kinde infrastructure library (recommended) The [Kinde infrastructure library](https://github.com/kinde-oss/infrastructure) provides a type-safe fetch helper. Note: you will also need the [url](/workflows/bindings/url-binding/) binding enabled for the workflow as this is used under the hood. ```js import {fetch} from "@kinde/infrastructure"; export default async function Workflow(event) { const {data: ipDetails} = await fetch( `https://ipinfo.io/${event.request.ip}`, { method: "GET", responseFormat: "json", headers: {"Content-Type": "application/json"} } ); console.log(ipDetails); } ``` ### Using the low-level API If you're not using the infrastructure library, you can call the underlying API directly: ```js const res = await kinde.fetch(`https://ipinfo.io/${event.request.ip}`, { method: "GET", responseFormat: "json", headers: {"Content-Type": "application/json"} }); const {json} = res; console.log(json); ```

# Workflows - Bindings - kinde.idToken

> Learn how to modify ID tokens for the current user using the kinde.idToken binding, including adding custom claims that are included in the ID token returned to the client.

ID token, custom claims, token modification, setCustomClaim, infrastructure library
workflows, bindings, tokens

The `kinde.idToken` binding lets you modify ID tokens for the current user. When you add custom claims, these are included in the ID token returned to the client. ## Methods ### `setCustomClaim(name: string, value: any): void` Adds a custom claim to the ID token. The claim will be available when the token is returned to the client. ## Available in workflows - [user:tokens_generation](/workflows/example-workflows/user-token-generation/) ## Configuration ```js export const workflowSettings = { // ...other settings bindings: {"kinde.idToken": {}} }; ``` ## Usage ### Using the Kinde infrastructure library (recommended) The [Kinde infrastructure library](https://github.com/kinde-oss/infrastructure) provides type-safe ID token modification: ```js import { idTokenCustomClaims } from "@kinde/infrastructure"; export default async function (event: onUserTokenGeneratedEvent) { const idToken = idTokenCustomClaims<{ userRole: string; lastLogin: string; }>(); idToken.userRole = "admin"; idToken.lastLogin = new Date().toISOString(); }; ``` ### Using the low-level API If you're not using the infrastructure library, you can modify the ID token directly: ```js kinde.idToken.setCustomClaim("userRole", "admin"); kinde.idToken.setCustomClaim("lastLogin", new Date().toISOString()); ```

# Workflows - Bindings - Bindings overview

> Overview of Kinde workflow bindings that allow workflow code to interact with Kinde infrastructure resources including tokens, authentication, environment variables, and HTTP requests.

bindings, Kinde bindings, native bindings, workflow resources, infrastructure integration
workflows, bindings, infrastructure

Bindings allow your workflow code to interact with resources within the Kinde infrastructure. ## Available bindings The following bindings are available. Only some are available within specific workflow contexts. Check the documentation to confirm which bindings are available for each workflow trigger. ### Kinde specific bindings: - [kinde.accessToken](/workflows/bindings/access-token-binding/) - [kinde.auth](/workflows/bindings/auth-binding/) - [kinde.env](/workflows/bindings/env-binding/) - [kinde.fetch](/workflows/bindings/fetch-binding/) - [kinde.idToken](/workflows/bindings/id-token-binding/) - [kinde.m2mToken](/workflows/bindings/m2m-token-binding/) - [kinde.mfa](/workflows/bindings/mfa-binding/) - [kinde.plan](/workflows/bindings/plan-binding/) - [kinde.secureFetch](/workflows/bindings/secure-fetch-binding/) ### Native bindings - [url](/workflows/bindings/url-binding/)

# Workflows - Bindings - kinde.m2mToken

> Learn how to modify machine-to-machine (M2M) tokens using the kinde.m2mToken binding, including adding custom claims that are included in the token returned to the client.

M2M token, machine-to-machine, custom claims, token modification, setCustomClaim, infrastructure library
workflows, bindings, tokens

The `kinde.m2mToken` binding lets you modify M2M (machine-to-machine) tokens. When you add custom claims, these are included in the M2M token returned to the client. ## Methods ### `setCustomClaim(name: string, value: any): void` Adds a custom claim to the M2M token. The claim is available when the token is returned to the client. ## Available in workflows - [m2m:token_generation](/workflows/example-workflows/m2m-token-generation-workflow/) ## Configuration ```js export const workflowSettings = { // ...other settings bindings: {"kinde.m2mToken": {}} }; ``` ## Usage ### Using the Kinde infrastructure library (recommended) The [Kinde infrastructure library](https://github.com/kinde-oss/infrastructure) provides type-safe M2M token modification: ```js import { m2mTokenCustomClaims } from "@kinde/infrastructure"; export default async function (event: onM2mTokenGeneratedEvent) { const m2mToken = m2mTokenCustomClaims<{ applicationId: string; apiVersion: string; permissions: string[]; }>(); m2mToken.applicationId = event.application.id; m2mToken.apiVersion = "v2"; m2mToken.permissions = ["read:data", "write:data"]; }; ``` ### Using the low-level API If you're not using the infrastructure library, you can modify the M2M token directly: ```js kinde.m2mToken.setCustomClaim("applicationId", event.application.id); kinde.m2mToken.setCustomClaim("apiVersion", "v2"); kinde.m2mToken.setCustomClaim("permissions", ["read:data", "write:data"]); ```

# Workflows - Bindings - kinde.mfa

> Learn how to perform multi-factor authentication (MFA) operations in workflows using the kinde.mfa binding, including setting enforcement policies for authentication flows.

MFA, multi-factor authentication, authentication, infrastructure library
workflows, bindings, MFA

The `kinde.mfa` binding lets you perform MFA-related operations. ## Methods ### `setEnforcementPolicy(policy: 'required' | 'skip'): void` Allows you to set the MFA enforcement policy for the user for the current auth flow. The policy can be either `required` or `skip`. ## Available in workflows - [user:pre_mfa](/workflows/example-workflows/pre-mfa-workflow/) ## Configuration ```js export const workflowSettings = { // ...other settings bindings: {"kinde.mfa": {}} }; ``` ## Usage ### Using the Kinde infrastructure library (recommended) The [Kinde infrastructure library](https://github.com/kinde-oss/infrastructure) provides type-safe helper to set the policy: ```js import {setEnforcementPolicy} from "@kinde/infrastructure"; export default async function (event) { setEnforcementPolicy("required"); } ``` ### Using the low-level API If you're not using the infrastructure library, you can call the underlying API directly: ```js kinde.mfa.setEnforcementPolicy("required"); ```

# Workflows - Bindings - kinde.plan

> Learn how to manage billing and subscription plan events in workflows using the kinde.plan binding, including denying plan changes or cancellations based on custom logic.

plan, billing, subscription, infrastructure library
workflows, bindings, billing

The `kinde.plan` binding provides methods to use for various plan related events such as when a customer requests to cancel or change their plan. ## Available in workflows - [user:plan_cancellation_request](/workflows/example-workflows/plan-cancellation-request-workflow/) - [user:plan_selection](/workflows/example-workflows/plan-selection-workflow/) ## Configuration ```js export const workflowSettings = { // ...other settings bindings: {"kinde.plan": {}} }; ``` ## Methods ### `denySelection(reason: string, suggestions: string[]): void` Prevent the user from changing their plan. #### Using the Kinde infrastructure library (recommended) The [Kinde infrastructure library](https://github.com/kinde-oss/infrastructure) provides a type-safe helper: ```js import { denyPlanSelection } from "@kinde/infrastructure"; export default async function (event: onPlanSelectionEvent) { if (!canChangePlan()) { denyPlanSelection("You are not allowed to change your plan as you have outstanding payments"); } } ``` #### Using the low-level API If you're not using the infrastructure library, you can call the underlying API directly: ```js kinde.plan.denySelection( "You are not allowed to change your plan as you have outstanding payments ); ``` ### `denyCancellation(reason: string): void` Prevent the user from cancelling their plan. #### Using the Kinde infrastructure library (recommended) The [Kinde infrastructure library](https://github.com/kinde-oss/infrastructure) provides a type-safe helper: ```js import { denyPlanCancellation } from "@kinde/infrastructure"; export default async function (event: onPlanCancellationRequestEvent) { if (!canChangePlan()) { denyPlanCancellation("You are not allowed to change your plan as you have outstanding payments"); } } ``` #### Using the low-level API If you're not using the infrastructure library, you can call the underlying API directly: ```js kinde.plan.denyCancellation( "You are not allowed to cancel your plan as you have outstanding payments ); ```

# Workflows - Bindings - kinde.secureFetch

> Learn how to make encrypted HTTP POST requests for sensitive data in workflows using the kinde.secureFetch binding, with automatic encryption of POST body content.

secure fetch, encrypted requests, sensitive data, HTTP requests, security, infrastructure library
workflows, bindings, security

The `kinde.secureFetch` binding allows you to make POST requests to external APIs where the payload is encrypted with the [workflow encryption key](/workflows/manage-workflows/workflow-encryption-key/) you have previously set up in Kinde. ## Available in workflows - [user:pre_registration](/workflows/example-workflows/pre-user-registration-workflow/) - [user:post_authentication](/workflows/example-workflows/workflow-user-post-auth/) - [m2m:token_generation](/workflows/example-workflows/m2m-token-generation-workflow/) - [user:new_password_provided](/workflows/example-workflows/new-password-provided-workflow/) - [user:existing_password_provided](http://localhost:4321/workflows/example-workflows/existing-password-provided-workflow/) - [user:tokens_generation](/workflows/example-workflows/user-token-generation/) - [user:pre_mfa](http://localhost:4321/workflows/example-workflows/pre-mfa-workflow/) - [user:plan_selection](/workflows/example-workflows/plan-selection-workflow/) - [user:plan_cancellation_request](/workflows/example-workflows/plan-cancellation-request-workflow/) ## Configuration ```js export const workflowSettings = { // ...other settings bindings: {"kinde.secureFetch": {}} }; ``` ## Usage ### Using the Kinde infrastructure library (recommended) The [Kinde infrastructure library](https://github.com/kinde-oss/infrastructure) provides type-safe secure fetch requests: Note: you will also need the [url](/workflows/bindings/url-binding/) binding enabled for the workflow as this is used under the hood. ```js import {fetch} from "@kinde-oss/infrastructure"; export default async function Workflow(event) { const {data} = await secureFetch(`https://api.somethingsecret.com/api`, { method: "POST", responseFormat: "json", headers: {"Content-Type": "application/json"} }); console.log(data); } ``` ### Using the low-level API If you're not using the infrastructure library, you can call the underlying API directly: ```js const res = await kinde.secureFetch(`https://ipinfo.io/${event.request.ip}`, { method: "POST", responseFormat: "json", headers: {"Content-Type": "application/json"} }); const {json} = res; console.log(json); ```

# Workflows - Bindings - url

> Learn how to use the native url binding in workflows for URL parsing and manipulation, often used with fetch bindings for API requests.

URL, URL parsing, native binding, URL manipulation
workflows, bindings, URL parsing

The `url` binding allows you to access the native JavaScript `URLSearchParams` API. This is useful for parsing and manipulating URLs in your workflow and is often used in conjunction with the [kinde.fetch](/workflows/bindings/fetch-binding/) binding. ## Available in workflows - [user:pre_registration](/workflows/example-workflows/pre-user-registration-workflow/) - [user:post_authentication](/workflows/example-workflows/workflow-user-post-auth/) - [m2m:token_generation](/workflows/example-workflows/m2m-token-generation-workflow/) - [user:new_password_provided](/workflows/example-workflows/new-password-provided-workflow/) - [user:existing_password_provided](/workflows/example-workflows/existing-password-provided-workflow/) - [user:tokens_generation](/workflows/example-workflows/user-token-generation/) - [user:pre_mfa](/workflows/example-workflows/pre-mfa-workflow/) - [user:plan_selection](/workflows/example-workflows/plan-selection-workflow/) - [user:plan_cancellation_request](/workflows/example-workflows/plan-cancellation-request-workflow/) ## Configuration ```js export const workflowSettings = { // ...other settings bindings: { url: {} } }; ``` ## Usage ### Using the low-level API Once the binding is enabled you can use `new URLSearchParams` directly. ```js export default async function (event) { const {data: token} = await fetch(`https://someapi.com/api`, { method: "POST", responseFormat: "json", headers: {"Content-type": "application/x-www-form-urlencoded"}, body: new URLSearchParams({a: "b", b: "c"}) }); } ```

# Workflows - Configuration - Bindings

> Learn how to configure bindings in workflow settings, including how to enable and configure various Kinde infrastructure bindings for your workflow code.

bindings configuration, workflow settings, infrastructure bindings, Kinde bindings
workflows, configuration, bindings

Bindings allow your workflow code to interact with resources within the Kinde infrastructure. When you declare a binding in your workflow, you grant it a specific capability, such as being able to access environment variables or add claims to an access token. For example: ```js export const workflowSettings: WorkflowSettings = { bindings: { "kinde.env": {} }, ... }; ``` If a binding is not declared and you try to use it in the workflow, you'll get a runtime error. ## Available bindings The following bindings available, but only within certain workflow contexts. Check the documentation to see which bindings are available for each workflow trigger. ### Kinde specific bindings: - [kinde.accessToken](/workflows/bindings/access-token-binding/) - [kinde.auth](/workflows/bindings/auth-binding/) - [kinde.env](/workflows/bindings/env-binding/) - [kinde.fetch](/workflows/bindings/fetch-binding/) - [kinde.idToken](/workflows/bindings/id-token-binding/) - [kinde.m2mToken](/workflows/bindings/m2m-token-binding/) - [kinde.mfa](/workflows/bindings/mfa-binding/) - [kinde.plan](/workflows/bindings/plan-binding/) - [kinde.secureFetch](/workflows/bindings/secure-fetch-binding/) ### Native bindings - [url](/workflows/bindings/url-binding/)

# Workflows - Configuration - Dependencies

> Learn how to manage dependencies in workflow projects, including package.json configuration, supported libraries, and external library usage in Kinde workflows.

dependencies, package.json, NPM packages, workflow dependencies, external libraries
workflows, configuration, dependencies

Kinde's workflow runtime operates differently from Node.js. Workflows provide a secure, restricted JavaScript environment with access only to a pre-defined set of trusted packages. While Kinde doesn't require a `package.json` file by default, you'll need one if you want to use third-party libraries whilst developing your workflow code. ## Set up package.json To include third-party libraries in your workflow: 1. **Create a package.json file** Generate one using `npm init` or create it manually in your project directory. 2. **Add dependencies** List the required libraries in the `dependencies` section: ```json {"dependencies": {"@kinde/infrastructure": "^0.21.1", "react": "^4.17.21"}} ``` ## Supported packages Runtime dependencies must be part of the Kinde-supported library list. Unsupported libraries won't function in the Kinde workflow runtime and will cause an exception to be thrown. ## Lock package versions By default, Kinde uses the latest version of imported packages. To lock specific versions: - Enable the [npm integration](/workflows/configuration/kinde-json/) in your `kinde.json` file - Ensure both `kinde.json` and `package.json` files are in the same directory

# Workflows - Configuration - Environment variables and secrets

> Learn how to manage environment variables and secrets in workflow configurations, including secure storage and access methods for sensitive information.

environment variables, secrets, configuration, security, env binding
workflows, configuration, security

You can set up environment variables and secrets in Kinde to use in your workflow code. This is useful for storing sensitive information, such as API keys or database credentials that you don't want to hard-code into your workflow files. ## Creating environment variables You can create environment variables in the [Kinde admin area](/build/env-variables/add-manage-env-variables/) or via the [management API](https://docs.kinde.com/kinde-apis/management/#tag/environment-variables/post/api/v1/environment_variables). ## Using environment variables in your code The `kinde.env` binding must be enabled in your workflow file to use environment variables. If you are using the Kinde infrastructure library, it provides a helper method to access environment variables: ```js import {getEnvironmentVariable} from "@kinde/infrastructure"; const myVar = getEnvironmentVariable("MY_VAR")?.value; ``` You can also use the `getEnvironmentVariable` method to access sensitive environment variables / secrets. Sensistive environment variables are only visible to the Kinde runtime and have their values redacted if they are logged. If you are not using the Kinde infrastructure library, you can access environment variables directly using the low level API. ## process.env Kinde is not a Node runtime so the `process` object is not available. Instead, you access environment variables using the methods described above.

# Workflows - Configuration - kinde.json

> Learn how to use the kinde.json configuration file to define project structure and tell Kinde where to discover workflow files in repositories.

kinde.json, configuration file, project structure, root directory, workflow discovery
workflows, configuration, project-structure

The `kinde.json` file controls how Kinde runs your workflow code. Place this file in your project's root directory so Kinde can discover your configuration during sync. ## Configuration options The `kinde.json` file lets you: - Specify the root directory for your custom code - Define the runtime environment version - Enable integrations you need When you sync your project to Kinde, it reads this file to understand your workflow's requirements and set up the appropriate runtime environment. ## Example ```json { "rootDir": "kindeSrc", "version": "2024-12-09", "integrations": {"npm": {"enabled": true}} } ``` ## API reference ### `rootDir` (string) Tells Kinde where to look for your custom code. - **Required:** No - **Default:** `kindeSrc` ### `version` (string) The version of the Kinde runtime environment. The date reflects the last breaking change. - **Required:** Yes ### `integrations` (object) The integrations you wish to use. Currently only `npm` is supported. - **Required:** No #### `npm` (object) The npm integration allows you to lock down package versions. For this to take effect, the `kinde.json` file must live in the same directory as the `package.json` responsible for defining the versions. - **Required:** No Example: ```json {"integrations": {"npm": {"enabled": true}}} ```

# Workflows - Configuration - Workflow settings

> Learn how to configure workflow settings in Kinde, including triggers, bindings, and other workflow-specific options using the workflowSettings object.

workflow settings, workflowSettings, triggers, bindings, configuration
workflows, configuration, settings

Every workflow file must export a configuration object named `workflowSettings` that defines how your workflow behaves. ## Example configuration ```js export const workflowSettings = { bindings: {"kinde.env": {}, "kinde.fetch": {}, url: {}}, failurePolicy: {action: "continue"}, id: "hubspotSync", name: "HubSpot sync", trigger: "user:tokens_generation" }; ``` ## API reference ### `bindings` (object) Kinde helper methods to access within your workflow code. See [bindings](/workflows/configuration/bindings/) for more details. ### `failurePolicy` (object) Defines behavior when workflow execution fails (for example, during fetch timeouts or exceptions). ### `id` (string) Unique identifier for the workflow. ### `name` (string) Display name shown in the Kinde admin area. ### `trigger` (string) Event that starts the workflow (for example, `user:tokens_generation`).

# Workflows - Example workflows - Existing password provided workflow

> Learn about the existing password provided workflow trigger that fires when users provide existing passwords, enabling validation against external databases and migration workflows.

existing password, password validation, password migration, drip feed migration, authentication triggers
workflows, example-workflows, passwords

Trigger: `user:existing_password_provided` This trigger fires after an existing password is entered in the sign-in flow. ## Security considerations Security is at the heart of our technical decisions at Kinde, and keeping user passwords safe is a huge part of this. Therefore: - Any attempt to log the password out to the console in this workflow will be redacted - API calls should only be made from these workflows using the Kinde provided [secureFetch](/workflows/bindings/secure-fetch-binding/) binding which secures the payload with an encryption key ## Example use cases ### Drip feed migration For gradual migrations to Kinde where you wish to check the password against an external database before creating the user in Kinde and migrating their password. [See example code](https://github.com/kinde-starter-kits/workflow-examples/blob/main/existingPassword/dripFeedMigrationWorkflow.ts) ## Workflow code ### Sample event object The main argument provided to your code is the Kinde workflow `event` object which has two keys `request` and `context`. This gives you access to the reason the workflow was triggered. Here's an example: ```json { "request": { "ip": "192.168.0.1", "userAgent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:135.0) Gecko/20100101 Firefox/135.0" }, "context": { "domains": { "kindeDomain": "https://example.kinde.com" // Your Kinde domain }, "auth": { "providedEmail": "hello@example.com", // the email provided by the user "password": "someSecurePassword", // the raw password "hashedPassword": "someHash", // the hashed password, "hasUserRecordInKinde": false // whether the user exists already in Kinde }, "user": { "id": "kp_1234566" // only provided in password reset flows as otherwise new user }, "workflow": { "trigger": "user:existing_password_provided" } } } ``` ### Secure fetch binding We recommend you use the [secureFetch](/workflows/bindings/secure-fetch-binding/) binding to make API calls from your workflow if they include sensitive data like passwords. ### Widget binding The `kinde.widget` binding gives you access to the Kinde widget, which is the central form on the page. In this case the form with the two password fields. It exposes a method for invalidating a form field `invalidateFormField` ```js kinde.widget.invalidateFormField(fieldName, message); ``` Example ```js if (!isUserPasswordValid) { kinde.widget.invalidateFormField("p_password", "User or password not found"); } ``` The field names for the widget binding in this workflow are: | Field name | Description | | ------------ | ------------------ | | `p_password` | The password field | ### Example workflows See examples on GitHub: [Drip feed migration](https://github.com/kinde-starter-kits/workflow-examples/blob/main/existingPassword/dripFeedMigrationWorkflow.ts) - Shows how to check a password against an external database before creating the user in Kinde.

# Workflows - Example workflows - M2M token generation workflow

> Learn about the M2M token generation workflow trigger that fires when machine-to-machine tokens are created, allowing customization and organization mapping for B2B API key management.

M2M token, machine-to-machine, token generation, custom claims, organization mapping, authentication triggers
workflows, example-workflows, M2M

Trigger: `m2m:token_generation` This trigger fires when an M2M token is generated. <Aside> You cannot modify tokens when the Kinde management API has been requested as an audience. </Aside> ## Example use cases ### Custom claims You may want to add additional custom claims to the M2M token before it is delivered to your product. ### Correlate an M2M application with an organization or user If you want, you can use M2M applications similar to API keys to enable access to various endpoints and tie them to an organization or user. For example, you add the organization code as a [custom property](/properties/work-with-properties/manage-properties/) on the M2M application, then fetch any data you’d like to include in the token. [See example code](https://github.com/kinde-starter-kits/workflow-examples/blob/main/m2mToken/mapOrgToM2MApplicationWorkflow.ts) ## Workflow code ### M2M token binding The [kinde.m2mToken](/workflows/bindings/m2m-token-binding/) binding is used to modify claims in the generated access token. ### Sample event object The main argument provided to your code is the Kinde workflow `event` object which has two keys `request` and `context`. This gives you access to the reason the workflow was triggered. Here's an example: ```json { "request": { "auth": { "audience": ["<EXAMPLE_API>"], "scope": ["read:users"] }, "ip": "192.168.0.1" }, "context": { "domains": { "kindeDomain": "https://example.kinde.com" // Your Kinde domain }, "application": { "clientId": "299627bd8bfa493f8b17e6aec8ebfb86" // the M2M application ID }, "workflow": { "trigger": "m2m:token_generation" } } } ``` ### Example workflows See examples on GitHub: [Map M2M applications to organizations](https://github.com/kinde-starter-kits/workflow-examples/blob/main/m2mToken/mapOrgToM2MApplicationWorkflow.ts) - Shows how to map M2M applications to organizations. Useful if using Kinde for B2B API key management

# Workflows - Example workflows - New password provided workflow

> Learn about the new password provided workflow trigger that fires when users set new passwords, enabling custom validation and secure password synchronization with external systems.

new password, password validation, password sync, encryption, authentication triggers
workflows, example-workflows, passwords

Trigger: `user:new_password_provided` This trigger fires after a new password is entered in either the sign-up flow or the reset password flow. ## Security considerations Security is at the heart of our technical decisions at Kinde, and keeping user passwords safe is a huge part of this. Therefore: - Any attempt to log the password out to the console in this workflow will be redacted - API calls should only be made from these workflows using the Kinde provided [secureFetch](/workflows/bindings/secure-fetch-binding/) binding which secures the payload with an encryption key ## Example use cases ### Custom password strength policy As a baseline, Kinde runs the following password checks: - A password is supplied - The password is at least 8 characters long - The password does not exist in the 1,000,000 most common passwords With this workflow you can add your own custom code to run additional checks, for example if your business requires a specific mix of upper / lower case characters, or inclusion of special characters. [See example code](https://github.com/kinde-starter-kits/workflow-examples/blob/main/newPassword/customPasswordValidationWorkflow.ts) ### Sync password updates with an external system For gradual migrations to Kinde where several apps are in play (e.g. a mobile application and a web application), you might want to migrate web users first and mobile app users later. If users have access to both applications, then password resets on the web application would not be persisted to the legacy mobile app password store. With this workflow you can securely send the password to your mobile app system in order to keep them in sync. [See example code](https://github.com/kinde-starter-kits/workflow-examples/blob/main/newPassword/securelySyncPasswordWorkflow.ts) ## Workflow code ### Sample event object The main argument provided to your code is the Kinde workflow `event` object which has two keys `request` and `context`. This gives you access to the reason the workflow was triggered. Here's an example: ```json { "request": { "ip": "192.168.0.1", "userAgent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:135.0) Gecko/20100101 Firefox/135.0" }, "context": { "domains": { "kindeDomain": "https://example.kinde.com" // Your Kinde domain }, "auth": { "firstPassword": "someSecurePassword", // the first password entered "secondPassword": "someSecurePassword", // password match field "newPasswordReason": "reset" | "initial" // whether it is registration or reset }, "user": { "id": "kp_1234566", // only provided in password reset flows as otherwise new user "email": "hello@example.com" // the email provided }, "workflow": { "trigger": "user:new_password_provided" } } } ``` ## Bindings ### Secure fetch binding We recommend you use the [secureFetch](/workflows/bindings/secure-fetch-binding/) binding to make API calls from your workflow if they include sensitive data like passwords. ### Widget binding The `kinde.widget` binding gives you access to the Kinde widget which is the central form on the page. In this case the form with the two password fields. It exposes a method for invalidating a form field `invalidateFormField`. ```js kinde.widget.invalidateFormField(fieldName, message); ``` Example ```js const isMinCharacters = context.auth.firstPassword.length >= 50; if (!isMinCharacters) { kinde.widget.invalidateFormField( "p_first_password", "Provide a password at least 50 characters long ); } ``` The field names for the widget binding in this workflow are: | Field name | Description | | ------------------- | ---------------------------------------------------------------------------------------- | | `p_first_password` | The first password field | | `p_second_password` | The second password field, typically to check it matches the first to help prevent typos | ### Example workflows See examples on GitHub: - [Sync passwords to another system](https://github.com/kinde-starter-kits/workflow-examples/blob/main/newPassword/securelySyncPasswordWorkflow.ts) - Use encryption keys to securely keep passwords in sync between systems. - [Custom password validation](https://github.com/kinde-starter-kits/workflow-examples/blob/main/newPassword/customPasswordValidationWorkflow.ts) - Shows how to validate a password against your own rules.

# Workflows - Example workflows - Plan cancellation request workflow

> Learn about the plan cancellation request workflow trigger that fires when users request to cancel their subscription plans, allowing custom validation and cancellation controls.

plan cancellation, billing, subscription, cancellation workflow, authentication triggers
workflows, example-workflows, billing

Trigger: `user:plan_cancellation_request` This trigger fires when a plan cancellation request is made. This can be initiated by the user through the Kinde self-serve portal or via the Kinde Management API. This is not a deprovisioning workflow, this occurs before a cancellation request is processed. This event is triggered when: - the user asks to cancel their plan in the Kinde self-serve portal - plan cancellation is initiated via the Kinde Management API ## Example use cases ### Check if customer is eligible to cancel You may want to check if the customer is eligible to cancel their plan based on certain criteria, such as outstanding payments or minimum contract periods. If they are not eligible, you can prevent the cancellation and notify them. ## Workflow code ### Plan binding The [kinde.plan](/workflows/bindings/plan-binding/) binding is used for plan related actions, such as denying a cancellation request. ### Sample event object The main argument provided to your code is the Kinde workflow `event` object which has two keys `request` and `context`. This gives you access to the reason the workflow was triggered. Here's an example: ```js { "request": { "userAgent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:135.0) Gecko/20100101 Firefox/135.0", "ip": "192.168.0.1" }, "context": { "domains": { "kindeDomain": "https://example.kinde.com" // Your Kinde domain }, "billing": { "currentPlanCode": "pro", "agreementId": "agreement_01971a7c5c7bf2d05888a8d6c77d08ce" // the subscription ID in Kinde }, "workflow": { "trigger": "user:plan_cancellation_request" } } } ``` ### Example workflows See examples on GitHub: [Deny cancellation request](https://github.com/kinde-starter-kits/workflow-examples/blob/main/planCancellationRequest/denyPlanCancellation.ts) - Deny a plan cancellation request from a user.

# Workflows - Example workflows - Plan selection workflow

> Learn about the plan selection workflow trigger that fires when users select subscription plans during the authentication process, allowing custom validation and plan change controls.

plan selection, billing, subscription, plan workflow, authentication triggers
workflows, example-workflows, billing

Trigger: `user:plan_selection` This trigger fires when a plan selection request is made. This can be initiated by the user through the Kinde self-serve portal or via the Kinde Management API. This is not a provisioning workflow, this occurs before plan selection or any payments are processed. This event is triggered when: - the user selects a new plan in the Kinde self-serve portal - changing a customers plan via the Kinde Management API It does not trigger when a plan is automatically assigned to a customer, such as when they sign up for the first time. ## Example use cases ### Check if customer is eligible to change plan You may want to check if the customer is eligible to change their plan based on certain criteria. For example, if they are trying to downgrade to a plan with a lower usage usage allowance that their current plan but they are already breaching the limits. ## Workflow code ### Plan binding The [kinde.plan](/workflows/bindings/plan-binding/) binding is used for various plan related events such as to prevent plan change requests. ### Sample event object The main argument provided to your code is the Kinde workflow `event` object which has two keys `request` and `context`. This gives you access to the reason the workflow was triggered. Here's an example: ```json { "request": { "userAgent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:135.0) Gecko/20100101 Firefox/135.0", "ip": "192.168.0.1" }, "context": { "domains": { "kindeDomain": "https://example.kinde.com" // Your Kinde domain }, "billing": { "currentPlanCode": "professional", // plan they are changing from "requestedPlanCode": "free" // plan they are changing to }, "user": { "id": "kp_1234566" // the user ID }, "organization": { "code": "org_123456" // the organization code if applicable }, "workflow": { "trigger": "user:plan_selection" } } } ``` ### Example workflows See examples in GitHub: [Deny plan change request](https://github.com/kinde-starter-kits/workflow-examples/blob/main/planSelection/denyPlanChangeWorkflow.ts) - Deny a plan change request from a user and return the reasons for rejecting the request.

# Workflows - Example workflows - Pre-MFA workflow

> Learn about the pre-MFA workflow trigger that fires before multi-factor authentication, allowing custom logic like grace periods and conditional MFA enforcement.

pre-MFA, multi-factor authentication, grace period, MFA enforcement, authentication triggers
workflows, example-workflows, MFA

<Aside type="upgrade"> This workflow trigger is only available on the Kinde Scale plan </Aside> Trigger: `user:pre_mfa` This trigger is fired after the user has complete single factor authentication (e.g email + password or Google) and determined which organization (if any) they are trying to access. ## Example use cases ### Determining if MFA is required based on data in an external service You may be using a service like Zanzibar or OpenFGA for fine-grained access control and wish to call out to it to determine if a user needs to complete MFA. ### Making MFA required if a user has a certain permission You may wish to enforce MFA for users who have some sensitive permissions such as `delete:project` . ### Skipping MFA for certain organizations You want to enforce MFA at an environment level for all organizations, but there are a few who do not want to adopt your policy. ### MFA prompt grace period When you only want to prompt MFA when a user has not been asked for MFA for a certain time period. [See example code](https://github.com/kinde-starter-kits/workflow-examples/blob/main/preMFA/gracePeriodWorkflow.ts) ## Workflow code ### Sample event object The main argument provided to your code is the Kinde workflow `event` object which has two keys `request` and `context`. This gives you access to the reason the workflow was triggered and additional relevant datapoints. Here’s an example: ```json { "request": { "ip": "192.168.0.1", "userAgent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:135.0) Gecko/20100101 Firefox/135.0" }, "context": { "auth": { "connectionId": "conn_01945d3ccf4926118bfdeb6e1158edb5" // connection ID the user auth'd with }, "domains": { "kindeDomain": "https://example.kinde.com" }, "mfa": { "policy": "required", // required | optional | off "context": "environment", // environment or organization "enabledFactors": ["mfa:sms", "mfa:email", "mfa:authenticator_app"], // factors you have enabled for this context "isUserRoleExempt": false, // advanced orgs can make specific roles exempt from MFA "isUserConnectionExempt": false // advanced orgs can make enterprise connections exempt from MFA }, "user": { "id": "kp_77d28fc7b16240dd9ec12b08071fe46e" // the users ID }, "workflow": { "trigger": "user:pre_mfa" }, "application": { "clientId": "cee9743fc7ee4d2e84061fe1a662051d" }, "organization": { "code": "org_75ad9f26d2c" } } } ``` ## Bindings ### MFA binding The [kinde.mfa](/workflows/bindings/mfa-binding/) binding is used to modify the MFA policy for the current auth flow. ### Example workflows See examples on GitHub: [Set a grace period for MFA](https://github.com/kinde-starter-kits/workflow-examples/blob/main/preMFA/gracePeriodWorkflow.ts) - Don't ask for MFA for a set period of time after a user has logged in.

# Workflows - Example workflows - User pre-registration workflow

> Learn about the user pre-registration workflow trigger that fires after single factor authentication but before user record creation, with examples for IP checks and disposable email blocking.

pre-registration, user registration, IP checks, disposable emails, spam prevention, authentication triggers
workflows, example-workflows, authentication

Trigger: `user:pre_registration` This trigger fires after the user has completed single factor authentication (e.g email + password or Google) but before a user record is created in Kinde. <Aside type="warning"> At this stage the user is not authorized - we have not checked organization access or carried out MFA. </Aside> ## Example use cases ### IP address checks Block user registrations from suspicious IP addresses. ### Block disposable email addresses Refuse disposable email addresses to prevent spam registrations. ## Workflow code ### Sample event object The main argument provided to your code is the Kinde workflow `event` object which has two keys `request` and `context`. This gives you access to the reason the workflow was triggered and additional relevant datapoints. Here's an example: ```json { "request": { "ip": "***", "userAgent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:135.0) Gecko/20100101 Firefox/135.0", "authUrlParams": { "state": "b9ea1131f7796a10abe8eac1b48c715575a0ffd349fb9c602e13d824", "orgCode": "org_12345667", "clientId": "cad2d86b1ac645e1957889fcb1eff0f9", "redirectUri": "http://localhost:3000" } }, "context": { "auth": { "connectionId": "conn_0194ee03c226d48c6858d5a412359ed2" }, "domains": { "kindeDomain": "https://newbus.localkinde.me" }, "workflow": { "trigger": "user:pre_registration" }, "application": { "clientId": "cad2d86b1ac645e1957889fcb1eff0f9" } } } ``` ### Example workflows See examples on GitHub: [Prevent disposable email sign ups](https://github.com/kinde-starter-kits/workflow-examples/blob/main/preUserRegistration/blockDisposableEmails.ts) - Check the email address against a list of disposable email domains and block the registration if it matches.

# Workflows - Example workflows - User token generation workflow

> Learn about the user token generation workflow trigger that fires when tokens are created, allowing customization of access and ID tokens with custom claims from external APIs.

token generation, custom claims, access token, ID token, external API, authentication triggers
workflows, example-workflows, tokens

Trigger: `user:tokens_generation` This trigger fires when ID and Access tokens are generated for a user. - After authentication - a sign in or sign up event. - After a pre-authentication event - i.e the user is redirected to Kinde and returned invisibly to your app because they were already authenticated. - When a refresh token is generated. ## Security considerations To ensure the integrity of Kinde-issued tokens there are some claims which cannot be modified. See [Prohibited claims](https://github.com/kinde-oss/infrastructure/blob/main/lib/prohibitedClaims.ts) in the workflows infrastructure resource. ## Example use cases Here's a few ways that this trigger might be used for a workflow. ### Custom claims using Kinde data You may want to add additional custom claims to the access or ID token before it is delivered to your product. ### Custom claims using data from an external service You have entitlements or other data in a CRM that you wish to make an API call out to, and then append that data into the access token. [See example code](https://github.com/kinde-starter-kits/workflow-examples/blob/main/userTokens/customClaimsAccessTokenWorkflow.ts) ### Reduce token size Kinde automatically populates the access token with data such as `permissions` and `feature_flags`. If your product use these features heavily, the access token can bloat and you may prefer to use the Kinde Management API to get the data, and strip them from the token. ### Modify Kinde claim format Some external systems rely on claims to be in a certain format. For example, Kinde supplies roles as an array of objects, but some systems require a space separated string. This workflow allows you to restructure the format of these Kinde claims. ## Workflow code ### Sample event object The main argument provided to your code is the Kinde workflow `event` object which has two keys `request` and `context`. This gives you access to the reason the workflow was triggered. Here's an example: ```json { "request": { "auth": { "audience": ["<EXAMPLE_API>"] }, "ip": "192.168.0.1" }, "context": { "domains": { "kindeDomain": "<https://example.kinde.com>" // Your Kinde domain }, "auth": { "origin": "authorization_request" | "refresh_token_request", "isExistingSession": false, // if user was preauthenticated, "connectionId": "conn_12345" // the ID of the auth connection method used }, "application": { "clientId": "299627bd8bfa493f8b17e6aec8ebfb86" // the M2M application ID }, "user": { "id": "kp_1234567890", // the ID of the user "identityId": "identity_123456789" // the ID of the identity the user authenticated with }, "organization": { "code": "org_123456789" // the org code the user authorized against }, "workflow": { "trigger": "user:tokens_generation" } } } ``` ### Access and ID token bindings To modify claims in the generated user tokens you will need to make use of the following bindings - [kinde.accessToken](/workflows/bindings/access-token-binding/) - [kinde.idToken](/workflows/bindings/id-token-binding/) ### Example workflows See examples on GitHub: [Add custom claims to access token](https://github.com/kinde-starter-kits/workflow-examples/blob/main/userTokens/customClaimsAccessTokenWorkflow.ts) - Call an external API to get data to add as custom claims to the user access token.

# Workflows - Example workflows - User post-authentication workflow

> Learn about the user post-authentication workflow trigger that fires after successful authentication, with examples for external system synchronization and security checks.

post-authentication, user authentication, external integrations, HubSpot sync, impossible travel, authentication triggers
workflows, example-workflows, authentication

Trigger: `user:post_authentication` This trigger fires after the user has completed single factor authentication (e.g email + password or Google). <Aside type="warning"> At this stage the user is not authorized - we have not checked organization access or carried out MFA. </Aside> ## Example use cases ### Minimize account sharing Check previous logins by the user to see if they have carried out impossible travel or if their IP address looks suspicious. [Example code](https://github.com/kinde-starter-kits/workflow-examples/blob/main/postUserAuthentication/impossibleTravelWorkflow.ts) ### Add properties to a user Add additional properties to a user before tokens are generated. ### Add user to organizations If the user has been invited to join multiple organizations you can add them as this point, before going through the authorization flow. ### Determine if the user is a first time user Users can be created in multiple ways (imported / API / via the UI / self-registration). This could well be an existing user in your own database, so we tell you if this is a new user from a Kinde perspective. i.e we create a new record so you can act accordingly. [Example code](https://github.com/kinde-starter-kits/workflow-examples/blob/main/postUserAuthentication/syncNewUserToHubspotWorkflow.ts) ## Workflow code ### Sample event object The main argument provided to your code is the Kinde workflow `event` object which has two keys `request` and `context`. This gives you access to the reason the workflow was triggered and additional relevant datapoints. Here's an example: ```json { "request": { "ip": "***", "userAgent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:135.0) Gecko/20100101 Firefox/135.0", "authUrlParams": { "state": "b9ea1131f7796a10abe8eac1b48c715575a0ffd349fb9c602e13d824", "orgCode": "org_12345667", "clientId": "cad2d86b1ac645e1957889fcb1eff0f9", "redirectUri": "http://localhost:3000" } }, "context": { "auth": { "connectionId": "conn_0194ee03c226d48c6858d5a412359ed2", "isNewUserRecordCreated": true }, "user": { "id": "kp_6e54d9612e8748b39557c9975bdba033" }, "domains": { "kindeDomain": "https://newbus.localkinde.me" }, "workflow": { "trigger": "user:post_authentication" }, "application": { "clientId": "cad2d86b1ac645e1957889fcb1eff0f9" } } } ``` ### Example workflows See examples on GitHub: - [Sync new user data to Hubspot](https://github.com/kinde-starter-kits/workflow-examples/blob/main/postUserAuthentication/syncNewUserToHubspotWorkflow.ts) - Send user data and UTM tags to Hubspot when a new user record is created in Kinde. - [Impossible travel - Trustpath integration](https://github.com/kinde-starter-kits/workflow-examples/blob/main/postUserAuthentication/impossibleTravelWorkflow.ts) - Evaluate user login risk using TrustPath's API by checking for "impossible travel" patterns based on IP and recent login activity. If high risk is detected, access is blocked proactively.

# Workflows - Getting started - Connect your workflows repo and branch

> Learn how to connect GitHub repository to Kinde workflows, including repo setup with kinde.json configuration, branch selection, code sync, and preview mode for safe deployments.

GitHub integration, repository setup, code sync, branch connection, workflow deployment, preview mode
workflows, getting-started, GitHub integration

We want you to keep control of your own code, in your own repo, so you can update and commit as usual. Then sync your code with one click and it’s ready to use. You first need to set up your GitHub repo and connect the branch to Kinde. ## Set up your repo For the code sync to work, your workflow files need to be stored in a specific place in your repo. This tells Kinde where your custom code lives. If you prefer to use an alternative directory you can change `kindeSrc` to something else. 1. In the root of the repo create a file called `kinde.json` with the content: ```jsx { "rootDir": "kindeSrc" // This is root folder Kinde will use to discover workflows. } ``` 2. Create this folder structure in your repo's root directory: `[RootFolder]/environment/workflows`. This is where you will add the files that Kinde will read. ## Connect or change your repo and branch 1. In Kinde, go to **Settings > Environment > Git repo**. 2. Select **Connect repo** (first time) or **Change repo**. 3. Follow the on-screen prompts to connect your git service. 4. Select the repo and select **Next**. 5. Select the branch and select **Save**. You will know the connection is successful when you see the connected repo panel at the top of the screen. 6. If you are on an eligible Kinde plan, switch on the code preview mode option in **Advanced settings**. This lets you preview code in prod before making it live. 7. Check if your code has synced to Kinde. Go to **Home > Workflows**. If you already have workflow files set up, the workflows will appear in **Workflows** page. If we failed to read your workflow code, you should see a warning. ![workflow in Kinde](https://imagedelivery.net/skPPZTHzSlcslvHjesZQcQ/7f6299c4-5af2-406a-4d8b-7e6812a94e00/public) 8. Review any issues in the [Sync log](/workflows/testing/preview-workflows/). 9. You can re-sync the code at anytime by selecting **Sync code**. <Aside type="warning"> If the preview code option is switched off, your code will be pushed live automatcially each time you sync. We recommend switching this off for production. This is a paid feature. </Aside> ## Code status alerts The home page of your Kinde dashboard shows a code alert status. You can see immediately if there are any concerns with your code. Select **View code status** to see if the issue is: - a code sync problem - a workflow code problem - a design custom code issue

# Workflows - Getting started - Infrastructure package

> Learn about Kinde's infrastructure package (@kinde/infrastructure) - an NPM package providing TypeScript methods and examples to simplify workflow development.

infrastructure package, NPM package, TypeScript, workflow methods, GitHub repository, installation
workflows, getting-started, infrastructure

Kinde provides a helpful infrastructure package that simplifies the process of creating workflows. This package includes a set of methods and examples to help you build your workflows effectively. It is built in TypeScript and is designed to be used in your workflow files. The package is available as an NPM package, which you can install in your project. ## Installation To install the Kinde infrastructure package, run the following command: ```bash # npm npm i @kinde/infrastructure ``` ## Github repository You can find the source code on [GitHub](https://github.com/kinde-oss/infrastructure). The repository includes a README file that provides a guide to creating the code that powers your workflows.

# Workflows - Getting started - Project structure

> Learn about Kinde workflow project structure including folder conventions, file naming rules, and recommendations for organizing workflow code in repositories.

project structure, folder conventions, file naming, workflow organization, kindeSrc, package.json, kinde.json
workflows, getting-started, project-structure

This page provides an overview of all the folder and file conventions for Kinde workflows, and recommendations for organizing your project. ## Folder and file conventions Your workflow code can live either in a brand new repo or it can co-exist with your main application code. ### Top-level folders Top-level folders are used to organize your workflow code ``` kindeSrc/ └── environment/ └── workflows/ ``` | Folder name | Description | | ------------- | ---------------------------------------------------------------------------------------------------- | | `kindeSrc` | The root directory of your custom code. Allows for co-locating Kinde code with your application code | | `environment` | The context for the workflow | | `workflows` | Houses all your workflow code | ### Top-level files Top-level files are used to configure your project and manage dependencies | File name | Description | | -------------- | ---------------------------- | | `package.json` | Project dependencies | | `kinde.json` | Configuration file for Kinde | ### Workflow files The files which contain your workflow code. These files are executed when the workflow is triggered. | File name | Extension | Description | | ---------- | ----------- | --------------------------------------------------------------------------------------- | | `Workflow` | `.ts` `.js` | Call the file whatever you like so long as it ends with "Workflow" e.g `m2mWorkflow.ts` | ## Organizing your project Kinde is mostly unopinionated about how you organize and colocate your project files. So long as you follow the conventions above, you can organize the workflow files within the `workflows` folder however you like.

# Workflows - Getting started - Quick start guide (workflows)

> Step-by-step guide to create your first Kinde workflow using the base template, connecting GitHub repository, and testing authentication triggers with runtime logs.

quick start, workflow setup, GitHub integration, template, first workflow, authentication triggers
workflows, getting-started, setup

The quickest way to see an end-to-end example is to follow this guide. It will help you set up your project and create your first workflow. ## Prerequisites - A Kinde account with an application set up - A GitHub account to host your code. ## 1. Clone the base template Sign in to your GitHub account and navigate to [Kinde base workflow template](https://github.com/kinde-starter-kits/workflow-base-template). Click the green **Use this template button** and select "Create a new repository". This will create a new repository in your GitHub account with the base template code. It contains a basic workflow that logs out "Hello, world!" when a user authenticates. ## 2. Connect your GitHub repository to Kinde Sign in to your Kinde account and navigate to **Settings > Git repo**. Select **Connect GitHub** and follow the instructions to connect your GitHub account to Kinde. When you select the repository you just created, Kinde will automatically sync the code and create a new workflow for you. ## 3. View your first workflow Navigate to Workflows in the Kinde admin area. You should see a new workflow called `Workflow 1`. Select the workflow to see the details and deployments. Select on **Runtime logs** to view the logs for the workflow. This should currently be empty. ## 4. Test your workflow Assuming you have a Kinde application set up, you can test your workflow by signing in to your application. This will trigger the workflow and a new runtime log entry will be available to view. Click on the new log entry to see "Hello, world! ## 5. That's it! You have successfully created your first Kinde workflow! You can now modify the workflow code to do whatever you like or add more workflows. ### Next steps - Explore the [Kinde workflows documentation](/workflows/about-workflows/) to learn more about how workflows work, the available triggers, and how to create more complex workflows. - Dive into example workflows in the [Kinde workflow examples GitHub repository](https://github.com/kinde-starter-kits/workflow-examples)

# Workflows - Getting started - Workflow examples

> Collection of workflow examples and templates including base template, password validation, custom claims, MFA grace periods, external integrations, and security workflows like impossible travel detection.

workflow examples, templates, GitHub repository, authentication workflows, password validation, custom claims, MFA, external integrations
workflows, getting-started, examples

View examples to help you get started with Kinde workflows. ## Base workflow template This is the most basic template for a Kinde workflow. You can use this as a starting point for your own workflows. You can use this in conjunction with the example files below to create more complex workflows. [Base workflow template](https://github.com/kinde-starter-kits/workflow-base-template) ## Workflow example files These can be used as a starting point for your own workflows. You can find them in the [Kinde GitHub repo](https://github.com/kinde-starter-kits/workflow-examples). Either copy the files you need into your existing project or the base template above. - [Block disposable emails](https://github.com/kinde-starter-kits/workflow-examples/blob/main/preUserRegistration/blockDisposableEmails.ts) - Prevent users from creating accounts with disposable email addresses. - [Drip feed migration](https://github.com/kinde-starter-kits/workflow-examples/blob/main/existingPassword/dripFeedMigrationWorkflow.ts) - Shows how to check a password against an external database before creating the user in Kinde. - [Sync passwords to another system](https://github.com/kinde-starter-kits/workflow-examples/blob/main/newPassword/securelySyncPasswordWorkflow.ts) - Use encryption keys to securely keep passwords in sync between systems. - [Custom password validation](https://github.com/kinde-starter-kits/workflow-examples/blob/main/newPassword/customPasswordValidationWorkflow.ts) - Shows how to validate a password against your own rules. - [Sync new user data to Hubspot](https://github.com/kinde-starter-kits/workflow-examples/blob/main/postUserAuthentication/syncNewUserToHubspotWorkflow.ts) - Send user data and UTM tags to Hubspot when a new user record is created in Kinde. - [Set a grace period for MFA](https://github.com/kinde-starter-kits/workflow-examples/blob/main/preMFA/gracePeriodWorkflow.ts) - Don't ask for MFA for a set period of time after a user has logged in. - [Add custom claims to access token](https://github.com/kinde-starter-kits/workflow-examples/blob/main/userTokens/customClaimsAccessTokenWorkflow.ts) - Call an external API to get data to add as custom claims to the user access token. - [Map M2M applications to organizations](https://github.com/kinde-starter-kits/workflow-examples/blob/main/m2mToken/mapOrgToM2MApplicationWorkflow.ts) - Shows how to map M2M applications to organizations. Useful if using Kinde for B2B API key management - [Impossible travel - Trustpath integration](https://github.com/kinde-starter-kits/workflow-examples/blob/main/postUserAuthentication/impossibleTravelWorkflow.ts) - Evaluate user login risk using TrustPath's API by checking for "impossible travel" patterns based on IP and recent login activity. If high risk is detected, access is blocked proactively.

# Workflows - Getting started - Workflow files

> Learn how to create workflow files with proper naming conventions, workflowSettings configuration, and API reference for request and context objects in Kinde workflows.

workflow files, file naming, workflowSettings, triggers, API reference, request object, context object
workflows, getting-started, file-structure

Kinde identifies workflows by searching for files named with the pattern `*Workflow.[ts/js]`. For instance, a workflow triggered upon m2m token generation might be named `m2mTokenWorkflow.ts`. ## Creating a workflow To create a workflow, add a file named Workflow.[ts/js] within the `workflows` directory. Each workflow file must export: - A workflowSettings object defining the workflow's configuration. - A default asynchronous function containing the workflow's logic. The simplest workflow example: ```js export const workflowSettings = { id: "onTokenGeneration", trigger: "user:tokens_generation" }; export default async function Workflow({request, context}) { console.log("Hello world"); } ``` In this example, every time a user token is generated, this workflow will execute, logging "Hello world" to the console. ## API reference The default exported function receives a single event argument, which is an object containing two keys: `context` and `request`. ### `request` (object) Provides information about the request that triggered the workflow, such as the originating IP address and user agent string. ### `context` (object) Contains additional, trigger-specific data relevant to the workflow, which can include details like the user ID or organization code. Refer to the documentation for each specific workflow trigger to understand the data available within the `request` and `context` objects.

# Workflows - Manage workflows - Create a workflow

> Learn how to create new workflows in Kinde, including connecting GitHub repositories, setting up workflow files, and configuring workflow settings.

create workflow, workflow setup, workflow creation, GitHub integration
workflows, manage-workflows, setup

You can create workflows using Kinde's provided triggers. All you need to do is add workflow code to your repo, that can be executed when the trigger fires. Note that workflows only show up in Kinde if you have connected your repo and there are valid workflow files found in the branch you select. Otherwise, you won't see them. ## Add a workflow file to your repo 1. In the Kinde infrastructure folder, you set up (e.g. `[RootFolder]/environment/workflows`) create a TypeScript file. You can name it anything ending in `...Workflow.ts`. For example if the Kinde workflow name is `Custom-access-token`, the filename could be `CustomAccessTokenWorkflow.ts.` 2. Enter your code into the file in plain JavaScript or TypeScript. For details on what must be included, see the [kinde/infrastructure readme file in Github](https://github.com/kinde-oss/infrastructure). 3. When you commit code in your repo and then sync the code in Kinde, we will perform validity tests on the files. If the commit is valid, it will have the status of ‘Draft’ in Kinde. You can make draft workflows live. ## Make the workflow live (for the first time) 1. Got to **Workflows** and click on the workflow trigger. 2. In the **Summary** screen for the workflow, find the draft deployment. 3. Select the three dots (…) menu on the far right and select **Make live**. 4. Confirm you want to make the deployment live. For information on managing deployments and making a different deployment live, see the [workflows management](/workflows/manage-workflows/manage-code-and-deployments/) topic.

# Workflows - Manage workflows - Deactivate or delete a workflow

> Learn how to deactivate or delete workflows in Kinde, including the differences between deactivation and permanent deletion, and how to safely manage workflow lifecycle.

deactivate workflow, delete workflow, workflow management, workflow lifecycle
workflows, manage-workflows, administration

There is a difference between deactivating and deleting a workflow. ## Deactivate a workflow Deactivating a workflow stops it from being triggered or used. The workflow cannot be triggered by users until you make the same or a different deployment live. 1. Go to **Workflows**. 2. Select the workflow you want to deactivate. The workflow **Summary** page opens. 3. In the **Live** section, select the three dots menu, then select **Deactivate**. 4. Confirm that you want to deactivate. The workflow will be stopped. It will not work again until you make a deployment live. ## Delete a workflow There are two parts to deleting a workflow: ### 1: Delete workflow files in your repo Even when you delete the workflow from your repo it will remain in Kinde. This is to safeguard against error and to protect your auth flow. The workflow keeps running until you manually delete it. ### 2: Delete a workflow in Kinde 1. Go to **Workflows**. 2. Select the … menu next to the workflow and select **Delete workflow**. A confirmation window opens explaining what is about to happen. 3. Confirm the deletion. <Aside> A workflow will re-appear if you add the files back in your repo and sync the code again. </Aside>

# Workflows - Manage workflows - Disconnect Git repo for workflows

> Learn how to disconnect Git repositories from Kinde workflows, including the process and implications of removing repository connections.

disconnect Git repo, GitHub integration, repository management, workflow setup
workflows, manage-workflows, GitHub integration

Follow the procedure below to disconnect the workflow git repo connection. You need to do this in GitHub while we work on making this possible in Kinde. ## Disconnect Git repo for workflows 1. Sign in to GitHub. 2. Go to https://github.com/settings/apps/authorizations. 3. Select **Revoke** next to the repo connected to Kinde. 4. Confirm that you want to revoke access. The repo will be disconnected from Kinde.

# Workflows - Manage workflows - Manage code and deployments

> Learn how to manage workflow code and deployments in Kinde, including GitHub synchronization, preview mode for testing, and production deployment strategies.

code management, deployments, GitHub sync, preview mode, production deployment
workflows, manage-workflows, deployment

Workflows rely on your code being available to execute when the trigger event happens. When you update your code, you need to update the related workflow in Kinde. ## Sync code from your repo Get the latest code from your repo so that it can be checked for deployment-readiness. The result of a sync will tell you if the code is ready. 1. Go to **Workflows**. 2. Select **Sync code**. This will update all workflows with any new code. The latest deployment shows on the **Summary** page for each workflow. 3. If the code is valid, Kinde will create a new deployment for each workflow. ## Make a deployment live By default, Kinde will create a new deployment and set it live immediately when you sync your code. If you have disabled this settings, you may wish to manually make the latest code deployment live, so it is used in the workflow. You can make any deployment live which can be useful for rolling back to working versions of your code if there are issues with your currently live version. 1. Go to **Workflows**. 2. Refresh code from your repo by selecting **Sync code**. 3. Select the workflow you want to update. 4. On the **Workflow** page, select **Make live** from the deployment context menu. The workflow will update to use the latest code. ## View all deployments 1. Go to **Workflows**. 2. Select the workflow to view the details. 3. Select **Deployments** in the menu. A list of all your deployments shows. See below to interpret deployment statuses. ## Deployment status | Status | Meaning | | ----------- | ------------------------------------------------------------------------------------------------------------------------- | | Live | The code version currently live and ready to use in a workflow | | Deployed | Code that you have committed in your repo and has been checked for validity in Kinde and is ready to run in the workflow. | | Failed | Code that you have committed in your repo and has been found not be valid to run in Kinde. | | Deactivated | Code that was live and has now been deactivated. It is possible for it to be made live again. | | Processing | You may occasionally see one of these. They indicate transitional states before a definitive status is achieved. | | Draft | New workflow without a live deployment. |

# Workflows - Manage workflows - Workflow encryption key

> Learn about workflow encryption keys used to secure sensitive data transmission in secure fetch operations and other encrypted workflow communications in Kinde workflows.

encryption key, security, secure fetch, sensitive data, encryption
workflows, manage-workflows, security

You can generate unique encryption keys to be used to make secure API calls within your workflows. Encryption keys protect sensitive data and should be updated regularly for continued protection. Keys are per-workflow, so you can have different keys for different workflows. You can also have multiple keys for a single workflow, but only one key can be active at a time. ## How encryption keys work When an POST request is made using the [kinde.secureFetch binding](/workflows/bindings/secure-fetch-binding/), the body is automatically encrypted with the active encryption key for the workflow. Use the same encryption key in your own code to decrypt the payload on arrival. This ensures secure transfer of the data. ## Add an encryption key to a workflow 1. Go to **Workflows** and select a workflow. 2. Select **Encryption keys** in the menu. 3. Select **Add encryption key**. A dialog appears, enabling you to copy the key. You need to copy it immediately, as it cannot be viewed again. 4. After you copy the key, select **Close**. If this is the first key you have added, it will automatically be made **active**. 5. Add the key to your code, to decrypt data sent from Kinde. ## Update an encryption key 1. Go to **Workflows** and select a workflow. 2. Select **Encryption keys** in the menu. 3. Select **Add encryption key**. A dialog opens with information about adding the key. 4. Select **Add**. A dialog appears showing the key value. 5. Copy the key value and store it somewhere you can access again. 6. Select **Close**. 7. When you are ready to update the key in your code, select the three dots menu on the new key, then select **Activate**. A dialog opens, confirming the action. 8. Select **Activate encryption key**. This makes the new key active and deactivates the previously active key. 9. Add the new key value to your code, to continue decrypting data sent from Kinde. ## Deactivate/activate an encryption key You can change the active status of any key. Remember to update your code to use the active key. 1. Go to **Workflows** and select a workflow. 2. Select **Encryption keys** in the menu. 3. To deactivate an active key: 1. Select the three dots menu on the active key. 2. Select **Deactivate**. A confirmation window opens. 3. Follow the prompts and select **Deactivate encryption key.** 4. To activate a deactivated key: 1. Select the three dots menu on the inactive key. An inactive key shows no status. 2. Select **Activate**. A confirmation window opens. 3. Follow the prompts and select **Activate encryption key**. This makes the new key active and deactivates any previously active key. ## Delete used or unwanted encryption keys Deleting used keys is good security hygiene. But deleting an active key can also break your code. Only delete inactive keys. 1. Go to **Workflows** and select a workflow. 2. Select **Encryption keys** in the menu. 3. Next to an inactive key, select the three dots menu. 4. Select **Delete key**. A confirmation window opens. 5. Follow the prompts and select **Delete encryption key**.

# Workflows - Observability - Workflow build logs

> Learn about workflow build logs that show compilation and deployment information when workflows are synced and deployed in Kinde, including error and warning details.

build logs, workflow logs, deployment logs, observability, debugging
workflows, observability, logs

A log entry is created every time your code is compiled and deployed on Kinde. This log entry contains information about the build process, including any errors or warnings that occurred during the build. ## View build logs If your code was succesfully synced from your repo Kinde will then attempt to build (compile and deploy) your code. The results of this build will show up in the deployment build logs. 1. Go to **Workflows**. 2. Select a workflow in the list to open it. The **Summary** page opens. 3. Select **Deployments** in the menu. A list of all your deployments shows. 4. Select the deployment you want to test. The **Deployment details** page opens. 5. Scroll to the bottom of the page and view the build logs. ## Common issues ### Failed to resolve file, invalid location Typically this means that the file you are trying to import is not in the correct location. Check the following: - The file is in the correct location. - The file you are importing is a valid file type - i.e a `.ts` or `.js` file - If you are using a package from the NPM registry make sure it is a Kinde supported package.

# Workflows - Observability - Workflow logs

> Learn about workflow logs that capture console output and debugging information from workflow execution in Kinde, helping troubleshoot and diagnose workflow issues.

workflow logs, console logs, observability, debugging, monitoring
workflows, observability, logs

Logs are an important component of a developer's toolkit to troubleshoot and diagnose workflow issues, and to maintain system health. Kinde offers a range of logs to help diagnose issues. ## Sync logs Sync logs are generated when you sync your code to Kinde. They provide information about the sync process, including any errors or warnings that occurred during the sync. [See more about sync logs](/workflows/observability/workflow-sync-logs/) ## Build logs Build logs are generated when you sync your code to Kinde. They provide information about the build process, including any errors or warnings that occurred during the build. [See more about build logs](/workflows/observability/workflow-build-logs/) ## Runtime logs Runtime logs are generated when your workflow is executed. They provide information about the execution of your workflow, including any errors or warnings that occurred during the execution. [See more about runtime logs](/workflows/observability/workflow-runtime-logs/)

# Workflows - Observability - Workflow runtime logs

> Learn about workflow runtime logs that show execution details and performance metrics when workflows are triggered and run in Kinde, including error and debugging information.

runtime logs, workflow execution, observability, debugging, monitoring
workflows, observability, logs

When your code is running in a workflow, we monitor performance and activity as the workflow executes. If you discover or someone reports an issue with the workflow, runtime logs are likely to pick up any errors. ## View runtime logs 1. Go to **Workflows**. 2. Select a workflow in the list to open it. The **Summary** page opens. 3. Select **Runtime logs** in the menu. A list of all your recent logs shows. 4. Select the runtime log you want to view. ## Common issues The Kinde runtime environment is a secure JavaScript environment. This means that some JavaScript features are not available in the Kinde runtime. If you try to use a feature that is not supported, you will see an error in the runtime logs. For example, if you try to use the `fs` module to read a file from the file system, you will see an error like this: ``` Error: fs is not defined ```

# Workflows - Observability - Workflow sync logs

> Learn about workflow sync logs that show GitHub repository synchronization status and any issues encountered during code deployment in Kinde workflows.

sync logs, GitHub sync, code synchronization, observability, deployment
workflows, observability, logs

A log entry is created every time your code is synced to Kinde from your repo. This log entry contains information about the sync process, including any errors or warnings that occurred during the sync. ## View code sync log When your code hits Kinde from a fresh commit in your repo, we check to make sure we’re able to run it. If these checks fail, this will show up in the sync logs. 1. Go to **Settings > Git repo > Sync logs**. This shows a page list of all the sync events in chronological order. 2. Select the leftmost column or open the three dots menu next to an item in the list to view details of the sync. The **Sync event details** page opens. 3. Details of which processes succeeded and fails are shown. ## Common issues ### No workflows At the point of syncing, Kinde checks to see if there are any workflows in your repo. If there are none, the sync will fail. You need to create a workflow before you can sync your code. If there is a workflow file in your repo there are other reasons why Kinde may not be able to find it. Check the following: - The workflow file is in the correct location. The workflow file must be in the root of your repo. - The workflow file is a valid file type - i.e a `.ts` or `.js` file - The file name finishes with `Workflow` - for example `m2mWorkflow.ts`. - Your `kinde.json` file is pointing at the correct `kindeSrc` ### Unknown trigger requested If you have a trigger in your workflow that Kinde does not recognize, the sync will fail. Check the following: - The trigger is a valid trigger type. See the [about workflows](/workflows/about-workflows/) page for a list of valid triggers. - The trigger is spelled correctly. Check for typos in the trigger name. ### More than one workflow assigned to this trigger A trigger can only be assigned to one workflow. If you have more than one workflow assigned to the same trigger, the sync will fail. Check the following: - The trigger is only assigned to one workflow. If you have more than one workflow assigned to the same trigger, remove the duplicate workflows. ### Duplicate workflow ID A workflow ID must be unique. If you have more than one workflow with the same ID, the sync will fail. Check the following: - The workflow ID is unique. If you have more than one workflow with the same ID, change the ID of one of the workflows. ### Missing output bundle When the Kinde compiler runs, it creates a bundle of the workflow code. If this generated bundle is empty, the sync will fail.

# Workflows - Testing - Testing workflows

> Overview of testing strategies for Kinde workflows including preview mode, testing methodologies, and best practices for ensuring workflow reliability.

workflow testing, preview mode, testing strategies, quality assurance, debugging
workflows, testing, quality-assurance

It is common that you would like to test your workflow code before you make it live for your end users. Kinde provides a few ways to do this. ## Use environments You can set up different environments in Kinde to test your code before you make it live. This is useful for testing new features or changes to your workflow code without affecting your production environment. To take advantage of this, we recommend you [add a second environment](/build/environments/environments/#add-an-environment) in Kinde (this is included on all plans). Connect your GitHub repo to this environment and ensure everything works as expected before syncing the branch to your production environment. You can make use of the [environment variables](/build/env-variables/store-environment-variables/) feature to set up different configurations for each environment to ensure seamless switching. ## Use preview mode <Aside type="upgrade"> Only users on eligible plans can preview workflows before they go live. This option needs to be switched on in **Settings > Environment > Git repo**. </Aside> Preview mode allows you to test your workflow code in your production environment without affecting your live deployment. See the [preview workflows](/workflows/testing/preview-workflows/) article for more information on how to use this feature.

# Workflows - Testing - Preview workflows

> Learn about preview mode in Kinde workflows that allows safe testing of workflow changes in production before making them live, using deployment IDs and passwords.

preview workflows, testing, safe deployment, production testing, workflow validation
workflows, testing, preview

<Aside type="upgrade"> Only users on eligible plans can preview workflows before they go live. This option needs to be switched on in **Settings > Environment > Git repo**. </Aside> You can preview a workflow by testing one of your code deployments. For this you need to get the Workflow deployment ID and password from Kinde. ## Copy workflow testing details for code preview If you don't have the right plan to preview and test your code in production, we recommend you test it in a [staging environment](/workflows/testing), before you make it live. 1. Go to **Workflows**. 2. Select a workflow in the list to open it. The **Summary** page opens. 3. Select **Deployments** in the menu. A list of all your deployments shows. 4. Select the deployment you want to test. The **Deployment details** page opens. 5. Select **Preview** in the menu and copy the workflow deployment ID and password that you need for testing. 6. Copy these and apply them in your application. Use them when you test the workflow. ## Use the workflow deployment ID in your code The deployment ID is used to identify the workflow deployment you want to test. You can use this in your code to make sure you are testing the right deployment. This should be passed as part of the authorization URL: ``` https://<your_kinde_subdomain>.kinde.com/oauth2/auth ?response_type=code &client_id=<your_kinde_client_id> &redirect_uri=<your_app_redirect_url> &scope=openid%20profile%20email &state=abc &deploy_id=<your_workflow_deployment_id> ``` ## Use the password If the `deploy_id` URL parameter is passed, then Kinde will display a password prompt at the start of the auth flow. This is the password you copied from the **Deployment details** page. When entered the auth flow will continue as normal and the workflow will be triggered.

